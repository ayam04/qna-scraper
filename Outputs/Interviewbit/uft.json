[
    {
        "question": "1. What are the possible types of errors that one can encounter in UFT?",
        "answer": "Following are the different types of errors that one can encounter in UFT: Syntax Errors:\nSyntax errors are typos or code that does not conform to the grammar of the VBscripting language. Syntax mistakes arise during code compilation and prevent the code from being executed unless the errors are corrected.\nUse the keyboard shortcut Ctrl+F7 to check the syntax, and the result will be presented as shown below. If the window does not appear, go to \"View\" and then \"Errors.\" Syntax Errors:\nSyntax errors are typos or code that does not conform to the grammar of the VBscripting language. Syntax mistakes arise during code compilation and prevent the code from being executed unless the errors are corrected.\nUse the keyboard shortcut Ctrl+F7 to check the syntax, and the result will be presented as shown below. If the window does not appear, go to \"View\" and then \"Errors.\" Syntax Errors: Syntax errors are typos or code that does not conform to the grammar of the VBscripting language. Syntax mistakes arise during code compilation and prevent the code from being executed unless the errors are corrected.\nUse the keyboard shortcut Ctrl+F7 to check the syntax, and the result will be presented as shown below. If the window does not appear, go to \"View\" and then \"Errors.\" Syntax errors are typos or code that does not conform to the grammar of the VBscripting language. Syntax mistakes arise during code compilation and prevent the code from being executed unless the errors are corrected. Use the keyboard shortcut Ctrl+F7 to check the syntax, and the result will be presented as shown below. If the window does not appear, go to \"View\" and then \"Errors.\"   Logical Errors:\nA logical error occurs when the script is syntactically accurate but produces unanticipated outcomes. The operation is usually not interrupted by logical errors, but the outcomes are erroneous. Logical errors can be caused by a variety of factors, including faulty assumptions or misinterpretations of the requirement, as well as poor program logic (using do-while instead of do-Until) or Infinite Loops.\nPeer reviews and verification of the QTP output file/result file are two approaches to uncover logical errors and guarantee that the tool did what it was supposed to do.\nRuntime Errors:\nThis type of error occurs during Run Time, as the name implies. Such failures occur when a script attempting to complete a task is unable to do so, and the script typically stops running because it is unable to continue.\nFollowing are some well-known examples of Run-Time Errors:\nThe file was not found, although the script attempted to read it.\nThe script is attempting to act on the item that was not found.\nArray Index out of limits while accessing array items while dividing a number by Zero. Logical Errors:\nA logical error occurs when the script is syntactically accurate but produces unanticipated outcomes. The operation is usually not interrupted by logical errors, but the outcomes are erroneous. Logical errors can be caused by a variety of factors, including faulty assumptions or misinterpretations of the requirement, as well as poor program logic (using do-while instead of do-Until) or Infinite Loops.\nPeer reviews and verification of the QTP output file/result file are two approaches to uncover logical errors and guarantee that the tool did what it was supposed to do. Logical Errors: A logical error occurs when the script is syntactically accurate but produces unanticipated outcomes. The operation is usually not interrupted by logical errors, but the outcomes are erroneous. Logical errors can be caused by a variety of factors, including faulty assumptions or misinterpretations of the requirement, as well as poor program logic (using do-while instead of do-Until) or Infinite Loops.\nPeer reviews and verification of the QTP output file/result file are two approaches to uncover logical errors and guarantee that the tool did what it was supposed to do. A logical error occurs when the script is syntactically accurate but produces unanticipated outcomes. The operation is usually not interrupted by logical errors, but the outcomes are erroneous. Logical errors can be caused by a variety of factors, including faulty assumptions or misinterpretations of the requirement, as well as poor program logic (using do-while instead of do-Until) or Infinite Loops. Peer reviews and verification of the QTP output file/result file are two approaches to uncover logical errors and guarantee that the tool did what it was supposed to do. Runtime Errors:\nThis type of error occurs during Run Time, as the name implies. Such failures occur when a script attempting to complete a task is unable to do so, and the script typically stops running because it is unable to continue.\nFollowing are some well-known examples of Run-Time Errors:\nThe file was not found, although the script attempted to read it.\nThe script is attempting to act on the item that was not found.\nArray Index out of limits while accessing array items while dividing a number by Zero. Runtime Errors: This type of error occurs during Run Time, as the name implies. Such failures occur when a script attempting to complete a task is unable to do so, and the script typically stops running because it is unable to continue.\nFollowing are some well-known examples of Run-Time Errors:\nThe file was not found, although the script attempted to read it.\nThe script is attempting to act on the item that was not found.\nArray Index out of limits while accessing array items while dividing a number by Zero. This type of error occurs during Run Time, as the name implies. Such failures occur when a script attempting to complete a task is unable to do so, and the script typically stops running because it is unable to continue. Following are some well-known examples of Run-Time Errors:\nThe file was not found, although the script attempted to read it.\nThe script is attempting to act on the item that was not found.\nArray Index out of limits while accessing array items while dividing a number by Zero. The file was not found, although the script attempted to read it.\nThe script is attempting to act on the item that was not found.\nArray Index out of limits while accessing array items while dividing a number by Zero. The file was not found, although the script attempted to read it. The script is attempting to act on the item that was not found. Array Index out of limits while accessing array items while dividing a number by Zero.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What do you understand about output value in the context of UFT? What are the different types of output values present in UFT?",
        "answer": "A step in which an object property value is recorded at a given time in your test and stored in the desired location is known as an output value step. The saved values can be utilised as input in a test script at various points. The following are the different types of output values present in UFT: Standard output value.\nText /Text Area output value.\nDatabase output value.\nXML output value (from application/resources). Standard output value. Text /Text Area output value. Database output value. XML output value (from application/resources).",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Is it feasible to run two UFT instances on the same workstation? If not, please explain why.",
        "answer": "No, we are unable to run two instances of UFT on the same computer. UFT, on the other hand, manages numerous instances of applications that will be evaluated. On the same PC, we can even operate on two distinct apps without interrupting UFT recording. To do so, you'll need to change a few UFT configuration parameters. From Automation -> Record and Run settings -> choose, select the option \"Record and Run on any opened application.\" UFT, for example, can work in several windows of the Internet Explorer browser.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What are the advantages of using UFT as an automation tool for testing?",
        "answer": "Following are the advantages of using UFT as an automation tool for testing: automation tool automation tool UFT has record and playback capabilities.\nIt records scripts on an active screen and assists testers in referring to screen object characteristics.\nUFT has a very good object recognition technique.\nIntegration and Support: \nThe tool's integration with various platforms, such as .net and mainframe, is fantastic. It works with both new and old web technologies, as well as terminal emulators and Windows thick-client apps.\nIt facilitates continuous integration by connecting with Jenkins, Git, and other similar tools.\nUFT enables cross-browser testing and works with all major browsers, including Internet Explorer, Firefox, Chrome, and Apple Safari. d)Its connection with ALM allows us to store automation execution results in ALM and even schedule automation execution at a specific date and time.\nThrough an active screen, you can improve existing tests even if you don't have Automated Ultrasonic Testing (AUT).\nIt supports a variety of automation frameworks, including keyword-driven testing, modular testing, data-driven testing, and so on.\nIt has an integrated development environment (IDE).\nIt works with test management software such as Quality Center, Test Director, and Winrunner.\nSmoke, Regression, and Sanity are examples of suites that can be simply maintained.\nUFT supports Business Process Testing (BPT), a component-based testing framework that provides a strong and efficient platform for manually and automatically testing complete business processes. Its component reusability feature makes the testing process very fast, and it combines manual and automation tests with less duplication.\nIt works with XML.\nQTP allows for test reporting for analysis purposes. UFT has record and playback capabilities. It records scripts on an active screen and assists testers in referring to screen object characteristics. UFT has a very good object recognition technique. Integration and Support: \nThe tool's integration with various platforms, such as .net and mainframe, is fantastic. It works with both new and old web technologies, as well as terminal emulators and Windows thick-client apps.\nIt facilitates continuous integration by connecting with Jenkins, Git, and other similar tools.\nUFT enables cross-browser testing and works with all major browsers, including Internet Explorer, Firefox, Chrome, and Apple Safari. d)Its connection with ALM allows us to store automation execution results in ALM and even schedule automation execution at a specific date and time. Integration and Support: The tool's integration with various platforms, such as .net and mainframe, is fantastic. It works with both new and old web technologies, as well as terminal emulators and Windows thick-client apps.\nIt facilitates continuous integration by connecting with Jenkins, Git, and other similar tools.\nUFT enables cross-browser testing and works with all major browsers, including Internet Explorer, Firefox, Chrome, and Apple Safari. d)Its connection with ALM allows us to store automation execution results in ALM and even schedule automation execution at a specific date and time. The tool's integration with various platforms, such as .net and mainframe, is fantastic. It works with both new and old web technologies, as well as terminal emulators and Windows thick-client apps. It facilitates continuous integration by connecting with Jenkins, Git, and other similar tools. UFT enables cross-browser testing and works with all major browsers, including Internet Explorer, Firefox, Chrome, and Apple Safari. d)Its connection with ALM allows us to store automation execution results in ALM and even schedule automation execution at a specific date and time. Through an active screen, you can improve existing tests even if you don't have Automated Ultrasonic Testing (AUT). It supports a variety of automation frameworks, including keyword-driven testing, modular testing, data-driven testing, and so on. It has an integrated development environment (IDE). It works with test management software such as Quality Center, Test Director, and Winrunner. Smoke, Regression, and Sanity are examples of suites that can be simply maintained. UFT supports Business Process Testing (BPT), a component-based testing framework that provides a strong and efficient platform for manually and automatically testing complete business processes. Its component reusability feature makes the testing process very fast, and it combines manual and automation tests with less duplication. It works with XML. QTP allows for test reporting for analysis purposes.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What do you understand about the synchronization point in the context of UFT? What are the different ways in which you can insert a synchronization point in UFT?",
        "answer": "The timing interface between the Tool and the Application under test is known as the synchronization point. Synchronization point is a feature that allows you to set the time delay between two test script phases. For example, clicking on a link may take 1 second to load the website, 5 seconds, or even 10 seconds to load completely. The response time of the application server, network bandwidth, and client system capabilities are all issues to consider. The script will fail if the time varies unless the tester manages the time discrepancies intelligently. Following are the different ways of inserting a synchronization point in UFT: WaitProperty: WaitProperty is a method that performs a sync using the property name, value and timeout value as input. Because it is a dynamic delay, this option is recommended.\nExist: Exist is a method that performs the sync using the Timeout value as an input. Because it is a dynamic delay, this option is recommended.\nWait: Wait is a hardcoded sync point that waits regardless of whether or not an event has occurred. As a result, using Wait is discouraged, but it can be useful for shorter wait times like 1 or 2 seconds. For example, wait(5) would denote that the system will wait for 5 seconds.\nSync Method: The Sync Method is only suitable for web applications with a constant lag between page loads.\nInserting inbuilt Synchronization Points in QTP:\nStep 1: Enter into recording mode. If the user is not in Recording Mode, this option will be disabled.\nStep 2: Select \"Design\"-> \"Synchronization Point\".\nStep 3: We must choose the object that will serve as the Sync Point. The object window appears after you choose the object. WaitProperty: WaitProperty is a method that performs a sync using the property name, value and timeout value as input. Because it is a dynamic delay, this option is recommended. WaitProperty: Exist: Exist is a method that performs the sync using the Timeout value as an input. Because it is a dynamic delay, this option is recommended. Exist: Wait: Wait is a hardcoded sync point that waits regardless of whether or not an event has occurred. As a result, using Wait is discouraged, but it can be useful for shorter wait times like 1 or 2 seconds. For example, wait(5) would denote that the system will wait for 5 seconds. Wait Sync Method: The Sync Method is only suitable for web applications with a constant lag between page loads. Sync Method: Inserting inbuilt Synchronization Points in QTP:\nStep 1: Enter into recording mode. If the user is not in Recording Mode, this option will be disabled.\nStep 2: Select \"Design\"-> \"Synchronization Point\".\nStep 3: We must choose the object that will serve as the Sync Point. The object window appears after you choose the object. Inserting inbuilt Synchronization Points in QTP:   ",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. How do you close the second browser that has been opened using UFT?",
        "answer": "The \"creation time\" feature can be used to determine which browser instance was opened after another. This is nothing more than a counter for each browser instance that is launched. It starts at 0 for the first one and goes up from there. You can use the following code to close the second browser that has been opened: Browser(\"creationtime:=1\").Close Browser(\"creationtime:=1\").Close",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What is the QTP Local Repository's extension? What does the .mtr extension stand for?",
        "answer": "The extension for a local repository in QTP is .bdb. The .mtr file is a binary file that provides information about checkpoints and other things. To double-check that the .bdb file is a local object repository, rename it with the extension .tsr and open it in Object Repository Management (ORM). The same objects that appear in the Object Repository will appear here. If you try the same thing with a .mtr file, it will not work.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What do you understand about GetRoProperty, SetToProperty and GetToProperty in the context of UFT?",
        "answer": "GetRoProperty: GetRoProperty is a built-in method for retrieving the object property's runtime value. There are four steps to using the GetRoProperty method. GetRoProperty: In the Object Repository, make a note of the object on which you wish to utilise the GetRoProperty method.\nIdentifies the run-time attribute that could be used for the recorded item. Object Spy is a tool that you can utilise.\nRetrieve the identified Run-time property using the GetRoProperty method and save the value in a variable.\nUse this figure to make more deductions. In the Object Repository, make a note of the object on which you wish to utilise the GetRoProperty method. Identifies the run-time attribute that could be used for the recorded item. Object Spy is a tool that you can utilise. Retrieve the identified Run-time property using the GetRoProperty method and save the value in a variable. Use this figure to make more deductions. SetToProperty and GetToProperty: SetToProperty and GetToProperty are two methods for changing a property's value. SetToProperty and GetToProperty: Let us consider a Web Button stored in the Object Repository.\nUFT produces a replica of this object called Test Object and compares it to the Run-Time Object when the test is run.\nYou may get the value of a property of Test Object using GetToProperty.\nYou can alter the value of a Test Object's property with SetToProperty.\nThis test object, as well as any changes you make to the object properties using the SetToProperty method, is deleted when the test is finished.\nWhen the test is re-run, a new copy of the test object is produced in the object repository with the original property values. Let us consider a Web Button stored in the Object Repository. UFT produces a replica of this object called Test Object and compares it to the Run-Time Object when the test is run. You may get the value of a property of Test Object using GetToProperty. You can alter the value of a Test Object's property with SetToProperty. This test object, as well as any changes you make to the object properties using the SetToProperty method, is deleted when the test is finished. When the test is re-run, a new copy of the test object is produced in the object repository with the original property values.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What do you understand by data tables in the context of UFT? Explain the different types of data tables. Describe some of the data table object methods.",
        "answer": "A DataTable, like MS Excel, aids testers in the creation of data-driven test scenarios that may be used to repeat an Action. Datatables are divided into two categories: Local Datatable: Each action has its own private data table, sometimes known as a local data table, which can be accessed across actions.\nGlobal Datatable: Each test has a single global data sheet that is accessible across all actions. Local Datatable: Each action has its own private data table, sometimes known as a local data table, which can be accessed across actions. Global Datatable: Each test has a single global data sheet that is accessible across all actions. The data sheet can be found under QTP's \"Data\" tab, as seen below.   The following table lists some of the data table object methods: Method Description Syntax\nAddSheet Adds the supplied sheet to the data table at runtime. DataTable.AddSheet (SheetName)\nDeleteSheet The given sheet is removed from the run-time data table. DataTable.DeleteSheet( SheetID)\nExport The Datatable is exported to a new file in the provided location. DataTable.Export(FileName)\nExportSheet Run-time export of a specific sheet of the Datatable. DataTable.ExportSheet(FileName, SheetName)\nGetSheet The given sheet from the run-time data table is returned. DataTable.GetSheet(SheetID)\nGetCurrentRow Returns the active row of the global sheet's run-time data table.2 DataTable.GetCurrentRow\nGetParameterCount The number of columns in the run-time data is returned. DataTable.GetParameterCount\nGetRowCount The number of rows in the Global Sheet's run-time data table is returned. DataTable.GetRowCount\nGetSheetCount The total number of sheets in the run-time data table is returned. DataTable.GetSheetCount\nSetCurrentRow Sets the current row's focus to the specified row number. DataTable.SetCurrentRow(RowNumber)\nSetNextRow Sets the focus of the run-time data table's next row. DataTable.SetNextRow\nSetPreviousRow Sets the previous row's focus in the run-time data. Table DataTable.SetPrevRow Method Description Syntax\nAddSheet Adds the supplied sheet to the data table at runtime. DataTable.AddSheet (SheetName)\nDeleteSheet The given sheet is removed from the run-time data table. DataTable.DeleteSheet( SheetID)\nExport The Datatable is exported to a new file in the provided location. DataTable.Export(FileName)\nExportSheet Run-time export of a specific sheet of the Datatable. DataTable.ExportSheet(FileName, SheetName)\nGetSheet The given sheet from the run-time data table is returned. DataTable.GetSheet(SheetID)\nGetCurrentRow Returns the active row of the global sheet's run-time data table.2 DataTable.GetCurrentRow\nGetParameterCount The number of columns in the run-time data is returned. DataTable.GetParameterCount\nGetRowCount The number of rows in the Global Sheet's run-time data table is returned. DataTable.GetRowCount\nGetSheetCount The total number of sheets in the run-time data table is returned. DataTable.GetSheetCount\nSetCurrentRow Sets the current row's focus to the specified row number. DataTable.SetCurrentRow(RowNumber)\nSetNextRow Sets the focus of the run-time data table's next row. DataTable.SetNextRow\nSetPreviousRow Sets the previous row's focus in the run-time data. Table DataTable.SetPrevRow Method Description Syntax Method Description Syntax Method Description Syntax AddSheet Adds the supplied sheet to the data table at runtime. DataTable.AddSheet (SheetName)\nDeleteSheet The given sheet is removed from the run-time data table. DataTable.DeleteSheet( SheetID)\nExport The Datatable is exported to a new file in the provided location. DataTable.Export(FileName)\nExportSheet Run-time export of a specific sheet of the Datatable. DataTable.ExportSheet(FileName, SheetName)\nGetSheet The given sheet from the run-time data table is returned. DataTable.GetSheet(SheetID)\nGetCurrentRow Returns the active row of the global sheet's run-time data table.2 DataTable.GetCurrentRow\nGetParameterCount The number of columns in the run-time data is returned. DataTable.GetParameterCount\nGetRowCount The number of rows in the Global Sheet's run-time data table is returned. DataTable.GetRowCount\nGetSheetCount The total number of sheets in the run-time data table is returned. DataTable.GetSheetCount\nSetCurrentRow Sets the current row's focus to the specified row number. DataTable.SetCurrentRow(RowNumber)\nSetNextRow Sets the focus of the run-time data table's next row. DataTable.SetNextRow\nSetPreviousRow Sets the previous row's focus in the run-time data. Table DataTable.SetPrevRow AddSheet Adds the supplied sheet to the data table at runtime. DataTable.AddSheet (SheetName) AddSheet Adds the supplied sheet to the data table at runtime. DataTable.AddSheet (SheetName) DataTable.AddSheet (SheetName) DeleteSheet The given sheet is removed from the run-time data table. DataTable.DeleteSheet( SheetID) DeleteSheet The given sheet is removed from the run-time data table. DataTable.DeleteSheet( SheetID) DataTable.DeleteSheet( SheetID) Export The Datatable is exported to a new file in the provided location. DataTable.Export(FileName) Export The Datatable is exported to a new file in the provided location. DataTable.Export(FileName) DataTable.Export(FileName) ExportSheet Run-time export of a specific sheet of the Datatable. DataTable.ExportSheet(FileName, SheetName) ExportSheet Run-time export of a specific sheet of the Datatable. DataTable.ExportSheet(FileName, SheetName) DataTable.ExportSheet(FileName, SheetName) GetSheet The given sheet from the run-time data table is returned. DataTable.GetSheet(SheetID) GetSheet The given sheet from the run-time data table is returned. DataTable.GetSheet(SheetID) DataTable.GetSheet(SheetID) GetCurrentRow Returns the active row of the global sheet's run-time data table.2 DataTable.GetCurrentRow GetCurrentRow Returns the active row of the global sheet's run-time data table.2 DataTable.GetCurrentRow DataTable.GetCurrentRow GetParameterCount The number of columns in the run-time data is returned. DataTable.GetParameterCount GetParameterCount The number of columns in the run-time data is returned. DataTable.GetParameterCount DataTable.GetParameterCount GetRowCount The number of rows in the Global Sheet's run-time data table is returned. DataTable.GetRowCount GetRowCount The number of rows in the Global Sheet's run-time data table is returned. DataTable.GetRowCount DataTable.GetRowCount GetSheetCount The total number of sheets in the run-time data table is returned. DataTable.GetSheetCount GetSheetCount The total number of sheets in the run-time data table is returned. DataTable.GetSheetCount DataTable.GetSheetCount SetCurrentRow Sets the current row's focus to the specified row number. DataTable.SetCurrentRow(RowNumber) SetCurrentRow Sets the current row's focus to the specified row number. DataTable.SetCurrentRow(RowNumber) DataTable.SetCurrentRow(RowNumber) SetNextRow Sets the focus of the run-time data table's next row. DataTable.SetNextRow SetNextRow Sets the focus of the run-time data table's next row. DataTable.SetNextRow DataTable.SetNextRow SetPreviousRow Sets the previous row's focus in the run-time data. Table DataTable.SetPrevRow SetPreviousRow Sets the previous row's focus in the run-time data. Table DataTable.SetPrevRow DataTable.SetPrevRow",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. How can you run numerous QTP scripts at the same time?",
        "answer": "Using the TestBatchRunner tool, we may run numerous QTP scripts at once.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. What do you understand about actions in the context of UFT? How can you import an action into a test?",
        "answer": "In UFT, your test will be divided into \"logical units\" or \"Business Processes\" with the help of actions. Actions aid in the creation of a more modular and efficient script. When a script is first written, it just has one action. However, depending on your needs, you can add more Actions to your Micro Focus UFT Script. Actions are divided into two categories:   Reusable Actions: Actions that can be reused in other tests. They can be used numerous times in the same Test Script.\nNon-Reusable Actions: Actions that aren't reusable can't be used in other tests. They can only be called once in the same script. When an action becomes large, it's a good idea to split it out. You have two options for splitting an existing activity.\nThe selected action is split into two sibling actions because they are independent of each other.\nNested Action splits the chosen action into a parent action, the last step of which invokes the second, child action. Reusable Actions: Actions that can be reused in other tests. They can be used numerous times in the same Test Script. Reusable Actions: Non-Reusable Actions: Actions that aren't reusable can't be used in other tests. They can only be called once in the same script. When an action becomes large, it's a good idea to split it out. You have two options for splitting an existing activity.\nThe selected action is split into two sibling actions because they are independent of each other.\nNested Action splits the chosen action into a parent action, the last step of which invokes the second, child action. Non-Reusable Actions: The selected action is split into two sibling actions because they are independent of each other.\nNested Action splits the chosen action into a parent action, the last step of which invokes the second, child action. The selected action is split into two sibling actions because they are independent of each other. Nested Action splits the chosen action into a parent action, the last step of which invokes the second, child action. Importing Actions into a Test can be done in two ways: Call to COPY of an Action: When you make a Copy of an Action, the action is duplicated in its entirety into the calling test, including checkpoints, parameterization, and the relevant action tab in the Data Table. You can make modifications to a copied action without affecting or being affected by any other test when you insert a copy of an existing action. Both reusable and non-reusable actions can be duplicated.\nCall to an EXISTING Action: In the calling test, calls to actions are read-only. Only the test in which they were created can be changed. Allows you to reuse the same action across multiple tests and simplifies test maintenance. Only \"Reusable\" actions are available for calls. Call to COPY of an Action: When you make a Copy of an Action, the action is duplicated in its entirety into the calling test, including checkpoints, parameterization, and the relevant action tab in the Data Table. You can make modifications to a copied action without affecting or being affected by any other test when you insert a copy of an existing action. Both reusable and non-reusable actions can be duplicated. Call to COPY of an Action: Call to an EXISTING Action: In the calling test, calls to actions are read-only. Only the test in which they were created can be changed. Allows you to reuse the same action across multiple tests and simplifies test maintenance. Only \"Reusable\" actions are available for calls. Call to an EXISTING Action:",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What do you understand about descriptive programming in the context of UFT? What are the different types of descriptive programming? Explain.",
        "answer": "Descriptive programming is used to perform operations on an AUT object whose definition isn't recorded in the Object Repository. You can use this approach to skip the Object Repository and provide the Object Description directly in the statement. An object name is merely a way to link a scripted item to its description in a repository. The script should run even if the object name in your script and object repository is changed. Following are the different types of descriptive programming: Static Descriptive Programming: Static Descriptive Programming: In the Static Method, you specify an object's attribute in the following pattern for object identification. property:=values, property:=values, This format is known as a property value pair, and it is delimited by inverted commas. If your object has many descriptions for identification, use commas to separate them. Dynamic Descriptive Programming: Dynamic Descriptive Programming: The second way to accomplish the same goal is to use Dynamic Descriptive Programming. It will be highly tedious to specify all the property value pairs for each sentence if your script uses the descriptive programming object candidate several times. In such instances, you might take advantage of QTP's Description Class. A description object's syntax is as follows: Set MyDescription = Description.Create();\nMyDescription(\"property\").Value = \"property-value\"; Set MyDescription = Description.Create();\nMyDescription(\"property\").Value = \"property-value\";",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What do you understand about checkpoints in the context of UFT? Explain the different types of checkpoints available in UFT.",
        "answer": "In UFT, a checkpoint is a point where the current value of an Object's specified properties is compared to the intended value. If the present and predicted values are equal, the status is PASS; otherwise, the status is FAIL. Following are the different types of checkpoints available in UFT:   Standard Checkpoint: During a run session, it compares the expected values of object properties captured during recording to the object's current values.\nPage Checkpoint: A Page Checkpoint is a Standard Checkpoint established for a web page. It's used to count how many links and images are on a page. Page Checkpoints can be used to monitor Load Time, or the time it takes for a web page to load.\nBitmap Checkpoint: A Bitmap Checkpoint is a checkpoint that allows a user to examine the bitmap of an image or a complete web page. It compares real and expected images on a pixel-by-pixel basis.\nImage Checkpoint: An image checkpoint allows you to inspect properties such as an online image's source file location. Unlike Bitmap Checkpoint, image checkpoint does not allow you to examine pixels (bitmaps).\nText Checkpoint: A text checkpoint is a tool for ensuring that expected text in a web page or application is present. This text could be from a specific area of the app or a small portion of the text on the screen.\nAccessibility Checkpoint: It ensures that Web-based technologies and information systems follow the World Wide Web Consortium's (W3C) instructions and recommendations. These guidelines make it simple for impaired people to use the internet.\nDatabase Checkpoint: A Database Checkpoint runs a query in real-time, and the database values are saved as intended. During runtime, the identical query is repeated and the actual and expected values are compared.\nTable Checkpoint: A Table Checkpoint allows you to examine the contents of cells in a table (grid) that appears in your environment on the fly. You can also inspect table parameters such as row height, cell width, and so on. Table Checkpoint is similar to Database Checkpoint in that it allows you to save your work.\nXML Checkpoint: You may verify XML Data, XML Schema, and XML Data using XML Checkpoints. Standard Checkpoint: During a run session, it compares the expected values of object properties captured during recording to the object's current values. Standard Checkpoint: Page Checkpoint: A Page Checkpoint is a Standard Checkpoint established for a web page. It's used to count how many links and images are on a page. Page Checkpoints can be used to monitor Load Time, or the time it takes for a web page to load. Page Checkpoint: Bitmap Checkpoint: A Bitmap Checkpoint is a checkpoint that allows a user to examine the bitmap of an image or a complete web page. It compares real and expected images on a pixel-by-pixel basis. Bitmap Checkpoint: Image Checkpoint: An image checkpoint allows you to inspect properties such as an online image's source file location. Unlike Bitmap Checkpoint, image checkpoint does not allow you to examine pixels (bitmaps). Image Checkpoint: Text Checkpoint: A text checkpoint is a tool for ensuring that expected text in a web page or application is present. This text could be from a specific area of the app or a small portion of the text on the screen. Text Checkpoint: Accessibility Checkpoint: It ensures that Web-based technologies and information systems follow the World Wide Web Consortium's (W3C) instructions and recommendations. These guidelines make it simple for impaired people to use the internet. Accessibility Checkpoint: Database Checkpoint: A Database Checkpoint runs a query in real-time, and the database values are saved as intended. During runtime, the identical query is repeated and the actual and expected values are compared. Database Checkpoint: Table Checkpoint: A Table Checkpoint allows you to examine the contents of cells in a table (grid) that appears in your environment on the fly. You can also inspect table parameters such as row height, cell width, and so on. Table Checkpoint is similar to Database Checkpoint in that it allows you to save your work. Table Checkpoint: XML Checkpoint: You may verify XML Data, XML Schema, and XML Data using XML Checkpoints. XML Checkpoint:",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. What are the features of UFT?",
        "answer": "UFT has a lot of functionality, but it's also quite straightforward to understand and train employees on. The following are a few excellent features that offer a lot of value to scripting: Test Combinations Generator (TCG): This software assists in the creation of test configurations by utilising test parameters and their possible values to generate different data combinations.\nInsight Recording:  It recognises controls solely based on their look, rather than their native properties. This can be handy for testing controls in environments where UFT isn't supported, or even on a distant machine running a non-Windows operating system. UFT recognises the controls in the application by matching them to the images saved with each of the Insight test objects when it runs the test or component.\nUFT offers built-in reporting capabilities as well as the ability to create customised output files that show exactly where a test step failed and when it did so, as well as the timestamp.\nRuntime objects for Windows are supported. We can use the Windows Runtime application to record and perform tests. With the Windows Runtime application, we may create object repositories. Test Combinations Generator (TCG): This software assists in the creation of test configurations by utilising test parameters and their possible values to generate different data combinations. Insight Recording:  It recognises controls solely based on their look, rather than their native properties. This can be handy for testing controls in environments where UFT isn't supported, or even on a distant machine running a non-Windows operating system. UFT recognises the controls in the application by matching them to the images saved with each of the Insight test objects when it runs the test or component. UFT offers built-in reporting capabilities as well as the ability to create customised output files that show exactly where a test step failed and when it did so, as well as the timestamp. Runtime objects for Windows are supported. We can use the Windows Runtime application to record and perform tests. With the Windows Runtime application, we may create object repositories.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. I successfully developed and executed a script, which I then saved to QC. When I tried to run the script from within QC, it didn't work. What could be the reasons?",
        "answer": "The following points should be considered while checking for the reason for the failure of the script within QC: To begin, install the QuickTest Add-In for Quality Center.\n'Allow other Mercury products to execute tests and components' should be selected in the QTP Tools -> Options -> run a tab.\nEnsure that QTP is being executed as an administrator.\nAll test resources must be in the proper order. To begin, install the QuickTest Add-In for Quality Center. 'Allow other Mercury products to execute tests and components' should be selected in the QTP Tools -> Options -> run a tab. Ensure that QTP is being executed as an administrator. All test resources must be in the proper order. Conclusion In this article, we have covered the most frequently asked interview questions on UFT. If you're writing code in an interview, don't forget to provide comments. Demonstrate good programming techniques. Before going to a QTP interview, make sure you know what version of QTP you're using, what add-ins you're using, what versions of other software you're using, and so on. It will take a couple of hours to re-familiarize yourself with QTP if you haven't used it in a while but have prior familiarity. Useful Resources: Useful Resources: Top Testing Tools\nUiPath Interview Questions\nTosca Interview Questions\nAPI Testing Interview Questions\nJava Selenium Interview Questions\nTechnical Interview Questions\nCoding Interview Questions Top Testing Tools Top Testing Tools UiPath Interview Questions UiPath Interview Questions Tosca Interview Questions Tosca Interview Questions API Testing Interview Questions API Testing Interview Questions Java Selenium Interview Questions Java Selenium Interview Questions Technical Interview Questions Technical Interview Questions Coding Interview Questions Coding Interview Questions",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What do you understand about Object Spy in the context of UFT?",
        "answer": "Object Spy is a feature in UFT that allows you to see the properties and methods of both test and run-time objects. It also contains the syntax for a particular method. Object Spy displays the entire hierarchy of the object you've chosen. Object Spy is a tool that allows you to add objects to the Object Repository in QTP. The toolbar, as seen below, can be used to access Object Spy.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What are the various methods for launching an application in UFT?",
        "answer": "Following are the different methods of launching an application: SystemUtil.Run: SystemUtil.Run: SystemUtil.Run: Following is the syntax for using SystemUtil.Run SystemUtil.Run ( FileName, Parameters, Path, Operation ) SystemUtil.Run ( FileName, Parameters, Path, Operation ) Example: Example: SystemUtil.Run(\"chrome.exe\",http://www.google.com)\nSystemUtil.Run(\"test.txt\", \"\",\"C:\\\",\"1\") SystemUtil.Run(\"chrome.exe\",http://www.google.com)\nSystemUtil.Run(\"test.txt\", \"\",\"C:\\\",\"1\") InvokeApplication: InvokeApplication: InvokeApplication: We can also use the InvokeApplication command for launching an application. InvokeApplication \"C:\\Program Files\\Google Chrome\\CHROME.EXE http://www.google.com\" InvokeApplication \"C:\\Program Files\\Google Chrome\\CHROME.EXE http://www.google.com\" Using VB Script to create a shell object: Using VB Script to create a shell object: Using VB Script to create a shell object: Example: We create a \u201cWScript.shell\u201d object. Example Dim testshell\nSet testshell= CreateObject (\"Wscript.shell\")\ntestshell.run \"%windir%\\paint\" Dim testshell\nSet testshell= CreateObject (\"Wscript.shell\")\ntestshell.run \"%windir%\\paint\"",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What do you understand about the Expert view and Keyword view in the context of UFT?",
        "answer": "Expert view: Each line in the Expert View represents a VB Script Test Step. Consider the code below. Expert view: Dialog(\"Login\").WinEdit(\"Site Name:\").Set \"InterviewBit\" Dialog(\"Login\").WinEdit(\"Site Name:\").Set \"InterviewBit\" Following the Object Type, the name of an object is shown in parenthesis. Login is the object name, and Dialog is the object type. A \"dot\" separates objects in an Object Hierarchy. The Object Hierarchy of Dialog and WinEdit is the same in this case. To put things in context, Object Hierarchy is an Object Oriented Concept that refers to a collection of items that are linked in a parent-child connection. In our situation, the Parent Object is Dialog Box, and the Child Object is WinEdit. At the end of the statement, the operation done on the object is always printed, followed by any values associated with the operation. Using the Set Method, the term \"InterviewBit\" is placed in the Site Name Edit Box. The GUI object on which the operation is done, along with its whole hierarchy, is the syntax for a statement in expert view, followed by the Operation on the Object and the value associated with that Operation. This is shown as below: ParentObject(Name).ChildObject1(Name)...ChildObjectN(Name).Operation ParentObject(Name).ChildObject1(Name)...ChildObjectN(Name).Operation Keyword view: The Keyword View is a table-like view in which each step is represented by a single row in the table and each column by different sections of the steps. Keyword view: The item on which you want to perform the step is listed in the Item Column. The hierarchy of the GUI item on which the operation is done is displayed in this column using icons.\nThe operation to be performed on the object is listed in the Operation Column.\nThe Value Column includes the argument values for the selected operation, while the Documentation Column describes each step for simple understanding.\nThese four columns are the defaults, however, assignment and comment columns can also be used in Keyword View. The item on which you want to perform the step is listed in the Item Column. The hierarchy of the GUI item on which the operation is done is displayed in this column using icons. The operation to be performed on the object is listed in the Operation Column. The Value Column includes the argument values for the selected operation, while the Documentation Column describes each step for simple understanding. These four columns are the defaults, however, assignment and comment columns can also be used in Keyword View.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What do you understand about virtual objects in the context of UFT? What are the limitations of the virtual objects in UFT?",
        "answer": "Standard window objects may be present in an application under test, but UFT may not recognise them. In certain cases, objects of the type button, link, or other can be declared as virtual objects (VO) so that user actions can be mimicked on the virtual objects during execution. For example: Let's pretend we're automating a Microsoft Word scenario. We open the MS Word application and click on any of the ribbon icons. For example, on the Ribbon, the user selects the Insert tab, then selects the \"Picture\" button. Here, a button is recognised as a WinObject, emphasising the relevance of virtual objects. For example: Following are the limitations of virtual objects in UFT: For analog or low-level recording, QTP does not allow virtual objects.\nVirtual Objects cannot have checkpoints added to them.\nObject Repository has no control over Virtual Objects.\nAlthough we map an object to a specific class (button or List), Virtual objects do not provide all of the original object's methods.\nVirtual Objects are not supported by Object Spy.\nIf the screen resolution changes as the coordinates change, the test will fail.\nVirtual objects should be recorded correctly if the application window is the same size as the screen. For analog or low-level recording, QTP does not allow virtual objects. Virtual Objects cannot have checkpoints added to them. Object Repository has no control over Virtual Objects. Although we map an object to a specific class (button or List), Virtual objects do not provide all of the original object's methods. Virtual Objects are not supported by Object Spy. If the screen resolution changes as the coordinates change, the test will fail. Virtual objects should be recorded correctly if the application window is the same size as the screen.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Differentiate between UFT and Selenium.",
        "answer": "UFT: Functional, regression, and service testing are the most common uses for the tool. UFT allows testers to automate user behaviours on a web or client-based computer application, as well as test and uncover defects that may arise as a result of such actions. This holds true for the identical operations performed on different people, data sets, Windows operating systems, and browsers. Automation with QTP/UFT, if properly planned and executed, can save a lot of time and money.\nSelenium: Selenium is an open-source umbrella project providing a collection of web browser automation technologies and libraries. Without having to learn a test scripting language, Selenium provides a playback tool for building functional tests (Selenium IDE). It also includes a test domain-specific language (Selenese) for writing tests in JavaScript (Node.js), C#, Groovy, Java, Perl, PHP, Python, Ruby, and Scala. Most recent web browsers can then be used to run the tests. Selenium is available for Windows, Linux, and Mac OS X. It's free software distributed under the Apache License 2.0. UFT: Functional, regression, and service testing are the most common uses for the tool. UFT allows testers to automate user behaviours on a web or client-based computer application, as well as test and uncover defects that may arise as a result of such actions. This holds true for the identical operations performed on different people, data sets, Windows operating systems, and browsers. Automation with QTP/UFT, if properly planned and executed, can save a lot of time and money. UFT: Selenium: Selenium is an open-source umbrella project providing a collection of web browser automation technologies and libraries. Without having to learn a test scripting language, Selenium provides a playback tool for building functional tests (Selenium IDE). It also includes a test domain-specific language (Selenese) for writing tests in JavaScript (Node.js), C#, Groovy, Java, Perl, PHP, Python, Ruby, and Scala. Most recent web browsers can then be used to run the tests. Selenium is available for Windows, Linux, and Mac OS X. It's free software distributed under the Apache License 2.0. Selenium: The following table lists the differences between UFT and Selenium:   Unified Functional Testing (UFT) Selenium \nIt is a Micro Focus commercial tool, thus it requires a licence and is costly. It's an open-source testing tool, therefore there's no need for a licence and it's completely free.\nIt's used for client-server application testing. It can test both web and desktop applications. Only web applications can be automated with Selenium.\nOnly the QTP IDE can be used to create QTP tests. Selenium can be used with a variety of IDEs, including Visual Studio, Eclipse, and Netbeans.\nOnly VB scripts are supported by HP UFT. Selenium supports a wide range of programming languages, including Java,.NET, Ruby, Perl, PHP, and many others.\nA built-in object repository is included with HP UFT. In HP ALM, creating and maintaining object repositories is a breeze. Although Selenium lacks a built-in object repository, objects can be maintained using the UI element user extension.\nHP UFT is compatible with test management software such as HP Quality Center. Selenium is not compatible with any such test management software.\nUFT Testing supports all forms of dialogue boxes. It partially supports dialogue boxes.\nIt supports a variety of environments, including SAP, Oracle, and.NET, but users must acquire an add-on licence for each of them. It allows you to add plug-ins to provide functionalities that Selenium doesn't give by default.\nBecause of the licencing fees, automation testing is costly. Selenium web automation testing is less expensive.\nHP QTP provides excellent technical support. Because it is an open-source project, it receives no formal support.\nOnly VBScript is supported by HP QTP. Hence Test Automation using an Object-Oriented Approach gets difficult. Selenium supports Object-Oriented Programming Languages such as Java.\nHP QTP is more user-friendly, and scripts may be written faster. It's a simple tool with limited capabilities. The development and maintenance of a script take more time.\nBackward compatibility has a lot of power. The most recent version of HP ALM supports code that was written five years ago. In Selenium, the API evolves with each new Selenium release. As a result, test scripts must be modified. Unified Functional Testing (UFT) Selenium \nIt is a Micro Focus commercial tool, thus it requires a licence and is costly. It's an open-source testing tool, therefore there's no need for a licence and it's completely free.\nIt's used for client-server application testing. It can test both web and desktop applications. Only web applications can be automated with Selenium.\nOnly the QTP IDE can be used to create QTP tests. Selenium can be used with a variety of IDEs, including Visual Studio, Eclipse, and Netbeans.\nOnly VB scripts are supported by HP UFT. Selenium supports a wide range of programming languages, including Java,.NET, Ruby, Perl, PHP, and many others.\nA built-in object repository is included with HP UFT. In HP ALM, creating and maintaining object repositories is a breeze. Although Selenium lacks a built-in object repository, objects can be maintained using the UI element user extension.\nHP UFT is compatible with test management software such as HP Quality Center. Selenium is not compatible with any such test management software.\nUFT Testing supports all forms of dialogue boxes. It partially supports dialogue boxes.\nIt supports a variety of environments, including SAP, Oracle, and.NET, but users must acquire an add-on licence for each of them. It allows you to add plug-ins to provide functionalities that Selenium doesn't give by default.\nBecause of the licencing fees, automation testing is costly. Selenium web automation testing is less expensive.\nHP QTP provides excellent technical support. Because it is an open-source project, it receives no formal support.\nOnly VBScript is supported by HP QTP. Hence Test Automation using an Object-Oriented Approach gets difficult. Selenium supports Object-Oriented Programming Languages such as Java.\nHP QTP is more user-friendly, and scripts may be written faster. It's a simple tool with limited capabilities. The development and maintenance of a script take more time.\nBackward compatibility has a lot of power. The most recent version of HP ALM supports code that was written five years ago. In Selenium, the API evolves with each new Selenium release. As a result, test scripts must be modified. Unified Functional Testing (UFT) Selenium Unified Functional Testing (UFT) Selenium Unified Functional Testing (UFT) Selenium It is a Micro Focus commercial tool, thus it requires a licence and is costly. It's an open-source testing tool, therefore there's no need for a licence and it's completely free.\nIt's used for client-server application testing. It can test both web and desktop applications. Only web applications can be automated with Selenium.\nOnly the QTP IDE can be used to create QTP tests. Selenium can be used with a variety of IDEs, including Visual Studio, Eclipse, and Netbeans.\nOnly VB scripts are supported by HP UFT. Selenium supports a wide range of programming languages, including Java,.NET, Ruby, Perl, PHP, and many others.\nA built-in object repository is included with HP UFT. In HP ALM, creating and maintaining object repositories is a breeze. Although Selenium lacks a built-in object repository, objects can be maintained using the UI element user extension.\nHP UFT is compatible with test management software such as HP Quality Center. Selenium is not compatible with any such test management software.\nUFT Testing supports all forms of dialogue boxes. It partially supports dialogue boxes.\nIt supports a variety of environments, including SAP, Oracle, and.NET, but users must acquire an add-on licence for each of them. It allows you to add plug-ins to provide functionalities that Selenium doesn't give by default.\nBecause of the licencing fees, automation testing is costly. Selenium web automation testing is less expensive.\nHP QTP provides excellent technical support. Because it is an open-source project, it receives no formal support.\nOnly VBScript is supported by HP QTP. Hence Test Automation using an Object-Oriented Approach gets difficult. Selenium supports Object-Oriented Programming Languages such as Java.\nHP QTP is more user-friendly, and scripts may be written faster. It's a simple tool with limited capabilities. The development and maintenance of a script take more time.\nBackward compatibility has a lot of power. The most recent version of HP ALM supports code that was written five years ago. In Selenium, the API evolves with each new Selenium release. As a result, test scripts must be modified. It is a Micro Focus commercial tool, thus it requires a licence and is costly. It's an open-source testing tool, therefore there's no need for a licence and it's completely free. It is a Micro Focus commercial tool, thus it requires a licence and is costly. It's an open-source testing tool, therefore there's no need for a licence and it's completely free. It's used for client-server application testing. It can test both web and desktop applications. Only web applications can be automated with Selenium. It's used for client-server application testing. It can test both web and desktop applications. Only web applications can be automated with Selenium. Only the QTP IDE can be used to create QTP tests. Selenium can be used with a variety of IDEs, including Visual Studio, Eclipse, and Netbeans. Only the QTP IDE can be used to create QTP tests. Selenium can be used with a variety of IDEs, including Visual Studio, Eclipse, and Netbeans. Only VB scripts are supported by HP UFT. Selenium supports a wide range of programming languages, including Java,.NET, Ruby, Perl, PHP, and many others. Only VB scripts are supported by HP UFT. Selenium supports a wide range of programming languages, including Java,.NET, Ruby, Perl, PHP, and many others. A built-in object repository is included with HP UFT. In HP ALM, creating and maintaining object repositories is a breeze. Although Selenium lacks a built-in object repository, objects can be maintained using the UI element user extension. A built-in object repository is included with HP UFT. In HP ALM, creating and maintaining object repositories is a breeze. Although Selenium lacks a built-in object repository, objects can be maintained using the UI element user extension. HP UFT is compatible with test management software such as HP Quality Center. Selenium is not compatible with any such test management software. HP UFT is compatible with test management software such as HP Quality Center. Selenium is not compatible with any such test management software. UFT Testing supports all forms of dialogue boxes. It partially supports dialogue boxes. UFT Testing supports all forms of dialogue boxes. It partially supports dialogue boxes. It supports a variety of environments, including SAP, Oracle, and.NET, but users must acquire an add-on licence for each of them. It allows you to add plug-ins to provide functionalities that Selenium doesn't give by default. It supports a variety of environments, including SAP, Oracle, and.NET, but users must acquire an add-on licence for each of them. It allows you to add plug-ins to provide functionalities that Selenium doesn't give by default. Because of the licencing fees, automation testing is costly. Selenium web automation testing is less expensive. Because of the licencing fees, automation testing is costly. Selenium web automation testing is less expensive. HP QTP provides excellent technical support. Because it is an open-source project, it receives no formal support. HP QTP provides excellent technical support. Because it is an open-source project, it receives no formal support. Only VBScript is supported by HP QTP. Hence Test Automation using an Object-Oriented Approach gets difficult. Selenium supports Object-Oriented Programming Languages such as Java. Only VBScript is supported by HP QTP. Hence Test Automation using an Object-Oriented Approach gets difficult. Selenium supports Object-Oriented Programming Languages such as Java. HP QTP is more user-friendly, and scripts may be written faster. It's a simple tool with limited capabilities. The development and maintenance of a script take more time. HP QTP is more user-friendly, and scripts may be written faster. It's a simple tool with limited capabilities. The development and maintenance of a script take more time. Backward compatibility has a lot of power. The most recent version of HP ALM supports code that was written five years ago. In Selenium, the API evolves with each new Selenium release. As a result, test scripts must be modified. Backward compatibility has a lot of power. The most recent version of HP ALM supports code that was written five years ago. In Selenium, the API evolves with each new Selenium release. As a result, test scripts must be modified.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What are the different types of object repositories available in UFT?",
        "answer": "Following are the different types of object repositories available in UFT: Local Object Repository: The default object repository is the Local Object Repository. It is action-specific and can only be used for one action at a time. When the application is not time-sensitive, a local object repository is preferred. The Local Object Repository can't be utilised again. In the local object repository, you can do a variety of things, including -\nOn the application under test, highlight an object saved in a repository.\nCheck to see if a specific object in your AUT is saved in the Object Repository.\nObjects can be cut, copied, pasted, modified, and deleted.\nIf you mistakenly changed the value of a property, you can edit its description using the update function in the application.\nShared Object Repository: When an application is dynamic and object descriptions change frequently, a global or shared object repository is preferred. In automation projects, shared object repositories are more typically utilised than local object repositories. However, when compared to a local object store, it has higher maintenance and administration costs. Local Object Repository: The default object repository is the Local Object Repository. It is action-specific and can only be used for one action at a time. When the application is not time-sensitive, a local object repository is preferred. The Local Object Repository can't be utilised again. In the local object repository, you can do a variety of things, including -\nOn the application under test, highlight an object saved in a repository.\nCheck to see if a specific object in your AUT is saved in the Object Repository.\nObjects can be cut, copied, pasted, modified, and deleted.\nIf you mistakenly changed the value of a property, you can edit its description using the update function in the application. Local Object Repository: On the application under test, highlight an object saved in a repository.\nCheck to see if a specific object in your AUT is saved in the Object Repository.\nObjects can be cut, copied, pasted, modified, and deleted.\nIf you mistakenly changed the value of a property, you can edit its description using the update function in the application. On the application under test, highlight an object saved in a repository. Check to see if a specific object in your AUT is saved in the Object Repository. Objects can be cut, copied, pasted, modified, and deleted. If you mistakenly changed the value of a property, you can edit its description using the update function in the application. Shared Object Repository: When an application is dynamic and object descriptions change frequently, a global or shared object repository is preferred. In automation projects, shared object repositories are more typically utilised than local object repositories. However, when compared to a local object store, it has higher maintenance and administration costs. Shared Object Repository:",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What do you understand about object repositories in the context of UFT? Explain how object identification works in UFT.",
        "answer": "UFT recognises an Object Repository as a collection of Test Objects and information for working on it. By default, when a user records a test, the objects and their properties are recorded. UFT will not be able to playback scripts until it understands objects and their properties. Object Identification in UFT can be described in the following points:\nFor object identification, UFT employs \"human-like\" technology.\nUFT tries to learn the properties of a GUI object on which an operation is performed during Record.\nMicro Focus UFT compares the recorded object attributes to the real object properties available on-screen during run-time and uniquely identifies an object regardless of its location on the screen.\nTEST Object is the name of the stored object and its characteristics.\nThe actual object available on the application under test during Run-Time is referred to as the Run-Time Object. This is the \"Test Object Model\" from Quick Tests.\nThe Object Repository stores information about the Test Objects.\nAdd-ins assist in informing Quick Test ahead of time about the nature of the object to be recorded, reducing the time spent learning its properties. Object Identification in UFT can be described in the following points: For object identification, UFT employs \"human-like\" technology. UFT tries to learn the properties of a GUI object on which an operation is performed during Record. Micro Focus UFT compares the recorded object attributes to the real object properties available on-screen during run-time and uniquely identifies an object regardless of its location on the screen. TEST Object is the name of the stored object and its characteristics. The actual object available on the application under test during Run-Time is referred to as the Run-Time Object. This is the \"Test Object Model\" from Quick Tests. The Object Repository stores information about the Test Objects. Add-ins assist in informing Quick Test ahead of time about the nature of the object to be recorded, reducing the time spent learning its properties.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What are the different types of recording modes available in UFT? Is it possible to change between Recording modes while creating a Test?",
        "answer": "Following are the different types of recording modes available in UFT: Context-Sensitive Recording Mode: Context-Sensitive Mode is another name for regular recording mode. It's the default recording mode, and it makes the most of Quick Test Professional's test object model. It recognises things in the app no matter where they are on the screen. It keeps track of the objects in your programme and the operations you make on them.\nAnalog Recording Mode: Quick Test Professional records and tracks every movement of the mouse as you drag it around a screen or window in analogue recording mode. Analog recordings made by UFT are saved as Tracks in your test directory. It's handy for capturing operations that can't be captured at the object level. For instance, a signature is created by dragging the mouse. You may record in analogue mode in the following ways:\nIn relation to the screen - Use the screen option when your analogue operation involves many screens, such as dragging and dropping an object from one window to another.\nIn relation to the window - Use relative to a window when your analogue operation is limited to a single window.\nLow-Level Mode: This mode allows you to record any object in your application, regardless of whether QTP recognises the object or operation. All run-time objects are recorded as Window or WinObject test objects in this mode, which records at the object level. It's utilised when you need to know the exact coordinates of an object for your tests. Hashmaps are a nice example, where clicking different portions of a picture lead to different URLs. This mode of recording is used when recording tests are done in an environment that QTP does not recognise. The x,y coordinates of any clicks are recorded in low-level mode. \nAnalog and low-level recording use up more disk space than standard recording. Screen positions during recording and playback must be similar in both modes, or the script will fail. As a result, only use analog or low-level recording when the regular recording mode fails to adequately capture your operation. When recording objects or surroundings that QTP does not support, QTP will occasionally convert to low-level mode. Context-Sensitive Recording Mode: Context-Sensitive Mode is another name for regular recording mode. It's the default recording mode, and it makes the most of Quick Test Professional's test object model. It recognises things in the app no matter where they are on the screen. It keeps track of the objects in your programme and the operations you make on them. Context-Sensitive Recording Mode: Analog Recording Mode: Quick Test Professional records and tracks every movement of the mouse as you drag it around a screen or window in analogue recording mode. Analog recordings made by UFT are saved as Tracks in your test directory. It's handy for capturing operations that can't be captured at the object level. For instance, a signature is created by dragging the mouse. You may record in analogue mode in the following ways:\nIn relation to the screen - Use the screen option when your analogue operation involves many screens, such as dragging and dropping an object from one window to another.\nIn relation to the window - Use relative to a window when your analogue operation is limited to a single window. Analog Recording Mode: In relation to the screen - Use the screen option when your analogue operation involves many screens, such as dragging and dropping an object from one window to another.\nIn relation to the window - Use relative to a window when your analogue operation is limited to a single window. In relation to the screen - Use the screen option when your analogue operation involves many screens, such as dragging and dropping an object from one window to another. In relation to the screen In relation to the window - Use relative to a window when your analogue operation is limited to a single window. In relation to the window Low-Level Mode: This mode allows you to record any object in your application, regardless of whether QTP recognises the object or operation. All run-time objects are recorded as Window or WinObject test objects in this mode, which records at the object level. It's utilised when you need to know the exact coordinates of an object for your tests. Hashmaps are a nice example, where clicking different portions of a picture lead to different URLs. This mode of recording is used when recording tests are done in an environment that QTP does not recognise. The x,y coordinates of any clicks are recorded in low-level mode. \nAnalog and low-level recording use up more disk space than standard recording. Screen positions during recording and playback must be similar in both modes, or the script will fail. As a result, only use analog or low-level recording when the regular recording mode fails to adequately capture your operation. When recording objects or surroundings that QTP does not support, QTP will occasionally convert to low-level mode. Low-Level Mode:  Yes, we can switch to Analog/Low-level mode in the middle of a recording, accomplish the task at hand, and then return to conventional recording. The Analog mode switch is only available when recording, not while editing.",
        "reference": "interviewbit.com"
    }
]