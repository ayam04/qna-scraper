[
    {
        "question": "1. What is COBOL?",
        "answer": "COBOL stands for Common Business Oriented Language and is one of the oldest high-level programming languages used for solving complex business problems in different domains like business verticals, finance, security and administrative purposes. Following are the features of this programming language: Simplicity: It is an easy-to-learn language with a simple and wide vocabulary for syntax and has an uncluttered style of coding.\nBusiness-oriented capabilities: COBOL has advanced capabilities for file handling that let it operate on huge data and can be used for simple to complex processing operations thereby being it the most popular technology for handling business transactions.\nUniversality: COBOL is one of the oldest programming languages and has survived for more than 6 decades across growing business needs and has adapted across almost every platform, product and compiler.\nScalability: COBOL is highly scalable, reliable and is also portable across different platforms. They provide variables control structures that make it easy to read, debug and modify. Simplicity: It is an easy-to-learn language with a simple and wide vocabulary for syntax and has an uncluttered style of coding. Simplicity: Business-oriented capabilities: COBOL has advanced capabilities for file handling that let it operate on huge data and can be used for simple to complex processing operations thereby being it the most popular technology for handling business transactions. Business-oriented capabilities: Universality: COBOL is one of the oldest programming languages and has survived for more than 6 decades across growing business needs and has adapted across almost every platform, product and compiler. Universality: Scalability: COBOL is highly scalable, reliable and is also portable across different platforms. They provide variables control structures that make it easy to read, debug and modify. Scalability:",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What are the available data types in the COBOL language?",
        "answer": "There are mainly three data types supported by COBOL, they are: Numeric data type \u2013 Used for representing numerical values between 0-9.\nAlphabetic data type \u2013 Used for representing alphabetic values ranging from A-Z.\nAlphanumeric data type \u2013 Used for representing both numeric and alphabetic types. Numeric data type \u2013 Used for representing numerical values between 0-9. Numeric data type Alphabetic data type \u2013 Used for representing alphabetic values ranging from A-Z. Alphabetic data type Alphanumeric data type \u2013 Used for representing both numeric and alphabetic types. Alphanumeric data type",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. How is the NEXT SENTENCE statement different from CONTINUE statement?",
        "answer": "The CONTINUE statement is like a null statement that indicates no operation and the control needs to be passed to the next executable instruction after explicit scope terminator. It can be used anywhere in conditional statements or imperative statements are used. Example syntax for CONTINUE in case of IF construct is: CONTINUE CONTINUE IF condition-1 THEN\n   {statement-1 ...    | CONTINUE}\n[ELSE {statement-2 ... | CONTINUE}]\n[END-IF] IF condition-1 THEN\n   {statement-1 ...    | CONTINUE}\n[ELSE {statement-2 ... | CONTINUE}]\n[END-IF] The NEXT SENTENCE statement does the task of simply transferring the control to an implicit CONTINUE statement that is present immediately after the next separator period. If the statement is specified along with the END-IF statement then the control passes to the statement after the closest following period. It is mainly used to transfer control to the next sentence. NEXT SENTENCE IF condition-1 THEN\n   {statement-1 ... | NEXT SENTENCE} IF condition-1 THEN\n   {statement-1 ... | NEXT SENTENCE}",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What is IS NUMERIC clause?",
        "answer": "This clause is used for checking if an item is a numeric value or not. If it is numeric - positive or negative, TRUE will be returned. For example: CHECK-NUMBER SECTION.\n    DISPLAY 'Check if input is numeric ' INPUT-NUM\n    IF INPUT-NUM IS NUMERIC\n        DISPLAY 'input is numeric'\n    ELSE\n        DISPLAY 'input is non numeric' CHECK-NUMBER SECTION.\n    DISPLAY 'Check if input is numeric ' INPUT-NUM\n    IF INPUT-NUM IS NUMERIC\n        DISPLAY 'input is numeric'\n    ELSE\n        DISPLAY 'input is non numeric'",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What is the importance of using REPLACING option in a COPY statement?",
        "answer": "REPLACING option is used for allowing the same copy to be used multiple times by changing the replace value in the same code.\nSyntax COPY <VariableName> REPLACING BY  COPY <VariableName> REPLACING BY",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. How is SSRANGE different from NOSSRANGE?",
        "answer": "Both are options used by the compiler for finding subscript outside of range.\nSSRANGE is used for handling the overflow of an array systematically. It needs to be specified explicitly which helps in finding exact subscript outside of range. Whereas the NOSSRANGE is used in cases of very sensitive applications that are driven by performance. It is the default option that gets applied and need not be specified explicitly and it does not support runtime errors whenever the index goes out of range. ",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. How is PERFORM \u2026 WITH TEST AFTER different from PERFORM \u2026 WITH TEST BEFORE?",
        "answer": "PERFORM ... WITH TEST BEFORE indicates that the condition must be tested at the beginning of every execution of the specified PERFORM range. Whereas TEST AFTER is used for testing the condition after every execution. PERFORM ... WITH TEST BEFORE",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What happens during INPUT PROCEDURE and OUTPUT PROCEDURE?",
        "answer": "In INPUT PROCEDURE, the input file will be opened, the records from the file are read and can also be edited. The records will then be released to sorting operation and then the file will be closed. Whereas in OUTPUT PROCEDURE, the output file will be opened, the records post sorting will be written in the output file and then the file will be closed.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. Why is LINKAGE SECTION needed?",
        "answer": "It is used for passing data from one program to another. It can also be used for passing data from a procedure to another program. It maps data in the calling program\u2019s working storage.",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Why should we not define OCCURS clause at 01 level?",
        "answer": "01 level is the level of record. We can repeat the fields within a record but we cannot repeat the record itself. The OCCURS clause indicates the repetition of the definition of data names. This is why we cannot use the OCCURS clause at the 01 level.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. How do we find current date from the system within a century?",
        "answer": "We can find it out by using the Intrinsic function called FUNCTION CURRENT-DATE. We can also make use of the DATE function for accepting the current date. It has to be noted that the current date cannot be accepted if we are using CICS COBOL programs. FUNCTION CURRENT-DATE",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. How is CALL command different from LINK?",
        "answer": "CALL command is an actual command that initiates an external program and returns. The LINK command is also similar to CALL but it does not belong to COBOL verb vocabulary. The LINK command runs like a separate run unit whereas CALL is executed as a single run unit.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What is the importance of INITIALIZE verb?",
        "answer": "INITIALIZE verb is used for initializing values in data items to their default value. Numeric items will be set to 0, alphabetic and alphanumeric items will be set to spaces. Items like FILLERS, OCCURS DEPENDING ON are to be left untouched during the initialization.",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. Differentiate between OS/VS COBOL and VS COBOL II.",
        "answer": "OS/VS COBOL VS COBOL II\nRuns in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes.\nSupports Report Writer. Does not support Report Writer.\nUSAGE IS POINTER is not supported. USAGE IS POINTER is supported.\nReference modification is not supported here. Reference modification is supported here.\nEVALUATE is not supported here. EVALUATE is supported here.\nScope terminators are not supported. Scope terminators are supported.\nFollows ANSI 74 standards. ANSI 85 standards are followed here.\nCalls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS. OS/VS COBOL VS COBOL II\nRuns in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes.\nSupports Report Writer. Does not support Report Writer.\nUSAGE IS POINTER is not supported. USAGE IS POINTER is supported.\nReference modification is not supported here. Reference modification is supported here.\nEVALUATE is not supported here. EVALUATE is supported here.\nScope terminators are not supported. Scope terminators are supported.\nFollows ANSI 74 standards. ANSI 85 standards are followed here.\nCalls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS. OS/VS COBOL VS COBOL II OS/VS COBOL VS COBOL II OS/VS COBOL VS COBOL II Runs in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes.\nSupports Report Writer. Does not support Report Writer.\nUSAGE IS POINTER is not supported. USAGE IS POINTER is supported.\nReference modification is not supported here. Reference modification is supported here.\nEVALUATE is not supported here. EVALUATE is supported here.\nScope terminators are not supported. Scope terminators are supported.\nFollows ANSI 74 standards. ANSI 85 standards are followed here.\nCalls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS. Runs in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes. Runs in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes. Supports Report Writer. Does not support Report Writer. Supports Report Writer. Does not support Report Writer. USAGE IS POINTER is not supported. USAGE IS POINTER is supported. USAGE IS POINTER is not supported. USAGE IS POINTER is supported. Reference modification is not supported here. Reference modification is supported here. Reference modification is not supported here. Reference modification is supported here. EVALUATE is not supported here. EVALUATE is supported here. EVALUATE is not supported here. EVALUATE is supported here. Scope terminators are not supported. Scope terminators are supported. Scope terminators are not supported. Scope terminators are supported. Follows ANSI 74 standards. ANSI 85 standards are followed here. Follows ANSI 74 standards. ANSI 85 standards are followed here. Calls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS. Calls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS.",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What do you understand by static and dynamic linking?",
        "answer": "Static and dynamic linking are two types of linking available in COBOL. Static linking refers to the linking of subroutine into calling program and not existing as a separate module. In dynamic linking, the subroutine exists as a separate program and does not link to the main program. The static linking can be done by using the NODYNAM link option and the dynamic linking can be done by using the DYNAM option.",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. What are the object oriented features provided in COBOL?",
        "answer": "Object-Oriented COBOL provides the following features: Define classes and let programs define and create objects of those classes.\nData encapsulation is due to the ability to create objects. The data properties will be encapsulated in the objects.\nBehaviour of objects can be defined for the class by means of methods.\nInheritance is supported in COBOL.\nProvides maximum flexibility by means of polymorphism and defining interfaces.\nAlso compatible with procedural programming. Define classes and let programs define and create objects of those classes. Data encapsulation is due to the ability to create objects. The data properties will be encapsulated in the objects. Behaviour of objects can be defined for the class by means of methods. Inheritance is supported in COBOL. Provides maximum flexibility by means of polymorphism and defining interfaces. Also compatible with procedural programming.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Consider a scenario where we have a program having an array of 20 items. When the program tries to access the 21st item, the program fails to abend. What is the reason for this?",
        "answer": "The default compiler option NOSSRANGE must have been used which does not allow the program to abend. If we want the program to abend whenever accessing an array element that is out of bounds, we need to use the compiler option of SSRANGE. Using this option, the program abends with SOC4 error which indicates that it tried to access an invalid address by using the wrong index.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Why is S9(4) COMP needed despite knowing that Comp-3 would utilise less space?",
        "answer": "S9(4) COMP represents that the item is a small integer which means two words of 1 byte each can occupy a total of 2 bytes. In S9(4) COMP-3, one word is equal to half a byte which means 4 words can occupy 2 bytes and additionally, the sign occupies another half byte which results in a maximum of 3 bytes usage. More can be accommodated in S9(4) COMP when compares to COMP-3.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What do you understand by the following terminologies?",
        "answer": "AMODE(31)\nAMODE(24)\nRMODE(24)\nRMODE(ANY) AMODE(31) AMODE(31) AMODE(24) AMODE(24) RMODE(24) RMODE(24) RMODE(ANY) RMODE(ANY) All 4 are the options that are available in compile or link editing. AMODE expands to Addressing Mode. AMODE(31) and AMODE(24) represents that the addressing mode used is 31-bit and 24-bit respectively. When we use AMODE(ANY), it indicates that either 31-bit mode or 24-bit addressing mode can be used and it is dependent on the value of RMODE. RMODE represents Resident Mode within the virtual storage. RMODE(24) represents that the mode can reside within virtual storage below the 16 Meg line. RMODE(ANY) represents that the mode can reside below or above 16 Meg line and the address bit can be either 24-bit or 31-bit depending on the RMODE.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. How is INCLUDE different from COPY?",
        "answer": "The main similarity between INCLUDE and COPY is that both help in expanding the program variables or codes. The important difference between them is that INCLUDE is used for expanding the code at the time of pre-compilation. Whereas the COPY expands the code at compilation time. DB2 pre-compilers won\u2019t be able to process COPY statements which is why the statements involving the validation of table attributes and DCL statements are embedded using INCLUDE.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What are the problems associated with using ordered sequential files?",
        "answer": "The main nature of ordered sequential files is that the records are arranged based on some key field(s). When a user wants to perform operations like insert or deletion, then the order based on the field(s) should be maintained at all times. This is attained only by creating a new file where we insert or update or delete the records within the new file and then maintain the ordered nature. All these take place on the disk directly and the time required to access data on disk is the main bottleneck while processing any functionality. This reduces the speed of computation and slows down the system unnecessarily if we try to use ordered sequential files whenever not needed.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Under what circumstances are scope terminators mandatorily needed?",
        "answer": "When we are using in-line PERFORMS or EVALUATE statements, we need to use scope terminators. It is recommended because it helps to read the code better and is deemed as a good coding practice.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What are the causes of S0C7, S0C5 and S0C1?",
        "answer": "S0C7 is caused mainly due to the following reasons: S0C7 is caused mainly due to the following reasons: Whenever numeric operations are performed on data of non-numeric type.\nWhen we are working on the uninitialized storage.\nWhen we try to code excessively that surpasses the maximum permitted dub script. Whenever numeric operations are performed on data of non-numeric type. When we are working on the uninitialized storage. When we try to code excessively that surpasses the maximum permitted dub script. S0C5 is caused mainly due to the following reasons: S0C5 is caused mainly due to the following reasons: Damaged index or subscript.\nExit occurred incorrectly from a perform.\nBefore the read operation, I/O is accessed.\nWhen we try to close an unopened dataset. Damaged index or subscript. Exit occurred incorrectly from a perform. Before the read operation, I/O is accessed. When we try to close an unopened dataset. S0C1 is caused mainly due to the following reasons: S0C1 is caused mainly due to the following reasons: Incorrectly spelt DD name.\nWhen we perform a read or write operation on an unopened dataset.\nWhen the subprograms that are called are not found. Incorrectly spelt DD name. When we perform a read or write operation on an unopened dataset. When the subprograms that are called are not found.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What are the differences between Structured COBOL and Object-Oriented COBOL programming?",
        "answer": "Structured COBOL Programming Object-Oriented COBOL Programming\nAll functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner.\nLess secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding.\nMore natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure. Structured COBOL Programming Object-Oriented COBOL Programming\nAll functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner.\nLess secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding.\nMore natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure. Structured COBOL Programming Object-Oriented COBOL Programming Structured COBOL Programming Object-Oriented COBOL Programming Structured COBOL Programming Object-Oriented COBOL Programming All functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner.\nLess secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding.\nMore natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure. All functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner. All functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner. Less secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding. Less secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding. More natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure. More natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. How can we reference or make COBOL program realise that about the following file formats?",
        "answer": "1. Fixed Block File\n2. Fixed Unblock File\n3. Variable Block File\n4. Variable Unblock File\n5. Printer File 1. Fixed Block File  2. Fixed Unblock File  3. Variable Block File  4. Variable Unblock File  5. Printer File Following are the explanation to the points one by one: Fixed Block File: We can identify that a file is a fixed block file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAINS 0\nFixed Unblock File: We can identify that a file is a fixed unblock file if the following 2 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nVariable Block File: We can identify that a file is a variable block file if the following 4 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nBLOCK CONTAINS 0\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4.\nVariable Unblock File: We can identify that a file is a variable unblock file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4.\nPrinter File: We can reference that a file is a printer file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAIN 0 Fixed Block File: We can identify that a file is a fixed block file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAINS 0 Fixed Block File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAINS 0 ORGANIZATION IS SEQUENTIAL RECORDING MODE IS F BLOCK CONTAINS 0 Fixed Unblock File: We can identify that a file is a fixed unblock file if the following 2 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F Fixed Unblock File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F ORGANIZATION IS SEQUENTIAL RECORDING MODE IS F Variable Block File: We can identify that a file is a variable block file if the following 4 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nBLOCK CONTAINS 0\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. Variable Block File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nBLOCK CONTAINS 0\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. ORGANIZATION IS SEQUENTIAL RECORDING MODE IS V BLOCK CONTAINS 0 Record length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. Variable Unblock File: We can identify that a file is a variable unblock file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. Variable Unblock File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. ORGANIZATION IS SEQUENTIAL RECORDING MODE IS V Record length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. Printer File: We can reference that a file is a printer file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAIN 0 Printer File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAIN 0 ORGANIZATION IS SEQUENTIAL RECORDING MODE IS F BLOCK CONTAIN 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. How can we process two files by comparing key fields?",
        "answer": "There are 2 possible approaches for this: Approach 1:\nWe can read records from both files, if the key fields match, then they can be ignored.\nIf upon key comparison, the results are unequal, then we identify which file has missing or new records and update the file with missing records accordingly.\nApproach 2:\nIf both files have the same records, then the work will be reduced.\nIf file 1 comes to the AT END state, then we have to move HIGH VALUES into the key field. The same goes to file 2.\nThis process needs to be repeated until both key fields are equal to HIGH VALUES.\nFor this process to work, the key fields should be in PIC(X) format and not numeric. Approach 1:\nWe can read records from both files, if the key fields match, then they can be ignored.\nIf upon key comparison, the results are unequal, then we identify which file has missing or new records and update the file with missing records accordingly. Approach 1: We can read records from both files, if the key fields match, then they can be ignored.\nIf upon key comparison, the results are unequal, then we identify which file has missing or new records and update the file with missing records accordingly. We can read records from both files, if the key fields match, then they can be ignored. If upon key comparison, the results are unequal, then we identify which file has missing or new records and update the file with missing records accordingly. Approach 2:\nIf both files have the same records, then the work will be reduced.\nIf file 1 comes to the AT END state, then we have to move HIGH VALUES into the key field. The same goes to file 2.\nThis process needs to be repeated until both key fields are equal to HIGH VALUES.\nFor this process to work, the key fields should be in PIC(X) format and not numeric. Approach 2: If both files have the same records, then the work will be reduced.\nIf file 1 comes to the AT END state, then we have to move HIGH VALUES into the key field. The same goes to file 2.\nThis process needs to be repeated until both key fields are equal to HIGH VALUES.\nFor this process to work, the key fields should be in PIC(X) format and not numeric. If both files have the same records, then the work will be reduced. If file 1 comes to the AT END state, then we have to move HIGH VALUES into the key field. The same goes to file 2. AT END HIGH VALUES This process needs to be repeated until both key fields are equal to HIGH VALUES. For this process to work, the key fields should be in PIC(X) format and not numeric. To make the process easier, we can avoid a lot of I-O operations by reading data to the local array table and then processing the records from there.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. How do we remove the spaces at end of every record in an output file that is of variable length?",
        "answer": "Spaces that are present at the end of the record are called trailing spaces. COBOL does not provide the functionality to remove such trailing spaces. But it can be achieved by using the RECORD-LENGTH field as follows:\nConsider a scenario where we have a file of variable length and the maximum possible record length is 4000. To remove trailing space from every record, then we can alter the record length value to RECORD-LENGTH. This ensures that the records are trimmed which are beyond actual record length. Assuming that a variable-length file has a maximum record length of 4000.  Move the original record length value to RECORD-LENGTH. This process enables the trimming of the entire record that is beyond the length.\nIn case the data is populated only up to 3000 bytes - meaning there are 1000 trailing spaces. Then move the record length value to RECORD-LENGTH.\nBy doing this, the records would be trimmed off and 1000 bytes would be freed. Move the original record length value to RECORD-LENGTH. This process enables the trimming of the entire record that is beyond the length. In case the data is populated only up to 3000 bytes - meaning there are 1000 trailing spaces. Then move the record length value to RECORD-LENGTH. By doing this, the records would be trimmed off and 1000 bytes would be freed.",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. Why should the file be opened in I-O mode when it is being used for REWRITE purposes?",
        "answer": "When the file REWRITE of the record needs to be performed, the file should first be opened and then the record must be read from the file. This is why the file should always be opened in I-O mode.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. How is sorting achieved in the COBOL program?",
        "answer": "It is done by using the SORT command whose syntax goes as follows: SORT file_1 ON ASCENDING/DESCENDING KEY key\u2026\nUSING file_2\nGIVING file_3. SORT file_1 ON ASCENDING/DESCENDING KEY key\u2026\nUSING file_2\nGIVING file_3. where file_1 - sort workfile that needs to be described by using SD entry in FILE SECTION.\nfile_2 - input file for SORT that needs to be described using FD entry in FILE SECTION and using a SELECT clause in FILE CONTROL.\nfile_3 - output file from SORT and again needs to be described using FD entry in FILE SECTION and SELECT clause in FILE CONTROL section. file_1 - sort workfile that needs to be described by using SD entry in FILE SECTION. file_2 - input file for SORT that needs to be described using FD entry in FILE SECTION and using a SELECT clause in FILE CONTROL. file_3 - output file from SORT and again needs to be described using FD entry in FILE SECTION and SELECT clause in FILE CONTROL section. All three files are not supposed to be opened explicitly. Note: Note: USING clause can be replaced by INPUT PROCEDURE IS para_1 THRU para_2. While using INPUT PROCEDURE, we need to remember that the section will be executed before sort and the records need to be released to the work file from the result of the input procedure.\nGIVING clause can be replaced by OUTPUT PROCEDURE IS para_1 THRU para_2. While using OUTPUT PROCEDURE, we need to note that the procedure will be executed once all records were sorted and the records from the sort work file should be populated one record at a time to the output procedure. USING clause can be replaced by INPUT PROCEDURE IS para_1 THRU para_2. While using INPUT PROCEDURE, we need to remember that the section will be executed before sort and the records need to be released to the work file from the result of the input procedure. USING INPUT PROCEDURE IS para_1 THRU para_2 GIVING clause can be replaced by OUTPUT PROCEDURE IS para_1 THRU para_2. While using OUTPUT PROCEDURE, we need to note that the procedure will be executed once all records were sorted and the records from the sort work file should be populated one record at a time to the output procedure. GIVING OUTPUT PROCEDURE IS para_1 THRU para_2  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. What are the different divisions in COBOL programs?",
        "answer": "There are mainly 4 divisions in a COBOL program, they are: IDENTIFICATION DIVISION: This is the most important division that is used for identifying the program. This division is needed for any COBOL program to run. If this division is not included in your program, then the program cannot be compiled.\nENVIRONMENT DIVISION: This division is subdivided into 2 types - Configuration and Input-Output section. They define the written program\u2019s environment.\nDATA DIVISION: This division is used for identifying the data items, allocating proper memory and defining the names within the program. It also has a file, linkage section and working storage.\nPROCEDURE DIVISION: This division supports the main logic of the program. It should consist of at least one statement for using user-defined variables. IDENTIFICATION DIVISION: This is the most important division that is used for identifying the program. This division is needed for any COBOL program to run. If this division is not included in your program, then the program cannot be compiled. IDENTIFICATION DIVISION ENVIRONMENT DIVISION: This division is subdivided into 2 types - Configuration and Input-Output section. They define the written program\u2019s environment. ENVIRONMENT DIVISION DATA DIVISION: This division is used for identifying the data items, allocating proper memory and defining the names within the program. It also has a file, linkage section and working storage. DATA DIVISION PROCEDURE DIVISION: This division supports the main logic of the program. It should consist of at least one statement for using user-defined variables. PROCEDURE DIVISION  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What are some of the guidelines that can be followed while developing a structured COBOL program?",
        "answer": "Certain guidelines need to be followed while writing a structured COBOL program. When developing the CASE construct, we can use EQUIVALENT statements. \nWe can use Scope Terminators while using nested constructs. \nWe can also try using IN-LINE PERFORM statements whenever possible when we want a program to perform something. \nTo perform a proper conditional check, we can also try using TEST BEFORE and TEST AFTER statements while using loop constructs to ensure desired results. When developing the CASE construct, we can use EQUIVALENT statements. We can use Scope Terminators while using nested constructs. We can also try using IN-LINE PERFORM statements whenever possible when we want a program to perform something. To perform a proper conditional check, we can also try using TEST BEFORE and TEST AFTER statements while using loop constructs to ensure desired results.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Write a COBOL program example for demonstrating the DELETE concept from a file based on a matching record.",
        "answer": "IDENTIFICATION DIVISION.\nPROGRAM-ID.   \nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.                                 \nFILE-CONTROL.          \n      SELECT RECORD-FILE ASSIGN TO DISK1. \n      ORGANIZATION IS INDEXED.                       \n      ACCESS MODE IS RANDOM.\n      RECORD KEY  IS STD-ID.\n      FILE STATUS IS WS-FS.            \nDATA DIVISION. \n    FILE SECTION.\n    FD  RECORD-FILE.   \n    01 STD-RECORD. \n    02 STD-ID          PIC 9(03).  \n    02 STD-NAME        PIC X(20).  \n\nWORKING-STORAGE SECTION.                            \n    77 WS-FS               PIC 9(02).  \n    01 WS-EOF-SW           PIC X(01) VALUE 'N'. \n    88 EOF-SW              VALUE 'Y'.      \n\nPROCEDURE DIVISION.\n    DISPLAY 'ENTER THE STUDENT ID TO BE MATCHED'\n    ACCEPT STD-ID.     \n    DISPLAY 'OPENING FILE TO DELETE MATCHING RECORD..'.  \n    OPEN INPUT RECORD-FILE. \n        PERFORM UNTIL EOF-SW   \n            READ RECORD-FILE     \n            KEY IS STD-ID      \n            AT END MOVE 'Y'  TO WS-EOF-SW  \n            IF WS-FS = 00   \n                DELETE STD-RECORD \n                MOVE 'Y'  TO WS-EOF-SW    \n            ELSE \n                DISPLAY 'RECORD NOT AVAILABLE'   \n            END-IF \n        END-PERFORM.   \n    CLOSE RECORD-FILE.  \n    DISPLAY STD-RECORD .    \n    STOP RUN. IDENTIFICATION DIVISION.\nPROGRAM-ID.   \nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.                                 \nFILE-CONTROL.          \n      SELECT RECORD-FILE ASSIGN TO DISK1. \n      ORGANIZATION IS INDEXED.                       \n      ACCESS MODE IS RANDOM.\n      RECORD KEY  IS STD-ID.\n      FILE STATUS IS WS-FS.            \nDATA DIVISION. \n    FILE SECTION.\n    FD  RECORD-FILE.   \n    01 STD-RECORD. \n    02 STD-ID          PIC 9(03).  \n    02 STD-NAME        PIC X(20).  \n\nWORKING-STORAGE SECTION.                            \n    77 WS-FS               PIC 9(02).  \n    01 WS-EOF-SW           PIC X(01) VALUE 'N'. \n    88 EOF-SW              VALUE 'Y'.      \n\nPROCEDURE DIVISION.\n    DISPLAY 'ENTER THE STUDENT ID TO BE MATCHED'\n    ACCEPT STD-ID.     \n    DISPLAY 'OPENING FILE TO DELETE MATCHING RECORD..'.  \n    OPEN INPUT RECORD-FILE. \n        PERFORM UNTIL EOF-SW   \n            READ RECORD-FILE     \n            KEY IS STD-ID      \n            AT END MOVE 'Y'  TO WS-EOF-SW  \n            IF WS-FS = 00   \n                DELETE STD-RECORD \n                MOVE 'Y'  TO WS-EOF-SW    \n            ELSE \n                DISPLAY 'RECORD NOT AVAILABLE'   \n            END-IF \n        END-PERFORM.   \n    CLOSE RECORD-FILE.  \n    DISPLAY STD-RECORD .    \n    STOP RUN. Conclusion COBOL has been around for many decades and has found its use in various business purposes due to its strong computational capabilities. In this article, we have seen the most commonly asked COBOL interview questions for both freshers and experienced professionals.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Write a COBOL program that takes 2 numbers as inputs and performs addition and multiplication on them and displays the result.",
        "answer": "IDENTIFICATION DIVISION.\nPROGRAM-ID. \n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  NUMBER1           PIC 9  VALUE ZEROS.\n01  NUMBER2           PIC 9  VALUE ZEROS.\n01  RESULTANT         PIC 99 VALUE ZEROS.\n01  OPERATOR          PIC X  VALUE SPACE.\n\nPROCEDURE DIVISION.\nADDER-MULTIPLIER.\n       DISPLAY \"FIRST INPUT: \" WITH NO ADVANCING\n       ACCEPT NUMBER1\n       DISPLAY \"SECOND INPUT: \" WITH NO ADVANCING\n       ACCEPT NUMBER2\n       DISPLAY \"ENTER + FOR ADD AND * FROM MULTIPLY: \" WITH NO ADVANCING\n       ACCEPT OPERATOR\n\n       IF OPERATOR = \"+\" THEN\n          ADD NUMBER1, NUMBER2 GIVING RESULTANT\n       END-IF\n       \n       IF OPERATOR = \"*\" THEN\n          MULTIPLY NUMBER1 BY NUMBER2 GIVING RESULTANT\n       END-IF\n       \n       DISPLAY \"RESULT OF OPERATION = \", RESULTANT\n       STOP RUN. IDENTIFICATION DIVISION.\nPROGRAM-ID. \n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  NUMBER1           PIC 9  VALUE ZEROS.\n01  NUMBER2           PIC 9  VALUE ZEROS.\n01  RESULTANT         PIC 99 VALUE ZEROS.\n01  OPERATOR          PIC X  VALUE SPACE.\n\nPROCEDURE DIVISION.\nADDER-MULTIPLIER.\n       DISPLAY \"FIRST INPUT: \" WITH NO ADVANCING\n       ACCEPT NUMBER1\n       DISPLAY \"SECOND INPUT: \" WITH NO ADVANCING\n       ACCEPT NUMBER2\n       DISPLAY \"ENTER + FOR ADD AND * FROM MULTIPLY: \" WITH NO ADVANCING\n       ACCEPT OPERATOR\n\n       IF OPERATOR = \"+\" THEN\n          ADD NUMBER1, NUMBER2 GIVING RESULTANT\n       END-IF\n       \n       IF OPERATOR = \"*\" THEN\n          MULTIPLY NUMBER1 BY NUMBER2 GIVING RESULTANT\n       END-IF\n       \n       DISPLAY \"RESULT OF OPERATION = \", RESULTANT\n       STOP RUN.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Write a COBOL program that allows users to enter the names of students of a class and then displays it. Try to use OCCURS clause for achieving this.",
        "answer": "OCCURS clause is used for specifying the table where the contents can be accessed using indexing. It is advantageous when we do not require different data entries for data of a similar kind.\nCOBOL Program: OCCURS clause is used for specifying the table where the contents can be accessed using indexing. It is advantageous when we do not require different data entries for data of a similar kind. OCCURS clause COBOL Program: IDENTIFICATION DIVISION \nPROGRAM-ID\nENVIRONMENT DIVISION\nDATA DIVISION\nWORKING-STORAGE SECTION\n    01 N PIC 9(2) VALUE 0\n    01 I PIC 9(2) VALUE 0\n    01 NAME-IN\n    02 NAME PIC X(10) OCCURS 10 times\n    01 KEY-IN PIC X VALUE SPACE\nPROCEDURE DIVISION\n    P-1\n    DISPLAY(1 1) ERASE\n    DISPLAY(3 5) \"HOW MANY STUDENTS?\"\n    ACCEPT N\n    DISPLAY(1 1) ERASE\n    PERFORM GET-DATA-PROC N TIMES\n    DISPLAY(1 1) ERASE\n    MOVE 0 to I\n    PERFORM DISPLAY-DATA-PROC N TIMES\n    STOP RUN\nGET-DATA-PROC\n    ACCEPT NAME(I)\n    ADD 1 TO I\nDISPLAY-DATA-PROC\n    DISPLAY NAME(I)\n    ACCEPT KEY-IN\n    ADD 1 TO I IDENTIFICATION DIVISION \nPROGRAM-ID\nENVIRONMENT DIVISION\nDATA DIVISION\nWORKING-STORAGE SECTION\n    01 N PIC 9(2) VALUE 0\n    01 I PIC 9(2) VALUE 0\n    01 NAME-IN\n    02 NAME PIC X(10) OCCURS 10 times\n    01 KEY-IN PIC X VALUE SPACE\nPROCEDURE DIVISION\n    P-1\n    DISPLAY(1 1) ERASE\n    DISPLAY(3 5) \"HOW MANY STUDENTS?\"\n    ACCEPT N\n    DISPLAY(1 1) ERASE\n    PERFORM GET-DATA-PROC N TIMES\n    DISPLAY(1 1) ERASE\n    MOVE 0 to I\n    PERFORM DISPLAY-DATA-PROC N TIMES\n    STOP RUN\nGET-DATA-PROC\n    ACCEPT NAME(I)\n    ADD 1 TO I\nDISPLAY-DATA-PROC\n    DISPLAY NAME(I)\n    ACCEPT KEY-IN\n    ADD 1 TO I",
        "reference": "interviewbit.com"
    }
]