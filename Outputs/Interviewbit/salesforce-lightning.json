[
    {
        "question": "1. What are our options for debugging our components?",
        "answer": "There are numerous approaches to component debugging. The simplest and quickest is to use console logging statements to log variables throughout code execution. However, this is a rather limiting technique, and there are far better ways to debug our components. To remove minification and provide clearer error messages, the first step is to enable \"Lightning Debug Mode.\" Additionally, we can utilise our browser's debugging tools to set breakpoints to inspect the precise execution of code within our components, evaluate variables at runtime, and walk through our code to better understand what's going on and figure out what's wrong.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What do you understand about lightning:navigation in the context of Salesforce Lightning?",
        "answer": "For navigating to a page reference or constructing a URL from the given page Reference, we use lightning: navigation. The page reference object must be defined in order to navigate. page Reference is a javascript object that refers to a page and provides a defined structure that specifies the page's type and values.\nWe can access the following features that are supported:  Lightning Component\nNamed Page\nKnowledge Article\nRecord Page\nObject Page\nNavigation Item Page\nWeb Page\nRecord Relationship Page. Lightning Component Named Page Knowledge Article Record Page Object Page Navigation Item Page Web Page Record Relationship Page.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Which interface should you use to retrieve the record's id from the record Detail page?",
        "answer": "We should use the force:hasRecordId interface to retrieve the record\u2019s id from the record detail page. force:hasRecordId",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What are attributes in the context of Salesforce Lightning? What are the parameters that must necessarily be provided?",
        "answer": "Attributes are variables that are used to store values. The name, type, default, description, and access of the attribute are all defined. The aura:attribute> tag is used, which requires the name and type attributes to be filled in. aura:attribute> However, only the parameters name and types are necessarily required.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What are the core principles of the Salesforce Lightning UI?",
        "answer": "Four essential design ideas were used to create the Lightning Experience UI, which SLDS embodies. They are as follows : Clarity: Eliminate ambiguity with clarity. Allow individuals to confidently perceive, comprehend, and act.\nEfficiency: Make workflows more efficient by streamlining and optimising them. Anticipate needs intelligently to help individuals perform better, smarter, and faster.\nConsistency: Applying the same solution to the same situation creates familiarity and strengthens intuition.\nBeauty: Through deliberate and elegant craftsmanship, show respect for people's time and attention. Clarity: Eliminate ambiguity with clarity. Allow individuals to confidently perceive, comprehend, and act. Clarity: Efficiency: Make workflows more efficient by streamlining and optimising them. Anticipate needs intelligently to help individuals perform better, smarter, and faster. Efficiency: Consistency: Applying the same solution to the same situation creates familiarity and strengthens intuition. Consistency: Beauty: Through deliberate and elegant craftsmanship, show respect for people's time and attention. Beauty:",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What are the benefits of using the Aura components programming model?",
        "answer": "Following are the benefits of using the Aura components programming model : Components that come pre-assembled: Comes with a pre-installed collection of components to get you started designing apps right away. You won't have to waste time optimising your apps for various devices because the components will do it for you.\nAn ecosystem with a Variety of Components: Make business-ready components available through the Salesforce app, Lightning Experience, and Communities. Users of the Salesforce app can access your components through the navigation menu. Drag-and-drop components on a Lightning Page in the Lightning App Builder or use Experience Builder to customise Lightning Experiences or Communities. The AppExchange has more components for your organisation. You can also publish and share your components with other users.\nFast Development: It enables teams to work more quickly by providing out-of-the-box components that work on both desktop and mobile platforms. Using components to build an app allows for parallel design, which improves overall development efficiency. Components are encapsulated, and their internals are kept private, but their public shape is visible to component users. This strong separation allows component authors to modify core implementation details while shielding component users from them.\nCross-browser compatibility and device awareness: Apps are responsive and support the most recent browser technology, including HTML5, CSS3, and touch events. Components that come pre-assembled: Comes with a pre-installed collection of components to get you started designing apps right away. You won't have to waste time optimising your apps for various devices because the components will do it for you. Components that come pre-assembled: An ecosystem with a Variety of Components: Make business-ready components available through the Salesforce app, Lightning Experience, and Communities. Users of the Salesforce app can access your components through the navigation menu. Drag-and-drop components on a Lightning Page in the Lightning App Builder or use Experience Builder to customise Lightning Experiences or Communities. The AppExchange has more components for your organisation. You can also publish and share your components with other users. An ecosystem with a Variety of Components: Fast Development: It enables teams to work more quickly by providing out-of-the-box components that work on both desktop and mobile platforms. Using components to build an app allows for parallel design, which improves overall development efficiency. Components are encapsulated, and their internals are kept private, but their public shape is visible to component users. This strong separation allows component authors to modify core implementation details while shielding component users from them. Fast Development: Cross-browser compatibility and device awareness: Apps are responsive and support the most recent browser technology, including HTML5, CSS3, and touch events. Cross-browser compatibility and device awareness:",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What are the benefits of using the Lightning Web Components (LWC) over the Aura components?",
        "answer": "The distinction between the Lightning Web Components and the Aura Components is only visible to those working behind the scenes. However, Salesforce and the community recommend that developers use LWCs when building SPAs for the following reasons: Easy to Learn: LWC takes the form and fills it up using the browser's native web standards. This means that no additional distraction layer, such as Aura Framework or another framework, is required; all we need to build is regular JavaScript.\nHigher Performance: Because performance is vital to deliverability, LWC is likely to render faster than the aura components in the absence of an abstraction layer.\nSites Load Faster: LWC is a lightweight framework that loads built components quickly.\nLess Proprietary, More Standards: Because LWC has built-in browser security features from Web Components Standards, out-of-the-box modification is becoming less common.\nComponents with no/little UI can be written in LWC, and those components can be reused in other components, making them more efficient than static resources.\nEasy to Learn for Developers: There is no need to learn any additional framework in order to construct LWC. As a result, the developers have an easier time.\nSecurity, Testing, and Browser Compatibility are all Improved: Script, CSS, and DOM isolation are better with LWC, and event scope is limited. We have more uniformity in the design of the components with each of these. In addition, LWC provides two-way data binding, which allows us to coordinate how data moves between different components. Easy to Learn: LWC takes the form and fills it up using the browser's native web standards. This means that no additional distraction layer, such as Aura Framework or another framework, is required; all we need to build is regular JavaScript. Easy to Learn: Higher Performance: Because performance is vital to deliverability, LWC is likely to render faster than the aura components in the absence of an abstraction layer. Higher Performance: Sites Load Faster: LWC is a lightweight framework that loads built components quickly. Sites Load Faster: Less Proprietary, More Standards: Because LWC has built-in browser security features from Web Components Standards, out-of-the-box modification is becoming less common. Less Proprietary, More Standards: Components with no/little UI can be written in LWC, and those components can be reused in other components, making them more efficient than static resources. Easy to Learn for Developers: There is no need to learn any additional framework in order to construct LWC. As a result, the developers have an easier time. Easy to Learn for Developers: Security, Testing, and Browser Compatibility are all Improved: Script, CSS, and DOM isolation are better with LWC, and event scope is limited. We have more uniformity in the design of the components with each of these. In addition, LWC provides two-way data binding, which allows us to coordinate how data moves between different components. Security, Testing, and Browser Compatibility are all Improved:",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. Explain how the two programming models, the Aura and the Lightning Web Framework coexist together?",
        "answer": "We can mix up the Aura and LWC components. The ultimate parent component is Aura. Auras contain both LWC and Aura components, whereas Lightning Web Components only have their own component.\nIf Aura and LWC components are enclosed within a parent, they can interact in a variety of ways:  Using application and component events to interact directly with the child component.\nReceive data and interact with child component methods and attributes provided through public APIs using JS CustomEvent objects.\nLightning Data Service (LDS) allows both the Aura components and LWC to receive and transfer data. There is currently no communication mechanism between Aura and Lightning web components that are not in the same hierarchy. Using application and component events to interact directly with the child component. Receive data and interact with child component methods and attributes provided through public APIs using JS CustomEvent objects. Lightning Data Service (LDS) allows both the Aura components and LWC to receive and transfer data. There is currently no communication mechanism between Aura and Lightning web components that are not in the same hierarchy.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What are the different sorts of Salesforce Lightning Events?",
        "answer": "There are four types of Salesforce Lightning Events. They are as follows: Salesforce Lightning Events   System Events: The lightning framework fires system events when a component is initialised, rendered, or an attribute value is changed, among other things. The following are the various sorts of Lightning-supported system events:\naura:valueInit: When the component markup is started or loaded but the component page is not yet rendered, this event runs a logic. This is the first time a system event is triggered.\naura:valueRender: When the component page is fully drawn or re-rendered, it runs a logic.\naura:noAccess: When the requested resource has no access authorization, this event runs a logic.\naura:locationChange: When the URL hash part of the URL has been updated, this event runs a logic.\naura:systemError: When an error occurs during the execution of a server-side (apex controller) activity, this event runs a logic.\naura:valueChange: When the value of an aura property is updated, this event runs a logic.\naura:valueDestroy: Runs a logic when a component is destroyed and we want to do some custom cleanup at the same time.\nLightning Application Events from Library: These events are offered by Salesforce Library and can be utilised frequently depending on your needs. However, some of these library events may not be supported simultaneously in a Salesforce app, Lightning Experience, or standalone app. As a result, it's best to use $A.get() to figure out where your component is running, whether it's a Salesforce app with Lightning Experience or a standalone app.\nApplication Events: Application Events assist in the exchange of values between two separate events (without a parent-child relationship). It works in the same way as a broadcast message, in that any device with the receiver turned on can receive the broadcast message transmitted by a single device. It means that any component having an event handler statement can receive the fired event in the case of Application Events.\nComponent Events: To send values from a child component to its parent, component events are required. The event fired by the child components (sender) will be handled by the parent component (receiver). System Events: The lightning framework fires system events when a component is initialised, rendered, or an attribute value is changed, among other things. The following are the various sorts of Lightning-supported system events:\naura:valueInit: When the component markup is started or loaded but the component page is not yet rendered, this event runs a logic. This is the first time a system event is triggered.\naura:valueRender: When the component page is fully drawn or re-rendered, it runs a logic.\naura:noAccess: When the requested resource has no access authorization, this event runs a logic.\naura:locationChange: When the URL hash part of the URL has been updated, this event runs a logic.\naura:systemError: When an error occurs during the execution of a server-side (apex controller) activity, this event runs a logic.\naura:valueChange: When the value of an aura property is updated, this event runs a logic.\naura:valueDestroy: Runs a logic when a component is destroyed and we want to do some custom cleanup at the same time. System Events: aura:valueInit: When the component markup is started or loaded but the component page is not yet rendered, this event runs a logic. This is the first time a system event is triggered.\naura:valueRender: When the component page is fully drawn or re-rendered, it runs a logic.\naura:noAccess: When the requested resource has no access authorization, this event runs a logic.\naura:locationChange: When the URL hash part of the URL has been updated, this event runs a logic.\naura:systemError: When an error occurs during the execution of a server-side (apex controller) activity, this event runs a logic.\naura:valueChange: When the value of an aura property is updated, this event runs a logic.\naura:valueDestroy: Runs a logic when a component is destroyed and we want to do some custom cleanup at the same time. aura:valueInit: When the component markup is started or loaded but the component page is not yet rendered, this event runs a logic. This is the first time a system event is triggered. aura:valueInit: aura:valueRender: When the component page is fully drawn or re-rendered, it runs a logic. aura:valueRender: aura:noAccess: When the requested resource has no access authorization, this event runs a logic. aura:noAccess: aura:locationChange: When the URL hash part of the URL has been updated, this event runs a logic. aura:locationChange: aura:systemError: When an error occurs during the execution of a server-side (apex controller) activity, this event runs a logic. aura:systemError: aura:valueChange: When the value of an aura property is updated, this event runs a logic. aura:valueChange: aura:valueDestroy: Runs a logic when a component is destroyed and we want to do some custom cleanup at the same time. aura:valueDestroy: Lightning Application Events from Library: These events are offered by Salesforce Library and can be utilised frequently depending on your needs. However, some of these library events may not be supported simultaneously in a Salesforce app, Lightning Experience, or standalone app. As a result, it's best to use $A.get() to figure out where your component is running, whether it's a Salesforce app with Lightning Experience or a standalone app. Lightning Application Events from Library: Application Events: Application Events assist in the exchange of values between two separate events (without a parent-child relationship). It works in the same way as a broadcast message, in that any device with the receiver turned on can receive the broadcast message transmitted by a single device. It means that any component having an event handler statement can receive the fired event in the case of Application Events. Application Events: Component Events: To send values from a child component to its parent, component events are required. The event fired by the child components (sender) will be handled by the parent component (receiver). Component Events:",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. What do you understand about Lightning Data Service (LDS) in the context of Salesforce Lightning?",
        "answer": "Lightning Data Service (LDS) is used to create, delete, update, and load records in our component without using Apex code. Lightning Data Service is in charge of field-level security and sharing regulations. Lightning Data Service enhances efficiency and user interface consistency while simplifying access to Salesforce data. At its most basic level, Lightning Data Service can be thought of as the Lightning components' version of the Visualforce standard controller. While this statement is exaggerated, it serves to highlight a point. Use Lightning Data Service to access and alter Salesforce data in your components wherever possible. Lightning Data Service   The Lightning Data Service makes data access easier than utilising a server-side Apex controller. Read-only access can be declared explicitly in the markup of your component. Your component's JavaScript controller has nearly the same amount of code for data modification, and you can get rid of the Apex entirely. All of your data access code is condensed inside your component, reducing complexity dramatically. Aside from the coding, Lightning Data Service has other advantages. It is based on highly efficient local storage that is shared by all components that make use of it. Lightning Data Service records are cached and shared between components.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. What do you understand about the Salesforce Lightning Design System (SLDS)?",
        "answer": "The Salesforce Lightning Design System (SLDS) allows you to create Lightning Experience-style applications without writing a single line of CSS. SLDS is a CSS framework that allows you to use the icons, colour palettes, and fonts that our designers use to create Lightning Experience.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What are the benefits of using Salesforce Lightning Design System (SLDS)?",
        "answer": "Salesforce Lightning Design System (SLDS) gives you the tools to construct apps that follow Lightning Experience's concepts, design language, and best practices. Salesforce Lightning Design System The following are some of the advantages that make SLDS so beneficial: advantages When enhancing existing functionality or integrating with external systems, gives a unified experience and streamlined workflows.\nPadding and margins are not over-enforced by default.\nIt is updated on a regular basis. As long as you're using the most recent version of SLDS, your pages will be Lightning Experience compliant.\nThe CSS framework includes accessibility.\nIt is compatible with various CSS frameworks, such as Bootstrap.\nVisualforce pages that match the look and feel of the Salesforce mobile app can be created with the Lightning Design System (SLDS). To use SLDS, you'll need to make a few changes to your code and remember a few things. Visualforce programming that uses SLDS, for the most part, works without a hitch.\nOur action, custom, doctype, standard, and utility icons are available in PNG and SVG (individual and sprite map) formats in the Lightning Design System (SLDS). When enhancing existing functionality or integrating with external systems, gives a unified experience and streamlined workflows. Padding and margins are not over-enforced by default. It is updated on a regular basis. As long as you're using the most recent version of SLDS, your pages will be Lightning Experience compliant. The CSS framework includes accessibility. It is compatible with various CSS frameworks, such as Bootstrap. Visualforce pages that match the look and feel of the Salesforce mobile app can be created with the Lightning Design System (SLDS). To use SLDS, you'll need to make a few changes to your code and remember a few things. Visualforce programming that uses SLDS, for the most part, works without a hitch. Our action, custom, doctype, standard, and utility icons are available in PNG and SVG (individual and sprite map) formats in the Lightning Design System (SLDS).",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What is the Salesforce Lightning Experience?",
        "answer": "Salesforce Lightning Experience is a user interface that is modern, fast, and intelligent, and it is built on established Salesforce1 Mobile App technology. To construct modern corporate applications, it integrates the Lightning Designing System (LDS), Lightning App Builder, and Lightning Components. Salesforce Lightning Experience is a next-generation productive user interface for Salesforce.com's sales and supports staff. Salesforce.com has introduced Salesforce1 for mobile applications, as well as two user interfaces for desktop versions of Salesforce traditional and lightning Salesforce. Salesforce Lightning Experience Lightning Experience (or LEX for short) introduces a completely new client-side architecture, departing from the server-side rendering given by its predecessors (Salesforce Classic) and Visualforce. Visualforce UIs can still be used with Lightning Experience for backwards compatibility, but they won't have the same amount of extensibility or visual appeal as custom UIs designed with the Lightning framework.",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. What are the different programming models that can be used to develop lightning components? Explain them.",
        "answer": "For Lightning components, there are two different programming models. The first is to build out Aura components using the Aura framework, and the second is to use the newer Lightning Web Components (LWC) framework.   Aura Framework: Aura is a user interface framework for creating dynamic web apps for mobile and desktop devices, with a scalable long-lived lifecycle to allow the development of growth-oriented apps. It allows for the creation of partitioned multi-tier components that connect the client and server. Aura, which has been around since 2013, allows developers to create apps that are not dependent on Salesforce data, allowing for minimal disruption to day-to-day customers. Because programs don't have to be optimised for each device, Aura allows for more efficient development.\nLightning Web Components Framework: Lightning Web Components is a W3C Web Components standard implementation. It supports the aspects of Web Components that work well in browsers and only adds what's required to work in all Salesforce-supported browsers. It is a collection of advanced lightweight frameworks based on the most recent web standards. It's a reusable code-based document object model element. It's used to create sophisticated interfaces without the need for JS or the creation of a library. This functionality makes it simple to use and faster, saving developers a lot of time and work on the web stack. Aura Framework: Aura is a user interface framework for creating dynamic web apps for mobile and desktop devices, with a scalable long-lived lifecycle to allow the development of growth-oriented apps. It allows for the creation of partitioned multi-tier components that connect the client and server. Aura, which has been around since 2013, allows developers to create apps that are not dependent on Salesforce data, allowing for minimal disruption to day-to-day customers. Because programs don't have to be optimised for each device, Aura allows for more efficient development. Aura Framework Lightning Web Components Framework: Lightning Web Components is a W3C Web Components standard implementation. It supports the aspects of Web Components that work well in browsers and only adds what's required to work in all Salesforce-supported browsers. It is a collection of advanced lightweight frameworks based on the most recent web standards. It's a reusable code-based document object model element. It's used to create sophisticated interfaces without the need for JS or the creation of a library. This functionality makes it simple to use and faster, saving developers a lot of time and work on the web stack. Lightning Web Components Framework",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What are the different types of component bundles for lightning components?",
        "answer": "A Mark-ups, JavaScript controller, a Helper, a Renderer, and other components make up each Lightning Component (Component Bundle). A screenshot of components in the developer console view is shown below.   The Types of Lightning Component Bundles are as follows: Types Component: Components are required while creating a Lightning app. Using Lightning Components, it holds the mark-up for the app design.\nController: This is a controller that runs on the client's side. A component's events are handled by a client-side controller. Following are the uses of the Controller :\nControllers are required to listen to user events as well as other events such as Component Events and Application Events.\nAllows business logic to be delegated to helper methods.\nDML operations should not be triggered during component initialization. When we do DML in init(), we risk a CSRF (Cross-Site Request Forgery) attack.\nIn the Controller, the DOM is not changed. If we change the DOM in the controller, it will call the renderer method, which will return an error.\nHelper: The server-side controller is known as a Helper. It's typically utilised for server-side activities and data or task processing. A client-side controller or renderer can invoke Helper's java-script function. It's also included in the component set. Because Helper is shared across all components, it allows us to centralise and share functionality between Controllers and Renderers. It also makes it easier to keep the logic in Controllers and Renderers minimal. We must relocate this logic to Helper whenever we need to invoke one controller function from another controller function. Any other JavaScript in the component bundle can call helper functions. When a component runs, Lightning Framework creates a Controller and a Renderer instance for each component, but only creates one copy of the Helper and sends the reference to the Helper into every Controller and Renderer instance.\nRenderer: The client-side controller is the renderer. It's a JavaScript resource that defines all of the component's actions and functions. When an event occurs, it may cause actions to be taken, such as changing data or calling rerender() on impacted components. The rerender() function allows components to update themselves based on other components' updates since they were last rendered. Before adding custom rerendering logic, we usually wish to expand default rerendering by invoking superRerender() from the renderer() function. The rerendering is chained to the components in the body attribute when superRerender() is called.\nStyle: The component's styles are stored in CSS Styles. Click the STYLE button in the Developer Console sidebar to add CSS to a component bundle. Component: Components are required while creating a Lightning app. Using Lightning Components, it holds the mark-up for the app design. Component Controller: This is a controller that runs on the client's side. A component's events are handled by a client-side controller. Following are the uses of the Controller :\nControllers are required to listen to user events as well as other events such as Component Events and Application Events.\nAllows business logic to be delegated to helper methods.\nDML operations should not be triggered during component initialization. When we do DML in init(), we risk a CSRF (Cross-Site Request Forgery) attack.\nIn the Controller, the DOM is not changed. If we change the DOM in the controller, it will call the renderer method, which will return an error. Controller uses Controllers are required to listen to user events as well as other events such as Component Events and Application Events.\nAllows business logic to be delegated to helper methods.\nDML operations should not be triggered during component initialization. When we do DML in init(), we risk a CSRF (Cross-Site Request Forgery) attack.\nIn the Controller, the DOM is not changed. If we change the DOM in the controller, it will call the renderer method, which will return an error. Controllers are required to listen to user events as well as other events such as Component Events and Application Events. Allows business logic to be delegated to helper methods. DML operations should not be triggered during component initialization. When we do DML in init(), we risk a CSRF (Cross-Site Request Forgery) attack. In the Controller, the DOM is not changed. If we change the DOM in the controller, it will call the renderer method, which will return an error. Helper: The server-side controller is known as a Helper. It's typically utilised for server-side activities and data or task processing. A client-side controller or renderer can invoke Helper's java-script function. It's also included in the component set. Because Helper is shared across all components, it allows us to centralise and share functionality between Controllers and Renderers. It also makes it easier to keep the logic in Controllers and Renderers minimal. We must relocate this logic to Helper whenever we need to invoke one controller function from another controller function. Any other JavaScript in the component bundle can call helper functions. When a component runs, Lightning Framework creates a Controller and a Renderer instance for each component, but only creates one copy of the Helper and sends the reference to the Helper into every Controller and Renderer instance. Helper Renderer: The client-side controller is the renderer. It's a JavaScript resource that defines all of the component's actions and functions. When an event occurs, it may cause actions to be taken, such as changing data or calling rerender() on impacted components. The rerender() function allows components to update themselves based on other components' updates since they were last rendered. Before adding custom rerendering logic, we usually wish to expand default rerendering by invoking superRerender() from the renderer() function. The rerendering is chained to the components in the body attribute when superRerender() is called. Renderer Style: The component's styles are stored in CSS Styles. Click the STYLE button in the Developer Console sidebar to add CSS to a component bundle. Style",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. Is it possible to link one Lightning component to another?",
        "answer": "Yes, one Lightning component can be included within another Lightning.",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. What do you understand by bound and unbound expressions in the context of Salesforce Lightning?",
        "answer": "Bound Expression: {!v.str} is the symbol for bound expression. This expression will reflect any changes in the string's value and will also influence the components where it is used, thus we can say the value changes dynamically through this expression.\nUnbound Expression: {#v.str} is the symbol for unbound expression. This expression will not reflect any changes in the string's value; we can argue that the value remains static as a result of this expression. Bound Expression: {!v.str} is the symbol for bound expression. This expression will reflect any changes in the string's value and will also influence the components where it is used, thus we can say the value changes dynamically through this expression. Bound Expression: {!v.str} Unbound Expression: {#v.str} is the symbol for unbound expression. This expression will not reflect any changes in the string's value; we can argue that the value remains static as a result of this expression. Unbound Expression: {#v.str}",
        "reference": "interviewbit.com"
    },
    {
        "question": "18. What are the Salesforce constraints on the maximum number of components per app?",
        "answer": "No, there is no restriction to the number of components that can be used in an application.",
        "reference": "interviewbit.com"
    },
    {
        "question": "19. Is it possible to integrate Lightning with a third-party framework?",
        "answer": "Yes, Lightning may be used in conjunction with other frameworks, such as Angular. Aura components can also be used with a third-party framework. However, a third-party framework cannot be used directly within Lightning Web Components.",
        "reference": "interviewbit.com"
    },
    {
        "question": "20. Is it possible to use Aura Components with Lightning Web Components and vice versa?",
        "answer": "As it's not feasible to add generic elements to custom components, Aura components can't be used in Lightning Web components (in other words, a parent Lightning Web component can only be made up of Lightning Web components). You can, however, incorporate Lightning Web components into Aura components (i.e. parent Aura components can contain both Aura Components and LWC). They can also deal with one other's events.",
        "reference": "interviewbit.com"
    },
    {
        "question": "21. What is the purpose of using Lightning's Aura: method Tag?",
        "answer": "The Aura: method tag can be used to specify a component API function. As a result, there's no need to fire and handle a component event, and we may call the method in the component's controller directly from the client. It also makes the code required for a parent component to invoke a method on a child component that is a part of the parent component easier to understand.",
        "reference": "interviewbit.com"
    },
    {
        "question": "22. Is it possible to use a Lightning component that works with both mobile and desktop interfaces?",
        "answer": "Lightning components, Salesforce1 mobile app, custom standalone apps, and template-based communities may all be used directly in Lightning Experience. The Visualforce page uses Lightning components for use in Salesforce Visualforce communities as well as the conventional environment. So, yes it is possible to use a lightning component that works with both mobile and desktop interfaces.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. What do you understand about lightning pages in the context of Salesforce Lightning?",
        "answer": "A Lightning page is a custom layout that you may use to create pages for the Salesforce mobile app or Lightning Experience. Lightning pages are a cross between Visualforce pages and page layouts. Lightning pages, like page layouts, allow you to add custom items to a page. Instead of being fields or Visualforce components, these elements are Lightning components, which provide far more freedom. A Lightning page's structure changes depending on the device it's being viewed on. When you create a page, the template you choose determines how it appears on different devices. The template for the Lightning page divides the page into regions. Lightning pages are made up of Lightning components, which are small, reusable, and adjustable pieces that you can drag and drop into page regions in the Lightning App Builder. A Lightning page can be used to construct an app page that you can add to the navigation bar of a Lightning app, making it visible in both Lightning Experience and the Salesforce mobile apps. An app page allows users to quickly access the most important objects and items in the app.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Explain what is Lightning Out in the context of Salesforce Lightning.",
        "answer": "Lightning Out is a feature that allows Lightning Apps to be extended. It operates as a connector, allowing Lightning Components to be accessed from any external web container. This means you may utilise your Lightning Components on an external site (such as SharePoint or SAP), in a hybrid app built with the Mobile SDK, or even on Heroku or in a Visualforce Page. You may embed Lightning Components in an app across domains and manage interactions between the component and the app directly in the DOM using the Lightning Out JavaScript libraries. Your Lightning Components become substantially more effective with Lightning Out. You can utilise Lightning Components not only in other Lightning Components or Lightning Apps, but you can also expose them in almost any web container, on or off the App Cloud.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Explain how a component event propagates in the context of Salesforce Lightning.",
        "answer": "For component event propagation, the framework offers capture and bubble phases. These phases are similar to DOM handling patterns in that they allow interested components to engage with an event and maybe impact how future handlers behave. The source component is the component that fires an event. The framework enables you to manage the event in stages. These phases provide you with the freedom to decide how to handle the event in your application. The phases are as follows: Capture: The event is caught and passed down to the source component from the application root. A component in the containment hierarchy that receives the captured event can handle the event. From the application root down to the source component that triggered the event, event handlers are called in succession. Any registered handler in this stage can prevent the event from propagating, at which point neither this phase nor the bubble phase will call any additional handlers.\nBubble: The event can be handled by the component that triggered it. The event then propagates up to the application root from the source component. A component in the containment hierarchy that gets the bubbled event can handle the event.\nThe event handlers are called in the order that they were triggered, starting with the source component that fired the event and ending with the application root.\nIn this phase, any registered handler can stop the event from propagating, at which point no more handlers are called. Capture: The event is caught and passed down to the source component from the application root. A component in the containment hierarchy that receives the captured event can handle the event. From the application root down to the source component that triggered the event, event handlers are called in succession. Any registered handler in this stage can prevent the event from propagating, at which point neither this phase nor the bubble phase will call any additional handlers. Capture: Bubble: The event can be handled by the component that triggered it. The event then propagates up to the application root from the source component. A component in the containment hierarchy that gets the bubbled event can handle the event.\nThe event handlers are called in the order that they were triggered, starting with the source component that fired the event and ending with the application root.\nIn this phase, any registered handler can stop the event from propagating, at which point no more handlers are called. Bubble:  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Explain how an application event propagates in the context of Salesforce Lighting.",
        "answer": "For the propagation of application events, the framework offers the capture, bubble, and default phases. The capture and bubble phases are similar to DOM handling patterns in that they allow interested components to engage with an event and perhaps impact later handler behaviour. The framework's initial handling behaviour is preserved in the default phase. The source component is the component that fires an event. The framework enables you to manage the event in stages. These phases provide you with the freedom to decide how to handle the event in your application. The phases are as follows: Capture: This phase is the same as that of the component event.\nBubble: This phase is the same as that of the component event.\nDefault: From the root node through its subtree, event handlers are called in a non-deterministic order. The default phase does not follow the same component hierarchy propagation principles as the capture and bubble phases. Application events that affect components in separate sub-trees of your app can be handled using the default phase.\nThe root node defaults to the application root if the event propagation was not stopped in a prior phase. The root node is set to the component whose handler invoked the event.stopPropagation() if it was halted in a previous phase. Capture: This phase is the same as that of the component event. Capture: Bubble: This phase is the same as that of the component event. Bubble: Default: From the root node through its subtree, event handlers are called in a non-deterministic order. The default phase does not follow the same component hierarchy propagation principles as the capture and bubble phases. Application events that affect components in separate sub-trees of your app can be handled using the default phase.\nThe root node defaults to the application root if the event propagation was not stopped in a prior phase. The root node is set to the component whose handler invoked the event.stopPropagation() if it was halted in a previous phase. Default:  event.stopPropagation()",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Differentiate between component events and application events in the context of Salesforce Lightning.",
        "answer": "The following table lists the differences between component events and application events : Component Event Application Event\nThe component that instantiates or contains the component can handle component events. Any component with an event handler is able to handle application events. These events follow the usual publish-subscribe format.\nOnly child components can register component events, which are then handled by the parent component. The application event can be utilised anywhere in the app.\nFor a component event, we utilise the aura:event tag's type=\"COMPONENT\" property. For an application event, we utilise the aura:event tag's type=\"APPLICATION\" property.\nWhen processing component events, the name property in aura:handler must be specified. The name attribute in aura:handler must match the name attribute in the aura:registerEvent tag in the event-firing Child Component. There is no need to give the name attribute in aura:handler when handling application events.\nIn JavaScript, we use cmp.getEvent(\"eventName\") to get an instance of the Component type event. In JavaScript, we acquire an instance of the Application type event by calling $A.get(\"e.myNamespace:myAppEvent\"). Component Event Application Event\nThe component that instantiates or contains the component can handle component events. Any component with an event handler is able to handle application events. These events follow the usual publish-subscribe format.\nOnly child components can register component events, which are then handled by the parent component. The application event can be utilised anywhere in the app.\nFor a component event, we utilise the aura:event tag's type=\"COMPONENT\" property. For an application event, we utilise the aura:event tag's type=\"APPLICATION\" property.\nWhen processing component events, the name property in aura:handler must be specified. The name attribute in aura:handler must match the name attribute in the aura:registerEvent tag in the event-firing Child Component. There is no need to give the name attribute in aura:handler when handling application events.\nIn JavaScript, we use cmp.getEvent(\"eventName\") to get an instance of the Component type event. In JavaScript, we acquire an instance of the Application type event by calling $A.get(\"e.myNamespace:myAppEvent\"). Component Event Application Event Component Event Application Event Component Event Application Event The component that instantiates or contains the component can handle component events. Any component with an event handler is able to handle application events. These events follow the usual publish-subscribe format.\nOnly child components can register component events, which are then handled by the parent component. The application event can be utilised anywhere in the app.\nFor a component event, we utilise the aura:event tag's type=\"COMPONENT\" property. For an application event, we utilise the aura:event tag's type=\"APPLICATION\" property.\nWhen processing component events, the name property in aura:handler must be specified. The name attribute in aura:handler must match the name attribute in the aura:registerEvent tag in the event-firing Child Component. There is no need to give the name attribute in aura:handler when handling application events.\nIn JavaScript, we use cmp.getEvent(\"eventName\") to get an instance of the Component type event. In JavaScript, we acquire an instance of the Application type event by calling $A.get(\"e.myNamespace:myAppEvent\"). The component that instantiates or contains the component can handle component events. Any component with an event handler is able to handle application events. These events follow the usual publish-subscribe format. The component that instantiates or contains the component can handle component events. Any component with an event handler is able to handle application events. These events follow the usual publish-subscribe format. Only child components can register component events, which are then handled by the parent component. The application event can be utilised anywhere in the app. Only child components can register component events, which are then handled by the parent component. The application event can be utilised anywhere in the app. For a component event, we utilise the aura:event tag's type=\"COMPONENT\" property. For an application event, we utilise the aura:event tag's type=\"APPLICATION\" property. For a component event, we utilise the aura:event tag's type=\"COMPONENT\" property. aura:event type=\"COMPONENT\" For an application event, we utilise the aura:event tag's type=\"APPLICATION\" property. aura:event type=\"APPLICATION\" When processing component events, the name property in aura:handler must be specified. The name attribute in aura:handler must match the name attribute in the aura:registerEvent tag in the event-firing Child Component. There is no need to give the name attribute in aura:handler when handling application events. When processing component events, the name property in aura:handler must be specified. The name attribute in aura:handler must match the name attribute in the aura:registerEvent tag in the event-firing Child Component. aura:handler aura:handler aura:registerEvent There is no need to give the name attribute in aura:handler when handling application events. aura:handler In JavaScript, we use cmp.getEvent(\"eventName\") to get an instance of the Component type event. In JavaScript, we acquire an instance of the Application type event by calling $A.get(\"e.myNamespace:myAppEvent\"). In JavaScript, we use cmp.getEvent(\"eventName\") to get an instance of the Component type event. cmp.getEvent(\"eventName\") In JavaScript, we acquire an instance of the Application type event by calling $A.get(\"e.myNamespace:myAppEvent\"). $A.get(\"e.myNamespace:myAppEvent\")",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Differentiate between Salesforce Classic and Salesforce Lightning.",
        "answer": "Salesforce Classic: Salesforce Classic is simply a term used to differentiate between the new and old user interfaces. It's essentially the same stage that we've been using for a long time. With the passage of time, the expectation to learn and adapt grows, and we can more easily discern the gaps between the customer's requirements and the services that they are receiving. It is critical to stay up with advancements, enhancements, and customer requirements during this particularly delicate phase of time innovation. It's also critical to update the user interface to make it easier to use and to keep it up to date with the latest technology. Salesforce Classic: Following are the differences between Salesforce Lightning and Salesforce Classic:   User Experience Improvements: The user interface is one of the most significant differences between Salesforce Classic and Salesforce Lightning. The latter provides a far superior user interface to its users, including features such as drag-and-drop functionality that may be accomplished without the use of any coding. Instead of engaging a Salesforce developer to construct or change a Salesforce page, an admin can quickly rearrange the page components to their preference. In addition, Lightning helps to reduce the requirement for Visualforce for each activity. Any code that is produced during development must be tested before being deployed. In the event that a bug is missed, the code is sent back to the developer to be fixed, and the process begins again. These types of time-consuming activities can be avoided with Salesforce Lightning.\nEnhanced Security: Salesforce Lightning provides a higher level of protection. LockerService, for example, is a feature that allows Lightning components to interact with each other by separating them. This contributes to the platform's protection against harmful data. In Classic mode, there is no such feature.\nPermissions work differently in Salesforce Lightning as well. Users cannot change their assurance levels in-session, for example, from standard to high. They'll have to log out of the Lightning platform and log back in user authentication with a higher level of certainty.\nEinstein (Wave) Analytics: While an improved and upgraded user interface and security are compelling arguments, Salesforce Lightning also gives consumers access to Einstein (Wave) Analytics reports, which the Classic does not. Salesforce Classic reports use common reporting types to create graphs, charts, and lists. These dashboards show to be a terrific solution for capturing a view of crucial indicators when the data is refreshed.\nProgressive platform: Lightning was criticized in its early days due to its transition and compatibility concerns with objects, custom code, and apps. But those days are behind, and the platform has developed to accommodate any custom metadata items, making it much easier for businesses to migrate their existing apps and workflows without having to start from scratch. User Experience Improvements: The user interface is one of the most significant differences between Salesforce Classic and Salesforce Lightning. The latter provides a far superior user interface to its users, including features such as drag-and-drop functionality that may be accomplished without the use of any coding. Instead of engaging a Salesforce developer to construct or change a Salesforce page, an admin can quickly rearrange the page components to their preference. In addition, Lightning helps to reduce the requirement for Visualforce for each activity. Any code that is produced during development must be tested before being deployed. In the event that a bug is missed, the code is sent back to the developer to be fixed, and the process begins again. These types of time-consuming activities can be avoided with Salesforce Lightning. User Experience Improvements: Enhanced Security: Salesforce Lightning provides a higher level of protection. LockerService, for example, is a feature that allows Lightning components to interact with each other by separating them. This contributes to the platform's protection against harmful data. In Classic mode, there is no such feature.\nPermissions work differently in Salesforce Lightning as well. Users cannot change their assurance levels in-session, for example, from standard to high. They'll have to log out of the Lightning platform and log back in user authentication with a higher level of certainty. Enhanced Security:  Einstein (Wave) Analytics: While an improved and upgraded user interface and security are compelling arguments, Salesforce Lightning also gives consumers access to Einstein (Wave) Analytics reports, which the Classic does not. Salesforce Classic reports use common reporting types to create graphs, charts, and lists. These dashboards show to be a terrific solution for capturing a view of crucial indicators when the data is refreshed. Einstein (Wave) Analytics: Progressive platform: Lightning was criticized in its early days due to its transition and compatibility concerns with objects, custom code, and apps. But those days are behind, and the platform has developed to accommodate any custom metadata items, making it much easier for businesses to migrate their existing apps and workflows without having to start from scratch. Progressive platform:",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What is Visualforce? How is Salesforce Lightning different from Visualforce?",
        "answer": "Visualforce: Visualforce is a framework that allows developers to create complex, creative user interfaces that run natively on the Lightning platform. The Visualforce framework provides a tag-based markup language, comparable to HTML, as well as a collection of server-side \"common controllers\" that make doing fundamental database operations like queries and saves a breeze. Each Visualforce tag corresponds to a coarse or fine-grained user interface component, such as a segment of a page, a related list, or a field, in the Visualforce markup language. Developers can attach their own logic with an Apex controller class to control the behaviour of Visualforce components, or they can utilise the same logic that is used in regular Salesforce pages to govern the behaviour of Visualforce components.   The majority of the work is done on the server with Visualforce components. Rather than using the concept of a page as its core unit, Lightning is built from the ground up. Client-side centricity makes Lightning Components more dynamic and mobile friendly.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What are the different types of lightning pages available in Salesforce Lightning?",
        "answer": "Following are the different types of lightning pages available in Salesforce Lightning : App Page: The Salesforce mobile app and Lightning Experience both enable app pages. We can create a home page for a third-party app using an app page, which we can integrate straight into the Salesforce mobile app and Lightning Experience navigation menus. Our users will then have access to an app home page where they can access the most important objects and items fast. To improve the functionality of an app page, we can add global actions. A user can enter call data, create and update records, send email, and start a task using global actions from your app page. When a user opens the Salesforce mobile app and navigates to a Lightning page, the page's activities display in the action bar. Actions display in the highlights panel at the top of the page in Lightning Experience.\nHome Page: Home pages are used to create custom pages with features relevant to specific categories of users, and assign the pages to various apps or app-and-user-profile combinations. Only the Lightning Experience supports custom home pages.\nRecord Page: We can construct a customised version of an object's record page with a record page, adapting it to your users' needs. Lightning Experience and the Salesforce mobile app both enable custom record pages. App Page: The Salesforce mobile app and Lightning Experience both enable app pages. We can create a home page for a third-party app using an app page, which we can integrate straight into the Salesforce mobile app and Lightning Experience navigation menus. Our users will then have access to an app home page where they can access the most important objects and items fast. To improve the functionality of an app page, we can add global actions. A user can enter call data, create and update records, send email, and start a task using global actions from your app page. When a user opens the Salesforce mobile app and navigates to a Lightning page, the page's activities display in the action bar. Actions display in the highlights panel at the top of the page in Lightning Experience. App Page: Home Page: Home pages are used to create custom pages with features relevant to specific categories of users, and assign the pages to various apps or app-and-user-profile combinations. Only the Lightning Experience supports custom home pages. Home Page: Record Page: We can construct a customised version of an object's record page with a record page, adapting it to your users' needs. Lightning Experience and the Salesforce mobile app both enable custom record pages. Record Page:",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What exactly is FlexiPage in the context of Salesforce Lightning?",
        "answer": "The metadata associated with a lightning page is represented by FlexiPage. The lightning page depicts an adaptive screen made up of areas that include the lightning components. There are 25 components on the lightning page. The Flexi page is saved as an XML file and deployed using a deployment tool or metadata API. In the API, lightning pages are referred to as Flexipages.",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. In the Salesforce Lightning component, what is the difference between force:lightningQuickAction and force:lightningQuickActionWithoutHeader?",
        "answer": "Interface force:lightning - QuickAction allows you to use the component in Lightning Experience or the Salesforce mobile app as a custom action. Component interface shows in a panel with typical action controls, such as a Cancel button, when force:lightningQuickAction is used in a component.\nInterface force:lightningQuickActionWithoutHeader - The component can be used as a custom action in Lightning Experience or the Salesforce mobile app thanks to the force:lightningQuickActionWithoutHeader interface. When force:lightningQuickAction is used in a component, the component interface appears in a panel without any normal action controls, such as a cancel button. Interface force:lightning - QuickAction allows you to use the component in Lightning Experience or the Salesforce mobile app as a custom action. Component interface shows in a panel with typical action controls, such as a Cancel button, when force:lightningQuickAction is used in a component. Interface force:lightning Interface force:lightningQuickActionWithoutHeader - The component can be used as a custom action in Lightning Experience or the Salesforce mobile app thanks to the force:lightningQuickActionWithoutHeader interface. When force:lightningQuickAction is used in a component, the component interface appears in a panel without any normal action controls, such as a cancel button. Interface force:lightningQuickActionWithoutHeader",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. What would be the most practical solution for keeping an application up and running while deactivating a specific user?",
        "answer": "You can freeze user accounts to prevent them from working in your business while you undertake the steps to deactivate them. So, until you figure out how to remove this user from the Role hierarchy, you can update the owner of the entries he created/from any location where this user is employed. For this, we can use the FREEZE button on the user record.  If we click the FREEZE button, the user will no longer be able to log in to the application. Changing user accounts in the state does not free up existing user licences for use in your organisation. To release the licence, we must deactivate the user.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. We have a regular Controller as well as a Controller Extension. All of the logic is written in a Controller Extension, which may or may not be written in a Custom Controller.",
        "answer": "First and foremost, It is impossible for a Controller Extension to exist on its own. It will be applied to either a standard or a custom controller.  So, keeping the end goal in mind, certain techniques, for example, must be dead in User Mode and sure in System Mode. In this case, using a standard controller with a custom extension is a no-brainer. Wherever the victim is, the normal Controller provides all of the Force.com platform's pre-existing options. However, after we use the normal Controller, all of the Sharing rules, as well as a user's permissions, are revered. So, if this is what we frequently require, we should always choose this type of solution.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Can there be two users with a similar profile? Will a user with two profiles be assigned?",
        "answer": "Profiles confirm the scope of a user's access in a Salesforce org. Because the first portion of the question is so important, Yes. A single profile is issued to a large number of users. A comparable profile will be issued to the entire team. The admin will create a single profile called Sales Profile, which will have access to Leads, Opportunities, Campaigns, Contacts, and other corporate items. This signifies that a similar profile has been assigned to a number of people. If the team leader or manager needs access to additional records or objects, distribution permission sets are created specifically for those users.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Consider the following situation: I have two objects, Obj1 and Obj2, that are not linked to each other. I need to create a Master-Detail Relationship (MDR) between these objects at the moment, but am I able to do so?",
        "answer": "First, choose an object that is a parent object (Master) and a child object (Kid) (Detail). Let's pretend that we've decided that Obj1 will be the Master object and Obj2 will be the Detail object for the time being. First, let's define a Master-Detail relationship.Every child should have a parent. This means that each record in Obj2 must be linked to a parent record in Obj1. In addition, one child will have only one parent. One parent, on the other hand, will have several children. Let us consider that there are already existing records in Obj2. According to the Master-Detail relationship, we must ensure that each record in Obj2 is linked to a record in Obj1. And, in our current condition of affairs, Obj1 and Obj2 are not linked. As a result, we must first create a simple search relation between these two things in order to construct a relationship between them. As a result, we have a tendency to follow the instructions outlined below. We usually create a search box within the child Object Obj2 and inform Obj1 as a parent.\nReplace the price from Obj1 in the search field of all records in Obj2 (Related field)\nWe then have a tendency to change the sphere search to a Master-Detail relationship. We usually create a search box within the child Object Obj2 and inform Obj1 as a parent. Replace the price from Obj1 in the search field of all records in Obj2 (Related field) We then have a tendency to change the sphere search to a Master-Detail relationship.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. How do I create a Many-to-Many Relationship in Salesforce?",
        "answer": "In Salesforce, a Many-to-Many Relationship is also known as a Junction object. The steps to make it are as follows. Create each object that has to be linked together.\nCreate one custom object, also known as a Junction object, that should have Associate in Nursing automotive vehicle number as a unique identifier.\nFor each item, create a pair of Master relationships.\nMake this a connected list on each object. Create each object that has to be linked together. Create one custom object, also known as a Junction object, that should have Associate in Nursing automotive vehicle number as a unique identifier. For each item, create a pair of Master relationships. Make this a connected list on each object. Conclusion Top Product Based Companies\nSalesforce Developer Salary\nMulesoft Interview Questions\nTechnical Interview Questions Top Product Based Companies Top Product Based Companies Salesforce Developer Salary Salesforce Developer Salary Mulesoft Interview Questions Mulesoft Interview Questions Technical Interview Questions Technical Interview Questions",
        "reference": "interviewbit.com"
    }
]