[
    {
        "question": "1. What is Node.js and how it works?",
        "answer": "Node.js is a virtual machine that uses JavaScript as its scripting language and runs Chrome\u2019s V8 JavaScript engine. Basically, Node.js is based on an event-driven architecture where I/O runs asynchronously making it lightweight and efficient. It is being used in developing desktop applications as well with a popular framework called electron as it provides API to access OS-level features such as file system, network, etc. Here is a Free course on Node.js for beginners to master the fundamentals of Node.js. Free course Free course ",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What tools can be used to assure consistent code style?",
        "answer": "ESLint can be used with any IDE to ensure a consistent coding style which further helps in maintaining the codebase.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What is a first class function in Javascript?",
        "answer": "When functions can be treated like any other variable then those functions are first-class functions. There are many other programming languages, for example, scala, Haskell, etc which follow this including JS. Now because of this function can be passed as a param to another function(callback) or a function can return another function(higher-order function). map() and filter() are higher-order functions that are popularly used.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. How do you manage packages in your node.js project?",
        "answer": "It can be managed by a number of package installers and their configuration file accordingly. Out of them mostly use npm or yarn. Both provide almost all libraries of javascript with extended features of controlling environment-specific configurations. To maintain versions of libs being installed in a project we use package.json and package-lock.json so that there is no issue in porting that app to a different environment.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. How is Node.js better than other frameworks most popularly used?",
        "answer": "Node.js provides simplicity in development because of its non-blocking I/O and event-based model results in short response time and concurrent processing, unlike other frameworks where developers have to use thread management. \n  It runs on a chrome v8 engine which is written in c++ and is highly performant with constant improvement. \n  Also since we will use Javascript in both the frontend and backend the development will be much faster. \n  And at last, there are sample libraries so that we don\u2019t need to reinvent the wheel. Node.js provides simplicity in development because of its non-blocking I/O and event-based model results in short response time and concurrent processing, unlike other frameworks where developers have to use thread management.  It runs on a chrome v8 engine which is written in c++ and is highly performant with constant improvement.  Also since we will use Javascript in both the frontend and backend the development will be much faster.  And at last, there are sample libraries so that we don\u2019t need to reinvent the wheel.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Explain the steps how \u201cControl Flow\u201d controls the functions calls?",
        "answer": "Control the order of execution\nCollect data\nLimit concurrency\nCall the following step in the program. Control the order of execution Collect data Limit concurrency Call the following step in the program.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What are some commonly used timing features of Node.js?",
        "answer": "setTimeout/clearTimeout \u2013 This is used to implement delays in code execution.\nsetInterval/clearInterval \u2013 This is used to run a code block multiple times.\nsetImmediate/clearImmediate \u2013 Any function passed as the setImmediate() argument is a callback that's executed in the next iteration of the event loop.\nprocess.nextTick \u2013 Both setImmediate and process.nextTick appear to be doing the same thing; however, you may prefer one over the other depending on your callback\u2019s urgency. setTimeout/clearTimeout \u2013 This is used to implement delays in code execution. setTimeout/clearTimeout setInterval/clearInterval \u2013 This is used to run a code block multiple times. setInterval/clearInterval setImmediate/clearImmediate \u2013 Any function passed as the setImmediate() argument is a callback that's executed in the next iteration of the event loop. setImmediate/clearImmediate  process.nextTick \u2013 Both setImmediate and process.nextTick appear to be doing the same thing; however, you may prefer one over the other depending on your callback\u2019s urgency. process.nextTick",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What are the advantages of using promises instead of callbacks?",
        "answer": "The main advantage of using promise is you get an object to decide the action that needs to be taken after the async task completes. This gives more manageable code and avoids callback hell.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What is fork in node JS?",
        "answer": "A fork in general is used to spawn child processes. In node it is used to create a new instance of v8 engine to run multiple workers to execute the code.",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Why is Node.js single-threaded?",
        "answer": "Node.js was created explicitly as an experiment in async processing. This was to try a new theory of doing async processing on a single thread over the existing thread-based implementation of scaling via different frameworks.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. How do you create a simple server in Node.js that returns Hello World?",
        "answer": "var http = require(\"http\");\nhttp.createServer(function (request, response) {\n  response.writeHead(200, {'Content-Type': 'text/plain'});\n  response.end('Hello World\\n');\n}).listen(3000); var http = require(\"http\");\nhttp.createServer(function (request, response) {\n  response.writeHead(200, {'Content-Type': 'text/plain'});\n  response.end('Hello World\\n');\n}).listen(3000); var require \"http\" function (request, response) function request, response 200 'Content-Type' 'text/plain' 'Hello World\\n' 3000",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. How many types of API functions are there in Node.js?",
        "answer": "There are two types of API functions: Asynchronous, non-blocking functions - mostly I/O operations which can be fork out of the main loop.\n  Synchronous, blocking functions - mostly operations that influence the process running in the main loop. Asynchronous, non-blocking functions - mostly I/O operations which can be fork out of the main loop. Asynchronous, non-blocking functions  Synchronous, blocking functions - mostly operations that influence the process running in the main loop. Synchronous, blocking functions",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What is REPL?",
        "answer": "PL in Node.js stands for Read, Eval, Print, and Loop, which further means evaluating code on the go. R E P L",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. List down the two arguments that async.queue takes as input?",
        "answer": "Task Function\nConcurrency Value Task Function Concurrency Value",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What is the purpose of module.exports?",
        "answer": "This is used to expose functions of a particular module or file to be used elsewhere in the project. This can be used to encapsulate all similar functions in a file which further improves the project structure.\n\nFor example, you have a file for all utils functions with util to get solutions in a different programming language of a problem statement.   const getSolutionInJavaScript = async ({\n problem_id\n}) => {\n...\n};\nconst getSolutionInPython = async ({\n problem_id\n}) => {\n...\n};\nmodule.exports = { getSolutionInJavaScript, getSolutionInPython } const getSolutionInJavaScript = async ({\n problem_id\n}) => {\n...\n};\nconst getSolutionInPython = async ({\n problem_id\n}) => {\n...\n};\nmodule.exports = { getSolutionInJavaScript, getSolutionInPython } Thus using module.exports we can use these functions in some other file: const { getSolutionInJavaScript, getSolutionInPython} = require(\"./utils\") const { getSolutionInJavaScript, getSolutionInPython} = require(\"./utils\")",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Explain the concept of stub in Node.js?",
        "answer": "Stubs are used in writing tests which are an important part of development. It replaces the whole function which is getting tested.  \n\nThis helps in scenarios where we need to test:   External calls which make tests slow and difficult to write (e.g HTTP calls/ DB calls)\nTriggering different outcomes for a piece of code (e.g. what happens if an error is thrown/ if it passes) External calls which make tests slow and difficult to write (e.g HTTP calls/ DB calls) Triggering different outcomes for a piece of code (e.g. what happens if an error is thrown/ if it passes) For example, this is the function: const request = require('request');\nconst getPhotosByAlbumId = (id) => {\nconst requestUrl = `https://jsonplaceholder.typicode.com/albums/${id}/photos?_limit=3`;\nreturn new Promise((resolve, reject) => {\n    request.get(requestUrl, (err, res, body) => {\n        if (err) {\n            return reject(err);\n        }\n        resolve(JSON.parse(body));\n    });\n});\n};\nmodule.exports = getPhotosByAlbumId;\nTo test this function this is the stub\nconst expect = require('chai').expect;\nconst request = require('request');\nconst sinon = require('sinon');\nconst getPhotosByAlbumId = require('./index');\ndescribe('with Stub: getPhotosByAlbumId', () => {\nbefore(() => {\n    sinon.stub(request, 'get')\n        .yields(null, null, JSON.stringify([\n            {\n                \"albumId\": 1,\n                \"id\": 1,\n                \"title\": \"A real photo 1\",\n                \"url\": \"https://via.placeholder.com/600/92c952\",\n                \"thumbnailUrl\": \"https://via.placeholder.com/150/92c952\"\n            },\n            {\n                \"albumId\": 1,\n                \"id\": 2,\n                \"title\": \"A real photo 2\",\n                \"url\": \"https://via.placeholder.com/600/771796\",\n                \"thumbnailUrl\": \"https://via.placeholder.com/150/771796\"\n            },\n            {\n                \"albumId\": 1,\n                \"id\": 3,\n                \"title\": \"A real photo 3\",\n                \"url\": \"https://via.placeholder.com/600/24f355\",\n                \"thumbnailUrl\": \"https://via.placeholder.com/150/24f355\"\n            }\n        ]));\n});\nafter(() => {\n    request.get.restore();\n});\nit('should getPhotosByAlbumId', (done) => {\n    getPhotosByAlbumId(1).then((photos) => {\n        expect(photos.length).to.equal(3);\n        photos.forEach(photo => {\n            expect(photo).to.have.property('id');\n            expect(photo).to.have.property('title');\n            expect(photo).to.have.property('url');\n        });\n        done();\n    });\n});\n}); const request = require('request');\nconst getPhotosByAlbumId = (id) => {\nconst requestUrl = `https://jsonplaceholder.typicode.com/albums/${id}/photos?_limit=3`;\nreturn new Promise((resolve, reject) => {\n    request.get(requestUrl, (err, res, body) => {\n        if (err) {\n            return reject(err);\n        }\n        resolve(JSON.parse(body));\n    });\n});\n};\nmodule.exports = getPhotosByAlbumId;\nTo test this function this is the stub\nconst expect = require('chai').expect;\nconst request = require('request');\nconst sinon = require('sinon');\nconst getPhotosByAlbumId = require('./index');\ndescribe('with Stub: getPhotosByAlbumId', () => {\nbefore(() => {\n    sinon.stub(request, 'get')\n        .yields(null, null, JSON.stringify([\n            {\n                \"albumId\": 1,\n                \"id\": 1,\n                \"title\": \"A real photo 1\",\n                \"url\": \"https://via.placeholder.com/600/92c952\",\n                \"thumbnailUrl\": \"https://via.placeholder.com/150/92c952\"\n            },\n            {\n                \"albumId\": 1,\n                \"id\": 2,\n                \"title\": \"A real photo 2\",\n                \"url\": \"https://via.placeholder.com/600/771796\",\n                \"thumbnailUrl\": \"https://via.placeholder.com/150/771796\"\n            },\n            {\n                \"albumId\": 1,\n                \"id\": 3,\n                \"title\": \"A real photo 3\",\n                \"url\": \"https://via.placeholder.com/600/24f355\",\n                \"thumbnailUrl\": \"https://via.placeholder.com/150/24f355\"\n            }\n        ]));\n});\nafter(() => {\n    request.get.restore();\n});\nit('should getPhotosByAlbumId', (done) => {\n    getPhotosByAlbumId(1).then((photos) => {\n        expect(photos.length).to.equal(3);\n        photos.forEach(photo => {\n            expect(photo).to.have.property('id');\n            expect(photo).to.have.property('title');\n            expect(photo).to.have.property('url');\n        });\n        done();\n    });\n});\n}); const require 'request' const (id) => id const `https://jsonplaceholder.typicode.com/albums/${id}/photos?_limit=3` ${id} return new Promise (resolve, reject) => resolve, reject (err, res, body) => err, res, body if return JSON module this function this is the stub\nconst expect = require('chai').expect function this is the stub const expect require 'chai' 'chai' expect const require 'request' const require 'sinon' const require './index' 'with Stub: getPhotosByAlbumId' () => () => 'get' null null JSON \"albumId\" 1 \"id\" 1 \"title\" \"A real photo 1\" \"url\" \"https://via.placeholder.com/600/92c952\" \"thumbnailUrl\" \"https://via.placeholder.com/150/92c952\" \"albumId\" 1 \"id\" 2 \"title\" \"A real photo 2\" \"url\" \"https://via.placeholder.com/600/771796\" \"thumbnailUrl\" \"https://via.placeholder.com/150/771796\" \"albumId\" 1 \"id\" 3 \"title\" \"A real photo 3\" \"url\" \"https://via.placeholder.com/600/24f355\" \"thumbnailUrl\" \"https://via.placeholder.com/150/24f355\" () => 'should getPhotosByAlbumId' (done) => done 1 (photos) => photos 3 photo => photo 'id' 'title' 'url'",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Describe the exit codes of Node.js?",
        "answer": "Exit codes give us an idea of how a process got terminated/the reason behind termination. \n\nA few of them are:   Uncaught fatal exception - (code - 1) - There has been an exception that is not handled\nUnused - (code - 2) - This is reserved by bash\nFatal Error - (code - 5) - There has been an error in V8 with stderr output of the description\nInternal Exception handler Run-time failure - (code - 7) - There has been an exception when bootstrapping function was called\nInternal JavaScript Evaluation Failure - (code - 4) - There has been an exception when the bootstrapping process failed to return function value when evaluated. Uncaught fatal exception - (code - 1) - There has been an exception that is not handled Unused - (code - 2) - This is reserved by bash Fatal Error - (code - 5) - There has been an error in V8 with stderr output of the description Internal Exception handler Run-time failure - (code - 7) - There has been an exception when bootstrapping function was called Internal JavaScript Evaluation Failure - (code - 4) - There has been an exception when the bootstrapping process failed to return function value when evaluated.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. For Node.js, why Google uses V8 engine?",
        "answer": "Well, are there any other options available? Yes, of course, we have Spidermonkey from Firefox, Chakra from Edge but Google\u2019s v8 is the most evolved(since it\u2019s open-source so there\u2019s a huge community helping in developing features and fixing bugs) and fastest(since it\u2019s written in c++) we got till now as a JavaScript and WebAssembly engine. And it is portable to almost every machine known. Spidermonkey",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Why should you separate Express app and server?",
        "answer": "The server is responsible for initializing the routes, middleware, and other application logic whereas the app has all the business logic which will be served by the routes initiated by the server. This ensures that the business logic is encapsulated and decoupled from the application logic which makes the project more readable and maintainable.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Explain what a Reactor Pattern in Node.js?",
        "answer": "Reactor pattern again a pattern for nonblocking I/O operations. But in general, this is used in any event-driven architecture. \n\nThere are two components in this: 1. Reactor 2. Handler.\n\nReactor: Its job is to dispatch the I/O event to appropriate handlers\nHandler: Its job is to actually work on those events     Reactor  Handler",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What is middleware?",
        "answer": "Middleware comes in between your request and business logic. It is mainly used to capture logs and enable rate limit, routing, authentication, basically whatever that is not a part of business logic. There are third-party middleware also such as body-parser and you can write your own middleware for a specific use case.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What are node.js buffers?",
        "answer": "In general, buffers is a temporary memory that is mainly used by stream to hold on to some data until consumed. Buffers are introduced with additional use cases than JavaScript\u2019s Unit8Array and are mainly used to represent a fixed-length sequence of bytes. This also supports legacy encodings like ASCII, utf-8, etc. It is a fixed(non-resizable) allocated memory outside the v8.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What is node.js streams?",
        "answer": "Streams are instances of EventEmitter which can be used to work with streaming data in Node.js. They can be used for handling and manipulating streaming large files(videos, mp3, etc) over the network. They use buffers as their temporary storage.\n\nThere are mainly four types of the stream:   Writable: streams to which data can be written (for example, fs.createWriteStream()).\nReadable: streams from which data can be read (for example, fs.createReadStream()).\nDuplex: streams that are both Readable and Writable (for example, net.Socket).\nTransform: Duplex streams that can modify or transform the data as it is written and read (for example, zlib.createDeflate()). Writable: streams to which data can be written (for example, fs.createWriteStream()). Writable: Readable: streams from which data can be read (for example, fs.createReadStream()). Readable: Duplex: streams that are both Readable and Writable (for example, net.Socket). Duplex: Transform: Duplex streams that can modify or transform the data as it is written and read (for example, zlib.createDeflate()). Transform:",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. How can we use async await in node.js?",
        "answer": "Here is an example of using async-await pattern: // this code is to retry with exponential backoff\nfunction wait (timeout) {\n return new Promise((resolve) => {\nsetTimeout(() => {\n  resolve()\n}, timeout);\n });\n}\nasync function requestWithRetry (url) {\n const MAX_RETRIES = 10;\n for (let i = 0; i <= MAX_RETRIES; i++) {\ntry {\n  return await request(url);\n} catch (err) {\n  const timeout = Math.pow(2, i);\n  console.log('Waiting', timeout, 'ms');\n  await wait(timeout);\n  console.log('Retrying', err.message, i);\n}\n }\n} // this code is to retry with exponential backoff\nfunction wait (timeout) {\n return new Promise((resolve) => {\nsetTimeout(() => {\n  resolve()\n}, timeout);\n });\n}\nasync function requestWithRetry (url) {\n const MAX_RETRIES = 10;\n for (let i = 0; i <= MAX_RETRIES; i++) {\ntry {\n  return await request(url);\n} catch (err) {\n  const timeout = Math.pow(2, i);\n  console.log('Waiting', timeout, 'ms');\n  await wait(timeout);\n  console.log('Retrying', err.message, i);\n}\n }\n} // this code is to retry with exponential backoff function wait (timeout) function wait timeout return new Promise (resolve) => resolve setTimeout () => async function requestWithRetry (url) function requestWithRetry url const 10 for let 0 try return await catch const Math 2 console 'Waiting' 'ms' await console 'Retrying'",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. How does Node.js overcome the problem of blocking of I/O operations?",
        "answer": "Since the node has an event loop that can be used to handle all the I/O operations in an asynchronous manner without blocking the main function. \n\nSo for example, if some network call needs to happen it will be scheduled in the event loop instead of the main thread(single thread). And if there are multiple such I/O calls each one will be queued accordingly to be executed separately(other than the main thread).   Thus even though we have single-threaded JS, I/O ops are handled in a nonblocking way.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. Differentiate between process.nextTick() and setImmediate()?",
        "answer": "Both can be used to switch to an asynchronous mode of operation by listener functions. \n\nprocess.nextTick() sets the callback to execute but setImmediate pushes the callback in the queue to be executed. So the event loop runs in the following manner\n\ntimers\u2013>pending callbacks\u2013>idle,prepare\u2013>connections(poll,data,etc)\u2013>check\u2013>close callbacks     timers\u2013>pending callbacks\u2013>idle,prepare\u2013>connections(poll,data,etc)\u2013>check\u2013>close callbacks In this process.nextTick() method adds the callback function to the start of the next event queue and setImmediate() method to place the function in the check phase of the next event queue.",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. If Node.js is single threaded then how does it handle concurrency?",
        "answer": "The main loop is single-threaded and all async calls are managed by libuv library. For example: const crypto = require(\"crypto\");\nconst start = Date.now();\nfunction logHashTime() {\n crypto.pbkdf2(\"a\", \"b\", 100000, 512, \"sha512\", () => {\nconsole.log(\"Hash: \", Date.now() - start);\n });\n}\nlogHashTime();\nlogHashTime();\nlogHashTime();\nlogHashTime(); const crypto = require(\"crypto\");\nconst start = Date.now();\nfunction logHashTime() {\n crypto.pbkdf2(\"a\", \"b\", 100000, 512, \"sha512\", () => {\nconsole.log(\"Hash: \", Date.now() - start);\n });\n}\nlogHashTime();\nlogHashTime();\nlogHashTime();\nlogHashTime(); const require \"crypto\" const Date function logHashTime() function logHashTime  \"a\" \"b\" 100000 512 \"sha512\" () => console \"Hash: \" Date This gives the output: Hash: 1213\nHash: 1225\nHash: 1212\nHash: 1222 Hash: 1213\nHash: 1225\nHash: 1212\nHash: 1222 1213 Hash 1225 Hash 1212 Hash 1222 This is because libuv sets up a thread pool to handle such concurrency. How many threads will be there in the thread pool depends upon the number of cores but you can override this.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What is an event-loop in Node JS?",
        "answer": "Whatever that is async is managed by event-loop using a queue and listener.  We can get the idea using the following diagram: Node.js Event Loop  Node.js Event Loop So when an async function needs to be executed(or I/O) the main thread sends it to a different thread allowing v8 to keep executing the main code. Event loop involves different phases with specific tasks such as timers, pending callbacks, idle or prepare, poll, check, close callbacks with different FIFO queues. Also in between iterations it checks for async I/O or timers and shuts down cleanly if there aren't any.",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. What do you understand by callback hell?",
        "answer": "async_A(function(){\n   async_B(function(){\n       async_C(function(){\n           async_D(function(){\n           ....\n           });\n       });\n   });\n}); async_A(function(){\n   async_B(function(){\n       async_C(function(){\n           async_D(function(){\n           ....\n           });\n       });\n   });\n}); For the above example, we are passing callback functions and it makes the code unreadable and not maintainable, thus we should change the async logic to avoid this.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. What is an Event Emitter in Node.js?",
        "answer": "EventEmitter is a Node.js class that includes all the objects that are basically capable of emitting events. This can be done by attaching named events that are emitted by the object using an eventEmitter.on() function. Thus whenever this object throws an even the attached functions are invoked synchronously. const EventEmitter = require('events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n console.log('an event occurred!');\n});\nmyEmitter.emit('event'); const EventEmitter = require('events');\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\nmyEmitter.on('event', () => {\n console.log('an event occurred!');\n});\nmyEmitter.emit('event'); const require 'events' class MyEmitter extends EventEmitter class MyEmitter extends EventEmitter const new 'event' () => console 'an event occurred!' 'event'",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Enhancing Node.js performance through clustering.",
        "answer": "Node.js applications run on a single processor, which means that by default they don\u2019t take advantage of a multiple-core system. Cluster mode is used to start up multiple node.js processes thereby having multiple instances of the event loop. When we start using cluster in a nodejs app behind the scene multiple node.js processes are created but there is also a parent process called the cluster manager which is responsible for monitoring the health of the individual instances of our application. cluster manager Clustering in Node.js  Clustering in Node.js",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What is a thread pool and which library handles it in Node.js",
        "answer": "The Thread pool is handled by the libuv library. libuv is a multi-platform C library that provides support for asynchronous I/O-based operations such as file systems, networking, and concurrency. Thread Pool  Thread Pool",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What is WASI and why is it being introduced?",
        "answer": "Web assembly provides an implementation of WebAssembly System Interface specification through WASI API in node.js implemented using WASI class. The introduction of WASI was done by keeping in mind its possible to use the underlying operating system via a collection of POSIX-like functions thus further enabling the application to use resources more efficiently and features that require system-level access. WebAssembly System Interface",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. How are worker threads different from clusters?",
        "answer": "Cluster: Cluster: There is one process on each CPU with an IPC to communicate.\nIn case we want to have multiple servers accepting HTTP requests via a single port, clusters can be helpful.\nThe processes are spawned in each CPU thus will have separate memory and node instance which further will lead to memory issues. There is one process on each CPU with an IPC to communicate. In case we want to have multiple servers accepting HTTP requests via a single port, clusters can be helpful. The processes are spawned in each CPU thus will have separate memory and node instance which further will lead to memory issues. Worker threads: Worker threads: There is only one process in total with multiple threads.\nEach thread has one Node instance (one event loop, one JS engine) with most of the APIs accessible.\nShares memory with other threads (e.g. SharedArrayBuffer)\nThis can be used for CPU-intensive tasks like processing data or accessing the file system since NodeJS is single-threaded, synchronous tasks can be made more efficient leveraging the worker's threads. There is only one process in total with multiple threads. Each thread has one Node instance (one event loop, one JS engine) with most of the APIs accessible. Shares memory with other threads (e.g. SharedArrayBuffer) This can be used for CPU-intensive tasks like processing data or accessing the file system since NodeJS is single-threaded, synchronous tasks can be made more efficient leveraging the worker's threads.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. How to measure the duration of async operations?",
        "answer": "Performance API provides us with tools to figure out the necessary performance metrics. A simple example would be using async_hooks and perf_hooks 'use strict';\nconst async_hooks = require('async_hooks');\nconst {\n performance,\n PerformanceObserver\n} = require('perf_hooks');\nconst set = new Set();\nconst hook = async_hooks.createHook({\n init(id, type) {\nif (type === 'Timeout') {\n  performance.mark(`Timeout-${id}-Init`);\n  set.add(id);\n}\n },\n destroy(id) {\nif (set.has(id)) {\n  set.delete(id);\n  performance.mark(`Timeout-${id}-Destroy`);\n  performance.measure(`Timeout-${id}`,\n                      `Timeout-${id}-Init`,\n                      `Timeout-${id}-Destroy`);\n}\n }\n});\nhook.enable();\nconst obs = new PerformanceObserver((list, observer) => {\n console.log(list.getEntries()[0]);\n performance.clearMarks();\n observer.disconnect();\n});\nobs.observe({ entryTypes: ['measure'], buffered: true });\nsetTimeout(() => {}, 1000); 'use strict';\nconst async_hooks = require('async_hooks');\nconst {\n performance,\n PerformanceObserver\n} = require('perf_hooks');\nconst set = new Set();\nconst hook = async_hooks.createHook({\n init(id, type) {\nif (type === 'Timeout') {\n  performance.mark(`Timeout-${id}-Init`);\n  set.add(id);\n}\n },\n destroy(id) {\nif (set.has(id)) {\n  set.delete(id);\n  performance.mark(`Timeout-${id}-Destroy`);\n  performance.measure(`Timeout-${id}`,\n                      `Timeout-${id}-Init`,\n                      `Timeout-${id}-Destroy`);\n}\n }\n});\nhook.enable();\nconst obs = new PerformanceObserver((list, observer) => {\n console.log(list.getEntries()[0]);\n performance.clearMarks();\n observer.disconnect();\n});\nobs.observe({ entryTypes: ['measure'], buffered: true });\nsetTimeout(() => {}, 1000); This would give us the exact time it took to execute the callback.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. How to measure the performance of async operations?",
        "answer": "Performance API provides us with tools to figure out the necessary performance metrics. \n\nA simple example would be:   const { PerformanceObserver, performance } = require('perf_hooks');\nconst obs = new PerformanceObserver((items) => {\n console.log(items.getEntries()[0].duration);\n performance.clearMarks();\n});\nobs.observe({ entryTypes: ['measure'] });\nperformance.measure('Start to Now');\nperformance.mark('A');\ndoSomeLongRunningProcess(() => {\n performance.measure('A to Now', 'A');\n performance.mark('B');\n performance.measure('A to B', 'A', 'B');\n}); const { PerformanceObserver, performance } = require('perf_hooks');\nconst obs = new PerformanceObserver((items) => {\n console.log(items.getEntries()[0].duration);\n performance.clearMarks();\n});\nobs.observe({ entryTypes: ['measure'] });\nperformance.measure('Start to Now');\nperformance.mark('A');\ndoSomeLongRunningProcess(() => {\n performance.measure('A to Now', 'A');\n performance.mark('B');\n performance.measure('A to B', 'A', 'B');\n});  Additional Useful Resources NodeJS MCQ\nTop 10 Node JS Projects Ideas\nNode.js Vs React.js: What\u2019s The Difference?\nNode.js Vs Django: Which One is Better For Web Development? NodeJS MCQ NodeJS MCQ Top 10 Node JS Projects Ideas Top 10 Node JS Projects Ideas Node.js Vs React.js: What\u2019s The Difference? Node.js Vs React.js: What\u2019s The Difference? Node.js Vs Django: Which One is Better For Web Development? Node.js Vs Django: Which One is Better For Web Development?",
        "reference": "interviewbit.com"
    }
]