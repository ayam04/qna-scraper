[
    {
        "question": "1. Why is Java a platform independent language?",
        "answer": "Java language was developed so that it does not depend on any hardware or software because the compiler compiles the code and then converts it to platform-independent byte code which can be run on multiple systems. compiler The only condition to run that byte code is for the machine to have a runtime environment (JRE) installed in it. The only condition to run that byte code is for the machine to have a runtime environment (JRE) installed in it. Learn More Learn More",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Why is Java not a pure object oriented language?",
        "answer": "Java supports primitive data types - byte, boolean, char, short, int, float, long, and double and hence it is not a pure object oriented language. object oriented language object oriented language",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Difference between Heap and Stack Memory in java. And how java utilizes this.",
        "answer": "Stack memory is the portion of memory that was assigned to every individual program. And it was fixed. On the other hand, Heap memory is the portion that was not allocated to the java program but it will be available for use by the java program when it is required, mostly during the runtime of the program. Java Utilizes this memory as - Java Utilizes this memory as - When we write a java program then all the variables, methods, etc are stored in the stack memory.\nAnd when we create any object in the java program then that object was created in the heap memory. And it was referenced from the stack memory. When we write a java program then all the variables, methods, etc are stored in the stack memory. And when we create any object in the java program then that object was created in the heap memory. And it was referenced from the stack memory. Example- Consider the below java program: Consider the below java program class Main {\n   public void printArray(int[] array){\n       for(int i : array)\n           System.out.println(i);\n   }\n   public static void main(String args[]) {\n       int[] array = new int[10];\n       printArray(array);\n   }\n} class Main {\n   public void printArray(int[] array){\n       for(int i : array)\n           System.out.println(i);\n   }\n   public static void main(String args[]) {\n       int[] array = new int[10];\n       printArray(array);\n   }\n} class Main class Main public void printArray(int[] array) public void printArray (int[] array) int for int public static void main(String args[]) public static void main (String args[]) int new int 10 For this java program. The stack and heap memory occupied by java is -   Main and PrintArray is the method that will be available in the stack area and as well as the variables declared that will also be in the stack area. And the Object (Integer Array of size 10) we have created, will be available in the Heap area because that space will be allocated to the program during runtime.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Can java be said to be the complete object-oriented programming language?",
        "answer": "It is not wrong if we claim that Java is the complete object-oriented programming language because everything in Java is under the classes and we can access them by creating the objects. But we can even say that Java is not a completely object-oriented programming language because it has the support of primitive data types like int, float, char, boolean, double, etc. Now for the question: Is Java a completely object-oriented programming language? We can say that - Java is not a pure object-oriented programming language, because it has direct access to primitive data types. And these primitive data types don't directly belong to the Integer classes. Is Java a completely object-oriented programming language?",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. How is Java different from C++?",
        "answer": "C++ is only a  compiled language, whereas Java is compiled as well as an interpreted language.\nJava programs are machine-independent whereas a c++ program can run only in the machine in which it is compiled. \nC++ allows users to use pointers in the program. Whereas java doesn\u2019t allow it. Java internally uses pointers. \nC++ supports the concept of Multiple inheritances whereas Java doesn't support this. And it is due to avoiding the complexity of name ambiguity that causes the diamond problem. C++ is only a  compiled language, whereas Java is compiled as well as an interpreted language. Java programs are machine-independent whereas a c++ program can run only in the machine in which it is compiled. C++ allows users to use pointers in the program. Whereas java doesn\u2019t allow it. Java internally uses pointers. C++ supports the concept of Multiple inheritances whereas Java doesn't support this. And it is due to avoiding the complexity of name ambiguity that causes the diamond problem.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Pointers are used in C/ C++. Why does Java not make use of pointers?",
        "answer": "Pointers are quite complicated and unsafe to use by beginner programmers. Java focuses on code simplicity, and the usage of pointers can make it challenging. Pointer utilization can also cause potential errors. Moreover, security is also compromised if pointers are used because the users can directly access memory with the help of pointers. Thus, a certain level of abstraction is furnished by not including pointers in Java. Moreover, the usage of pointers can make the procedure of garbage collection quite slow and erroneous. Java makes use of references as these cannot be manipulated, unlike pointers.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What do you understand by an instance variable and a local variable?",
        "answer": "Instance variables are those variables that are accessible by all the methods in the class. They are declared outside the methods and inside the class. These variables describe the properties of an object and remain bound to it at any cost. Instance variables All the objects of the class will have their copy of the variables for utilization. If any modification is done on these variables, then only that instance will be impacted by it, and all other class instances continue to remain unaffected. Example: Example: class Athlete {\npublic String athleteName;\npublic double athleteSpeed;\npublic int athleteAge;\n} class Athlete {\npublic String athleteName;\npublic double athleteSpeed;\npublic int athleteAge;\n} class Athlete class Athlete public public double public int Local variables are those variables present within a block, function, or constructor and can be accessed only inside them. The utilization of the variable is restricted to the block scope. Whenever a local variable is declared inside a method, the other class methods don\u2019t have any knowledge about the local variable. Local variables Example: Example: public void athlete() {\nString athleteName;\ndouble athleteSpeed;\nint athleteAge;\n} public void athlete() {\nString athleteName;\ndouble athleteSpeed;\nint athleteAge;\n} public void athlete() public void athlete () double int  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What are the default values assigned to variables and instances in java?",
        "answer": "There are no default values assigned to the variables in java. We need to initialize the value before using it. Otherwise, it will throw a compilation error of (Variable might not be initialized). \nBut for instance, if we create the object, then the default value will be initialized by the default constructor depending on the data type. \nIf it is a reference, then it will be assigned to null. \nIf it is numeric, then it will assign to 0.\nIf it is a boolean, then it will be assigned to false. Etc. There are no default values assigned to the variables in java. We need to initialize the value before using it. Otherwise, it will throw a compilation error of (Variable might not be initialized). Variable might not be initialized But for instance, if we create the object, then the default value will be initialized by the default constructor depending on the data type. If it is a reference, then it will be assigned to null. If it is numeric, then it will assign to 0. If it is a boolean, then it will be assigned to false. Etc.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What do you mean by data encapsulation?",
        "answer": "Data Encapsulation is an Object-Oriented Programming concept of hiding the data attributes and their behaviours in a single unit.\nIt helps developers to follow modularity while developing software by ensuring that each object is independent of other objects by having its own methods, attributes, and functionalities.\nIt is used for the security of the private properties of an object and hence serves the purpose of data hiding. Data Encapsulation is an Object-Oriented Programming concept of hiding the data attributes and their behaviours in a single unit. It helps developers to follow modularity while developing software by ensuring that each object is independent of other objects by having its own methods, attributes, and functionalities. It is used for the security of the private properties of an object and hence serves the purpose of data hiding.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Tell us something about JIT compiler.",
        "answer": "JIT stands for Just-In-Time and it is used for improving the performance during run time. It does the task of compiling parts of byte code having similar functionality at the same time thereby reducing the amount of compilation time for the code to run.\nThe compiler is nothing but a translator of source code to machine-executable code. But what is special about the JIT compiler? Let us see how it works:\nFirst, the Java source code (.java) conversion to byte code (.class) occurs with the help of the javac compiler.\nThen, the .class files are loaded at run time by JVM and with the help of an interpreter, these are converted to machine understandable code.\nJIT compiler is a part of JVM. When the JIT compiler is enabled, the JVM analyzes the method calls in the .class files and compiles them to get more efficient and native code. It also ensures that the prioritized method calls are optimized.\nOnce the above step is done, the JVM executes the optimized code directly instead of interpreting the code again. This increases the performance and speed of the execution. JIT stands for Just-In-Time and it is used for improving the performance during run time. It does the task of compiling parts of byte code having similar functionality at the same time thereby reducing the amount of compilation time for the code to run. The compiler is nothing but a translator of source code to machine-executable code. But what is special about the JIT compiler? Let us see how it works:\nFirst, the Java source code (.java) conversion to byte code (.class) occurs with the help of the javac compiler.\nThen, the .class files are loaded at run time by JVM and with the help of an interpreter, these are converted to machine understandable code.\nJIT compiler is a part of JVM. When the JIT compiler is enabled, the JVM analyzes the method calls in the .class files and compiles them to get more efficient and native code. It also ensures that the prioritized method calls are optimized.\nOnce the above step is done, the JVM executes the optimized code directly instead of interpreting the code again. This increases the performance and speed of the execution. First, the Java source code (.java) conversion to byte code (.class) occurs with the help of the javac compiler.\nThen, the .class files are loaded at run time by JVM and with the help of an interpreter, these are converted to machine understandable code.\nJIT compiler is a part of JVM. When the JIT compiler is enabled, the JVM analyzes the method calls in the .class files and compiles them to get more efficient and native code. It also ensures that the prioritized method calls are optimized.\nOnce the above step is done, the JVM executes the optimized code directly instead of interpreting the code again. This increases the performance and speed of the execution. First, the Java source code (.java) conversion to byte code (.class) occurs with the help of the javac compiler. Then, the .class files are loaded at run time by JVM and with the help of an interpreter, these are converted to machine understandable code. JIT compiler is a part of JVM. When the JIT compiler is enabled, the JVM analyzes the method calls in the .class files and compiles them to get more efficient and native code. It also ensures that the prioritized method calls are optimized. Once the above step is done, the JVM executes the optimized code directly instead of interpreting the code again. This increases the performance and speed of the execution.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. Can you tell the difference between equals() method and equality operator (==) in Java?",
        "answer": "We are already aware of the (==) equals operator. That we have used this to compare the equality of the values. But when we talk about the terms of object-oriented programming, we deal with the values in the form of objects. And this object may contain multiple types of data. So using the (==) operator does not work in this case. So we need to go with the .equals() method. (==) equals (==) operator equals() method. Both [(==) and .equals()] primary functionalities are to compare the values, but the secondary functionality is different. [(==) .equals()] So in order to understand this better, let\u2019s consider this with the example - String str1 = \"InterviewBit\";\nString str2 = \"InterviewBit\";\n \nSystem.out.println(str1 == str2); String str1 = \"InterviewBit\";\nString str2 = \"InterviewBit\";\n \nSystem.out.println(str1 == str2); \"InterviewBit\" \"InterviewBit\" This code will print true. We know that both strings are equals so it will print true. But here (==) Operators don\u2019t compare each character in this case. It compares the memory location. And because the string uses the constant pool for storing the values in the memory, both str1 and str2 are stored at the same memory location. See the detailed Explanation in Question no 73: Link. (==) Operators str1 str2 Link Link   Now, if we modify the program a little bit with - String str1 = new String(\"InterviewBit\");\nString str2 = \"InterviewBit\";\n \nSystem.out.println(str1 == str2); String str1 = new String(\"InterviewBit\");\nString str2 = \"InterviewBit\";\n \nSystem.out.println(str1 == str2); new \"InterviewBit\" \"InterviewBit\"   Then in this case, it will print false. Because here no longer the constant pool concepts are used. Here, new memory is allocated. So here the memory address is different, therefore ( == ) Operator returns false. But the twist is that the values are the same in both strings. So how to compare the values? Here the .equals() method is used. .equals() method compares the values and returns the result accordingly.  If we modify the above code with - .equals() System.out.println(str1.equals(str2)); System.out.println(str1.equals(str2)); Then it returns true. equals()  ==\nThis is a method defined in the Object class.  It is a binary operator in Java.\nThe .equals() Method is present in the Object class, so we can override our custom .equals() method in the custom class, for objects comparison. It cannot be modified. They always compare the HashCode.\nThis method is used for checking the equality of contents between two objects as per the specified business logic. This operator is used for comparing addresses (or references), i.e checks if both the objects are pointing to the same memory location. equals()  ==\nThis is a method defined in the Object class.  It is a binary operator in Java.\nThe .equals() Method is present in the Object class, so we can override our custom .equals() method in the custom class, for objects comparison. It cannot be modified. They always compare the HashCode.\nThis method is used for checking the equality of contents between two objects as per the specified business logic. This operator is used for comparing addresses (or references), i.e checks if both the objects are pointing to the same memory location. equals()  == equals()  == equals() == This is a method defined in the Object class.  It is a binary operator in Java.\nThe .equals() Method is present in the Object class, so we can override our custom .equals() method in the custom class, for objects comparison. It cannot be modified. They always compare the HashCode.\nThis method is used for checking the equality of contents between two objects as per the specified business logic. This operator is used for comparing addresses (or references), i.e checks if both the objects are pointing to the same memory location. This is a method defined in the Object class.  It is a binary operator in Java. This is a method defined in the Object class. It is a binary operator in Java. The .equals() Method is present in the Object class, so we can override our custom .equals() method in the custom class, for objects comparison. It cannot be modified. They always compare the HashCode. The .equals() Method is present in the Object class, so we can override our custom .equals() method in the custom class, for objects comparison. It cannot be modified. They always compare the HashCode. This method is used for checking the equality of contents between two objects as per the specified business logic. This operator is used for comparing addresses (or references), i.e checks if both the objects are pointing to the same memory location. This method is used for checking the equality of contents between two objects as per the specified business logic. This operator is used for comparing addresses (or references), i.e checks if both the objects are pointing to the same memory location. Note: Note: In the cases where the equals method is not overridden in a class, then the class uses the default implementation of the equals method that is closest to the parent class.\nObject class is considered as the parent class of all the java classes. The implementation of the equals method in the Object class uses the == operator to compare two objects. This default implementation can be overridden as per the business logic. In the cases where the equals method is not overridden in a class, then the class uses the default implementation of the equals method that is closest to the parent class. Object class is considered as the parent class of all the java classes. The implementation of the equals method in the Object class uses the == operator to compare two objects. This default implementation can be overridden as per the business logic.",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. How is an infinite loop declared in Java?",
        "answer": "Infinite loops are those loops that run infinitely without any breaking conditions. Some examples of consciously declaring infinite loop is: Using For Loop: Using For Loop: for (;;)\n{\n   // Business logic\n   // Any break logic\n} for (;;)\n{\n   // Business logic\n   // Any break logic\n} for // Business logic // Any break logic Using while loop: Using while loop: while(true){\n   // Business logic\n   // Any break logic\n} while(true){\n   // Business logic\n   // Any break logic\n} while true // Business logic // Any break logic Using do-while loop: Using do-while loop: do{\n   // Business logic\n   // Any break logic\n}while(true); do{\n   // Business logic\n   // Any break logic\n}while(true); do // Business logic // Any break logic while true",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. Briefly explain the concept of constructor overloading",
        "answer": "Constructor overloading is the process of creating multiple constructors in the class consisting of the same name with a difference in the constructor parameters. Depending upon the number of parameters and their corresponding types, distinguishing of the different types of constructors is done by the compiler. class Hospital {\nint variable1, variable2;\ndouble variable3;\npublic Hospital(int doctors, int nurses) {\n variable1 = doctors;\n variable2 = nurses;\n}\npublic Hospital(int doctors) {\n variable1 = doctors;\n}\npublic Hospital(double salaries) {\n variable3 = salaries\n}\n} class Hospital {\nint variable1, variable2;\ndouble variable3;\npublic Hospital(int doctors, int nurses) {\n variable1 = doctors;\n variable2 = nurses;\n}\npublic Hospital(int doctors) {\n variable1 = doctors;\n}\npublic Hospital(double salaries) {\n variable3 = salaries\n}\n} class Hospital class Hospital int double public Hospital(int doctors, int nurses) public Hospital (int doctors, int nurses) int int public Hospital(int doctors) public Hospital (int doctors) int public Hospital(double salaries) public Hospital (double salaries) double   Three constructors are defined here but they differ on the basis of parameter type and their numbers.",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. Define Copy constructor in java.",
        "answer": "Copy Constructor is the constructor used when we want to initialize the value to the new object from the old object of the same class. class InterviewBit{\n   String department;\n   String service;\n   InterviewBit(InterviewBit ib){\n       this.departments = ib.departments;\n       this.services = ib.services;\n   }\n} class InterviewBit{\n   String department;\n   String service;\n   InterviewBit(InterviewBit ib){\n       this.departments = ib.departments;\n       this.services = ib.services;\n   }\n} class InterviewBit class InterviewBit this this Here we are initializing the new object value from the old object value in the constructor. Although, this can also be achieved with the help of object cloning.",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. Can the main method be Overloaded?",
        "answer": "Yes, It is possible to overload the main method. We can create as many overloaded main methods we want. However, JVM has a predefined calling method that JVM will only call the main method with the definition of - public static void main(string[] args) public static void main(string[] args) public static void main(string[] args) public static void main (string[] args) Consider the below code snippets: class Main {\n    public static void main(String args[]) {\n        System.out.println(\" Main Method\");\n    }\n    public static void main(int[] args){\n        System.out.println(\"Overloaded Integer array Main Method\");\n    }\n    public static void main(char[] args){\n        System.out.println(\"Overloaded Character array Main Method\");\n    }\n    public static void main(double[] args){\n        System.out.println(\"Overloaded Double array Main Method\");\n    }\n    public static void main(float args){\n        System.out.println(\"Overloaded float Main Method\");\n    }\n} class Main {\n    public static void main(String args[]) {\n        System.out.println(\" Main Method\");\n    }\n    public static void main(int[] args){\n        System.out.println(\"Overloaded Integer array Main Method\");\n    }\n    public static void main(char[] args){\n        System.out.println(\"Overloaded Character array Main Method\");\n    }\n    public static void main(double[] args){\n        System.out.println(\"Overloaded Double array Main Method\");\n    }\n    public static void main(float args){\n        System.out.println(\"Overloaded float Main Method\");\n    }\n} class Main class Main public static void main(String args[]) public static void main (String args[]) \" Main Method\" public static void main(int[] args) public static void main (int[] args) int \"Overloaded Integer array Main Method\" public static void main(char[] args) public static void main (char[] args) char \"Overloaded Character array Main Method\" public static void main(double[] args) public static void main (double[] args) double \"Overloaded Double array Main Method\" public static void main(float args) public static void main (float args) float \"Overloaded float Main Method\"",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. Comment on method overloading and overriding by citing relevant examples.",
        "answer": "In Java, method overloading is made possible by introducing different methods in the same class consisting of the same name. Still, all the functions differ in the number or type of parameters. It takes place inside a class and enhances program readability. method overloading The only difference in the return type of the method does not promote method overloading. The following example will furnish you with a clear picture of it. class OverloadingHelp {\n   public int findarea (int l, int b) {\n           int var1;\n           var1 = l * b;\n           return var1;\n   }\n   public int findarea (int l, int b, int h) {\n           int var2;\n           var2 = l * b * h;\n           return var2;\n   }\n} class OverloadingHelp {\n   public int findarea (int l, int b) {\n           int var1;\n           var1 = l * b;\n           return var1;\n   }\n   public int findarea (int l, int b, int h) {\n           int var2;\n           var2 = l * b * h;\n           return var2;\n   }\n} class OverloadingHelp class OverloadingHelp public int findarea (int l, int b) public int findarea (int l, int b) int int int return public int findarea (int l, int b, int h) public int findarea (int l, int b, int h) int int int int return   Both the functions have the same name but differ in the number of arguments. The first method calculates the area of the rectangle, whereas the second method calculates the area of a cuboid. Method overriding is the concept in which two methods having the same method signature are present in two different classes in which an inheritance relationship is present. A particular method implementation (already present in the base class) is possible for the derived class by using method overriding.\nLet\u2019s give a look at this example: Method overriding  class HumanBeing {\n       public int walk (int distance, int time) {\n               int speed = distance / time;\n               return speed;\n       }\n}\nclass Athlete extends HumanBeing {\n       public int walk(int distance, int time) {\n               int speed = distance / time;\n               speed = speed * 2;\n               return speed;\n       }\n} class HumanBeing {\n       public int walk (int distance, int time) {\n               int speed = distance / time;\n               return speed;\n       }\n}\nclass Athlete extends HumanBeing {\n       public int walk(int distance, int time) {\n               int speed = distance / time;\n               speed = speed * 2;\n               return speed;\n       }\n} class HumanBeing class HumanBeing public int walk (int distance, int time) public int walk (int distance, int time) int int int return class Athlete extends HumanBeing class Athlete extends HumanBeing public int walk(int distance, int time) public int walk (int distance, int time) int int int 2 return   Both class methods have the name walk and the same parameters, distance, and time. If the derived class method is called, then the base class method walk gets overridden by that of the derived class.",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. A single try block and multiple catch blocks can co-exist in a Java Program. Explain.",
        "answer": "Yes, multiple catch blocks can exist but specific approaches should come prior to the general approach because only the first catch block satisfying the catch condition is executed. The given code illustrates the same: public class MultipleCatch {\npublic static void main(String args[]) {\n try {\n  int n = 1000, x = 0;\n  int arr[] = new int[n];\n  for (int i = 0; i <= n; i++) {\n   arr[i] = i / x;\n  }\n }\n catch (ArrayIndexOutOfBoundsException exception) {\n  System.out.println(\"1st block = ArrayIndexOutOfBoundsException\");\n }\n catch (ArithmeticException exception) {\n  System.out.println(\"2nd block = ArithmeticException\");\n }\n catch (Exception exception) {\n  System.out.println(\"3rd block = Exception\");\n }\n}\n} public class MultipleCatch {\npublic static void main(String args[]) {\n try {\n  int n = 1000, x = 0;\n  int arr[] = new int[n];\n  for (int i = 0; i <= n; i++) {\n   arr[i] = i / x;\n  }\n }\n catch (ArrayIndexOutOfBoundsException exception) {\n  System.out.println(\"1st block = ArrayIndexOutOfBoundsException\");\n }\n catch (ArithmeticException exception) {\n  System.out.println(\"2nd block = ArithmeticException\");\n }\n catch (Exception exception) {\n  System.out.println(\"3rd block = Exception\");\n }\n}\n} public class MultipleCatch class MultipleCatch public static void main(String args[]) public static void main (String args[]) try int 1000 0 int new int for int 0 catch \"1st block = ArrayIndexOutOfBoundsException\" catch \"2nd block = ArithmeticException\" catch \"3rd block = Exception\" Here, the second catch block will be executed because of division by 0 (i / x). In case x was greater than 0 then the first catch block will execute because for loop runs till i = n and array index are till n-1.",
        "reference": "interviewbit.com"
    },
    {
        "question": "18. Explain the use of final keyword in variable, method and class.",
        "answer": "In Java, the final keyword is used as defining something as constant /final and represents the non-access modifier. final variable:\nWhen a variable is declared as final in Java, the value can\u2019t be modified once it has been assigned.\nIf any value has not been assigned to that variable, then it can be assigned only by the constructor of the class.\nfinal method:\nA method declared as final cannot be overridden by its children's classes.\nA constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn't make sense. Java throws compilation error saying - modifier final not allowed here\nfinal class:\nNo classes can be inherited from the class declared as final. But that final class can extend other classes for its usage. final variable:\nWhen a variable is declared as final in Java, the value can\u2019t be modified once it has been assigned.\nIf any value has not been assigned to that variable, then it can be assigned only by the constructor of the class. final variable: When a variable is declared as final in Java, the value can\u2019t be modified once it has been assigned.\nIf any value has not been assigned to that variable, then it can be assigned only by the constructor of the class. When a variable is declared as final in Java, the value can\u2019t be modified once it has been assigned. If any value has not been assigned to that variable, then it can be assigned only by the constructor of the class. final method:\nA method declared as final cannot be overridden by its children's classes.\nA constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn't make sense. Java throws compilation error saying - modifier final not allowed here final method: A method declared as final cannot be overridden by its children's classes.\nA constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn't make sense. Java throws compilation error saying - modifier final not allowed here A method declared as final cannot be overridden by its children's classes. A constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn't make sense. Java throws compilation error saying - modifier final not allowed here modifier final not allowed here final class:\nNo classes can be inherited from the class declared as final. But that final class can extend other classes for its usage. final class: No classes can be inherited from the class declared as final. But that final class can extend other classes for its usage. No classes can be inherited from the class declared as final. But that final class can extend other classes for its usage.",
        "reference": "interviewbit.com"
    },
    {
        "question": "19. Do final, finally and finalize keywords have the same function?",
        "answer": "All three keywords have their own utility while programming. Final: If any restriction is required for classes, variables, or methods, the final keyword comes in handy. Inheritance of a final class and overriding of a final method is restricted by the use of the final keyword. The variable value becomes fixed after incorporating the final keyword. Example: Final: final int a=100;\na = 0;  // error final int a=100;\na = 0;  // error final int 100 0 // error The second statement will throw an error. Finally: It is the block present in a program where all the codes written inside it get executed irrespective of handling of exceptions. Example: Finally: try {\nint variable = 5;\n}\ncatch (Exception exception) {\nSystem.out.println(\"Exception occurred\");\n}\nfinally {\nSystem.out.println(\"Execution of finally block\");\n} try {\nint variable = 5;\n}\ncatch (Exception exception) {\nSystem.out.println(\"Exception occurred\");\n}\nfinally {\nSystem.out.println(\"Execution of finally block\");\n} try int 5 catch \"Exception occurred\" finally \"Execution of finally block\" Finalize: Prior to the garbage collection of an object, the finalize method is called so that the clean-up activity is implemented. Example: Finalize: public static void main(String[] args) {\nString example = new String(\"InterviewBit\");\nexample = null;\nSystem.gc(); // Garbage collector called\n}\npublic void finalize() {\n// Finalize called\n} public static void main(String[] args) {\nString example = new String(\"InterviewBit\");\nexample = null;\nSystem.gc(); // Garbage collector called\n}\npublic void finalize() {\n// Finalize called\n} public static void main(String[] args) public static void main (String[] args) new \"InterviewBit\" null // Garbage collector called public void finalize() public void finalize () // Finalize called",
        "reference": "interviewbit.com"
    },
    {
        "question": "20. Is it possible that the \u2018finally\u2019 block will not be executed? If yes then list the case.",
        "answer": "Yes. It is possible that the \u2018finally\u2019 block will not be executed. The cases are- Suppose we use System.exit() in the above statement.\nIf there are fatal errors like Stack overflow, Memory access error, etc. Suppose we use System.exit() in the above statement. System.exit() If there are fatal errors like Stack overflow, Memory access error, etc.",
        "reference": "interviewbit.com"
    },
    {
        "question": "21. Identify the output of the java program and state the reason.",
        "answer": "1. public class InterviewBit\n2. {\n3.  public static void main(String[] args) {\n4.    final int i;\n5.   i = 20;\n6.   int j = i+20;\n7.   i = j+30;\n8.      System.out.println(i + \" \" + j);\n9.  }\n10. } 1. public class InterviewBit\n2. {\n3.  public static void main(String[] args) {\n4.    final int i;\n5.   i = 20;\n6.   int j = i+20;\n7.   i = j+30;\n8.      System.out.println(i + \" \" + j);\n9.  }\n10. } 1. public class InterviewBit\n2. class InterviewBit 3. public static void main(String[] args) public static void main (String[] args) 4. final int 5. 20 6. int 20 7. 30 8. \" \" 9. 10. The above code will generate a compile-time error at Line 7 saying - [error: variable i might already have been initialized]. It is because variable \u2018i\u2019 is the final variable. And final variables are allowed to be initialized only once, and that was already done on line no 5. [error: variable i might already have been initialized]",
        "reference": "interviewbit.com"
    },
    {
        "question": "22. When can you use super keyword?",
        "answer": "The super keyword is used to access hidden fields and overridden methods or attributes of the parent class.\nFollowing are the cases when this keyword can be used:\nAccessing data members of parent class when the member names of the class and its child subclasses are same.\nTo call the default and parameterized constructor of the parent class inside the child class.\nAccessing the parent class methods when the child classes have overridden them.\nThe following example demonstrates all 3 cases when a super keyword is used. The super keyword is used to access hidden fields and overridden methods or attributes of the parent class. Following are the cases when this keyword can be used:\nAccessing data members of parent class when the member names of the class and its child subclasses are same.\nTo call the default and parameterized constructor of the parent class inside the child class.\nAccessing the parent class methods when the child classes have overridden them. Accessing data members of parent class when the member names of the class and its child subclasses are same.\nTo call the default and parameterized constructor of the parent class inside the child class.\nAccessing the parent class methods when the child classes have overridden them. Accessing data members of parent class when the member names of the class and its child subclasses are same. To call the default and parameterized constructor of the parent class inside the child class. Accessing the parent class methods when the child classes have overridden them. The following example demonstrates all 3 cases when a super keyword is used. class Parent{\n       protected int num = 1;\n       \n       Parent(){\n           System.out.println(\"Parent class default constructor.\");\n       }\n       \n       Parent(String x){\n           System.out.println(\"Parent class parameterised constructor.\");\n       }\n       \n       public void foo(){\n           System.out.println(\"Parent class foo!\");\n       }\n   }\nclass Child extends Parent{\n       private int num = 2;\n       \n       Child(){\n           //super constructor call should always be in the first line\n           // super();              // Either call default super() to call default parent constructor OR\n           super(\"Call Parent\");    // call parameterised super to call parameterised parent constructor.\n           System.out.println(\"Child class default Constructor\");\n       }\n       \n       void printNum(){\n           System.out.println(num);\n           System.out.println(super.num); //prints the value of num of parent class\n       }\n       \n       @Override\n       public void foo(){\n           System.out.println(\"Child class foo!\");\n           super.foo();    //Calls foo method of Parent class inside the Overriden foo method of Child class.\n       }\n   }\n\npublic class DemoClass {\n    public static void main(String args[]) {\n     Child demoObject=new Child();\n     demoObject.foo();\n     /*\n      This would print - \n      Parent class parameterised constructor.\n      Child class default Constructor\n      Child class foo!\n      Parent class foo!\n     */\n    }\n} class Parent{\n       protected int num = 1;\n       \n       Parent(){\n           System.out.println(\"Parent class default constructor.\");\n       }\n       \n       Parent(String x){\n           System.out.println(\"Parent class parameterised constructor.\");\n       }\n       \n       public void foo(){\n           System.out.println(\"Parent class foo!\");\n       }\n   }\nclass Child extends Parent{\n       private int num = 2;\n       \n       Child(){\n           //super constructor call should always be in the first line\n           // super();              // Either call default super() to call default parent constructor OR\n           super(\"Call Parent\");    // call parameterised super to call parameterised parent constructor.\n           System.out.println(\"Child class default Constructor\");\n       }\n       \n       void printNum(){\n           System.out.println(num);\n           System.out.println(super.num); //prints the value of num of parent class\n       }\n       \n       @Override\n       public void foo(){\n           System.out.println(\"Child class foo!\");\n           super.foo();    //Calls foo method of Parent class inside the Overriden foo method of Child class.\n       }\n   }\n\npublic class DemoClass {\n    public static void main(String args[]) {\n     Child demoObject=new Child();\n     demoObject.foo();\n     /*\n      This would print - \n      Parent class parameterised constructor.\n      Child class default Constructor\n      Child class foo!\n      Parent class foo!\n     */\n    }\n} class Parent class Parent protected int 1 \"Parent class default constructor.\" \"Parent class parameterised constructor.\" public void foo() public void foo () \"Parent class foo!\" class Child extends Parent class Child extends Parent private int 2 //super constructor call should always be in the first line // super();              // Either call default super() to call default parent constructor OR super \"Call Parent\" // call parameterised super to call parameterised parent constructor. \"Child class default Constructor\" void printNum() void printNum () super //prints the value of num of parent class @Override public void foo() public void foo () \"Child class foo!\" super //Calls foo method of Parent class inside the Overriden foo method of Child class. public class DemoClass class DemoClass public static void main(String args[]) public static void main (String args[]) new /*\n      This would print - \n      Parent class parameterised constructor.\n      Child class default Constructor\n      Child class foo!\n      Parent class foo!\n     */",
        "reference": "interviewbit.com"
    },
    {
        "question": "23. Can the static methods be overloaded?",
        "answer": "Yes! There can be two or more static methods in a class with the same name but differing input parameters.",
        "reference": "interviewbit.com"
    },
    {
        "question": "24. Why is the main method static in Java?",
        "answer": "The main method is always static because static members are those methods that belong to the classes, not to an individual object. So if the main method will not be static then for every object, It is available. And that is not acceptable by JVM. JVM calls the main method based on the class name itself. Not by creating the object. Because there must be only 1 main method in the java program as the execution starts from the main method. So for this reason the main method is static.",
        "reference": "interviewbit.com"
    },
    {
        "question": "25. Can the static methods be overridden?",
        "answer": "No! Declaration of static methods having the same signature can be done in the subclass but run time polymorphism can not take place in such cases.\nOverriding or dynamic polymorphism occurs during the runtime, but the static methods are loaded and looked up at the compile time statically. Hence, these methods cant be overridden. No! Declaration of static methods having the same signature can be done in the subclass but run time polymorphism can not take place in such cases. Overriding or dynamic polymorphism occurs during the runtime, but the static methods are loaded and looked up at the compile time statically. Hence, these methods cant be overridden.",
        "reference": "interviewbit.com"
    },
    {
        "question": "26. Difference between static methods, static variables, and static classes in java.",
        "answer": "Static Methods and Static variables are those methods and variables that belong to the class of the java program, not to the object of the class. This gets memory where the class is loaded. And these can directly be called with the help of class names.\nFor example - We have used mathematical functions in the java program like - max(), min(), sqrt(), pow(), etc. And if we notice that, then we will find that we call it directly with the class name. Like - Math.max(), Math.min(), etc. So that is a static method.  And Similarly static variables we have used like (length) for the array to get the length. So that is the static method.\nStatic classes - A class in the java program cannot be static except if it is the inner class. If it is an inner static class, then it exactly works like other static members of the class. Static Methods and Static variables are those methods and variables that belong to the class of the java program, not to the object of the class. This gets memory where the class is loaded. And these can directly be called with the help of class names.\nFor example - We have used mathematical functions in the java program like - max(), min(), sqrt(), pow(), etc. And if we notice that, then we will find that we call it directly with the class name. Like - Math.max(), Math.min(), etc. So that is a static method.  And Similarly static variables we have used like (length) for the array to get the length. So that is the static method. Static Methods and Static variables For example - We have used mathematical functions in the java program like - max(), min(), sqrt(), pow(), etc. And if we notice that, then we will find that we call it directly with the class name. Like - Math.max(), Math.min(), etc. So that is a static method.  And Similarly static variables we have used like (length) for the array to get the length. So that is the static method. For example - We have used mathematical functions in the java program like - max(), min(), sqrt(), pow(), etc. And if we notice that, then we will find that we call it directly with the class name. Like - Math.max(), Math.min(), etc. So that is a static method.  And Similarly static variables we have used like (length) for the array to get the length. So that is the static method. Static classes - A class in the java program cannot be static except if it is the inner class. If it is an inner static class, then it exactly works like other static members of the class. Static classes",
        "reference": "interviewbit.com"
    },
    {
        "question": "27. What is the main objective of garbage collection?",
        "answer": "The main objective of this process is to free up the memory space occupied by the unnecessary and unreachable objects during the Java program execution by deleting those unreachable objects. This ensures that the memory resource is used efficiently, but it provides no guarantee that there would be sufficient memory for the program execution. This ensures that the memory resource is used efficiently, but it provides no guarantee that there would be sufficient memory for the program execution.",
        "reference": "interviewbit.com"
    },
    {
        "question": "28. What is a ClassLoader?",
        "answer": "Java Classloader is the program that belongs to JRE (Java Runtime Environment). The task of ClassLoader is to load the required classes and interfaces to the JVM when required. \nExample- To get input from the console, we require the scanner class. And the Scanner class is loaded by the ClassLoader. Java Classloader is the program that belongs to JRE (Java Runtime Environment). The task of ClassLoader is to load the required classes and interfaces to the JVM when required. Example- To get input from the console, we require the scanner class. And the Scanner class is loaded by the ClassLoader. Example-",
        "reference": "interviewbit.com"
    },
    {
        "question": "29. What part of memory - Stack or Heap - is cleaned in garbage collection process?",
        "answer": "Heap.",
        "reference": "interviewbit.com"
    },
    {
        "question": "30. What are shallow copy and deep copy in java?",
        "answer": "To copy the object's data, we have several methods like deep copy and shallow copy. Example - Example - class Rectangle{\nint length = 5;\n     int breadth = 3;\n} class Rectangle{\nint length = 5;\n     int breadth = 3;\n} class Rectangle class Rectangle int 5 int 3 Object for this Rectangle class - Rectangle obj1 = new Rectangle(); Rectangle obj1 = new Rectangle(); Shallow copy - The shallow copy only creates a new reference and points to the same object. Example - For Shallow copy, we can do this by - Shallow copy - The shallow copy only creates a new reference and points to the same object. Example - For Shallow copy, we can do this by - Shallow copy Rectangle obj2 = obj1; Rectangle obj2 = obj1; Now by doing this what will happen is the new reference is created with the name obj2 and that will point to the same memory location. Deep Copy - In a deep copy, we create a new object and copy the old object value to the new object. Example - Deep Copy - In a deep copy, we create a new object and copy the old object value to the new object. Example - Deep Copy Rectangle obj3 = new Rectangle();\nObj3.length = obj1.length;\nObj3.breadth = obj1.breadth; Rectangle obj3 = new Rectangle();\nObj3.length = obj1.length;\nObj3.breadth = obj1.breadth; new Both these objects will point to the memory location as stated below -   Now, if we change the values in shallow copy then they affect the other reference as well. Let's see with the help of an example - class Rectangle\n{\nint length = 5;\n   int breadth = 3;\n}\npublic class Main\n{\npublic static void main(String[] args) {\n Rectangle obj1 = new Rectangle();\n //Shallow Copy\n           Rectangle obj2 = obj1;\n      \n           System.out.println(\" Before Changing the value of object 1, the object2 will be - \");\n           System.out.println(\" Object2 Length = \"+obj2.length+\", Object2 Breadth = \"+obj2.breadth);\n       \n           //Changing the values for object1.\n           obj1.length = 10;\n           obj1.breadth = 20;\n       \n           System.out.println(\"\\n After Changing the value of object 1, the object2 will be - \");\n           System.out.println(\" Object2 Length = \"+obj2.length+\", Object2 Breadth = \"+obj2.breadth);\n       \n}\n} class Rectangle\n{\nint length = 5;\n   int breadth = 3;\n}\npublic class Main\n{\npublic static void main(String[] args) {\n Rectangle obj1 = new Rectangle();\n //Shallow Copy\n           Rectangle obj2 = obj1;\n      \n           System.out.println(\" Before Changing the value of object 1, the object2 will be - \");\n           System.out.println(\" Object2 Length = \"+obj2.length+\", Object2 Breadth = \"+obj2.breadth);\n       \n           //Changing the values for object1.\n           obj1.length = 10;\n           obj1.breadth = 20;\n       \n           System.out.println(\"\\n After Changing the value of object 1, the object2 will be - \");\n           System.out.println(\" Object2 Length = \"+obj2.length+\", Object2 Breadth = \"+obj2.breadth);\n       \n}\n} class Rectangle class Rectangle int 5 int 3 public class Main class Main public static void main(String[] args) public static void main (String[] args) new //Shallow Copy \" Before Changing the value of object 1, the object2 will be - \" \" Object2 Length = \" \", Object2 Breadth = \" //Changing the values for object1. 10 20 \"\\n After Changing the value of object 1, the object2 will be - \" \" Object2 Length = \" \", Object2 Breadth = \" Output - Before Changing the value of object 1, the object2 will be - \nObject2 Length = 5, Object2 Breadth = 3\n\nAfter Changing the value of object 1, the object2 will be - \nObject2 Length = 10, Object2 Breadth = 20 Before Changing the value of object 1, the object2 will be - \nObject2 Length = 5, Object2 Breadth = 3\n\nAfter Changing the value of object 1, the object2 will be - \nObject2 Length = 10, Object2 Breadth = 20 1 5 3 1 10 20 We can see that in the above code, if we change the values of object1, then the object2 values also get changed. It is because of the reference. Now, if we change the code to deep copy, then there will be no effect on object2 if it is of type deep copy. Consider some snippets to be added in the above code. class Rectangle\n{\n   int length = 5;\n   int breadth = 3;\n}\npublic class Main\n{\npublic static void main(String[] args) {\n Rectangle obj1 = new Rectangle();\n //Shallow Copy\n           Rectangle obj2 = new Rectangle();\n           obj2.length = obj1.length;\n           obj2.breadth = obj1.breadth;\n      \n           System.out.println(\" Before Changing the value of object 1, the object2 will be - \");\n           System.out.println(\" Object2 Length = \"+obj2.length+\", Object2 Breadth = \"+obj2.breadth);\n       \n           //Changing the values for object1.\n           obj1.length = 10;\n           obj1.breadth = 20;\n       \n           System.out.println(\"\\n After Changing the value of object 1, the object2 will be - \");\n           System.out.println(\" Object2 Length = \"+obj2.length+\", Object2 Breadth = \"+obj2.breadth);\n       \n}\n} class Rectangle\n{\n   int length = 5;\n   int breadth = 3;\n}\npublic class Main\n{\npublic static void main(String[] args) {\n Rectangle obj1 = new Rectangle();\n //Shallow Copy\n           Rectangle obj2 = new Rectangle();\n           obj2.length = obj1.length;\n           obj2.breadth = obj1.breadth;\n      \n           System.out.println(\" Before Changing the value of object 1, the object2 will be - \");\n           System.out.println(\" Object2 Length = \"+obj2.length+\", Object2 Breadth = \"+obj2.breadth);\n       \n           //Changing the values for object1.\n           obj1.length = 10;\n           obj1.breadth = 20;\n       \n           System.out.println(\"\\n After Changing the value of object 1, the object2 will be - \");\n           System.out.println(\" Object2 Length = \"+obj2.length+\", Object2 Breadth = \"+obj2.breadth);\n       \n}\n} class Rectangle class Rectangle int 5 int 3 public class Main class Main public static void main(String[] args) public static void main (String[] args) new //Shallow Copy new \" Before Changing the value of object 1, the object2 will be - \" \" Object2 Length = \" \", Object2 Breadth = \" //Changing the values for object1. 10 20 \"\\n After Changing the value of object 1, the object2 will be - \" \" Object2 Length = \" \", Object2 Breadth = \" The above snippet will not affect the object2 values. It has its separate values. The output will be Before Changing the value of object 1, the object2 will be - \nObject2 Length = 5, Object2 Breadth = 3\n\nAfter Changing the value of object 1, the object2 will be - \nObject2 Length = 5, Object2 Breadth = 3 Before Changing the value of object 1, the object2 will be - \nObject2 Length = 5, Object2 Breadth = 3\n\nAfter Changing the value of object 1, the object2 will be - \nObject2 Length = 5, Object2 Breadth = 3 1 5 3 1 5 3 Now we see that we need to write the number of codes for this deep copy. So to reduce this, In java, there is a method called clone(). clone(). The clone() will do this deep copy internally and return a new object. And to do this we need to write only 1 line of code. That is - Rectangle obj2 = obj1.clone(); clone() Rectangle obj2 = obj1.clone();",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Apart from the security aspect, what are the reasons behind making strings immutable in Java?",
        "answer": "A String is made immutable due to the following reasons: String Pool: Designers of Java were aware of the fact that String data type is going to be majorly used by the programmers and developers. Thus, they wanted optimization from the beginning. They came up with the notion of using the String pool (a storage area in Java heap) to store the String literals. They intended to decrease the temporary String object with the help of sharing. An immutable class is needed to facilitate sharing. The sharing of the mutable structures between two unknown parties is not possible. Thus, immutable Java String helps in executing the concept of String Pool. String Pool: Designers of Java were aware of the fact that String data type is going to be majorly used by the programmers and developers. Thus, they wanted optimization from the beginning. They came up with the notion of using the String pool (a storage area in Java heap) to store the String literals. They intended to decrease the temporary String object with the help of sharing. An immutable class is needed to facilitate sharing. The sharing of the mutable structures between two unknown parties is not possible. Thus, immutable Java String helps in executing the concept of String Pool. String Pool:   Multithreading: The safety of threads regarding the String objects is an important aspect in Java. No external synchronization is required if the String objects are immutable. Thus, a cleaner code can be written for sharing the String objects across different threads. The complex process of concurrency is facilitated by this method.\nCollections: In the case of Hashtables and HashMaps, keys are String objects. If the String objects are not immutable, then it can get modified during the period when it resides in the HashMaps. Consequently, the retrieval of the desired data is not possible. Such changing states pose a lot of risks. Therefore, it is quite safe to make the string immutable. Multithreading: The safety of threads regarding the String objects is an important aspect in Java. No external synchronization is required if the String objects are immutable. Thus, a cleaner code can be written for sharing the String objects across different threads. The complex process of concurrency is facilitated by this method. Multithreading Multithreading : Collections: In the case of Hashtables and HashMaps, keys are String objects. If the String objects are not immutable, then it can get modified during the period when it resides in the HashMaps. Consequently, the retrieval of the desired data is not possible. Such changing states pose a lot of risks. Therefore, it is quite safe to make the string immutable. Collections Collections :",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What is a singleton class in Java? And How to implement a singleton class?",
        "answer": "Singleton classes are those classes, whose objects are created only once. And with only that object the class members can be accessed. Understand this with the help of an example-: Understand this with the help of an example-: Consider the water jug in the office and if every employee wants that water then they will not create a new water jug for drinking water. They will use the existing one with their own reference as a glass. So programmatically it should be implemented as - class WaterJug{\n   private int waterQuantity = 500;\n   private WaterJug(){}\n   private WaterJug object = null;\n   \n   // Method to provide the service of Giving Water.\n   public int getWater(int quantity){\n       waterQuantity -= quantity;\n       return quantity;\n   }\n   // Method to return the object to the user.\n   public static Waterjug getInstance(){\n       // Will Create a new object if the object is not already created and return the object.\n       if(object == null){\n           object = new WaterJug();\n       }\n       return object;\n   }\n} class WaterJug{\n   private int waterQuantity = 500;\n   private WaterJug(){}\n   private WaterJug object = null;\n   \n   // Method to provide the service of Giving Water.\n   public int getWater(int quantity){\n       waterQuantity -= quantity;\n       return quantity;\n   }\n   // Method to return the object to the user.\n   public static Waterjug getInstance(){\n       // Will Create a new object if the object is not already created and return the object.\n       if(object == null){\n           object = new WaterJug();\n       }\n       return object;\n   }\n} class WaterJug class WaterJug private int 500 private WaterJug() private WaterJug () private null // Method to provide the service of Giving Water. public int getWater(int quantity) public int getWater (int quantity) int return // Method to return the object to the user. public static Waterjug getInstance() public static getInstance () // Will Create a new object if the object is not already created and return the object. if null new return In the above class, the Constructor is private so we cannot create the object of the class. But we can get the object by calling the method getInstance(). And the getInstance is static so it can be called without creating the object. And it returns the object. Now with that object, we can call getWater() to get the water. getInstance() getWater() Waterjug glass1 = WaterJug.getInstance();\nglass1.getWater(1); Waterjug glass1 = WaterJug.getInstance();\nglass1.getWater(1); 1 We can get the single object using this getInstance(). And it is static, so it is a thread-safe singleton class. Although there are many ways to create a thread-safe singleton class. So thread-safe classes can also be: When singletons are written with double-checked locking, they can be thread-safe.\nWe can use static singletons that are initialized during class loading. Like we did in the above example.\nBut the most straightforward way to create a thread-safe singleton is to use Java enums. When singletons are written with double-checked locking, they can be thread-safe. We can use static singletons that are initialized during class loading. Like we did in the above example. But the most straightforward way to create a thread-safe singleton is to use Java enums.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Which of the below generates a compile-time error? State the reason.",
        "answer": "int[] n1 = new int[0];\nboolean[] n2 = new boolean[-200];\ndouble[] n3 = new double[2241423798];\nchar[] ch = new char[20]; int[] n1 = new int[0]; int[] n1 = new int[0]; boolean[] n2 = new boolean[-200]; boolean[] n2 = new boolean[-200]; double[] n3 = new double[2241423798]; double[] n3 = new double[2241423798]; char[] ch = new char[20]; char[] ch = new char[20]; We get a compile-time error in line 3. The error we will get in Line 3 is - integer number too large. It is because the array requires size as an integer. And Integer takes 4 Bytes in the memory. And the number (2241423798) is beyond the capacity of the integer. The maximum array size we can declare is - (2147483647). integer number too large 2241423798 2147483647 Because the array requires the size in integer, none of the lines (1, 2, and 4) will give a compile-time error. The program will compile fine. But we get the runtime exception in line 2. The exception is - NegativeArraySizeException. NegativeArraySizeException Here what will happen is - At the time when JVM will allocate the required memory during runtime then it will find that the size is negative. And the array size can\u2019t be negative. So the JVM will throw the exception.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. How would you differentiate between a String, StringBuffer, and a StringBuilder?",
        "answer": "Storage area: In string, the String pool serves as the storage area. For StringBuilder and StringBuffer, heap memory is the storage area.\nMutability: A String is immutable, whereas both the StringBuilder and StringBuffer are mutable.\nEfficiency: It is quite slow to work with a String. However, StringBuilder is the fastest in performing operations. The speed of a StringBuffer is more than a String and less than a StringBuilder. (For example appending a character is fastest in StringBuilder and very slow in String because a new memory is required for the new String with appended character.)\nThread-safe: In the case of a threaded environment, StringBuilder and StringBuffer are used whereas a String is not used. However, StringBuilder is suitable for an environment with a single thread, and a StringBuffer is suitable for multiple threads.\nSyntax: Storage area: In string, the String pool serves as the storage area. For StringBuilder and StringBuffer, heap memory is the storage area. Storage area: Mutability: A String is immutable, whereas both the StringBuilder and StringBuffer are mutable. Mutability: Efficiency: It is quite slow to work with a String. However, StringBuilder is the fastest in performing operations. The speed of a StringBuffer is more than a String and less than a StringBuilder. (For example appending a character is fastest in StringBuilder and very slow in String because a new memory is required for the new String with appended character.) Efficiency: Thread-safe: In the case of a threaded environment, StringBuilder and StringBuffer are used whereas a String is not used. However, StringBuilder is suitable for an environment with a single thread, and a StringBuffer is suitable for multiple threads.\nSyntax: Thread-safe:  Syntax: // String\nString first = \"InterviewBit\";\nString second = new String(\"InterviewBit\");\n// StringBuffer\nStringBuffer third = new StringBuffer(\"InterviewBit\");\n// StringBuilder\nStringBuilder fourth = new StringBuilder(\"InterviewBit\"); // String\nString first = \"InterviewBit\";\nString second = new String(\"InterviewBit\");\n// StringBuffer\nStringBuffer third = new StringBuffer(\"InterviewBit\");\n// StringBuilder\nStringBuilder fourth = new StringBuilder(\"InterviewBit\"); // String \"InterviewBit\" new \"InterviewBit\" // StringBuffer new \"InterviewBit\" // StringBuilder new \"InterviewBit\"",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Using relevant properties highlight the differences between interfaces and abstract classes.",
        "answer": "Availability of methods: Only abstract methods are available in interfaces, whereas non-abstract methods can be present along with abstract methods in abstract classes.\nVariable types: Static and final variables can only be declared in the case of interfaces, whereas abstract classes can also have non-static and non-final variables.\nInheritance: Multiple inheritances are facilitated by interfaces, whereas abstract classes do not promote multiple inheritances.\nData member accessibility: By default, the class data members of interfaces are of the public- type. Conversely, the class members for an abstract class can be protected or private also.\nImplementation: With the help of an abstract class, the implementation of an interface is easily possible. However, the converse is not true; Availability of methods: Only abstract methods are available in interfaces, whereas non-abstract methods can be present along with abstract methods in abstract classes. Availability of methods: Variable types: Static and final variables can only be declared in the case of interfaces, whereas abstract classes can also have non-static and non-final variables. Variable types Inheritance: Multiple inheritances are facilitated by interfaces, whereas abstract classes do not promote multiple inheritances. Inheritance: Data member accessibility: By default, the class data members of interfaces are of the public- type. Conversely, the class members for an abstract class can be protected or private also. Data member accessibility: Implementation: With the help of an abstract class, the implementation of an interface is easily possible. However, the converse is not true; Implementation: Abstract class example: Abstract class example: public abstract class Athlete {\npublic abstract void walk();\n} public abstract class Athlete {\npublic abstract void walk();\n} public abstract class Athlete class Athlete public abstract void walk() public abstract void walk () Interface example: Interface example: public interface Walkable {\nvoid walk();\n} public interface Walkable {\nvoid walk();\n} public interface Walkable interface Walkable void walk() void walk ()",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Is this program giving a compile-time error? If Yes then state the reason and number of errors it will give. If not then state the reason.",
        "answer": "abstract final class InterviewBit{\n2.    public abstract void printMessage();\n3. }\n4. class ScalarAcademy extends InterviewBit{\n5.    public void printMessage(){\n6.        System.out.println(\"Welcome to Scalar Academy By InterviewBit\");\n7.    }\n8. }\n9. class ScalarTopics extends ScalarAcademy{\n10.    public void printMessage(){\n11.        System.out.println(\"Welcome to Scalar Topics By Scalar Academy\");\n12.    }\n13. }\npublic class Main{\n public static void main(String[] args) {\n      InterviewBit ib = new ScalarTopics();\n      ib.printMessage();\n }\n} abstract final class InterviewBit{\n2.    public abstract void printMessage();\n3. }\n4. class ScalarAcademy extends InterviewBit{\n5.    public void printMessage(){\n6.        System.out.println(\"Welcome to Scalar Academy By InterviewBit\");\n7.    }\n8. }\n9. class ScalarTopics extends ScalarAcademy{\n10.    public void printMessage(){\n11.        System.out.println(\"Welcome to Scalar Topics By Scalar Academy\");\n12.    }\n13. }\npublic class Main{\n public static void main(String[] args) {\n      InterviewBit ib = new ScalarTopics();\n      ib.printMessage();\n }\n} abstract final class InterviewBit class InterviewBit 2. public abstract void printMessage() public abstract void printMessage () 3. 4. class ScalarAcademy extends InterviewBit class ScalarAcademy extends InterviewBit 5. public void printMessage() public void printMessage () 6. \"Welcome to Scalar Academy By InterviewBit\" 7. 8. 9. class ScalarTopics extends ScalarAcademy class ScalarTopics extends ScalarAcademy 10. public void printMessage() public void printMessage () 11. \"Welcome to Scalar Topics By Scalar Academy\" 12. 13. public class Main class Main public static void main(String[] args) public static void main (String[] args) new The above program will give a compile-time error. The compiler will throw 2 errors in this. [Illegal Combination of modifiers: abstract and final] at line 1.\n[Cannot inherit from final \u2018InterviewBit\u2019] at line 4. [Illegal Combination of modifiers: abstract and final] at line 1. [Illegal Combination of modifiers: abstract and final] [Cannot inherit from final \u2018InterviewBit\u2019] at line 4. [Cannot inherit from final \u2018InterviewBit\u2019] It is because abstract classes are incomplete classes that need to be inherited for making their concrete classes. And on the other hand, the final keywords in class are used for avoiding inheritance. So these combinations are not allowed in java.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What is a Comparator in java?",
        "answer": "Consider the example where we have an ArrayList of employees like( EId, Ename, Salary), etc. Now if we want to sort this list of employees based on the names of employees. Then that is not possible to sort using the Collections.sort() method. We need to provide something to the sort() function depending on what values we have to perform sorting. Then in that case a comparator is used. Comparator is the interface in java that contains the compare method. And by overloading the compare method, we can define that on what basis we need to compare the values.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. In Java, static as well as private method overriding is possible. Comment on the statement.",
        "answer": "The statement in the context is completely False. The static methods have no relevance with the objects, and these methods are of the class level. In the case of a child class, a static method with a method signature exactly like that of the parent class can exist without even throwing any compilation error. The phenomenon mentioned here is popularly known as method hiding, and overriding is certainly not possible. Private method overriding is unimaginable because the visibility of the private method is restricted to the parent class only. As a result, only hiding can be facilitated and not overriding.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What makes a HashSet different from a TreeSet?",
        "answer": "Although both HashSet and TreeSet are not synchronized and ensure that duplicates are not present, there are certain properties that distinguish a HashSet from a TreeSet. Implementation: For a HashSet, the hash table is utilized for storing the elements in an unordered manner. However, TreeSet makes use of the red-black tree to store the elements in a sorted manner.\nComplexity/ Performance: For adding, retrieving, and deleting elements, the time amortized complexity is O(1) for a HashSet. The time complexity for performing the same operations is a bit higher for TreeSet and is equal to O(log n). Overall, the performance of HashSet is faster in comparison to TreeSet.\nMethods: hashCode() and equals() are the methods utilized by HashSet for making comparisons between the objects. Conversely, compareTo() and compare() methods are utilized by TreeSet to facilitate object comparisons.\nObjects type: Heterogeneous and null objects can be stored with the help of HashSet. In the case of a TreeSet, runtime exception occurs while inserting heterogeneous objects or null objects. Implementation: For a HashSet, the hash table is utilized for storing the elements in an unordered manner. However, TreeSet makes use of the red-black tree to store the elements in a sorted manner. Implementation: Complexity/ Performance: For adding, retrieving, and deleting elements, the time amortized complexity is O(1) for a HashSet. The time complexity for performing the same operations is a bit higher for TreeSet and is equal to O(log n). Overall, the performance of HashSet is faster in comparison to TreeSet. Complexity/ Performance: Methods: hashCode() and equals() are the methods utilized by HashSet for making comparisons between the objects. Conversely, compareTo() and compare() methods are utilized by TreeSet to facilitate object comparisons. Methods: Objects type: Heterogeneous and null objects can be stored with the help of HashSet. In the case of a TreeSet, runtime exception occurs while inserting heterogeneous objects or null objects. Objects type:",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Why is the character array preferred over string for storing confidential information?",
        "answer": "In Java, a string is basically immutable i.e. it cannot be modified. After its declaration, it continues to stay in the string pool as long as it is not removed in the form of garbage. In other words, a string resides in the heap section of the memory for an unregulated and unspecified time interval after string value processing is executed. As a result, vital information can be stolen for pursuing harmful activities by hackers if a memory dump is illegally accessed by them. Such risks can be eliminated by using mutable objects or structures like character arrays for storing any variable. After the work of the character array variable is done, the variable can be configured to blank at the same instant. Consequently, it helps in saving heap memory and also gives no chance to the hackers to extract vital data.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. What do we get in the JDK file?",
        "answer": "JDK- For making java programs, we need some tools that are provided by JDK (Java Development Kit). JDK is the package that contains various tools, Compiler, Java Runtime Environment, etc.\nJRE -  To execute the java program we need an environment. (Java Runtime Environment) JRE contains a library of Java classes +  JVM. What are JAVA Classes?  It contains some predefined methods that help Java programs to use that feature, build and execute. For example - there is a system class in java that contains the print-stream method, and with the help of this, we can print something on the console.\nJVM - (Java Virtual Machine) JVM  is a part of JRE that executes the Java program at the end.  Actually, it is part of JRE, but it is software that converts bytecode into machine-executable code to execute on hardware. JDK- For making java programs, we need some tools that are provided by JDK (Java Development Kit). JDK is the package that contains various tools, Compiler, Java Runtime Environment, etc. JDK JRE -  To execute the java program we need an environment. (Java Runtime Environment) JRE contains a library of Java classes +  JVM. What are JAVA Classes?  It contains some predefined methods that help Java programs to use that feature, build and execute. For example - there is a system class in java that contains the print-stream method, and with the help of this, we can print something on the console. JRE What are JAVA Classes? For example For example JVM - (Java Virtual Machine) JVM  is a part of JRE that executes the Java program at the end.  Actually, it is part of JRE, but it is software that converts bytecode into machine-executable code to execute on hardware. JVM  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What are the differences between JVM, JRE and JDK in Java?",
        "answer": "Criteria JDK  JRE JVM\nAbbreviation Java Development Kit Java Runtime Environment Java Virtual Machine\nDefinition JDK is a complete software development kit for developing Java applications. It comprises JRE, JavaDoc, compiler, debuggers, etc. JRE is a software package providing Java class libraries, JVM and all the required components to run the Java applications. JVM is a platform-dependent, abstract machine comprising of 3 specifications - document describing the JVM implementation requirements, computer program meeting the JVM requirements and instance object for executing the Java byte code and provide the runtime environment for execution.\nMain Purpose JDK is mainly used for code development and execution. JRE is mainly used for environment creation to execute the code. JVM provides specifications for all the implementations to JRE.\nTools provided JDK provides tools like compiler, debuggers, etc for code development JRE provides libraries and classes required by JVM to run the program. JVM does not include any tools, but instead, it provides the specification for implementation.\nSummary JDK = (JRE) + Development tools JRE = (JVM) + Libraries to execute the application JVM = Runtime environment to execute Java byte code. Criteria JDK  JRE JVM\nAbbreviation Java Development Kit Java Runtime Environment Java Virtual Machine\nDefinition JDK is a complete software development kit for developing Java applications. It comprises JRE, JavaDoc, compiler, debuggers, etc. JRE is a software package providing Java class libraries, JVM and all the required components to run the Java applications. JVM is a platform-dependent, abstract machine comprising of 3 specifications - document describing the JVM implementation requirements, computer program meeting the JVM requirements and instance object for executing the Java byte code and provide the runtime environment for execution.\nMain Purpose JDK is mainly used for code development and execution. JRE is mainly used for environment creation to execute the code. JVM provides specifications for all the implementations to JRE.\nTools provided JDK provides tools like compiler, debuggers, etc for code development JRE provides libraries and classes required by JVM to run the program. JVM does not include any tools, but instead, it provides the specification for implementation.\nSummary JDK = (JRE) + Development tools JRE = (JVM) + Libraries to execute the application JVM = Runtime environment to execute Java byte code. Criteria JDK  JRE JVM Criteria JDK  JRE JVM Criteria JDK JRE JVM Abbreviation Java Development Kit Java Runtime Environment Java Virtual Machine\nDefinition JDK is a complete software development kit for developing Java applications. It comprises JRE, JavaDoc, compiler, debuggers, etc. JRE is a software package providing Java class libraries, JVM and all the required components to run the Java applications. JVM is a platform-dependent, abstract machine comprising of 3 specifications - document describing the JVM implementation requirements, computer program meeting the JVM requirements and instance object for executing the Java byte code and provide the runtime environment for execution.\nMain Purpose JDK is mainly used for code development and execution. JRE is mainly used for environment creation to execute the code. JVM provides specifications for all the implementations to JRE.\nTools provided JDK provides tools like compiler, debuggers, etc for code development JRE provides libraries and classes required by JVM to run the program. JVM does not include any tools, but instead, it provides the specification for implementation.\nSummary JDK = (JRE) + Development tools JRE = (JVM) + Libraries to execute the application JVM = Runtime environment to execute Java byte code. Abbreviation Java Development Kit Java Runtime Environment Java Virtual Machine Abbreviation Java Development Kit Java Runtime Environment Java Virtual Machine Definition JDK is a complete software development kit for developing Java applications. It comprises JRE, JavaDoc, compiler, debuggers, etc. JRE is a software package providing Java class libraries, JVM and all the required components to run the Java applications. JVM is a platform-dependent, abstract machine comprising of 3 specifications - document describing the JVM implementation requirements, computer program meeting the JVM requirements and instance object for executing the Java byte code and provide the runtime environment for execution. Definition JDK is a complete software development kit for developing Java applications. It comprises JRE, JavaDoc, compiler, debuggers, etc. JRE is a software package providing Java class libraries, JVM and all the required components to run the Java applications. JVM is a platform-dependent, abstract machine comprising of 3 specifications - document describing the JVM implementation requirements, computer program meeting the JVM requirements and instance object for executing the Java byte code and provide the runtime environment for execution. Main Purpose JDK is mainly used for code development and execution. JRE is mainly used for environment creation to execute the code. JVM provides specifications for all the implementations to JRE. Main Purpose JDK is mainly used for code development and execution. JRE is mainly used for environment creation to execute the code. JVM provides specifications for all the implementations to JRE. Tools provided JDK provides tools like compiler, debuggers, etc for code development JRE provides libraries and classes required by JVM to run the program. JVM does not include any tools, but instead, it provides the specification for implementation. Tools provided JDK provides tools like compiler, debuggers, etc for code development JRE provides libraries and classes required by JVM to run the program. JVM does not include any tools, but instead, it provides the specification for implementation. Summary JDK = (JRE) + Development tools JRE = (JVM) + Libraries to execute the application JVM = Runtime environment to execute Java byte code. Summary JDK = (JRE) + Development tools JRE = (JVM) + Libraries to execute the application JVM = Runtime environment to execute Java byte code.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What are the differences between HashMap and HashTable in Java?",
        "answer": "HashMap HashTable\nHashMap is not synchronized thereby making it better for non-threaded applications. HashTable is synchronized and hence it is suitable for threaded applications.\nAllows only one null key but any number of null in the values. This does not allow null in both keys or values.\nSupports order of insertion by making use of its subclass LinkedHashMap. Order of insertion is not guaranteed in HashTable. HashMap HashTable\nHashMap is not synchronized thereby making it better for non-threaded applications. HashTable is synchronized and hence it is suitable for threaded applications.\nAllows only one null key but any number of null in the values. This does not allow null in both keys or values.\nSupports order of insertion by making use of its subclass LinkedHashMap. Order of insertion is not guaranteed in HashTable. HashMap HashTable HashMap HashTable HashMap HashTable HashMap is not synchronized thereby making it better for non-threaded applications. HashTable is synchronized and hence it is suitable for threaded applications.\nAllows only one null key but any number of null in the values. This does not allow null in both keys or values.\nSupports order of insertion by making use of its subclass LinkedHashMap. Order of insertion is not guaranteed in HashTable. HashMap is not synchronized thereby making it better for non-threaded applications. HashTable is synchronized and hence it is suitable for threaded applications. HashMap is not synchronized thereby making it better for non-threaded applications. HashTable is synchronized and hence it is suitable for threaded applications. Allows only one null key but any number of null in the values. This does not allow null in both keys or values. Allows only one null key but any number of null in the values. This does not allow null in both keys or values. Supports order of insertion by making use of its subclass LinkedHashMap. Order of insertion is not guaranteed in HashTable. Supports order of insertion by making use of its subclass LinkedHashMap. Order of insertion is not guaranteed in HashTable.",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. What is the importance of reflection in Java?",
        "answer": "The term reflection is used for describing the inspection capability of a code on other code either of itself or of its system and modify it during runtime.\nConsider an example where we have an object of unknown type and we have a method \u2018fooBar()\u2019 which we need to call on the object. The static typing system of Java doesn't allow this method invocation unless the type of the object is known beforehand. This can be achieved using reflection which allows the code to scan the object and identify if it has any method called \u201cfooBar()\u201d and only then call the method if needed. The term reflection is used for describing the inspection capability of a code on other code either of itself or of its system and modify it during runtime. reflection Consider an example where we have an object of unknown type and we have a method \u2018fooBar()\u2019 which we need to call on the object. The static typing system of Java doesn't allow this method invocation unless the type of the object is known beforehand. This can be achieved using reflection which allows the code to scan the object and identify if it has any method called \u201cfooBar()\u201d and only then call the method if needed. Method methodOfFoo = fooObject.getClass().getMethod(\"fooBar\", null);\nmethodOfFoo.invoke(fooObject, null); Method methodOfFoo = fooObject.getClass().getMethod(\"fooBar\", null);\nmethodOfFoo.invoke(fooObject, null); \"fooBar\" null null Using reflection has its own cons:\nSpeed \u2014 Method invocations due to reflection are about three times slower than the direct method calls.\nType safety \u2014 When a method is invoked via its reference wrongly using reflection, invocation fails at runtime as it is not detected at compile/load time.\nTraceability \u2014 Whenever a reflective method fails, it is very difficult to find the root cause of this failure due to a huge stack trace. One has to deep dive into the invoke() and proxy() method logs to identify the root cause.\nHence, it is advisable to follow solutions that don't involve reflection and use this method as a last resort. Using reflection has its own cons:\nSpeed \u2014 Method invocations due to reflection are about three times slower than the direct method calls.\nType safety \u2014 When a method is invoked via its reference wrongly using reflection, invocation fails at runtime as it is not detected at compile/load time.\nTraceability \u2014 Whenever a reflective method fails, it is very difficult to find the root cause of this failure due to a huge stack trace. One has to deep dive into the invoke() and proxy() method logs to identify the root cause. Speed \u2014 Method invocations due to reflection are about three times slower than the direct method calls.\nType safety \u2014 When a method is invoked via its reference wrongly using reflection, invocation fails at runtime as it is not detected at compile/load time.\nTraceability \u2014 Whenever a reflective method fails, it is very difficult to find the root cause of this failure due to a huge stack trace. One has to deep dive into the invoke() and proxy() method logs to identify the root cause. Speed \u2014 Method invocations due to reflection are about three times slower than the direct method calls. Type safety \u2014 When a method is invoked via its reference wrongly using reflection, invocation fails at runtime as it is not detected at compile/load time. Traceability \u2014 Whenever a reflective method fails, it is very difficult to find the root cause of this failure due to a huge stack trace. One has to deep dive into the invoke() and proxy() method logs to identify the root cause. Hence, it is advisable to follow solutions that don't involve reflection and use this method as a last resort.",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What are the different ways of threads usage?",
        "answer": "We can define and implement a thread in java using two ways:\nExtending the Thread class We can define and implement a thread in java using two ways:\nExtending the Thread class Extending the Thread class Extending the Thread class Extending the Thread class class InterviewBitThreadExample extends Thread{  \n   public void run(){  \n       System.out.println(\"Thread runs...\");  \n   }  \n   public static void main(String args[]){  \n       InterviewBitThreadExample ib = new InterviewBitThreadExample();  \n       ib.start();  \n   }  \n} class InterviewBitThreadExample extends Thread{  \n   public void run(){  \n       System.out.println(\"Thread runs...\");  \n   }  \n   public static void main(String args[]){  \n       InterviewBitThreadExample ib = new InterviewBitThreadExample();  \n       ib.start();  \n   }  \n} class InterviewBitThreadExample extends Thread class InterviewBitThreadExample extends Thread public void run() public void run () \"Thread runs...\" public static void main(String args[]) public static void main (String args[]) new Implementing the Runnable interface Implementing the Runnable interface Implementing the Runnable interface class InterviewBitThreadExample implements Runnable{  \n   public void run(){  \n       System.out.println(\"Thread runs...\");  \n   }  \n   public static void main(String args[]){  \n       Thread ib = new Thread(new InterviewBitThreadExample()); \n       ib.start();  \n   }  \n} class InterviewBitThreadExample implements Runnable{  \n   public void run(){  \n       System.out.println(\"Thread runs...\");  \n   }  \n   public static void main(String args[]){  \n       Thread ib = new Thread(new InterviewBitThreadExample()); \n       ib.start();  \n   }  \n} class InterviewBitThreadExample implements Runnable class InterviewBitThreadExample implements Runnable public void run() public void run () \"Thread runs...\" public static void main(String args[]) public static void main (String args[]) new new Implementing a thread using the method of Runnable interface is more preferred and advantageous as Java does not have support for multiple inheritances of classes.\nstart() method is used for creating a separate call stack for the thread execution. Once the call stack is created, JVM calls the run() method for executing the thread in that call stack. Implementing a thread using the method of Runnable interface is more preferred and advantageous as Java does not have support for multiple inheritances of classes. start() method is used for creating a separate call stack for the thread execution. Once the call stack is created, JVM calls the run() method for executing the thread in that call stack. start() run()",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. What are the different types of Thread Priorities in Java? And what is the default priority of a thread assigned by JVM?",
        "answer": "There are a total of 3 different types of priority available in Java. MIN_PRIORITY: It has an integer value assigned with 1.\nMAX_PRIORITY: It has an integer value assigned with 10.\nNORM_PRIORITY: It has an integer value assigned with 5. MIN_PRIORITY:  MAX_PRIORITY:  NORM_PRIORITY: In Java, Thread with MAX_PRIORITY gets the first chance to execute. But the default priority for any thread is NORM_PRIORITY assigned by JVM.",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. What is the difference between the program and the process?",
        "answer": "A program can be defined as a line of code written in order to accomplish a particular task. Whereas the process can be defined as the programs which are under execution. \nA program doesn't execute directly by the CPU. First, the resources are allocated to the program and when it is ready for execution then it is a process. A program can be defined as a line of code written in order to accomplish a particular task. Whereas the process can be defined as the programs which are under execution. A program doesn't execute directly by the CPU. First, the resources are allocated to the program and when it is ready for execution then it is a process.",
        "reference": "interviewbit.com"
    },
    {
        "question": "18. What is the difference between the \u2018throw\u2019 and \u2018throws\u2019 keyword in java?",
        "answer": "The \u2018throw\u2019 keyword is used to manually throw the exception to the calling method.\nAnd the \u2018throws\u2019 keyword is used in the function definition to inform the calling method that this method throws the exception. So if you are calling, then you have to handle the exception. The \u2018throw\u2019 keyword is used to manually throw the exception to the calling method. throw And the \u2018throws\u2019 keyword is used in the function definition to inform the calling method that this method throws the exception. So if you are calling, then you have to handle the exception. throws Example - Example - class Main {\n   public static int testExceptionDivide(int a, int b) throws ArithmeticException{\n       if(a == 0 || b == 0)\n           throw new ArithmeticException();\n       return a/b;\n   }\n   public static void main(String args[]) {\n       try{\n           testExceptionDivide(10, 0);\n       }\n       catch(ArithmeticException e){\n           //Handle the exception\n       }\n   }\n} class Main {\n   public static int testExceptionDivide(int a, int b) throws ArithmeticException{\n       if(a == 0 || b == 0)\n           throw new ArithmeticException();\n       return a/b;\n   }\n   public static void main(String args[]) {\n       try{\n           testExceptionDivide(10, 0);\n       }\n       catch(ArithmeticException e){\n           //Handle the exception\n       }\n   }\n} class Main class Main public static int testExceptionDivide(int a, int b) throws ArithmeticException public static int testExceptionDivide (int a, int b) int int throws if 0 0 throw new return public static void main(String args[]) public static void main (String args[]) try 10 0 catch //Handle the exception Here in the above snippet, the method testExceptionDivide throws an exception. So if the main method is calling it then it must have handled the exception. Otherwise, the main method can also throw the exception to JVM. And the method testExceptionDivide 'throws\u2019 the exception based on the condition.",
        "reference": "interviewbit.com"
    },
    {
        "question": "19. What are the differences between constructor and method of a class in Java?",
        "answer": "Constructor Method\nConstructor is used for initializing the object state. Method is used for exposing the object's behavior.\nConstructor has no return type. Method should have a return type. Even if it does not return anything, return type is void.\nConstructor gets invoked implicitly. Method has to be invoked on the object explicitly.\nIf the constructor is not defined, then a default constructor is provided by the java compiler. If a method is not defined, then the compiler does not provide it.\nThe constructor name should be equal to the class name. The name of the method can have any name or have a class name too.\nA constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn't make sense. Java throws compilation error saying - modifier final not allowed here A method can be defined as final but it cannot be overridden in its subclasses.\nFinal variable instantiations are possible inside a constructor and the scope of this applies to the whole class and its objects. A final variable if initialised inside a method ensures that the variable cant be changed only within the scope of that method. Constructor Method\nConstructor is used for initializing the object state. Method is used for exposing the object's behavior.\nConstructor has no return type. Method should have a return type. Even if it does not return anything, return type is void.\nConstructor gets invoked implicitly. Method has to be invoked on the object explicitly.\nIf the constructor is not defined, then a default constructor is provided by the java compiler. If a method is not defined, then the compiler does not provide it.\nThe constructor name should be equal to the class name. The name of the method can have any name or have a class name too.\nA constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn't make sense. Java throws compilation error saying - modifier final not allowed here A method can be defined as final but it cannot be overridden in its subclasses.\nFinal variable instantiations are possible inside a constructor and the scope of this applies to the whole class and its objects. A final variable if initialised inside a method ensures that the variable cant be changed only within the scope of that method. Constructor Method Constructor Method Constructor Method Constructor is used for initializing the object state. Method is used for exposing the object's behavior.\nConstructor has no return type. Method should have a return type. Even if it does not return anything, return type is void.\nConstructor gets invoked implicitly. Method has to be invoked on the object explicitly.\nIf the constructor is not defined, then a default constructor is provided by the java compiler. If a method is not defined, then the compiler does not provide it.\nThe constructor name should be equal to the class name. The name of the method can have any name or have a class name too.\nA constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn't make sense. Java throws compilation error saying - modifier final not allowed here A method can be defined as final but it cannot be overridden in its subclasses.\nFinal variable instantiations are possible inside a constructor and the scope of this applies to the whole class and its objects. A final variable if initialised inside a method ensures that the variable cant be changed only within the scope of that method. Constructor is used for initializing the object state. Method is used for exposing the object's behavior. Constructor is used for initializing the object state. Method is used for exposing the object's behavior. Constructor has no return type. Method should have a return type. Even if it does not return anything, return type is void. Constructor has no return type. Method should have a return type. Even if it does not return anything, return type is void. Constructor gets invoked implicitly. Method has to be invoked on the object explicitly. Constructor gets invoked implicitly. Method has to be invoked on the object explicitly. If the constructor is not defined, then a default constructor is provided by the java compiler. If a method is not defined, then the compiler does not provide it. If the constructor is not defined, then a default constructor is provided by the java compiler. If a method is not defined, then the compiler does not provide it. The constructor name should be equal to the class name. The name of the method can have any name or have a class name too. The constructor name should be equal to the class name. The name of the method can have any name or have a class name too. A constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn't make sense. Java throws compilation error saying - modifier final not allowed here A method can be defined as final but it cannot be overridden in its subclasses. A constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn't make sense. Java throws compilation error saying - modifier final not allowed here modifier final not allowed here A method can be defined as final but it cannot be overridden in its subclasses. Final variable instantiations are possible inside a constructor and the scope of this applies to the whole class and its objects. A final variable if initialised inside a method ensures that the variable cant be changed only within the scope of that method. Final variable instantiations are possible inside a constructor and the scope of this applies to the whole class and its objects. A final variable if initialised inside a method ensures that the variable cant be changed only within the scope of that method.",
        "reference": "interviewbit.com"
    },
    {
        "question": "20. Identify the output of the below java program and Justify your answer.",
        "answer": "class Main {\n    public static void main(String args[]) {\n        Scaler s = new Scaler(5);\n    }\n}\nclass InterviewBit{\n    InterviewBit(){\n        System.out.println(\" Welcome to InterviewBit \");\n    }\n}\nclass Scaler extends InterviewBit{\n    Scaler(){\n        System.out.println(\" Welcome to Scaler Academy \");\n    }\n    Scaler(int x){\n        this();\n        super();\n        System.out.println(\" Welcome to Scaler Academy 2\");\n    }\n} class Main {\n    public static void main(String args[]) {\n        Scaler s = new Scaler(5);\n    }\n}\nclass InterviewBit{\n    InterviewBit(){\n        System.out.println(\" Welcome to InterviewBit \");\n    }\n}\nclass Scaler extends InterviewBit{\n    Scaler(){\n        System.out.println(\" Welcome to Scaler Academy \");\n    }\n    Scaler(int x){\n        this();\n        super();\n        System.out.println(\" Welcome to Scaler Academy 2\");\n    }\n} class Main class Main public static void main(String args[]) public static void main (String args[]) new 5 class InterviewBit class InterviewBit \" Welcome to InterviewBit \" class Scaler extends InterviewBit class Scaler extends InterviewBit \" Welcome to Scaler Academy \" int this super \" Welcome to Scaler Academy 2\" The above code will throw the compilation error. It is because the super() is used to call the parent class constructor. But there is the condition that super() must be the first statement in the block. Now in this case, if we replace this() with super() then also it will throw the compilation error. Because this() also has to be the first statement in the block. So in conclusion, we can say that we cannot use this() and super() keywords in the same block. super() this() super() this() super()",
        "reference": "interviewbit.com"
    },
    {
        "question": "21. Java works as \u201cpass by value\u201d or \u201cpass by reference\u201d phenomenon?",
        "answer": "Java always works as a \u201cpass by value\u201d. There is nothing called a \u201cpass by reference\u201d in Java. However, when the object is passed in any method, the address of the value is passed due to the nature of object handling in Java. When an object is passed, a copy of the reference is created by Java and that is passed to the method. The objects point to the same memory location. 2 cases might happen inside the method: Case 1: When the object is pointed to another location: In this case, the changes made to that object do not get reflected the original object before it was passed to the method as the reference points to another location. Case 1: When the object is pointed to another location: In this case, the changes made to that object do not get reflected the original object before it was passed to the method as the reference points to another location. Case 1: For example: class InterviewBitTest{\n   int num;\n   InterviewBitTest(int x){ \n       num = x; \n   }\n   InterviewBitTest(){ \n       num = 0; \n   }\n}\nclass Driver {\n   public static void main(String[] args)\n   {\n       //create a reference\n       InterviewBitTest ibTestObj = new InterviewBitTest(20);\n       //Pass the reference to updateObject Method\n       updateObject(ibTestObj);\n       //After the updateObject is executed, check for the value of num in the object.\n       System.out.println(ibTestObj.num);\n   }\n   public static void updateObject(InterviewBitTest ibObj)\n   {\n       // Point the object to new reference\n       ibObj = new InterviewBitTest();\n       // Update the value \n       ibObj.num = 50;\n   }\n}\nOutput:\n20 class InterviewBitTest{\n   int num;\n   InterviewBitTest(int x){ \n       num = x; \n   }\n   InterviewBitTest(){ \n       num = 0; \n   }\n}\nclass Driver {\n   public static void main(String[] args)\n   {\n       //create a reference\n       InterviewBitTest ibTestObj = new InterviewBitTest(20);\n       //Pass the reference to updateObject Method\n       updateObject(ibTestObj);\n       //After the updateObject is executed, check for the value of num in the object.\n       System.out.println(ibTestObj.num);\n   }\n   public static void updateObject(InterviewBitTest ibObj)\n   {\n       // Point the object to new reference\n       ibObj = new InterviewBitTest();\n       // Update the value \n       ibObj.num = 50;\n   }\n}\nOutput:\n20 class InterviewBitTest class InterviewBitTest int int 0 class Driver class Driver public static void main(String[] args) public static void main (String[] args) //create a reference new 20 //Pass the reference to updateObject Method //After the updateObject is executed, check for the value of num in the object. public static void updateObject(InterviewBitTest ibObj) public static void updateObject (InterviewBitTest ibObj) // Point the object to new reference new // Update the value 50 20 Case 2: When object references are not modified: In this case, since we have the copy of reference the main object pointing to the same memory location, any changes in the content of the object get reflected in the original object. Case 2: When object references are not modified: In this case, since we have the copy of reference the main object pointing to the same memory location, any changes in the content of the object get reflected in the original object. Case 2: For example: class InterviewBitTest{\n   int num;\n   InterviewBitTest(int x){ \n       num = x; \n   }\n   InterviewBitTest(){ \n       num = 0; \n   }\n}\nclass Driver{\n   public static void main(String[] args)\n   {\n       //create a reference\n       InterviewBitTest ibTestObj = new InterviewBitTest(20);\n       //Pass the reference to updateObject Method\n       updateObject(ibTestObj);\n       //After the updateObject is executed, check for the value of num in the object.\n       System.out.println(ibTestObj.num);\n   }\n   public static void updateObject(InterviewBitTest ibObj)\n   {\n       // no changes are made to point the ibObj to new location\n       // Update the value of num\n       ibObj.num = 50;\n   }\n}\nOutput:\n50 class InterviewBitTest{\n   int num;\n   InterviewBitTest(int x){ \n       num = x; \n   }\n   InterviewBitTest(){ \n       num = 0; \n   }\n}\nclass Driver{\n   public static void main(String[] args)\n   {\n       //create a reference\n       InterviewBitTest ibTestObj = new InterviewBitTest(20);\n       //Pass the reference to updateObject Method\n       updateObject(ibTestObj);\n       //After the updateObject is executed, check for the value of num in the object.\n       System.out.println(ibTestObj.num);\n   }\n   public static void updateObject(InterviewBitTest ibObj)\n   {\n       // no changes are made to point the ibObj to new location\n       // Update the value of num\n       ibObj.num = 50;\n   }\n}\nOutput:\n50 class InterviewBitTest class InterviewBitTest int int 0 class Driver class Driver public static void main(String[] args) public static void main (String[] args) //create a reference new 20 //Pass the reference to updateObject Method //After the updateObject is executed, check for the value of num in the object. public static void updateObject(InterviewBitTest ibObj) public static void updateObject (InterviewBitTest ibObj) // no changes are made to point the ibObj to new location // Update the value of num 50 50",
        "reference": "interviewbit.com"
    },
    {
        "question": "22. What is the \u2018IS-A \u2018 relationship in OOPs java?",
        "answer": "\u2018IS-A\u2019 relationship is another name for inheritance. When we inherit the base class from the derived class, then it forms a relationship between the classes. So that relationship is termed an \u2018IS-A\u2019 Relationship. Example - Consider a Television (Typical CRT TV). Now another Smart TV  that is inherited from television class. So we can say that the Smart iv is also a TV. Because CRT TV things can also be done in the Smart TV. Example   So here \u2018IS-A\u2019 Relationship formed. [ SmartTV \u2018IS-A\u2019 TV ]. [ SmartTV \u2018IS-A\u2019 TV ]",
        "reference": "interviewbit.com"
    },
    {
        "question": "23. Which among String or String Buffer should be preferred when there are lot of updates required to be done in the data?",
        "answer": "StringBuffer is mutable and dynamic in nature whereas String is immutable. Every updation / modification of String creates a new String thereby overloading the string pool with unnecessary objects. Hence, in the cases of a lot of updates, it is always preferred to use StringBuffer as it will reduce the overhead of the creation of multiple String objects in the string pool.",
        "reference": "interviewbit.com"
    },
    {
        "question": "24. How to not allow serialization of attributes of a class in Java?",
        "answer": "In order to achieve this, the attribute can be declared along with the usage of transient keyword as shown below: In order to achieve this, the attribute can be declared along with the usage of transient keyword as shown below: transient public class InterviewBitExample { \n\n   private transient String someInfo; \n   private String name;\n   private int id;\n   // :\n   // Getters setters\n   // :\n} public class InterviewBitExample { \n\n   private transient String someInfo; \n   private String name;\n   private int id;\n   // :\n   // Getters setters\n   // :\n} public class InterviewBitExample class InterviewBitExample private transient private private int // : // Getters setters // : In the above example, all the fields except someInfo can be serialized. In the above example, all the fields except someInfo can be serialized. someInfo",
        "reference": "interviewbit.com"
    },
    {
        "question": "25. What happens if the static modifier is not included in the main method signature in Java?",
        "answer": "There wouldn't be any compilation error. But then the program is run, since the JVM cant map the main method signature, the code throws \u201cNoSuchMethodError\u201d error at the runtime.",
        "reference": "interviewbit.com"
    },
    {
        "question": "26. Consider the below program, identify the output, and also state the reason for that.",
        "answer": "public class Main{\npublic static void main(String[] args) {\n System.out.println(\" Hello. Main Method. \");\n}\npublic static void main(int[] args) {\n System.out.println(\" Hello. Main Method2. \");\n}\n} public class Main{\npublic static void main(String[] args) {\n System.out.println(\" Hello. Main Method. \");\n}\npublic static void main(int[] args) {\n System.out.println(\" Hello. Main Method2. \");\n}\n} public class Main class Main public static void main(String[] args) public static void main (String[] args) \" Hello. Main Method. \" public static void main(int[] args) public static void main (int[] args) int \" Hello. Main Method2. \" The output of the above program will be Hello. Main Method. This is because JVM will always call the main method based on the definition it already has. Doesn't matter how many main methods we overload it will only execute one main method based on its declaration in JVM. Hello. Main Method",
        "reference": "interviewbit.com"
    },
    {
        "question": "27. Can we make the main() thread a daemon thread?",
        "answer": "In java multithreading, the main() threads are always non-daemon threads. And there is no way we can change the nature of the non-daemon thread to the daemon thread.",
        "reference": "interviewbit.com"
    },
    {
        "question": "28. What happens if there are multiple main methods inside one class in Java?",
        "answer": "The program can't compile as the compiler says that the method has been already defined inside the class.",
        "reference": "interviewbit.com"
    },
    {
        "question": "29. What do you understand by Object Cloning and how do you achieve it in Java?",
        "answer": "It is the process of creating an exact copy of any object. In order to support this, a java class has to implement the Cloneable interface of java.lang package and override the clone() method provided by the Object class the syntax of which is: It is the process of creating an exact copy of any object. In order to support this, a java class has to implement the Cloneable interface of java.lang package and override the clone() method provided by the Object class the syntax of which is: protected Object clone() throws CloneNotSupportedException{\n return (Object)super.clone();\n} protected Object clone() throws CloneNotSupportedException{\n return (Object)super.clone();\n} protected Object clone() throws CloneNotSupportedException protected clone () throws return super In case the Cloneable interface is not implemented and just the method is overridden, it results in CloneNotSupportedException in Java. In case the Cloneable interface is not implemented and just the method is overridden, it results in CloneNotSupportedException in Java.",
        "reference": "interviewbit.com"
    },
    {
        "question": "30. How does an exception propagate in the code?",
        "answer": "When an exception occurs, first it searches to locate the matching catch block. In case, the matching catch block is located, then that block would be executed. Else, the exception propagates through the method call stack and goes into the caller method where the process of matching the catch block is performed. This propagation happens until the matching catch block is found. If the match is not found, then the program gets terminated in the main method.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "31. How do exceptions affect the program if it doesn't handle them?",
        "answer": "Exceptions are runtime errors. Suppose we are making an android application with java. And it all works fine but there is an exceptional case when the application tries to get the file from storage and the file doesn\u2019t exist (This is the case of exception in java). And if this case is not handled properly then the application will crash. This will be a bad experience for users.  This is the type of error that cannot be controlled by the programmer. But programmers can take some steps to avoid this so that the application won\u2019t crash. The proper action can be taken at this step.",
        "reference": "interviewbit.com"
    },
    {
        "question": "32. Is it mandatory for a catch block to be followed after a try block?",
        "answer": "No, it is not necessary for a catch block to be present after a try block. - A try block should be followed either by a catch block or by a finally block. If the exceptions likelihood is more, then they should be declared using the throws clause of the method.",
        "reference": "interviewbit.com"
    },
    {
        "question": "33. Will the finally block get executed when the return statement is written at the end of try block and catch block as shown below?",
        "answer": "public int someMethod(int i){\n   try{\n       //some statement\n       return 1;\n   }catch(Exception e){\n       //some statement\n       return 999;\n   }finally{\n       //finally block statements\n   }\n} public int someMethod(int i){\n   try{\n       //some statement\n       return 1;\n   }catch(Exception e){\n       //some statement\n       return 999;\n   }finally{\n       //finally block statements\n   }\n} public int someMethod(int i) public int someMethod (int i) int try //some statement return 1 catch //some statement return 999 finally //finally block statements finally block will be executed irrespective of the exception or not. The only case where finally block is not executed is when it encounters \u2018System.exit()\u2019 method anywhere in try/catch block.",
        "reference": "interviewbit.com"
    },
    {
        "question": "34. Can you call a constructor of a class inside the another constructor?",
        "answer": "Yes, the concept can be termed as constructor chaining and can be achieved using this(). this()  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "35. Contiguous memory locations are usually used for storing actual values in an array but not in ArrayList. Explain.",
        "answer": "In the case of ArrayList, data storing in the form of primitive data types (like int, float, etc.) is not possible. The data members/objects present in the ArrayList have references to the objects which are located at various sites in the memory. Thus, storing of actual objects or non-primitive data types (like Integer, Double, etc.) takes place in various memory locations.   However, the same does not apply to the arrays. Object or primitive type values can be stored in arrays in contiguous memory locations, hence every element does not require any reference to the next element.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "36. Why does the java array index start with 0?",
        "answer": "It is because the 0 index array avoids the extra arithmetic operation to calculate the memory address. Example - Consider the array and assume each element takes 4-byte memory space. Then the address will be like this -   Now if we want to access index 4. Then internally java calculates the address using the formula- [Base Address + (index * no_of_bytes)]. So according to this. The starting address of the index 4 will be - [100 + (4*4)] = 116. And exactly that's what the address is calculated. \nNow consider the same with 1 index Array - [Base Address + (index * no_of_bytes)] [100 + (4*4)] = 116    Now if we apply the same formula here. Then we get - 116 as the starting address of the 4th index. Which is wrong. Then we need to apply formula - [Base Address + ((index-1) * no_of_bytes)]. 116 Base Address + ((index-1) * no_of_bytes)] And for calculating this, an extra arithmetic operation has to be performed. And consider the case where millions of addresses need to be calculated, this causes complexity. So to avoid this, ) the index array is supported by java.",
        "reference": "interviewbit.com"
    },
    {
        "question": "37. Why is the remove method faster in the linked list than in an array?",
        "answer": "In the linked list, we only need to adjust the references when we want to delete the element from either end or the front of the linked list. But in the array, indexes are used. So to manage proper indexing, we need to adjust the values from the array So this adjustment of value is costlier than the adjustment of references. Example - To Delete from the front of the linked list, internally the references adjustments happened like this. Example   The only thing that will change is that the head pointer will point to the head\u2019s next node. And delete the previous node. That is the constant time operation. Whereas in the ArrayList, internally it should work like this-   For deletion of the first element, all the next element has to move to one place ahead. So this copying value takes time. So that is the reason why removing in ArrayList is slower than LinkedList.",
        "reference": "interviewbit.com"
    },
    {
        "question": "38. How many overloaded add() and addAll() methods are available in the List interface? Describe the need and uses.",
        "answer": "There are a total of 4 overloaded methods for add() and addAll() methods available in List Interface. The below table states the description of all. Return Type Method Description\nboolean add(Element e): This method is used for adding the element at the end of the List. The Datatype of the element is of any type it has been initially assigned with. It returns the boolean indicating successfully inserted or not.\nvoid add(int index, Element e): This method is the overloaded version of add() method. In this, along with the element, the index is also passed to the method for the specific index the value needs to be inserted. \nboolean addAll(Collection <extends ? Element > c): This method helps to add all elements at the end of collections from the list received in the parameter. It contains an iterator that helps to iterate the list and add the elements to the collection.\nboolean addAll(int index, Collection <extends ? Element > c): This is the overloaded method for addAll() method. In this along with the list, we can pass the specified index from which the list elements need to be added. Return Type Method Description\nboolean add(Element e): This method is used for adding the element at the end of the List. The Datatype of the element is of any type it has been initially assigned with. It returns the boolean indicating successfully inserted or not.\nvoid add(int index, Element e): This method is the overloaded version of add() method. In this, along with the element, the index is also passed to the method for the specific index the value needs to be inserted. \nboolean addAll(Collection <extends ? Element > c): This method helps to add all elements at the end of collections from the list received in the parameter. It contains an iterator that helps to iterate the list and add the elements to the collection.\nboolean addAll(int index, Collection <extends ? Element > c): This is the overloaded method for addAll() method. In this along with the list, we can pass the specified index from which the list elements need to be added. Return Type Method Description Return Type Method Description Return Type Method Description boolean add(Element e): This method is used for adding the element at the end of the List. The Datatype of the element is of any type it has been initially assigned with. It returns the boolean indicating successfully inserted or not.\nvoid add(int index, Element e): This method is the overloaded version of add() method. In this, along with the element, the index is also passed to the method for the specific index the value needs to be inserted. \nboolean addAll(Collection <extends ? Element > c): This method helps to add all elements at the end of collections from the list received in the parameter. It contains an iterator that helps to iterate the list and add the elements to the collection.\nboolean addAll(int index, Collection <extends ? Element > c): This is the overloaded method for addAll() method. In this along with the list, we can pass the specified index from which the list elements need to be added. boolean add(Element e): This method is used for adding the element at the end of the List. The Datatype of the element is of any type it has been initially assigned with. It returns the boolean indicating successfully inserted or not. boolean add(Element e): This method is used for adding the element at the end of the List. The Datatype of the element is of any type it has been initially assigned with. It returns the boolean indicating successfully inserted or not. add(Element e) void add(int index, Element e): This method is the overloaded version of add() method. In this, along with the element, the index is also passed to the method for the specific index the value needs to be inserted. void add(int index, Element e): This method is the overloaded version of add() method. In this, along with the element, the index is also passed to the method for the specific index the value needs to be inserted. add(int index, Element e) boolean addAll(Collection <extends ? Element > c): This method helps to add all elements at the end of collections from the list received in the parameter. It contains an iterator that helps to iterate the list and add the elements to the collection. boolean addAll(Collection <extends ? Element > c): This method helps to add all elements at the end of collections from the list received in the parameter. It contains an iterator that helps to iterate the list and add the elements to the collection. addAll(Collection <extends ? Element > c) boolean addAll(int index, Collection <extends ? Element > c): This is the overloaded method for addAll() method. In this along with the list, we can pass the specified index from which the list elements need to be added. boolean addAll(int index, Collection <extends ? Element > c): This is the overloaded method for addAll() method. In this along with the list, we can pass the specified index from which the list elements need to be added. addAll(int index, Collection <extends ? Element > c)",
        "reference": "interviewbit.com"
    },
    {
        "question": "39. How does the size of ArrayList grow dynamically? And also state how it is implemented internally.",
        "answer": "ArrayList is implemented in such a way that it can grow dynamically. We don't need to specify the size of ArrayList. For adding the values in it, the methodology it uses is - 1. Consider initially that there are 2 elements in the ArrayList. [2, 3]. [2, 3]   2. If we need to add the element into this. Then internally what will happen is- ArrayList will allocate the new ArrayList of Size (current size + half of the current size). And add the old elements into the new. Old - [2, 3],    New - [2, 3, null]. ArrayList will allocate the new ArrayList of Size (current size + half of the current size). And add the old elements into the new. Old - [2, 3],    New - [2, 3, null].   Then the new value will be inserted into it. [2, 3, 4, null]. And for the next time, the extra space will be available for the value to be inserted. Then the new value will be inserted into it. [2, 3, 4, null]. And for the next time, the extra space will be available for the value to be inserted.   3. This process continues and the time taken to perform all of these is considered as the amortized constant time. This is how the ArrayList grows dynamically. And when we delete any entry from the ArrayList then the following steps are performed - 1. It searches for the element index in the array. Searching takes some time. Typically it\u2019s O(n) because it needs to search for the element in the entire array.   2. After searching the element, it needs to shift the element from the right side to fill the index.   So this is how the elements are deleted from the ArrayList internally. Similarly, the search operations are also implemented internally as defined in removing elements from the list (searching for elements to delete).",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Although inheritance is a popular OOPs concept, it is less advantageous than composition. Explain.",
        "answer": "Inheritance lags behind composition in the following scenarios: Multiple-inheritance is not possible in Java. Classes can only extend from one superclass. In cases where multiple functionalities are required, for example - to read and write information into the file, the pattern of composition is preferred. The writer, as well as reader functionalities, can be made use of by considering them as the private members.\nComposition assists in attaining high flexibility and prevents breaking of encapsulation.\nUnit testing is possible with composition and not inheritance. When a developer wants to test a class composing a different class, then Mock Object can be created for signifying the composed class to facilitate testing. This technique is not possible with the help of inheritance as the derived class cannot be tested without the help of the superclass in inheritance.\nThe loosely coupled nature of composition is preferable over the tightly coupled nature of inheritance. Multiple-inheritance is not possible in Java. Classes can only extend from one superclass. In cases where multiple functionalities are required, for example - to read and write information into the file, the pattern of composition is preferred. The writer, as well as reader functionalities, can be made use of by considering them as the private members. Composition assists in attaining high flexibility and prevents breaking of encapsulation. Unit testing is possible with composition and not inheritance. When a developer wants to test a class composing a different class, then Mock Object can be created for signifying the composed class to facilitate testing. This technique is not possible with the help of inheritance as the derived class cannot be tested without the help of the superclass in inheritance. The loosely coupled nature of composition is preferable over the tightly coupled nature of inheritance. Let\u2019s take an example: package comparison;\npublic class Top {\npublic int start() {\n  return 0;\n}\n}\nclass Bottom extends Top {\n public int stop() {\n  return 0;\n }\n} package comparison;\npublic class Top {\npublic int start() {\n  return 0;\n}\n}\nclass Bottom extends Top {\n public int stop() {\n  return 0;\n }\n} package public class Top class Top public int start() public int start () return 0 class Bottom extends Top class Bottom extends Top public int stop() public int stop () return 0 In the above example, inheritance is followed. Now, some modifications are done to the Top class like this: public class Top {\n public int start() {\n  return 0;\n }\n public void stop() {\n }\n} public class Top {\n public int start() {\n  return 0;\n }\n public void stop() {\n }\n} public class Top class Top public int start() public int start () return 0 public void stop() public void stop () If the new implementation of the Top class is followed, a compile-time error is bound to occur in the Bottom class. Incompatible return type is there for the Top.stop() function. Changes have to be made to either the Top or the Bottom class to ensure compatibility. However, the composition technique can be utilized to solve the given problem: class Bottom {\n Top par = new Top();\n public int stop() {\n  par.start();\n  par.stop();\n  return 0;\n }\n} class Bottom {\n Top par = new Top();\n public int stop() {\n  par.start();\n  par.stop();\n  return 0;\n }\n} class Bottom class Bottom new public int stop() public int stop () return 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What is the difference between \u2018>>\u2019 and \u2018>>>\u2019 operators in java?",
        "answer": "These 2 are the bitwise right shift operators. Although both operators look similar. But there is a minimal difference between these two right shift operators. \u2018>>\u2019 Bitwise Right Shift Operator- This operator shifts each bit to its right position. And this maintains the signed bit.\n\u2018>>>\u2019 Bitwise Right Shift Operator with trailing zero- This operator also shifts each bit to its right. But this doesn\u2019t maintain the signed bit. This operator makes the Most significant bit to 0. \u2018>>\u2019 Bitwise Right Shift Operator- This operator shifts each bit to its right position. And this maintains the signed bit. \u2018>>\u2019 Bitwise Right Shift Operator \u2018>>>\u2019 Bitwise Right Shift Operator with trailing zero- This operator also shifts each bit to its right. But this doesn\u2019t maintain the signed bit. This operator makes the Most significant bit to 0. \u2018>>>\u2019 Bitwise Right Shift Operator with trailing zero Example- Num1 = 8, Num2 = -8. Example- So the binary form of these numbers are - Num1 = 00000000 00000000 00000000 00001000 \nNum2 = 11111111 11111111 11111111  11111000 Num1 = 00000000 00000000 00000000 00001000  Num2 = 11111111 11111111 11111111  11111000 \u2018>>\u2019 Operator : 8 >> 1 (Shift by one bit) : \u2018>>\u2019 Operator Num1 = 00000000 00000000 00000000 00000100\nNum2 = 11111111 11111111 11111111  11111100 Num1 = 00000000 00000000 00000000 00000100  Num2 = 11111111 11111111 11111111  11111100 \u2018>>>\u2019 Operator : 8 >>> 1 (Shift by one bit) = \u2018>>>\u2019 Operator Num1 = 00000000 00000000 00000000 00000100\nNum2 = 01111111 11111111 11111111 11111100 Num1 = 00000000 00000000 00000000 00000100  Num2 = 01111111 11111111 11111111 11111100",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What are Composition and Aggregation? State the difference.",
        "answer": "Composition, and Aggregation help to build (Has - A - Relationship) between classes and objects. But both are not the same in the end. Let\u2019s understand with the help of an example. Let\u2019s understand with the help of an example. Consider the University as a class that has some departments in it. So the university will be the container object. And departments in it will contain objects. Now in this case, if the container object destroys then the contained objects will also get destroyed automatically.  So here we can say that there is a strong association between the objects. So this Strong Association is called Composition.\nNow consider one more example. Suppose we have a class department and there are several professors' objects there in the department. Now if the department class is destroyed then the professor's object will become free to bind with other objects. Because container objects (Department) only hold the references of contained objects (Professor\u2019s). So here is the weak association between the objects. And this weak association is called Aggregation. Consider the University as a class that has some departments in it. So the university will be the container object. And departments in it will contain objects. Now in this case, if the container object destroys then the contained objects will also get destroyed automatically.  So here we can say that there is a strong association between the objects. So this Strong Association is called Composition. Composition Now consider one more example. Suppose we have a class department and there are several professors' objects there in the department. Now if the department class is destroyed then the professor's object will become free to bind with other objects. Because container objects (Department) only hold the references of contained objects (Professor\u2019s). So here is the weak association between the objects. And this weak association is called Aggregation. Aggregation",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. How is the creation of a String using new() different from that of a literal?",
        "answer": "When a String is formed as a literal with the assistance of an assignment operator, it makes its way into the String constant pool so that String Interning can take place. This same object in the heap will be referenced by a different String if the content is the same for both of them. public bool checking() {\nString first = \"InterviewBit\";\nString second = \"InterviewBit\";\nif (first == second)\n return true;\nelse\n return false;\n} public bool checking() {\nString first = \"InterviewBit\";\nString second = \"InterviewBit\";\nif (first == second)\n return true;\nelse\n return false;\n} public bool checking() public checking () \"InterviewBit\" \"InterviewBit\" if return true else return false The checking() function will return true as the same content is referenced by both the variables.   Conversely, when a String formation takes place with the help of a new() operator, interning does not take place. The object gets created in the heap memory even if the same content object is present. public bool checking() {\nString first = new String(\"InterviewBit\");\nString second = new String(\"InterviewBit\");\nif (first == second)\n return true;\nelse\n return false;\n} public bool checking() {\nString first = new String(\"InterviewBit\");\nString second = new String(\"InterviewBit\");\nif (first == second)\n return true;\nelse\n return false;\n} public bool checking() public checking () new \"InterviewBit\" new \"InterviewBit\" if return true else return false The checking() function will return false as the same content is not referenced by both the variables.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. How is the \u2018new\u2019 operator different from the \u2018newInstance()\u2019 operator in java?",
        "answer": "Both \u2018new\u2019 and \u2018newInstance()\u2019 operators are used to creating objects. The difference is- that when we already know the class name for which we have to create the object then we use a new operator. But suppose we don\u2019t know the class name for which we need to create the object, Or we get the class name from the command line argument, or the database, or the file. Then in that case we use the \u2018newInstance()\u2019 operator. new newInstance() newInstance() The \u2018newInstance()\u2019 keyword throws an exception that we need to handle. It is because there are chances that the class definition doesn\u2019t exist, and we get the class name from runtime. So it will throw an exception. newInstance()",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Is exceeding the memory limit possible in a program despite having a garbage collector?",
        "answer": "Yes, it is possible for the program to go out of memory in spite of the presence of a garbage collector. Garbage collection assists in recognizing and eliminating those objects which are not required in the program anymore, in order to free up the resources used by them. In a program, if an object is unreachable, then the execution of garbage collection takes place with respect to that object. If the amount of memory required for creating a new object is not sufficient, then memory is released for those objects which are no longer in the scope with the help of a garbage collector. The memory limit is exceeded for the program when the memory released is not enough for creating new objects. Moreover, exhaustion of the heap memory takes place if objects are created in such a manner that they remain in the scope and consume memory. The developer should make sure to dereference the object after its work is accomplished. Although the garbage collector endeavors its level best to reclaim memory as much as possible, memory limits can still be exceeded. Let\u2019s take a look at the following example: List<String> example = new LinkedList<String>();\nwhile(true){\nexample.add(new String(\"Memory Limit Exceeded\"));\n} List<String> example = new LinkedList<String>();\nwhile(true){\nexample.add(new String(\"Memory Limit Exceeded\"));\n} new while true new \"Memory Limit Exceeded\"",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. Why is synchronization necessary? Explain with the help of a relevant example.",
        "answer": "Concurrent execution of different processes is made possible by synchronization. When a particular resource is shared between many threads, situations may arise in which multiple threads require the same shared resource. Synchronization assists in resolving the issue and the resource is shared by a single thread at a time. Let\u2019s take an example to understand it more clearly. For example, you have a URL and you have to find out the number of requests made to it. Two simultaneous requests can make the count erratic. No synchronization: No synchronization: package anonymous;\npublic class Counting {\n       private int increase_counter;\n       public int increase() {\n               increase_counter = increase_counter + 1;\n               return increase_counter;\n       }\n} package anonymous;\npublic class Counting {\n       private int increase_counter;\n       public int increase() {\n               increase_counter = increase_counter + 1;\n               return increase_counter;\n       }\n} package public class Counting class Counting private int public int increase() public int increase () 1 return   If a thread Thread1 views the count as 10, it will be increased by 1 to 11. Simultaneously, if another thread Thread2 views the count as 10, it will be increased by 1 to 11. Thus, inconsistency in count values takes place because the expected final value is 12 but the actual final value we get will be 11. Now, the function increase() is made synchronized so that simultaneous accessing cannot take place. With synchronization: With synchronization: package anonymous;\npublic class Counting {\n       private int increase_counter;\n       public synchronized int increase() {\n               increase_counter = increase_counter + 1;\n               return increase_counter;\n       }\n} package anonymous;\npublic class Counting {\n       private int increase_counter;\n       public synchronized int increase() {\n               increase_counter = increase_counter + 1;\n               return increase_counter;\n       }\n} package public class Counting class Counting private int public synchronized int increase() public synchronized int increase () 1 return   If a thread Thread1 views the count as 10, it will be increased by 1 to 11, then the thread Thread2 will view the count as 11, it will be increased by 1 to 12. Thus, consistency in count values takes place.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. In the given code below, what is the significance of ... ?",
        "answer": "public void fooBarMethod(String... variables){\n   // method code\n} public void fooBarMethod(String... variables){\n   // method code\n} public void fooBarMethod(String... variables) public void fooBarMethod (String... variables) // method code Ability to provide ... is a feature called varargs (variable arguments) which was introduced as part of Java 5.\nThe function having ... in the above example indicates that it can receive multiple arguments of the datatype String.\nFor example, the fooBarMethod can be called in multiple ways and we can still have one method to process the data as shown below: Ability to provide ... is a feature called varargs (variable arguments) which was introduced as part of Java 5. ... The function having ... in the above example indicates that it can receive multiple arguments of the datatype String. ... For example, the fooBarMethod can be called in multiple ways and we can still have one method to process the data as shown below: fooBarMethod(\"foo\", \"bar\");\nfooBarMethod(\"foo\", \"bar\", \"boo\");\nfooBarMethod(new String[]{\"foo\", \"var\", \"boo\"});\npublic void myMethod(String... variables){\n   for(String variable : variables){\n       // business logic\n   }\n} fooBarMethod(\"foo\", \"bar\");\nfooBarMethod(\"foo\", \"bar\", \"boo\");\nfooBarMethod(new String[]{\"foo\", \"var\", \"boo\"});\npublic void myMethod(String... variables){\n   for(String variable : variables){\n       // business logic\n   }\n} \"foo\" \"bar\" \"foo\" \"bar\" \"boo\" new \"foo\" \"var\" \"boo\" public void myMethod(String... variables) public void myMethod (String... variables) for // business logic",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What will be the output of the below java program and define the steps of Execution of the java program with the help of the below code?",
        "answer": "class InterviewBit{\n    int i;\n    static int j;\n    {\n        System.out.println(\" Instance Block 1. Value of i = \"+i);\n    }\n    static{\n        System.out.println(\" Static Block 1. Value of j = \"+j);\n        method_2();\n    }\n    {\n        i = 5;\n    }\n    static{\n        j = 10;\n    }\n    InterviewBit(){\n        System.out.println(\" Welcome to InterviewBit \");\n    }\n    public static void main(String[] args){\n        InterviewBit ib = new InterviewBit();\n    }\n    public void method_1(){\n        System.out.println(\" Instance method. \");\n    }\n    static{\n        System.out.println(\" Static Block 2. Value of j = \"+j);\n    }\n    {\n        System.out.println(\" Instance Block 2. Value of i = \"+i);\n        method_1();\n    }\n    public static void method_2(){\n        System.out.println(\" Static method. \");\n    }\n} class InterviewBit{\n    int i;\n    static int j;\n    {\n        System.out.println(\" Instance Block 1. Value of i = \"+i);\n    }\n    static{\n        System.out.println(\" Static Block 1. Value of j = \"+j);\n        method_2();\n    }\n    {\n        i = 5;\n    }\n    static{\n        j = 10;\n    }\n    InterviewBit(){\n        System.out.println(\" Welcome to InterviewBit \");\n    }\n    public static void main(String[] args){\n        InterviewBit ib = new InterviewBit();\n    }\n    public void method_1(){\n        System.out.println(\" Instance method. \");\n    }\n    static{\n        System.out.println(\" Static Block 2. Value of j = \"+j);\n    }\n    {\n        System.out.println(\" Instance Block 2. Value of i = \"+i);\n        method_1();\n    }\n    public static void method_2(){\n        System.out.println(\" Static method. \");\n    }\n} class InterviewBit class InterviewBit int static int \" Instance Block 1. Value of i = \" static \" Static Block 1. Value of j = \" 5 static 10 \" Welcome to InterviewBit \" public static void main(String[] args) public static void main (String[] args) new public void method_1() public void method_1 () \" Instance method. \" static \" Static Block 2. Value of j = \" \" Instance Block 2. Value of i = \" public static void method_2() public static void method_2 () \" Static method. \" The Output we get by executing this program will be Static Block 1. Value of j = 0\nStatic method. \nStatic Block 2. Value of j = 10\nInstance Block 1. Value of i = 0\nInstance Block 2. Value of i = 5\nInstance method. \nWelcome to InterviewBit Static Block 1. Value of j = 0  Static method.  Static Block 2. Value of j = 10  Instance Block 1. Value of i = 0  Instance Block 2. Value of i = 5  Instance method.  Welcome to InterviewBit This is a java tricky interview question frequently asked in java interviews for the experienced. The output will be like this because, when the java program is compiled and gets executed, then there are various steps followed for execution. And the steps are - Identification of Static Members from top to bottom.\nExecution of Static variable assignment and a Static block from top to bottom.\nExecution of the main method.\nIdentification of Instance Members from top to bottom.\nExecution of Instance variable assignment and Instance block from top to bottom.\nExecution of Constructor. Identification of Static Members from top to bottom. Execution of Static variable assignment and a Static block from top to bottom. Execution of the main method. Identification of Instance Members from top to bottom. Execution of Instance variable assignment and Instance block from top to bottom. Execution of Constructor. In above steps from 4 to 6, will be executed for every object creation. If we create multiple objects then for every object these steps will be performed. Now from the above code, the execution will happen like this - 1. In the step of identification of static members. It is found that - static int j.\nstatic block.\nmain method.\nstatic method_2. static int j. static block. main method. static method_2. During identification, the JVM will assign the default value in the static int j variable. Then it is currently in the state of reading and indirectly writing. Because the original value is not assigned. 2. In the next step, it will execute the static block and assign the value in static variables. First static block it will print and because execution from top to bottom and original value in j is not assigned. So it will print the default value of 0.\nAfter executing static block 1. It will execute the static method_1 because it is called from the static block 1.\nThen it will assign the original value of 5 in the j variable. And executes the remaining static block. First static block it will print and because execution from top to bottom and original value in j is not assigned. So it will print the default value of 0. After executing static block 1. It will execute the static method_1 because it is called from the static block 1. Then it will assign the original value of 5 in the j variable. And executes the remaining static block. 3. Now it will execute the main method. In which it will create an object for the class InterviewBit. And then the execution of instances will happen. 4. Identify the instance variables and blocks from top to bottom. int i.\nInstance block 1.\nInstance method_1. int i. Instance block 1. Instance method_1. Like a static variable, the instance variable also has been initialized with the default value 0 and will be in the state of reading and writing indirectly. 5. It will execute the instance methods and assign the original value to the instance variable. Prints the Instance block 1. And the current value of i is not assigned till now, so it will print 0.\nAssign the original value to i. Then print instance block 2. And after that instance method will be called and printed because it is being called in the instance block. Prints the Instance block 1. And the current value of i is not assigned till now, so it will print 0. Assign the original value to i. Then print instance block 2. And after that instance method will be called and printed because it is being called in the instance block. 6. And at the last step, the constructor will be invoked and the lines will be executed in the constructor. This is how the java program gets executed.",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Define System.out.println().",
        "answer": "System.out.println() is used to print the message on the console. System - It is a class present in java.lang package. Out is the static variable of type PrintStream class present in the System class. println() is the method present in the PrintStream class. System.out.println() System java.lang package System class. println() So if we justify the statement, then we can say that if we want to print anything on the console then we need to call the println() method that was present in PrintStream class. And we can call this using the output object that is present in the System class. println()",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. Can you explain the Java thread lifecycle?",
        "answer": "Java thread life cycle is as follows: New \u2013 When the instance of the thread is created and the start() method has not been invoked, the thread is considered to be alive and hence in the NEW state.\nRunnable \u2013 Once the start() method is invoked, before the run() method is called by JVM, the thread is said to be in RUNNABLE (ready to run) state. This state can also be entered from the Waiting or Sleeping state of the thread.\nRunning \u2013 When the run() method has been invoked and the thread starts its execution, the thread is said to be in a RUNNING state.\nNon-Runnable (Blocked/Waiting) \u2013 When the thread is not able to run despite the fact of its aliveness, the thread is said to be in a NON-RUNNABLE state. Ideally, after some time of its aliveness, the thread should go to a runnable state.\nA thread is said to be in a Blocked state if it wants to enter synchronized code but it is unable to as another thread is operating in that synchronized block on the same object. The first thread has to wait until the other thread exits the synchronized block.\nA thread is said to be in a Waiting state if it is waiting for the signal to execute from another thread, i.e it waits for work until the signal is received.\nTerminated \u2013 Once the run() method execution is completed, the thread is said to enter the TERMINATED step and is considered to not be alive. New \u2013 When the instance of the thread is created and the start() method has not been invoked, the thread is considered to be alive and hence in the NEW state. New Runnable \u2013 Once the start() method is invoked, before the run() method is called by JVM, the thread is said to be in RUNNABLE (ready to run) state. This state can also be entered from the Waiting or Sleeping state of the thread. Runnable Running \u2013 When the run() method has been invoked and the thread starts its execution, the thread is said to be in a RUNNING state. Running Non-Runnable (Blocked/Waiting) \u2013 When the thread is not able to run despite the fact of its aliveness, the thread is said to be in a NON-RUNNABLE state. Ideally, after some time of its aliveness, the thread should go to a runnable state.\nA thread is said to be in a Blocked state if it wants to enter synchronized code but it is unable to as another thread is operating in that synchronized block on the same object. The first thread has to wait until the other thread exits the synchronized block.\nA thread is said to be in a Waiting state if it is waiting for the signal to execute from another thread, i.e it waits for work until the signal is received. Non-Runnable (Blocked/Waiting) A thread is said to be in a Blocked state if it wants to enter synchronized code but it is unable to as another thread is operating in that synchronized block on the same object. The first thread has to wait until the other thread exits the synchronized block.\nA thread is said to be in a Waiting state if it is waiting for the signal to execute from another thread, i.e it waits for work until the signal is received. A thread is said to be in a Blocked state if it wants to enter synchronized code but it is unable to as another thread is operating in that synchronized block on the same object. The first thread has to wait until the other thread exits the synchronized block. A thread is said to be in a Waiting state if it is waiting for the signal to execute from another thread, i.e it waits for work until the signal is received. Terminated \u2013 Once the run() method execution is completed, the thread is said to enter the TERMINATED step and is considered to not be alive. Terminated The following flowchart clearly explains the lifecycle of the thread in Java.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What could be the tradeoff between the usage of an unordered array versus the usage of an ordered array?",
        "answer": "The main advantage of having an ordered array is the reduced search time complexity of O(log n) whereas the time complexity in an unordered array is O(n).\nThe main drawback of the ordered array is its increased insertion time which is O(n) due to the fact that its element has to reordered to maintain the order of array during every insertion whereas the time complexity in the unordered array is only O(1).\nConsidering the above 2 key points and depending on what kind of scenario a developer requires, the appropriate data structure can be used for implementation. The main advantage of having an ordered array is the reduced search time complexity of O(log n) whereas the time complexity in an unordered array is O(n). O(log n) O(n) The main drawback of the ordered array is its increased insertion time which is O(n) due to the fact that its element has to reordered to maintain the order of array during every insertion whereas the time complexity in the unordered array is only O(1). Considering the above 2 key points and depending on what kind of scenario a developer requires, the appropriate data structure can be used for implementation.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. Is it possible to import the same class or package twice in Java and what happens to it during runtime?",
        "answer": "It is possible to import a class or package more than once, however, it is redundant because the JVM internally loads the package or class only once.",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. In case a package has sub packages, will it suffice to import only the main package? e.g. Does importing of com.myMainPackage.* also import com.myMainPackage.mySubPackage.*?",
        "answer": "This is a big NO. We need to understand that the importing of the sub-packages of a package needs to be done explicitly. Importing the parent package only results in the import of the classes within it and not the contents of its child/sub-packages.",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. Will the finally block be executed if the code System.exit(0) is written at the end of try block?",
        "answer": "NO. The control of the program post System.exit(0) is immediately gone and the program gets terminated which is why the finally block never gets executed. System.exit(0)",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. What do you understand by marker interfaces in Java?",
        "answer": "Marker interfaces, also known as tagging interfaces are those interfaces that have no methods and constants defined in them. They are there for helping the compiler and JVM to get run time-related information regarding the objects.",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. Explain the term \u201cDouble Brace Initialisation\u201d in Java?",
        "answer": "This is a convenient means of initializing any collections in Java. Consider the below example. import java.util.HashSet;\nimport java.util.Set;\n \npublic class IBDoubleBraceDemo{\n   public static void main(String[] args){\n       Set<String> stringSets = new HashSet<String>()\n       {\n           {\n               add(\"set1\");\n               add(\"set2\");\n               add(\"set3\");\n           }\n       };\n \n       doSomething(stringSets);\n   }\n \n   private static void doSomething(Set<String> stringSets){\n       System.out.println(stringSets);\n   }\n} import java.util.HashSet;\nimport java.util.Set;\n \npublic class IBDoubleBraceDemo{\n   public static void main(String[] args){\n       Set<String> stringSets = new HashSet<String>()\n       {\n           {\n               add(\"set1\");\n               add(\"set2\");\n               add(\"set3\");\n           }\n       };\n \n       doSomething(stringSets);\n   }\n \n   private static void doSomething(Set<String> stringSets){\n       System.out.println(stringSets);\n   }\n} import import public class IBDoubleBraceDemo class IBDoubleBraceDemo public static void main(String[] args) public static void main (String[] args) new \"set1\" \"set2\" \"set3\" private static void doSomething(Set<String> stringSets) private static void doSomething (Set<String> stringSets) In the above example, we see that the stringSets were initialized by using double braces. The first brace does the task of creating an anonymous inner class that has the capability of accessing the parent class\u2019s behavior. In our example, we are creating the subclass of HashSet so that it can use the add() method of HashSet.\nThe second braces do the task of initializing the instances. The first brace does the task of creating an anonymous inner class that has the capability of accessing the parent class\u2019s behavior. In our example, we are creating the subclass of HashSet so that it can use the add() method of HashSet. The second braces do the task of initializing the instances. Care should be taken while initializing through this method as the method involves the creation of anonymous inner classes which can cause problems during the garbage collection or serialization processes and may also result in memory leaks.",
        "reference": "interviewbit.com"
    },
    {
        "question": "18. Why is it said that the length() method of String class doesn't return accurate results?",
        "answer": "The length method returns the number of Unicode units of the String. Let's understand what Unicode units are and what is the confusion below.\nWe know that Java uses UTF-16 for String representation. With this Unicode, we need to understand the below two Unicode related terms:\nCode Point: This represents an integer denoting a character in the code space.\nCode Unit: This is a bit sequence used for encoding the code points. In order to do this, one or more units might be required for representing a code point.\nUnder the UTF-16 scheme, the code points were divided logically into 17 planes and the first plane was called the Basic Multilingual Plane (BMP). The BMP has classic characters - U+0000 to U+FFFF. The rest of the characters- U+10000 to U+10FFFF were termed as the supplementary characters as they were contained in the remaining planes.\nThe code points from the first plane are encoded using one 16-bit code unit\nThe code points from the remaining planes are encoded using two code units. The length method returns the number of Unicode units of the String. Let's understand what Unicode units are and what is the confusion below. We know that Java uses UTF-16 for String representation. With this Unicode, we need to understand the below two Unicode related terms:\nCode Point: This represents an integer denoting a character in the code space.\nCode Unit: This is a bit sequence used for encoding the code points. In order to do this, one or more units might be required for representing a code point. Code Point: This represents an integer denoting a character in the code space.\nCode Unit: This is a bit sequence used for encoding the code points. In order to do this, one or more units might be required for representing a code point. Code Point: This represents an integer denoting a character in the code space. Code Unit: This is a bit sequence used for encoding the code points. In order to do this, one or more units might be required for representing a code point. Under the UTF-16 scheme, the code points were divided logically into 17 planes and the first plane was called the Basic Multilingual Plane (BMP). The BMP has classic characters - U+0000 to U+FFFF. The rest of the characters- U+10000 to U+10FFFF were termed as the supplementary characters as they were contained in the remaining planes.\nThe code points from the first plane are encoded using one 16-bit code unit\nThe code points from the remaining planes are encoded using two code units. The code points from the first plane are encoded using one 16-bit code unit\nThe code points from the remaining planes are encoded using two code units. The code points from the first plane are encoded using one 16-bit code unit one The code points from the remaining planes are encoded using two code units. two Now if a string contained supplementary characters, the length function would count that as 2 units and the result of the length() function would not be as per what is expected. In other words, if there is 1 supplementary character of 2 units, the length of that SINGLE character is considered to be TWO - Notice the inaccuracy here? As per the java documentation, it is expected, but as per the real logic, it is inaccurate.",
        "reference": "interviewbit.com"
    },
    {
        "question": "19. What is the output of the below code and why?",
        "answer": "public class InterviewBit{\n   public static void main(String[] args)\n   {\n       System.out.println('b' + 'i' + 't');\n   }\n} public class InterviewBit{\n   public static void main(String[] args)\n   {\n       System.out.println('b' + 'i' + 't');\n   }\n} public class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) 'b' 'i' 't' \u201cbit\u201d would have been the result printed if the letters were used in double-quotes (or the string literals). But the question has the character literals (single quotes) being used which is why concatenation wouldn't occur. The corresponding ASCII values of each character would be added and the result of that sum would be printed.\nThe ASCII values of \u2018b\u2019, \u2018i\u2019, \u2018t\u2019 are:  \u2018b\u2019 = 98\n\u2018i\u2019 = 105\n\u2018t\u2019 = 116 \u2018b\u2019 = 98 \u2018i\u2019 = 105 \u2018t\u2019 = 116 98 + 105 + 116 = 319 98 + 105 + 116 = 319 Hence 319 would be printed.",
        "reference": "interviewbit.com"
    },
    {
        "question": "20. What are the possible ways of making object eligible for garbage collection (GC) in Java?",
        "answer": "First Approach: Set the object references to null once the object creation purpose is served. First Approach: public class IBGarbageCollect {\n  public static void main (String [] args){\n       String s1 = \"Some String\";\n           // s1 referencing String object - not yet eligible for GC\n       s1 = null; // now s1 is eligible for GC\n   }\n } public class IBGarbageCollect {\n  public static void main (String [] args){\n       String s1 = \"Some String\";\n           // s1 referencing String object - not yet eligible for GC\n       s1 = null; // now s1 is eligible for GC\n   }\n } public class IBGarbageCollect class IBGarbageCollect public static void main (String [] args) public static void main (String [] args) \"Some String\" // s1 referencing String object - not yet eligible for GC null // now s1 is eligible for GC Second Approach: Point the reference variable to another object. Doing this, the object which the reference variable was referencing before becomes eligible for GC. Second Approach: public class IBGarbageCollect {\n public static void main(String [] args){\n     String s1 = \"To Garbage Collect\";\n     String s2 = \"Another Object\";\n     System.out.println(s1); // s1 is not yet eligible for GC\n     s1 = s2; // Point s1 to other object pointed by s2\n     /* Here, the string object having the content  \"To Garbage Collect\" is not referred by any reference variable. Therefore, it is eligible for GC */\n }\n} public class IBGarbageCollect {\n public static void main(String [] args){\n     String s1 = \"To Garbage Collect\";\n     String s2 = \"Another Object\";\n     System.out.println(s1); // s1 is not yet eligible for GC\n     s1 = s2; // Point s1 to other object pointed by s2\n     /* Here, the string object having the content  \"To Garbage Collect\" is not referred by any reference variable. Therefore, it is eligible for GC */\n }\n} public class IBGarbageCollect class IBGarbageCollect public static void main(String [] args) public static void main (String [] args) \"To Garbage Collect\" \"Another Object\" // s1 is not yet eligible for GC // Point s1 to other object pointed by s2 /* Here, the string object having the content  \"To Garbage Collect\" is not referred by any reference variable. Therefore, it is eligible for GC */ Third Approach: Island of Isolation Approach: When 2 reference variables pointing to instances of the same class, and these variables refer to only each other and the objects pointed by these 2 variables don't have any other references, then it is said to have formed an \u201cIsland of Isolation\u201d and these 2 objects are eligible for GC. Third Approach: public class IBGarbageCollect {\n   IBGarbageCollect ib;    \n   public static void main(String [] str){\n       IBGarbageCollect ibgc1 = new IBGarbageCollect();\n       IBGarbageCollect ibgc2 = new IBGarbageCollect();\n       ibgc1.ib = ibgc2; //ibgc1 points to ibgc2\n       ibgc2.ib = ibgc1; //ibgc2 points to ibgc1\n       ibgc1 = null;\n       ibgc2 = null;\n       /* \n       * We see that ibgc1 and ibgc2 objects refer \n       * to only each other and have no valid \n       * references- these 2 objects for island of isolcation - eligible for GC\n       */\n   }\n} public class IBGarbageCollect {\n   IBGarbageCollect ib;    \n   public static void main(String [] str){\n       IBGarbageCollect ibgc1 = new IBGarbageCollect();\n       IBGarbageCollect ibgc2 = new IBGarbageCollect();\n       ibgc1.ib = ibgc2; //ibgc1 points to ibgc2\n       ibgc2.ib = ibgc1; //ibgc2 points to ibgc1\n       ibgc1 = null;\n       ibgc2 = null;\n       /* \n       * We see that ibgc1 and ibgc2 objects refer \n       * to only each other and have no valid \n       * references- these 2 objects for island of isolcation - eligible for GC\n       */\n   }\n} public class IBGarbageCollect class IBGarbageCollect public static void main(String [] str) public static void main (String [] str) new new //ibgc1 points to ibgc2 //ibgc2 points to ibgc1 null null /* \n       * We see that ibgc1 and ibgc2 objects refer \n       * to only each other and have no valid \n       * references- these 2 objects for island of isolcation - eligible for GC\n       */",
        "reference": "interviewbit.com"
    },
    {
        "question": "21. In the below Java Program, how many objects are eligible for garbage collection?",
        "answer": "class Main{\n   public static void main(String[] args){\n       int[][] num = new int[3][];\n       num[0] = new int[5];\n       num[1] = new int[2];\n       num[2] = new int[3];\n       \n       num[2] = new int[5];\n       num[0] = new int[4];\n       num[1] = new int[3];\n       \n       num = new int[2][];\n   }\n} class Main{\n   public static void main(String[] args){\n       int[][] num = new int[3][];\n       num[0] = new int[5];\n       num[1] = new int[2];\n       num[2] = new int[3];\n       \n       num[2] = new int[5];\n       num[0] = new int[4];\n       num[1] = new int[3];\n       \n       num = new int[2][];\n   }\n} class Main class Main public static void main(String[] args) public static void main (String[] args) int new int 3 0 new int 5 1 new int 2 2 new int 3 2 new int 5 0 new int 4 1 new int 3 new int 2 In the above program, a total of 7 objects will be eligible for garbage collection. Let\u2019s visually understand what's happening in the code.     In the above figure on line 3, we can see that on each array index we are declaring a new array so the reference will be of that new array on all the 3 indexes. So the old array will be pointed to by none. So these three are eligible for garbage collection. And on line 4, we are creating a new array object on the older reference. So that will point to a new array and older multidimensional objects will become eligible for garbage collection.",
        "reference": "interviewbit.com"
    },
    {
        "question": "22. What is the best way to inject dependency? Also, state the reason.",
        "answer": "There is no boundation for using a particular dependency injection. But the recommended approach is - Setters are mostly recommended for optional dependencies injection, and constructor arguments are recommended for mandatory ones. This is because constructor injection enables the injection of values into immutable fields and enables reading them more easily.",
        "reference": "interviewbit.com"
    },
    {
        "question": "23. How we can set the spring bean scope. And what supported scopes does it have?",
        "answer": "A scope can be set by an annotation such as the @Scope annotation or the \"scope\" attribute in an XML configuration file. Spring Bean supports the following five scopes: Singleton\nPrototype\nRequest\nSession\nGlobal-session Singleton Prototype Request Session Global-session",
        "reference": "interviewbit.com"
    },
    {
        "question": "24. What are the different categories of Java Design patterns?",
        "answer": "Java Design patterns are categorized into the following different types. And those are also further categorized as Structural patterns: Structural patterns: Adapter\nBridge\nFilter\nComposite\nDecorator\nFacade\nFlyweight\nProxy Adapter Bridge Filter Composite Decorator Facade Flyweight Proxy Behavioral patterns: Behavioral patterns: Interpreter\nTemplate method/ pattern\nChain of responsibility\nCommand pattern\nIterator pattern\nStrategy pattern\nVisitor pattern Interpreter Template method/ pattern Chain of responsibility Command pattern Iterator pattern Strategy pattern Visitor pattern J2EE patterns: J2EE patterns: MVC Pattern\nData Access Object pattern\nFront controller pattern\nIntercepting filter pattern\nTransfer object pattern MVC Pattern Data Access Object pattern Front controller pattern Intercepting filter pattern Transfer object pattern Creational patterns: Creational patterns: Factory method/Template\nAbstract Factory\nBuilder\nPrototype\nSingleton Factory method/Template Abstract Factory Builder Prototype Singleton",
        "reference": "interviewbit.com"
    },
    {
        "question": "25. What is a Memory Leak? Discuss some common causes of it.",
        "answer": "The Java Garbage Collector (GC) typically removes unused objects when they are no longer required, but when they are still referenced, the unused objects cannot be removed. So this causes the memory leak problem. Example - Consider a linked list like the structure below - Example   In the above image, there are unused objects that are not referenced. But then also Garbage collection will not free it. Because it is referencing some existing referenced object. So this can be the situation of memory leak. Some common causes of Memory leaks are - Some common causes of Memory leaks are When there are Unbounded caches.\nExcessive page swapping is done by the operating system.\nImproper written custom data structures.\nInserting into a collection object without first deleting it.\netc. When there are Unbounded caches. Excessive page swapping is done by the operating system. Improper written custom data structures. Inserting into a collection object without first deleting it.\netc. ",
        "reference": "interviewbit.com"
    },
    {
        "question": "26. Assume a thread has a lock on it, calling the sleep() method on that thread will release the lock?",
        "answer": "A thread that has a lock won't be released even after it calls sleep(). Despite the thread sleeping for a specified period of time, the lock will not be released.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Check if a given string is palindrome using recursion.",
        "answer": "/*\n* Java program to check if a given inputted string is palindrome or not using recursion.\n*/\nimport java.util.*;\npublic class InterviewBit { \n   public static void main(String args[]) { \n       Scanner s = new Scanner(System.in);\n       String word = s.nextLine();\n       System.out.println(\"Is \"+word+\" palindrome? - \"+isWordPalindrome(word));\n   } \n   \n   \n   public static boolean isWordPalindrome(String word){ \n       String reverseWord = getReverseWord(word); \n       //if word equals its reverse, then it is a palindrome\n       if(word.equals(reverseWord)){ \n           return true; \n       } \n       return false; \n   } \n   \n   public static String getReverseWord(String word){ \n       if(word == null || word.isEmpty()){ \n           return word; \n       } \n       \n       return word.charAt(word.length()- 1) + getReverseWord(word.substring(0, word.length() - 1)); \n   } \n} /*\n* Java program to check if a given inputted string is palindrome or not using recursion.\n*/\nimport java.util.*;\npublic class InterviewBit { \n   public static void main(String args[]) { \n       Scanner s = new Scanner(System.in);\n       String word = s.nextLine();\n       System.out.println(\"Is \"+word+\" palindrome? - \"+isWordPalindrome(word));\n   } \n   \n   \n   public static boolean isWordPalindrome(String word){ \n       String reverseWord = getReverseWord(word); \n       //if word equals its reverse, then it is a palindrome\n       if(word.equals(reverseWord)){ \n           return true; \n       } \n       return false; \n   } \n   \n   public static String getReverseWord(String word){ \n       if(word == null || word.isEmpty()){ \n           return word; \n       } \n       \n       return word.charAt(word.length()- 1) + getReverseWord(word.substring(0, word.length() - 1)); \n   } \n} /*\n* Java program to check if a given inputted string is palindrome or not using recursion.\n*/ import public class InterviewBit class InterviewBit public static void main(String args[]) public static void main (String args[]) new \"Is \" \" palindrome? - \" public static boolean isWordPalindrome(String word) public static boolean isWordPalindrome (String word) //if word equals its reverse, then it is a palindrome if return true return false public static String getReverseWord(String word) public static getReverseWord (String word) if null return return 1 0 1",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Write a Java Program to print Fibonacci Series using Recursion.",
        "answer": "class InterviewBit {\n    public static void printFibonacci(int val_1, int val_2, int num){\n        //Base Case\n        if(num == 0)\n            return;\n\n        //Printing the next Fibonacci number    \n        System.out.print( val_1 + val_2 + \" \");\n\n        //Recursively calling for printing Fibonacci for remaining length\n        printFibonacci(val_2, val_1+val_2, --num);\n    }\n    public static void main(String args[]) {\n        System.out.println(\" *** Fibonacci Series *** \");\n\n        //Printing the first two values\n        System.out.print(\"0 1 \");\n\n        //Calling Method to print the fibonacci for length 10\n        printFibonacci(0, 1, 10);\n    }\n} class InterviewBit {\n    public static void printFibonacci(int val_1, int val_2, int num){\n        //Base Case\n        if(num == 0)\n            return;\n\n        //Printing the next Fibonacci number    \n        System.out.print( val_1 + val_2 + \" \");\n\n        //Recursively calling for printing Fibonacci for remaining length\n        printFibonacci(val_2, val_1+val_2, --num);\n    }\n    public static void main(String args[]) {\n        System.out.println(\" *** Fibonacci Series *** \");\n\n        //Printing the first two values\n        System.out.print(\"0 1 \");\n\n        //Calling Method to print the fibonacci for length 10\n        printFibonacci(0, 1, 10);\n    }\n} class InterviewBit class InterviewBit public static void printFibonacci(int val_1, int val_2, int num) public static void printFibonacci (int val_1, int val_2, int num) int int int //Base Case if 0 return //Printing the next Fibonacci number \" \" //Recursively calling for printing Fibonacci for remaining length public static void main(String args[]) public static void main (String args[]) \" *** Fibonacci Series *** \" //Printing the first two values \"0 1 \" //Calling Method to print the fibonacci for length 10 0 1 10 In the above code, we are printing the base 2 Fibonacci values 0 and 1. And then based on the length of Fibonacci to be printed, we are using the helper function to print that.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Write a Java program to check if the two strings are anagrams.",
        "answer": "The main idea is to validate the length of strings and then if found equal, convert the string to char array and then sort the arrays and check if both are equal. import java.util.Arrays;\nimport java.util.Scanner;\npublic class InterviewBit {\n public static void main(String[] args) {\n   Scanner s = new Scanner(System.in);\n   //Input from two strings\n   System.out.print(\"First String: \");\n   String string1 = s.nextLine();\n   System.out.print(\"Second String: \");\n   String string2 = s.nextLine();\n   // check for the length\n   if(string1.length() == string2.length()) {\n     // convert strings to char array\n     char[] characterArray1 = string1.toCharArray();\n     char[] characterArray2 = string2.toCharArray();\n     // sort the arrays\n     Arrays.sort(characterArray1);\n     Arrays.sort(characterArray2);\n     // check for equality, if found equal then anagram, else not an anagram\n     boolean isAnagram = Arrays.equals(characterArray1, characterArray2);\n     System.out.println(\"Anagram: \"+ isAnagram);\n }\n} import java.util.Arrays;\nimport java.util.Scanner;\npublic class InterviewBit {\n public static void main(String[] args) {\n   Scanner s = new Scanner(System.in);\n   //Input from two strings\n   System.out.print(\"First String: \");\n   String string1 = s.nextLine();\n   System.out.print(\"Second String: \");\n   String string2 = s.nextLine();\n   // check for the length\n   if(string1.length() == string2.length()) {\n     // convert strings to char array\n     char[] characterArray1 = string1.toCharArray();\n     char[] characterArray2 = string2.toCharArray();\n     // sort the arrays\n     Arrays.sort(characterArray1);\n     Arrays.sort(characterArray2);\n     // check for equality, if found equal then anagram, else not an anagram\n     boolean isAnagram = Arrays.equals(characterArray1, characterArray2);\n     System.out.println(\"Anagram: \"+ isAnagram);\n }\n} import import public class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) new //Input from two strings \"First String: \" \"Second String: \" // check for the length if // convert strings to char array char char // sort the arrays // check for equality, if found equal then anagram, else not an anagram boolean \"Anagram: \"",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Write a Java Program to find the factorial of a given number.",
        "answer": "public class FindFactorial {\n   public static void main(String[] args) {\n       int num = 10;\n       long factorialResult = 1l;\n       for(int i = 1; i <= num; ++i)\n       {\n           factorialResult *= i;\n       }\n       System.out.println(\"Factorial: \"+factorialResult);\n   }\n} public class FindFactorial {\n   public static void main(String[] args) {\n       int num = 10;\n       long factorialResult = 1l;\n       for(int i = 1; i <= num; ++i)\n       {\n           factorialResult *= i;\n       }\n       System.out.println(\"Factorial: \"+factorialResult);\n   }\n} public class FindFactorial class FindFactorial public static void main(String[] args) public static void main (String[] args) int 10 long 1l for int 1 \"Factorial: \"",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Given an array of non-duplicating numbers from 1 to n where one number is missing, write an efficient java program to find that missing number.",
        "answer": "Idea is to find the sum of n natural numbers using the formula and then finding the sum of numbers in the given array. Subtracting these two sums results in the number that is the actual missing number. This results in O(n) time complexity and O(1) space complexity. public class IBMissingNumberProblem {\n\n   public static void main(String[] args) {\n\n       int[] array={4,3,8,7,5,2,6};\n       int missingNumber = findMissingNum(array);\n       System.out.println(\"Missing Number is \"+ missingNumber); \n   }\n\n   public static int findMissingNum(int[] array) {\n       int n=array.length+1;\n       int sumOfFirstNNums=n*(n+1)/2;\n       int actualSumOfArr=0;\n       for (int i = 0; i < array.length; i++) {\n           actualSumOfArr+=array[i];\n       }\n       return sumOfFirstNNums-actualSumOfArr;\n   }\n} public class IBMissingNumberProblem {\n\n   public static void main(String[] args) {\n\n       int[] array={4,3,8,7,5,2,6};\n       int missingNumber = findMissingNum(array);\n       System.out.println(\"Missing Number is \"+ missingNumber); \n   }\n\n   public static int findMissingNum(int[] array) {\n       int n=array.length+1;\n       int sumOfFirstNNums=n*(n+1)/2;\n       int actualSumOfArr=0;\n       for (int i = 0; i < array.length; i++) {\n           actualSumOfArr+=array[i];\n       }\n       return sumOfFirstNNums-actualSumOfArr;\n   }\n} public class IBMissingNumberProblem class IBMissingNumberProblem public static void main(String[] args) public static void main (String[] args) int 4 3 8 7 5 2 6 int \"Missing Number is \" public static int findMissingNum(int[] array) public static int findMissingNum (int[] array) int int 1 int 1 2 int 0 for int 0 return",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Write a Java Program to check if any number is a magic number or not. A number is said to be a magic number if after doing sum of digits in each step and inturn doing sum of digits of that sum, the ultimate result (when there is only one digit left) is 1.",
        "answer": "Example, consider the number: Step 1: 163 => 1+6+3 = 10\nStep 2: 10 => 1+0 = 1 => Hence 163 is a magic number Step 1: 163 => 1+6+3 = 10 Step 2: 10 => 1+0 = 1 => Hence 163 is a magic number public class IBMagicNumber{\n\n   public static void main(String[] args) { \n       int num = 163;  \n       int sumOfDigits = 0;\n       while (num > 0 || sumOfDigits > 9) \n       { \n           if (num == 0) \n           { \n               num = sumOfDigits; \n               sumOfDigits = 0; \n           } \n           sumOfDigits += num % 10; \n           num /= 10; \n       } \n\n       // If sum is 1, original number is magic number \n       if(sumOfDigits == 1) {\n           System.out.println(\"Magic number\");\n       }else {\n           System.out.println(\"Not magic number\");\n       }\n   }\n} public class IBMagicNumber{\n\n   public static void main(String[] args) { \n       int num = 163;  \n       int sumOfDigits = 0;\n       while (num > 0 || sumOfDigits > 9) \n       { \n           if (num == 0) \n           { \n               num = sumOfDigits; \n               sumOfDigits = 0; \n           } \n           sumOfDigits += num % 10; \n           num /= 10; \n       } \n\n       // If sum is 1, original number is magic number \n       if(sumOfDigits == 1) {\n           System.out.println(\"Magic number\");\n       }else {\n           System.out.println(\"Not magic number\");\n       }\n   }\n} public class IBMagicNumber class IBMagicNumber public static void main(String[] args) public static void main (String[] args) int 163 int 0 while 0 9 if 0 0 10 10 // If sum is 1, original number is magic number if 1 \"Magic number\" else \"Not magic number\"",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. Write a Java program to create and throw custom exceptions.",
        "answer": "class InterviewBit {\n    public static void main(String args[]) throws CustomException {\n\n        // Throwing the custom exception be passing the message\n        throw new CustomException(\" This is my custom Exception \");\n    }\n}\n//Creating Custom Exception Class\nclass CustomException extends Exception{\n    //Defining Constructor to throw exception message\n    public CustomException(String message){\n        super(message);\n    }\n} class InterviewBit {\n    public static void main(String args[]) throws CustomException {\n\n        // Throwing the custom exception be passing the message\n        throw new CustomException(\" This is my custom Exception \");\n    }\n}\n//Creating Custom Exception Class\nclass CustomException extends Exception{\n    //Defining Constructor to throw exception message\n    public CustomException(String message){\n        super(message);\n    }\n} class InterviewBit class InterviewBit public static void main(String args[]) throws CustomException public static void main (String args[]) throws // Throwing the custom exception be passing the message throw new \" This is my custom Exception \" //Creating Custom Exception Class class CustomException extends Exception class CustomException extends Exception //Defining Constructor to throw exception message public CustomException(String message) public CustomException (String message) super We have created the exception class named with CustomException and called the base exception constructor with the error message that we want to print. And to avoid handling exceptions in the main method, we have used the throws keyword in the method declaration.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. Write a Java program to reverse a string.",
        "answer": "class InterviewBit{\n    public static void main(String[] args){\n        //Input String\n        String str = \"Welcome to InterviewBit\";\n        \n        //Pointers.\n        int i = 0, j = str.length()-1;\n        \n        //Result character array to store the reversed string.\n        char[] revString = new char[j+1];\n        \n        //Looping and reversing the string.\n        while(i < j){\n            revString[j] = str.charAt(i);\n            revString[i] = str.charAt(j);\n            i++;\n            j--;\n        }\n        //Printing the reversed String.\n        System.out.println(\"Reversed String = \" + String.valueOf(revString));\n    }\n} class InterviewBit{\n    public static void main(String[] args){\n        //Input String\n        String str = \"Welcome to InterviewBit\";\n        \n        //Pointers.\n        int i = 0, j = str.length()-1;\n        \n        //Result character array to store the reversed string.\n        char[] revString = new char[j+1];\n        \n        //Looping and reversing the string.\n        while(i < j){\n            revString[j] = str.charAt(i);\n            revString[i] = str.charAt(j);\n            i++;\n            j--;\n        }\n        //Printing the reversed String.\n        System.out.println(\"Reversed String = \" + String.valueOf(revString));\n    }\n} class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) //Input String \"Welcome to InterviewBit\" //Pointers. int 0 1 //Result character array to store the reversed string. char new char 1 //Looping and reversing the string. while //Printing the reversed String. \"Reversed String = \" In the above code, we are storing the last character from the string to the first and the first value to the last in the output character array. And doing the same thing in the loop for the remaining 2nd to n-1 characters. This is how the string will be reversed.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. Write a Java program to rotate arrays 90 degree clockwise by taking matrices from user input.",
        "answer": "mport java.util.Scanner;\npublic class InterviewBit\n{\n    public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   int no;\n        System.out.print(\"Enter size of Array : \");\n        no = sc.nextInt();\n        int[][] a = new int[no][no];\n        System.out.print(\"Enter  \"+ no*no+\" Element Array : \");\n        \n        for(int i = 0; i<no; i++){\n            for(int j = 0; j<no; j++){\n                a[i][j] = sc.nextInt();\n            }\n        }\n        System.out.print(\"\\nArray Before Rotation\\n\\n\");\n        for(int i = 0; i<no; i++){\n            for(int j = 0; j<no; j++){\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    \n        System.out.println(\"\\n\");\n        //Rotation\n        \n        //Transpose\n        for(int i = 0; i < no; i++){\n            for(int j = i; j < no; j++){\n                int temp = a[i][j];\n                a[i][j] = a[j][i];\n                a[j][i] = temp;\n            }\n        }\n        \n        //Reverse Each row\n        for(int i = 0; i < no; i++){\n            int l, j;\n            for(j = 0, l = no -1; j < l; j++){\n                int temp = a[i][j];\n                a[i][j] = a[i][l];\n                a[i][l] = temp;\n                l--;\n            }\n        }\n        \n        System.out.println(\"Array After Rotation - \\n\");\n    \n        for(int i = 0; i<no; i++){\n            for(int j = 0; j<no; j++){\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n} mport java.util.Scanner;\npublic class InterviewBit\n{\n    public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   int no;\n        System.out.print(\"Enter size of Array : \");\n        no = sc.nextInt();\n        int[][] a = new int[no][no];\n        System.out.print(\"Enter  \"+ no*no+\" Element Array : \");\n        \n        for(int i = 0; i<no; i++){\n            for(int j = 0; j<no; j++){\n                a[i][j] = sc.nextInt();\n            }\n        }\n        System.out.print(\"\\nArray Before Rotation\\n\\n\");\n        for(int i = 0; i<no; i++){\n            for(int j = 0; j<no; j++){\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    \n        System.out.println(\"\\n\");\n        //Rotation\n        \n        //Transpose\n        for(int i = 0; i < no; i++){\n            for(int j = i; j < no; j++){\n                int temp = a[i][j];\n                a[i][j] = a[j][i];\n                a[j][i] = temp;\n            }\n        }\n        \n        //Reverse Each row\n        for(int i = 0; i < no; i++){\n            int l, j;\n            for(j = 0, l = no -1; j < l; j++){\n                int temp = a[i][j];\n                a[i][j] = a[i][l];\n                a[i][l] = temp;\n                l--;\n            }\n        }\n        \n        System.out.println(\"Array After Rotation - \\n\");\n    \n        for(int i = 0; i<no; i++){\n            for(int j = 0; j<no; j++){\n                System.out.print(a[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n} public class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) new int \"Enter size of Array : \" int new int \"Enter  \" \" Element Array : \" for int 0 for int 0 \"\\nArray Before Rotation\\n\\n\" for int 0 for int 0 \" \" \"\\n\" //Rotation //Transpose for int 0 for int int //Reverse Each row for int 0 int for 0 1 int \"Array After Rotation - \\n\" for int 0 for int 0 \" \" In the above code, for rotating the matrix to  90 degrees we are first transposing the matrix so the row becomes the column. And after that, we are reversing each row in the matrix. So this is how the matrix got rotated.",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Write a java program to check if any number given as input is the sum of 2 prime numbers.",
        "answer": "Example : Example : Input - 18 Input - 18 Output - Output - 18 = 13 + 5\n18 = 11 + 7 18 = 13 + 5  18 = 11 + 7 public class InterviewBit\n{\n    // Method to Check Prime Number\n    private static int check_prime(int num){\n        int flag = 0;\n        for(int i = 2; i<=num/2; i++){\n            if(num%i == 0){\n                flag = 1;\n                return 1;\n            }\n        }\n        if(flag == 0)\n            return 0;\n        return 1;\n    }\n    // Method to get print the prime sum\n    private static void find(int num){\n        for(int i = 2; i <= num/2; i++){\n            if(check_prime(i) == 0){\n                if(check_prime(num-i) == 0)\n                    System.out.println(num + \" = \"+ (num-i) + \" \"+ i);\n            }\n        }\n    }\n public static void main(String[] args) {\n  find(18);\n }\n} public class InterviewBit\n{\n    // Method to Check Prime Number\n    private static int check_prime(int num){\n        int flag = 0;\n        for(int i = 2; i<=num/2; i++){\n            if(num%i == 0){\n                flag = 1;\n                return 1;\n            }\n        }\n        if(flag == 0)\n            return 0;\n        return 1;\n    }\n    // Method to get print the prime sum\n    private static void find(int num){\n        for(int i = 2; i <= num/2; i++){\n            if(check_prime(i) == 0){\n                if(check_prime(num-i) == 0)\n                    System.out.println(num + \" = \"+ (num-i) + \" \"+ i);\n            }\n        }\n    }\n public static void main(String[] args) {\n  find(18);\n }\n} public class InterviewBit class InterviewBit // Method to Check Prime Number private static int check_prime(int num) private static int check_prime (int num) int int 0 for int 2 2 if 0 1 return 1 if 0 return 0 return 1 // Method to get print the prime sum private static void find(int num) private static void find (int num) int for int 2 2 if 0 if 0 \" = \" \" \" public static void main(String[] args) public static void main (String[] args) 18 In the above code, for any number n, we find all the 2 pairs of numbers that are added together resulting in n. And each checking number if it is prime. If it is prime then we are printing that. n n",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. Write a Java program for solving the Tower of Hanoi Problem.",
        "answer": "public class InterviewBit\n{\n    //Recursive Method for Solving the Tower of hanoi.\n    private static void TOH(char source, char auxiliary, char destination, int numOfDisk){\n     if (numOfDisk > 0){\n      TOH(source, destination, auxiliary, numOfDisk-1);\n      System.out.println(\"Move 1 disk from \"+source+\" to \"+destination+\" using \"+auxiliary+\".\");\n      TOH(auxiliary, source, destination, numOfDisk-1);\n     }\n    }\n public static void main(String[] args) {\n  TOH('A','B','C', 3);\n }\n} public class InterviewBit\n{\n    //Recursive Method for Solving the Tower of hanoi.\n    private static void TOH(char source, char auxiliary, char destination, int numOfDisk){\n     if (numOfDisk > 0){\n      TOH(source, destination, auxiliary, numOfDisk-1);\n      System.out.println(\"Move 1 disk from \"+source+\" to \"+destination+\" using \"+auxiliary+\".\");\n      TOH(auxiliary, source, destination, numOfDisk-1);\n     }\n    }\n public static void main(String[] args) {\n  TOH('A','B','C', 3);\n }\n} public class InterviewBit class InterviewBit //Recursive Method for Solving the Tower of hanoi. private static void TOH(char source, char auxiliary, char destination, int numOfDisk) private static void TOH (char source, char auxiliary, char destination, int numOfDisk) char char char int if 0 1 \"Move 1 disk from \" \" to \" \" using \" \".\" 1 public static void main(String[] args) public static void main (String[] args) 'A' 'B' 'C' 3 In the above code we are first moving the n-1 disk from Tower A to Tower B, then moving that nth disk from Tower A to Tower C, and finally, the remaining n-1 disk from Tower B to Tower C. And we are doing this recursively for the n-1 disk. n-1 A B nth A C n-1 B C n-1",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. Implement Binary Search in Java using recursion.",
        "answer": "public class Main\n{\n    //Recursive method for binary search\n    private static boolean binarySearch(int[] arr, int low, int high, int key){\n       \n        //Calculating Mid.\n        int mid = (low + high)/2;\n       \n        //Base Case.\n        if(low > high)\n            return false;\n       \n        //Checking if the key is found in the middle.\n        if(arr[mid] == key)\n            return true;\n       \n        //Searching on the left half if a key exists there.  \n        if(key < arr[mid])\n            return binarySearch(arr, low, mid-1, key);\n       \n        //Searching on the other half otherwise.\n        return binarySearch(arr, mid+1, high, key);\n    }\npublic static void main(String[] args) {\n   \n   int[] arr = {2, 5, 9, 13, 17, 21, 30};\n   if(binarySearch(arr, 0, (arr.length-1), 30))\n       System.out.println(\" Element Found. \");\n   else\n       System.out.println(\" Element not Found.\");\n}\n} public class Main\n{\n    //Recursive method for binary search\n    private static boolean binarySearch(int[] arr, int low, int high, int key){\n       \n        //Calculating Mid.\n        int mid = (low + high)/2;\n       \n        //Base Case.\n        if(low > high)\n            return false;\n       \n        //Checking if the key is found in the middle.\n        if(arr[mid] == key)\n            return true;\n       \n        //Searching on the left half if a key exists there.  \n        if(key < arr[mid])\n            return binarySearch(arr, low, mid-1, key);\n       \n        //Searching on the other half otherwise.\n        return binarySearch(arr, mid+1, high, key);\n    }\npublic static void main(String[] args) {\n   \n   int[] arr = {2, 5, 9, 13, 17, 21, 30};\n   if(binarySearch(arr, 0, (arr.length-1), 30))\n       System.out.println(\" Element Found. \");\n   else\n       System.out.println(\" Element not Found.\");\n}\n} public class Main class Main //Recursive method for binary search private static boolean binarySearch(int[] arr, int low, int high, int key) private static boolean binarySearch (int[] arr, int low, int high, int key) int int int int //Calculating Mid. int 2 //Base Case. if return false //Checking if the key is found in the middle. if return true //Searching on the left half if a key exists there. if return 1 //Searching on the other half otherwise. return 1 public static void main(String[] args) public static void main (String[] args) int 2 5 9 13 17 21 30 if 0 1 30 \" Element Found. \" else \" Element not Found.\" In the above code, we are finding the middle element each time and checking if the element is in the middle or not. If it is not, then we check on which side from the middle it exists. And Recursively searching on the particular subarray. So this way we are reducing the search space by 2 every time. So the search time is very low.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Conclusion",
        "answer": "Java is one of the simple high-level languages that provides powerful tools and impressive standards required for application development. It was also one of the first languages to provide amazing threading support for tackling concurrency-based problems. The easy-to-use syntax and the built-in features of Java combined with the stability it provides to applications are the main reasons for this language has ever-growing usage in the software community. features of Java Interview Preparation Resources How to Become a Java Developer?\nHow much does a Java Developer earn in India?\nJava Projects\nJava Programming Questions for Interview\nJava 8 Interview Questions\nJava String Interview Questions\nSpring Interview Questions\nHibernate Interview Questions\nJava Collections Interview Questions\nArray Interview Questions\nDesign Patterns Interview Questions\nMultithreading Interview Questions\nJava Tutorial\nJava MCQ\nAdvance Java MCQ\nDifference Between C++ and Java\nDifference Between C and Java\nDifference Between Java and Javascript\nHashmap vs Hashtable in Java\nKotlin Vs Java\nJava Vs Python\nFeatures of Java 9\nJava 8 Features\nJava Frameworks\nJava Developer Skills\nJava IDE\nJava 11 Features\nAdditional Technical Interview Questions\nJAVA SE Download How to Become a Java Developer? How to Become a Java Developer? How much does a Java Developer earn in India? How much does a Java Developer earn in India? Java Projects Java Projects Java Programming Questions for Interview Java Programming Questions for Interview Java 8 Interview Questions Java 8 Interview Questions Java String Interview Questions Java String Interview Questions Spring Interview Questions Spring Interview Questions Hibernate Interview Questions Hibernate Interview Questions Java Collections Interview Questions Java Collections Interview Questions Array Interview Questions Array Interview Questions Design Patterns Interview Questions Design Patterns Interview Questions Multithreading Interview Questions Multithreading Interview Questions Java Tutorial Java Tutorial Java MCQ Java MCQ Advance Java MCQ Advance Java MCQ Difference Between C++ and Java Difference Between C++ and Java Difference Between C and Java Difference Between C and Java Difference Between Java and Javascript Difference Between Java and Javascript Hashmap vs Hashtable in Java Hashmap vs Hashtable in Java Kotlin Vs Java Kotlin Vs Java Java Vs Python Java Vs Python Features of Java 9 Features of Java 9 Java 8 Features Java 8 Features Java Frameworks Java Frameworks Java Developer Skills Java Developer Skills Java IDE Java IDE Java 11 Features Java 11 Features Additional Technical Interview Questions Additional Technical Interview Questions JAVA SE Download JAVA SE Download",
        "reference": "interviewbit.com"
    }
]