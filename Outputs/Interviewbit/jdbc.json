[
    {
        "question": "1. What is Rowset?",
        "answer": "A RowSet is an object that encapsulates a row set from either JDBC result sets or tabular data sources such as files or spreadsheets. It supports component-based development models like JavaBeans, with the help of a standard set of properties and event notifications.\nThe advantages of using RowSet are:\nIt is easier and flexible to use.\nIt is Scrollable and Updatable by default. A RowSet is an object that encapsulates a row set from either JDBC result sets or tabular data sources such as files or spreadsheets. It supports component-based development models like JavaBeans, with the help of a standard set of properties and event notifications. The advantages of using RowSet are:\nIt is easier and flexible to use.\nIt is Scrollable and Updatable by default. It is easier and flexible to use.\nIt is Scrollable and Updatable by default. It is easier and flexible to use. It is Scrollable and Updatable by default.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What is ResultSet?",
        "answer": "The java.sql.ResultSet interface represents the database result set, which is obtained after the execution of SQL query using Statement objects.\nObject of ResultSet maintains a cursor pointing to the current row of data in the result set. Initially, the cursor is located before the first row. Then the cursor is moved to the next row by using the next() method. The next() method can be used to iterate through the result set with the help of a while loop. If there are no further rows, the next() method will return false.\nExample for the creation of ResultSet is given below:\nResultSet rs = con.executeQuery(sqlQuery); The java.sql.ResultSet interface represents the database result set, which is obtained after the execution of SQL query using Statement objects. java.sql.ResultSet Object of ResultSet maintains a cursor pointing to the current row of data in the result set. Initially, the cursor is located before the first row. Then the cursor is moved to the next row by using the next() method. The next() method can be used to iterate through the result set with the help of a while loop. If there are no further rows, the next() method will return false. next() next() next() Example for the creation of ResultSet is given below:\nResultSet rs = con.executeQuery(sqlQuery);  ResultSet rs = con.executeQuery(sqlQuery);",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What is JDBC driver?",
        "answer": "JDBC driver is a software component having various classes and interfaces, that enables the Java application to interact with a database. To connect with individual databases, JDBC requires particular drivers for each specific database. These drivers are provided by the database vendor in addition to the database. For example: MySQL Connector/J is the official JDBC driver for MySQL and we can locate the mysql-connector-java-<version>-bin.jar file among the installed files. On windows, this file can be obtained at MySQL Connector/J is the official JDBC driver for MySQL and we can locate the mysql-connector-java-<version>-bin.jar file among the installed files. On windows, this file can be obtained at mysql-connector-java-<version>-bin.jar C:\\Program Files (x86)\\MySQL\\MySQL Connector J\\mysql-connector-java-5.1.30-bin.jar. C:\\Program Files (x86)\\MySQL\\MySQL Connector J\\mysql-connector-java-5.1.30-bin.jar. JDBC driver of Oracle 10G is ojdbc14.jar and it can be obtained in the installation directory of an Oracle at \u2026/Oracle/app/oracle/product/10.2.0/server/jdbc/lib . JDBC driver of Oracle 10G is ojdbc14.jar and it can be obtained in the installation directory of an Oracle at \u2026/Oracle/app/oracle/product/10.2.0/server/jdbc/lib . \u2026/Oracle/app/oracle/product/10.2.0/server/jdbc/lib JDBC driver provides the connection to the database. Also, it implements the protocol for sending the query and result between client and database.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What is DriverManager in JDBC?",
        "answer": "JDBC DriverManager is a static class in Java, through which we manage the set of JDBC drivers that are available for an application to use.\nMultiple JDBC drivers can be used concurrently by an application, if necessary. By using a Uniform Resource Locator(URL), each application specifies a JDBC driver.\nWhen we load the JDBC Driver class into an application, it registers itself to the DriverManager by using Class.forName() or DriverManager.registerDriver(). To check this, you can have a look into the source code of JDBC Driver classes. After this, when we call DriverManager.getConnection() method by passing the details regarding database configuration, DriverManager will make use of registered drivers to obtain the connection and return it to the caller program. JDBC DriverManager is a static class in Java, through which we manage the set of JDBC drivers that are available for an application to use. Multiple JDBC drivers can be used concurrently by an application, if necessary. By using a Uniform Resource Locator(URL), each application specifies a JDBC driver. When we load the JDBC Driver class into an application, it registers itself to the DriverManager by using Class.forName() or DriverManager.registerDriver(). To check this, you can have a look into the source code of JDBC Driver classes. After this, when we call DriverManager.getConnection() method by passing the details regarding database configuration, DriverManager will make use of registered drivers to obtain the connection and return it to the caller program. Class.forName() DriverManager.registerDriver() DriverManager.getConnection()",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Which JDBC driver is fastest and used more commonly?",
        "answer": "JDBC Net pure Java driver(Type 4 driver) is the fastest driver for localhost and remote connections because it directly interacts with the database by converting the JDBC calls into vendor-specific protocol calls. JDBC Net pure Java driver(Type 4 driver",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Which data types are used for storing the image and file in the database table?",
        "answer": "BLOB data type is used to store the image in the database. We can also store videos and audio by using the BLOB data type. It stores the binary type of data.\nCLOB data type is used to store the file in the database. It stores the character type of data. BLOB data type is used to store the image in the database. We can also store videos and audio by using the BLOB data type. It stores the binary type of data. BLOB CLOB data type is used to store the file in the database. It stores the character type of data. CLOB",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What is stored procedure? What are the parameter types in stored procedure?",
        "answer": "Stored procedure is a group of SQL queries that are executed as a single logical unit to perform a specific task. Name of the procedure should be unique since each procedure is represented by its name.\nFor example, operations on an employee database like obtaining information about an employee could be coded as stored procedures that will be executed by an application. Code for creating a stored procedure named GET_EMP_DETAILS is given below: Stored procedure is a group of SQL queries that are executed as a single logical unit to perform a specific task. Name of the procedure should be unique since each procedure is represented by its name. For example, operations on an employee database like obtaining information about an employee could be coded as stored procedures that will be executed by an application. Code for creating a stored procedure named GET_EMP_DETAILS is given below: DELIMITER $$\nDROP PROCEDURE IF EXISTS `EMP`.`GET_EMP_DETAILS` $$\nCREATE PROCEDURE `EMP`.`GET_EMP_DETAILS` \n  (IN EMP_ID INT, OUT EMP_DETAILS VARCHAR(255))\nBEGIN\n  SELECT first INTO EMP_DETAILS\n  FROM Employees\n  WHERE ID = EMP_ID;\nEND $$\nDELIMITER ; DELIMITER $$\nDROP PROCEDURE IF EXISTS `EMP`.`GET_EMP_DETAILS` $$\nCREATE PROCEDURE `EMP`.`GET_EMP_DETAILS` \n  (IN EMP_ID INT, OUT EMP_DETAILS VARCHAR(255))\nBEGIN\n  SELECT first INTO EMP_DETAILS\n  FROM Employees\n  WHERE ID = EMP_ID;\nEND $$\nDELIMITER ; Stored procedures are called using CallableStatement class available in JDBC API. Below given code demonstrates this: CallableStatement cs = con.prepareCall(\"{call GET_EMP_DETAILS(?,?)}\");\nResultSet rs = cs.executeQuery(); CallableStatement cs = con.prepareCall(\"{call GET_EMP_DETAILS(?,?)}\");\nResultSet rs = cs.executeQuery(); Three types of parameters are provided in the stored procedures. They are:\nIN: It is used for passing the input values to the procedure. With the help of setXXX() methods, you can bind values to IN parameters.\nOUT: It is used for getting the value from the procedure. With the help of getXXX() methods, you can obtain values from OUT parameters.\nIN/OUT: It is used for passing the input values and obtaining the value to/from the procedure. You bind variable values with the setXXX() methods and obtain values with the getXXX() methods. Three types of parameters are provided in the stored procedures. They are:\nIN: It is used for passing the input values to the procedure. With the help of setXXX() methods, you can bind values to IN parameters.\nOUT: It is used for getting the value from the procedure. With the help of getXXX() methods, you can obtain values from OUT parameters.\nIN/OUT: It is used for passing the input values and obtaining the value to/from the procedure. You bind variable values with the setXXX() methods and obtain values with the getXXX() methods. IN: It is used for passing the input values to the procedure. With the help of setXXX() methods, you can bind values to IN parameters.\nOUT: It is used for getting the value from the procedure. With the help of getXXX() methods, you can obtain values from OUT parameters.\nIN/OUT: It is used for passing the input values and obtaining the value to/from the procedure. You bind variable values with the setXXX() methods and obtain values with the getXXX() methods. IN: It is used for passing the input values to the procedure. With the help of setXXX() methods, you can bind values to IN parameters. IN OUT: It is used for getting the value from the procedure. With the help of getXXX() methods, you can obtain values from OUT parameters. OUT IN/OUT: It is used for passing the input values and obtaining the value to/from the procedure. You bind variable values with the setXXX() methods and obtain values with the getXXX() methods. IN/OUT",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What do you mean by DatabaseMetaData and why we are using it?",
        "answer": "DatabaseMetaData is an interface that provides methods to obtain information about the database.\nWe can use this for getting database-related informations, such as database name, database version, driver name, the total number of tables or views, etc. DatabaseMetaData is an interface that provides methods to obtain information about the database. We can use this for getting database-related informations, such as database name, database version, driver name, the total number of tables or views, etc.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What are the differences between ODBC and JDBC?",
        "answer": "ODBC(Open Database Connectivity) JDBC(Java Database Connectivity)\nODBC can be used for languages like C, C++, Java, etc. JDBC is used only for the Java language\nWe can use ODBC only for the Windows platform, thus it is platform-dependent. We can use JDBC on any platform, thus it is platform-independent\nMost of the ODBC Drivers developed in native languages like C, C++ JDBC drivers are developed using the Java language\nIt is not recommended to use ODBC for Java applications, because of low performance due to internal conversion. It is highly recommended to use JDBC for Java applications because there are no performance issues.\nODBC is procedural. JDBC is Object Oriented. ODBC(Open Database Connectivity) JDBC(Java Database Connectivity)\nODBC can be used for languages like C, C++, Java, etc. JDBC is used only for the Java language\nWe can use ODBC only for the Windows platform, thus it is platform-dependent. We can use JDBC on any platform, thus it is platform-independent\nMost of the ODBC Drivers developed in native languages like C, C++ JDBC drivers are developed using the Java language\nIt is not recommended to use ODBC for Java applications, because of low performance due to internal conversion. It is highly recommended to use JDBC for Java applications because there are no performance issues.\nODBC is procedural. JDBC is Object Oriented. ODBC(Open Database Connectivity) JDBC(Java Database Connectivity) ODBC(Open Database Connectivity) JDBC(Java Database Connectivity) ODBC(Open Database Connectivity) JDBC(Java Database Connectivity) ODBC can be used for languages like C, C++, Java, etc. JDBC is used only for the Java language\nWe can use ODBC only for the Windows platform, thus it is platform-dependent. We can use JDBC on any platform, thus it is platform-independent\nMost of the ODBC Drivers developed in native languages like C, C++ JDBC drivers are developed using the Java language\nIt is not recommended to use ODBC for Java applications, because of low performance due to internal conversion. It is highly recommended to use JDBC for Java applications because there are no performance issues.\nODBC is procedural. JDBC is Object Oriented. ODBC can be used for languages like C, C++, Java, etc. JDBC is used only for the Java language ODBC can be used for languages like C, C++, Java, etc. JDBC is used only for the Java language We can use ODBC only for the Windows platform, thus it is platform-dependent. We can use JDBC on any platform, thus it is platform-independent We can use ODBC only for the Windows platform, thus it is platform-dependent. We can use JDBC on any platform, thus it is platform-independent Most of the ODBC Drivers developed in native languages like C, C++ JDBC drivers are developed using the Java language Most of the ODBC Drivers developed in native languages like C, C++ JDBC drivers are developed using the Java language It is not recommended to use ODBC for Java applications, because of low performance due to internal conversion. It is highly recommended to use JDBC for Java applications because there are no performance issues. It is not recommended to use ODBC for Java applications, because of low performance due to internal conversion. It is highly recommended to use JDBC for Java applications because there are no performance issues. ODBC is procedural. JDBC is Object Oriented. ODBC is procedural. JDBC is Object Oriented.",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. What is JDBC in Java?",
        "answer": "JDBC(Java Database Connectivity) is a Java API, which is helpful in interaction with the database to retrieve, manipulate and process the data using SQL. It will make use of JDBC drivers for connecting with the database. By using JDBC, we can access tabular data stored in various types of relational databases such as Oracle, MySQL, MS Access, etc.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. What are the types of JDBC architecture?",
        "answer": "JDBC supports 2 types of processing models to access the database. They are: Two-tier Architecture: Here Java programs are explicitly connected with the database. It doesn\u2019t require any mediator such as an application server for connecting with the database except the JDBC driver. It is also called client-server architecture. Two-tier Architecture: Here Java programs are explicitly connected with the database. It doesn\u2019t require any mediator such as an application server for connecting with the database except the JDBC driver. It is also called client-server architecture. Two-tier Architecture:   Three-tier Architecture: It is the complete opposite of two-tier architecture. There will be no explicit communication between the JDBC driver or Java application and the database. It will make use of an application server as a mediator between them. Java code will send the request to an application server, then the server will send it to the database and receive the response from the database. Three-tier Architecture: It is the complete opposite of two-tier architecture. There will be no explicit communication between the JDBC driver or Java application and the database. It will make use of an application server as a mediator between them. Java code will send the request to an application server, then the server will send it to the database and receive the response from the database. Three-tier Architecture  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Explain the types of RowSet available in JDBC.",
        "answer": "A RowSet is an object that encapsulates a set of rows from JDBC result sets or tabular data sources.\nThere are five types of RowSet interfaces available in JDBC. They are:  JDBCRowSet: It is a connected RowSet, which is having a live connection to the database, and all calls on this are percolated to the mapping call in the JDBC connection, result set, or statement. The Oracle implementation of JDBCRowSet is done by using oracle.jdbc.rowset.OracleJDBCRowSet .\nCachedRowSet: It is a RowSet in which the rows are cached and RowSet is disconnected, which means it does not maintain an active database connection. The oracle.jdbc.rowset.OracleCachedRowSet class is used as the Oracle implementation of CachedRowSet.\nWebRowSet: It is an extension to CachedRowSet and it represents a set of fetched rows of tabular data that can be passed between tiers and components so that no active data source connections need to be maintained.\nIt provides support for the production and consumption of result sets and their synchronization with the data source, both in XML(Extensible Markup Language) format and in a disconnected fashion. This permits result sets to be transmitted across tiers and over Internet protocols. The Oracle implementation of WebRowSet is done by using oracle.jdbc.rowset.OracleWebRowSet .\nFilteredRowSet: It\u2019s an extension to WebRowSet and gives programmatic support to filter its content. This enables you to avoid the difficulty of query supply and processing involved. The Oracle implementation of FilteredRowSet is done by using oracle.jdbc.rowset.OracleFilteredRowSet .\nJoinRowSet: It\u2019s an extension to WebRowSet and consists of related data from various RowSets. There is no standard way to establish a SQL JOIN operation between disconnected RowSets without a data source connection. A JoinRowSet addresses this problem. The Oracle implementation of JoinRowSet is done by using oracle.jdbc.rowset.OracleJoinRowSet class. JDBCRowSet: It is a connected RowSet, which is having a live connection to the database, and all calls on this are percolated to the mapping call in the JDBC connection, result set, or statement. The Oracle implementation of JDBCRowSet is done by using oracle.jdbc.rowset.OracleJDBCRowSet . JDBCRowSet oracle.jdbc.rowset.OracleJDBCRowSet CachedRowSet: It is a RowSet in which the rows are cached and RowSet is disconnected, which means it does not maintain an active database connection. The oracle.jdbc.rowset.OracleCachedRowSet class is used as the Oracle implementation of CachedRowSet. CachedRowSet oracle.jdbc.rowset.OracleCachedRowSet WebRowSet: It is an extension to CachedRowSet and it represents a set of fetched rows of tabular data that can be passed between tiers and components so that no active data source connections need to be maintained.\nIt provides support for the production and consumption of result sets and their synchronization with the data source, both in XML(Extensible Markup Language) format and in a disconnected fashion. This permits result sets to be transmitted across tiers and over Internet protocols. The Oracle implementation of WebRowSet is done by using oracle.jdbc.rowset.OracleWebRowSet . WebRowSet  oracle.jdbc.rowset.OracleWebRowSet FilteredRowSet: It\u2019s an extension to WebRowSet and gives programmatic support to filter its content. This enables you to avoid the difficulty of query supply and processing involved. The Oracle implementation of FilteredRowSet is done by using oracle.jdbc.rowset.OracleFilteredRowSet . FilteredRowSet oracle.jdbc.rowset.OracleFilteredRowSet JoinRowSet: It\u2019s an extension to WebRowSet and consists of related data from various RowSets. There is no standard way to establish a SQL JOIN operation between disconnected RowSets without a data source connection. A JoinRowSet addresses this problem. The Oracle implementation of JoinRowSet is done by using oracle.jdbc.rowset.OracleJoinRowSet class. JoinRowSet oracle.jdbc.rowset.OracleJoinRowSet",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Explain the usage of the getter and setter methods in ResultSet.",
        "answer": "Getter methods: These are used for retrieving the particular column values of the table from ResultSet. As a parameter, either the column index value or column name should be passed. Usually, the getter method is represented as getXXX() methods.\nExample:\nint getInt(string Column_Name) Getter methods: These are used for retrieving the particular column values of the table from ResultSet. As a parameter, either the column index value or column name should be passed. Usually, the getter method is represented as getXXX() methods.\nExample:\nint getInt(string Column_Name) Getter methods:   int getInt(string Column_Name) The above statement is used to retrieve the value of the specified column Index and the return type is an int data type. Setter Methods: These methods are used to set the value in the database. It is almost similar to getter methods, but here it requires to pass the data/values for the particular column to insert into the database and the column name or index value of that column. Usually, setter method is represented as setXXX() methods.\nExample:\nvoid setInt(int Column_Index, int Data_Value) Setter Methods: These methods are used to set the value in the database. It is almost similar to getter methods, but here it requires to pass the data/values for the particular column to insert into the database and the column name or index value of that column. Usually, setter method is represented as setXXX() methods.\nExample:\nvoid setInt(int Column_Index, int Data_Value) Setter Methods:   void setInt(int Column_Index, int Data_Value) The above statement is used to insert the value of the specified column Index with an int value.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What is meant by a locking system in JDBC?",
        "answer": "If two users are viewing the same record, then there is no issue, and locking will not be done. If one user is updating a record and the second user also wants to update the same record, in this situation, we are going to use locking so that there will be no lost update.\nTwo types of locking are available in JDBC by which we can handle multiple user issues using the record. They are:\nOptimistic Locking: It will lock the record only when an update takes place. This type of locking will not make use of exclusive locks when reading or selecting the record.\nPessimistic Locking: It will lock the record as soon as it selects the row to update. The strategy of this locking system guarantees that the changes are made safely and consistently. If two users are viewing the same record, then there is no issue, and locking will not be done. If one user is updating a record and the second user also wants to update the same record, in this situation, we are going to use locking so that there will be no lost update. Two types of locking are available in JDBC by which we can handle multiple user issues using the record. They are:\nOptimistic Locking: It will lock the record only when an update takes place. This type of locking will not make use of exclusive locks when reading or selecting the record.\nPessimistic Locking: It will lock the record as soon as it selects the row to update. The strategy of this locking system guarantees that the changes are made safely and consistently. Optimistic Locking: It will lock the record only when an update takes place. This type of locking will not make use of exclusive locks when reading or selecting the record.\nPessimistic Locking: It will lock the record as soon as it selects the row to update. The strategy of this locking system guarantees that the changes are made safely and consistently. Optimistic Locking: It will lock the record only when an update takes place. This type of locking will not make use of exclusive locks when reading or selecting the record. Optimistic Locking: Pessimistic Locking: It will lock the record as soon as it selects the row to update. The strategy of this locking system guarantees that the changes are made safely and consistently. Pessimistic Locking:",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What is database connection pooling? What are the advantages of connection pool?",
        "answer": "Connection pooling means database connections will be stored in the cache and can be reused when future requests to the database are required. So in this mechanism, the client need not make new connections every time for interacting with the database. Instead of that, connection objects are stored in the connection pool and the client will get the connection object from there.\nAdvantages of using a connection pool are:\nIt is faster.\nEasier to diagnose and analyze database connections.\nIncreases the performance of executing commands on a database. Connection pooling means database connections will be stored in the cache and can be reused when future requests to the database are required. So in this mechanism, the client need not make new connections every time for interacting with the database. Instead of that, connection objects are stored in the connection pool and the client will get the connection object from there. Advantages of using a connection pool are:\nIt is faster.\nEasier to diagnose and analyze database connections.\nIncreases the performance of executing commands on a database. It is faster.\nEasier to diagnose and analyze database connections.\nIncreases the performance of executing commands on a database. It is faster. Easier to diagnose and analyze database connections. Increases the performance of executing commands on a database.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What is \u201cDirty read\u201d in terms of database?",
        "answer": "Dirty read implies the meaning \u201cread the value which may or may not be correct\u201d. In the database, when a transaction is executing and changing some field value, at the same time another transaction comes and reads the changed field value before the first transaction could commit or rollback the value, which may cause an invalid value for that particular field. This situation is known as a dirty read.\nConsider an example given below, where Transaction 2 changes a row but does not commit the changes made. Then Transaction 1 reads the uncommitted data. Now, if Transaction 2 goes for roll backing its changes (which is already read by Transaction 1) or updates any changes to the database, then the view of the data may be wrong in the records related to Transaction 1. But in this case, no row exists that has an id of 100 and an age of 25. Dirty read implies the meaning \u201cread the value which may or may not be correct\u201d. In the database, when a transaction is executing and changing some field value, at the same time another transaction comes and reads the changed field value before the first transaction could commit or rollback the value, which may cause an invalid value for that particular field. This situation is known as a dirty read. Consider an example given below, where Transaction 2 changes a row but does not commit the changes made. Then Transaction 1 reads the uncommitted data. Now, if Transaction 2 goes for roll backing its changes (which is already read by Transaction 1) or updates any changes to the database, then the view of the data may be wrong in the records related to Transaction 1. But in this case, no row exists that has an id of 100 and an age of 25.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What causes \u201cNo suitable driver\u201d error?",
        "answer": "\u201cNo suitable driver\u201d error occurs during a call to the DriverManager.getConnection() method, because of the following reasons: DriverManager.getConnection() Unable to load the appropriate JDBC drivers before calling the getConnection() method.\nIt can specify an invalid or wrong JDBC URL, which cannot be recognized by the JDBC driver.\nThis error may occur when one or more shared libraries required by the bridge cannot be loaded. Unable to load the appropriate JDBC drivers before calling the getConnection() method. It can specify an invalid or wrong JDBC URL, which cannot be recognized by the JDBC driver. This error may occur when one or more shared libraries required by the bridge cannot be loaded.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What is JDBC Connection? Explain steps to get JDBC database connection in a simple Java program.",
        "answer": "Loading the driver: At first, you need to load or register the driver before using it in the program. Registration must be done once in your program. You can register a driver by using any one of the two methods mentioned below: Loading the driver: Loading the driver: Class.forName(): Using this, we load the driver\u2019s class file into memory during runtime. It\u2019s not required to use a new or creation of an object. Class.forName(): Using this, we load the driver\u2019s class file into memory during runtime. It\u2019s not required to use a new or creation of an object. Class.forName() The below given example uses Class.forName() to load the Oracle driver: Class.forName(\u201coracle.jdbc.driver.OracleDriver\u201d); Class.forName(\u201coracle.jdbc.driver.OracleDriver\u201d); The MySQL Connector/J version 8.0 library comes with a JDBC driver class: com.mysql.jdbc.Driver. Before Java 6, we had to load the driver explicitly using the statement given below: Class.forName(\"com.mysql.jdbc.Driver\"); Class.forName(\"com.mysql.jdbc.Driver\"); However, this statement is no longer needed, because of a new update in JDBC 4.0 that comes from Java 6. As long as you place the MySQL JDBC driver JAR file into the classpath of your program, the driver manager can find and load the driver. DriverManager.registerDriver(): DriverManager is a built-in Java class with a static member register. Here we will be calling the constructor of the driver class during compile time. DriverManager.registerDriver(): DriverManager is a built-in Java class with a static member register. Here we will be calling the constructor of the driver class during compile time. DriverManager.registerDriver() The below given example uses DriverManager.registerDriver() to register the Oracle driver: DriverManager.registerDriver() DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver()); DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver()); For registering the MySQL driver, use the below-given code: DriverManager.registerDriver(new com.mysql.jdbc.Driver(); ); DriverManager.registerDriver(new com.mysql.jdbc.Driver(); ); Create the connections: Create the connections: Create the connections: After loading the driver into the program, establish connections using the code given below: After loading the driver into the program, establish connections using the code given below: Connection con = DriverManager.getConnection(url,user,password); Connection con = DriverManager.getConnection(url,user,password); Here, con: Reference to a Connection interface. url: Uniform Resource Locator. user: Username from which SQL command prompt is accessed. password: Password from which SQL command prompt is accessed. Url in Oracle can be created as follows: Url in Oracle can be created as follows: String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; Where oracle represents the database used, thin is the driver used, @localhost is the IP(Internet Protocol) address where the database is stored, 1521 is the port number and xe represents the service provider. All 3 parameters given above are of string type and are expected to be declared by the programmer before the function call. Use of this can be referred from the final code of an application. Url in MySQL can be created as follows: Url in MySQL can be created as follows: String url = \"jdbc:mysql://localhost:3306/test1\"; String url = \"jdbc:mysql://localhost:3306/test1\"; Where localhost represents hostname or IP address of the MySQL server, 3306 port number of the server and by default, it is 3306, test1 is the name of the database on the server. Create a statement: Create a statement: Create a statement: Once a connection establishment is done, you can interact with the database. The Statement, PreparedStatement, and CallableStatement JDBC interfaces will define the methods that permit you to send SQL commands and receive data from the database.\nWe can use JDBC Statement as follows: Once a connection establishment is done, you can interact with the database. The Statement, PreparedStatement, and CallableStatement JDBC interfaces will define the methods that permit you to send SQL commands and receive data from the database. We can use JDBC Statement as follows: Statement st = con.createStatement(); Statement st = con.createStatement(); Here, con is a reference to the Connection interface used in the earlier step. Execute the query: Execute the query Execute the query Here, query means an SQL query. We can have various types of queries. A few of them are as follows:\nQuery for updating or inserting a table in a database.\nQuery for data retrieval.\nThe executeQuery() method that belongs to the Statement interface is used for executing queries related to values retrieval from the database. This method returns the ResultSet object which can be used to get all the table records.\nThe executeUpdate(sql_query) method of the Statement interface is used for executing queries related to the update/insert operation. Here, query means an SQL query. We can have various types of queries. A few of them are as follows:\nQuery for updating or inserting a table in a database.\nQuery for data retrieval. Query for updating or inserting a table in a database.\nQuery for data retrieval. Query for updating or inserting a table in a database. Query for data retrieval. The executeQuery() method that belongs to the Statement interface is used for executing queries related to values retrieval from the database. This method returns the ResultSet object which can be used to get all the table records. The executeUpdate(sql_query) method of the Statement interface is used for executing queries related to the update/insert operation. Example: int m = st.executeUpdate(sql);\n   if (m==1)\n       System.out.println(\"Data inserted successfully : \"+sql);\n   else\n       System.out.println(\"Data insertion failed\"); int m = st.executeUpdate(sql);\n   if (m==1)\n       System.out.println(\"Data inserted successfully : \"+sql);\n   else\n       System.out.println(\"Data insertion failed\"); Here SQL is the SQL query of string type. Close the connection: Close the connection: Close the connection: So finally we have sent the data to the location specified and now we are at the end of our task completion.\nOn connection closing, objects of Statement and ResultSet will be automatically closed. The close() method of the Connection interface is used for closing the connection. So finally we have sent the data to the location specified and now we are at the end of our task completion. On connection closing, objects of Statement and ResultSet will be automatically closed. The close() method of the Connection interface is used for closing the connection. Example: con.close(); con.close(); Implementation of JDBC Oracle database connection using a Java program: Implementation of JDBC Oracle database connection using a Java program: import java.sql.*;\nimport java.util.*;\nclass OracleCon\n{\n   public static void main(String a[])\n   {\n       //Creating the connection\n       String url = \"jdbc:oracle:thin:@localhost:1521:xe\";\n       String user = \"system\";\n       String password = \"123\";\n\n       //Entering the data\n       Scanner k = new Scanner(System.in);\n       System.out.println(\"Enter employee Id\");\n       int empid = k.nextInt();\n       System.out.println(\"Enter employee name\");\n       String empname = k.next();\n       System.out.println(\"Enter employee address\");\n       String address =  k.next();\n\n       //Inserting data using SQL query\n       String sql = \"insert into employee values(\"+empid+\",'\"+empname+\"','\"+address+\"')\";\n       Connection con=null;\n       try\n       {\n           DriverManager.registerDriver(new oracle.jdbc.OracleDriver());\n\n           //Reference to connection interface\n           con = DriverManager.getConnection(url,user,password);\n\n           Statement st = con.createStatement();\n           int m = st.executeUpdate(sql);\n           if (m == 1)\n               System.out.println(\"Data inserted successfully : \"+sql);\n           else\n               System.out.println(\"Data insertion failed\");\n           con.close();\n       }\n       catch(Exception ex)\n       {\n           System.err.println(ex);\n       }\n   }\n} import java.sql.*;\nimport java.util.*;\nclass OracleCon\n{\n   public static void main(String a[])\n   {\n       //Creating the connection\n       String url = \"jdbc:oracle:thin:@localhost:1521:xe\";\n       String user = \"system\";\n       String password = \"123\";\n\n       //Entering the data\n       Scanner k = new Scanner(System.in);\n       System.out.println(\"Enter employee Id\");\n       int empid = k.nextInt();\n       System.out.println(\"Enter employee name\");\n       String empname = k.next();\n       System.out.println(\"Enter employee address\");\n       String address =  k.next();\n\n       //Inserting data using SQL query\n       String sql = \"insert into employee values(\"+empid+\",'\"+empname+\"','\"+address+\"')\";\n       Connection con=null;\n       try\n       {\n           DriverManager.registerDriver(new oracle.jdbc.OracleDriver());\n\n           //Reference to connection interface\n           con = DriverManager.getConnection(url,user,password);\n\n           Statement st = con.createStatement();\n           int m = st.executeUpdate(sql);\n           if (m == 1)\n               System.out.println(\"Data inserted successfully : \"+sql);\n           else\n               System.out.println(\"Data insertion failed\");\n           con.close();\n       }\n       catch(Exception ex)\n       {\n           System.err.println(ex);\n       }\n   }\n} import import class OracleCon class OracleCon public static void main(String a[]) public static void main (String a[]) //Creating the connection \"jdbc:oracle:thin:@localhost:1521:xe\" \"system\" \"123\" //Entering the data new \"Enter employee Id\" int \"Enter employee name\" \"Enter employee address\" //Inserting data using SQL query \"insert into employee values(\" \",'\" \"','\" \"')\" null try new //Reference to connection interface int if 1 \"Data inserted successfully : \" else \"Data insertion failed\" catch Implementation of JDBC MySQL database connection using Java program: Implementation of JDBC MySQL database connection using Java program: import java.sql.*;  \nclass MysqlCon\n{  \n   public static void main(String args[])\n   {  \n        //Creating the connection\n       String url = \"jdbc:mysql://localhost:3306/test1\";\n       String user = \"system\";\n       String password = \"123\";\n       try\n       {  \n           Class.forName(\"com.mysql.jdbc.Driver\");\n           \n            //Reference to connection interface\n           Connection con=DriverManager.getConnection(url,user,password);\n           \n           Statement st = con.createStatement();  \n           \n           //Displaying all the records of employee table\n           ResultSet rs = st.executeQuery(\"select * from employee\");  \n           while(rs.next())  \n               System.out.println(rs.getInt(1)+\" \"+rs.getString(2)+\" \"+rs.getString(3));  \n           con.close();  \n       }\n       catch(Exception e)\n       { \n           System.out.println(e);\n       }  \n   }  \n} import java.sql.*;  \nclass MysqlCon\n{  \n   public static void main(String args[])\n   {  \n        //Creating the connection\n       String url = \"jdbc:mysql://localhost:3306/test1\";\n       String user = \"system\";\n       String password = \"123\";\n       try\n       {  \n           Class.forName(\"com.mysql.jdbc.Driver\");\n           \n            //Reference to connection interface\n           Connection con=DriverManager.getConnection(url,user,password);\n           \n           Statement st = con.createStatement();  \n           \n           //Displaying all the records of employee table\n           ResultSet rs = st.executeQuery(\"select * from employee\");  \n           while(rs.next())  \n               System.out.println(rs.getInt(1)+\" \"+rs.getString(2)+\" \"+rs.getString(3));  \n           con.close();  \n       }\n       catch(Exception e)\n       { \n           System.out.println(e);\n       }  \n   }  \n} import class MysqlCon class MysqlCon public static void main(String args[]) public static void main (String args[]) //Creating the connection \"jdbc:mysql://localhost:3306/test1\" \"system\" \"123\" try \"com.mysql.jdbc.Driver\" //Reference to connection interface //Displaying all the records of employee table \"select * from employee\" while 1 \" \" 2 \" \" 3 catch",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. How to use JDBC API to call Stored procedures?",
        "answer": "Stored procedures are a set of SQL queries that are compiled in the database and will be executed from JDBC API. For executing Stored procedures in the database, JDBC CallableStatement can be used. The syntax for initializing a CallableStatement is: CallableStatement cs = con.prepareCall(\"{call insertEmployee(?,?,?,?,?)}\");\nstmt.setInt(1, id);\nstmt.setString(2, name);\nstmt.setString(3, role);\nstmt.setString(4, address);\nstmt.setString(5, salary);\n//registering the OUT parameter before calling the stored procedure\ncs.registerOutParameter(5, java.sql.Types.VARCHAR);\n            \ncs.executeUpdate(); CallableStatement cs = con.prepareCall(\"{call insertEmployee(?,?,?,?,?)}\");\nstmt.setInt(1, id);\nstmt.setString(2, name);\nstmt.setString(3, role);\nstmt.setString(4, address);\nstmt.setString(5, salary);\n//registering the OUT parameter before calling the stored procedure\ncs.registerOutParameter(5, java.sql.Types.VARCHAR);\n            \ncs.executeUpdate(); We must register the OUT parameters before executing the CallableStatement.",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Explain the difference between execute(), executeQuery() and executeUpdate() methods in JDBC.",
        "answer": "execute()  executeQuery()  executeUpdate()\nIt can be used for any SQL statements. It is used to execute SQL Select queries. It is used to execute the SQL statements such as Insert/Update/Delete which will update or modify the database data.\nIt returns the boolean value TRUE if the result is a ResultSet object and FALSE when there is no ResultSet object. It returns the ResultSet object which contains the data retrieved by the SELECT statement. It returns an integer value which represents the number of affected rows where 0 indicates that the query returns null.\nUsed for executing both SELECT and non-SELECT queries. Used for executing only the SELECT Query. Used for executing only a non-SELECT query. execute()  executeQuery()  executeUpdate()\nIt can be used for any SQL statements. It is used to execute SQL Select queries. It is used to execute the SQL statements such as Insert/Update/Delete which will update or modify the database data.\nIt returns the boolean value TRUE if the result is a ResultSet object and FALSE when there is no ResultSet object. It returns the ResultSet object which contains the data retrieved by the SELECT statement. It returns an integer value which represents the number of affected rows where 0 indicates that the query returns null.\nUsed for executing both SELECT and non-SELECT queries. Used for executing only the SELECT Query. Used for executing only a non-SELECT query. execute()  executeQuery()  executeUpdate() execute()  executeQuery()  executeUpdate() execute() executeQuery() executeUpdate() It can be used for any SQL statements. It is used to execute SQL Select queries. It is used to execute the SQL statements such as Insert/Update/Delete which will update or modify the database data.\nIt returns the boolean value TRUE if the result is a ResultSet object and FALSE when there is no ResultSet object. It returns the ResultSet object which contains the data retrieved by the SELECT statement. It returns an integer value which represents the number of affected rows where 0 indicates that the query returns null.\nUsed for executing both SELECT and non-SELECT queries. Used for executing only the SELECT Query. Used for executing only a non-SELECT query. It can be used for any SQL statements. It is used to execute SQL Select queries. It is used to execute the SQL statements such as Insert/Update/Delete which will update or modify the database data. It can be used for any SQL statements. It is used to execute SQL Select queries. It is used to execute the SQL statements such as Insert/Update/Delete which will update or modify the database data. It returns the boolean value TRUE if the result is a ResultSet object and FALSE when there is no ResultSet object. It returns the ResultSet object which contains the data retrieved by the SELECT statement. It returns an integer value which represents the number of affected rows where 0 indicates that the query returns null. It returns the boolean value TRUE if the result is a ResultSet object and FALSE when there is no ResultSet object. It returns the ResultSet object which contains the data retrieved by the SELECT statement. It returns an integer value which represents the number of affected rows where 0 indicates that the query returns null. Used for executing both SELECT and non-SELECT queries. Used for executing only the SELECT Query. Used for executing only a non-SELECT query. Used for executing both SELECT and non-SELECT queries. Used for executing only the SELECT Query. Used for executing only a non-SELECT query. The execute() method is used in the situations when you are not sure about the type of statement else you can use executeQuery() or executeUpdate() method.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. What is JDBC Transaction Management and why is it needed?",
        "answer": "The sequence of actions (SQL statements) served as a single unit that is called a transaction. Transaction Management places an important role in RDBMS-oriented applications to maintain data consistency and integrity.\nTransaction Management can be described well \u2013 by using ACID properties. ACID stands for Atomicity, Consistency, Isolation, and Durability.\nAtomicity - If all queries are successfully executed, then only data will be committed to the database.\nConsistency - It ensures bringing the database into a consistent state after any transaction.\nIsolation - It ensures that the transaction is isolated from other transactions.\nDurability - If a transaction has been committed once, it will remain always committed, even in the situation of errors, power loss, etc.\nNeed for Transaction Management:\nWhen creating a connection to the database, the auto-commit mode will be selected by default. This implies that every time when the request is executed, it will be committed automatically upon completion.\nWe might want to commit the transaction after the execution of few more SQL statements. In such a situation, we must set the auto-commit value to False. So that data will not be able to commit before executing all the queries. In case if we get an exception in the transaction, we can rollback() changes made and make it like before. The sequence of actions (SQL statements) served as a single unit that is called a transaction. Transaction Management places an important role in RDBMS-oriented applications to maintain data consistency and integrity. Transaction Management can be described well \u2013 by using ACID properties. ACID stands for Atomicity, Consistency, Isolation, and Durability.\nAtomicity - If all queries are successfully executed, then only data will be committed to the database.\nConsistency - It ensures bringing the database into a consistent state after any transaction.\nIsolation - It ensures that the transaction is isolated from other transactions.\nDurability - If a transaction has been committed once, it will remain always committed, even in the situation of errors, power loss, etc. Atomicity - If all queries are successfully executed, then only data will be committed to the database.\nConsistency - It ensures bringing the database into a consistent state after any transaction.\nIsolation - It ensures that the transaction is isolated from other transactions.\nDurability - If a transaction has been committed once, it will remain always committed, even in the situation of errors, power loss, etc. Atomicity - If all queries are successfully executed, then only data will be committed to the database. Atomicity Consistency - It ensures bringing the database into a consistent state after any transaction. Consistency Isolation - It ensures that the transaction is isolated from other transactions. Isolation Durability - If a transaction has been committed once, it will remain always committed, even in the situation of errors, power loss, etc. Durability Need for Transaction Management:\nWhen creating a connection to the database, the auto-commit mode will be selected by default. This implies that every time when the request is executed, it will be committed automatically upon completion.\nWe might want to commit the transaction after the execution of few more SQL statements. In such a situation, we must set the auto-commit value to False. So that data will not be able to commit before executing all the queries. In case if we get an exception in the transaction, we can rollback() changes made and make it like before.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. Explain the benefits of PreparedStatement over Statement.",
        "answer": "Benefits of PreparedStatement over Statement interface are: It performs faster compared to the Statement because the Statement needs to be compiled each time when we run the code whereas the PreparedStatement is compiled once and then executed only on runtime.\nIt can execute parametrized queries. But Statement can only run static queries.\nThe query used in PreparedStatement looks similar each time, so the database can reuse the previous access plan. Statement inline the parameters into the string, so the query doesn\u2019t look to be the same every time which prevents reusage of cache. It performs faster compared to the Statement because the Statement needs to be compiled each time when we run the code whereas the PreparedStatement is compiled once and then executed only on runtime. It can execute parametrized queries. But Statement can only run static queries. The query used in PreparedStatement looks similar each time, so the database can reuse the previous access plan. Statement inline the parameters into the string, so the query doesn\u2019t look to be the same every time which prevents reusage of cache.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. Explain the methods available for Transaction Management in JDBC.",
        "answer": "The connection interface is having 5 methods for transaction management. They are given below: setAutoCommit() method:\nThe value of AutoCommit is set to TR\nUE by default. After the SQL statement execution, it will be committed automatically. By using this method we can set the value for AutoCommit.\nSyntax: conn.setAutoCommit(boolean_value)\nHere, boolean_value is set to TRUE for enabling autocommit mode for the connection, FALSE for disabling it.\nCommit() method:\nThe commit() method is used for committing the data. After the SQL statement execution, we can call the commit() method. It will commit the changes made by the SQL statement.\nSyntax: conn.commit();\nRollback() method:\nThe rollback() method is used to undo the changes made till the last commit has occurred. If we face any problem or exception in the SQL statements execution flow, we may roll back the transaction.\nSyntax: conn.rollback();\nsetSavepoint() method:\nIf you have set a savepoint in the transaction (a group of SQL statements), you can use the rollback() method to undo all the changes till the savepoint or after the savepoint(), if something goes wrong within the current transaction. The setSavepoint() method is used to create a new savepoint which refers to the current state of the database within the transaction.\nSyntax:  Savepoint sp= conn.setSavepoint(\"MysavePoint\")\nreleaseSavepoint() method:\nIt is used for deleting or releasing the created savepoint.\nSyntax: conn.releaseSavepoint(\"MysavePoint\"); setAutoCommit() method:\nThe value of AutoCommit is set to TR\nUE by default. After the SQL statement execution, it will be committed automatically. By using this method we can set the value for AutoCommit.\nSyntax: conn.setAutoCommit(boolean_value)\nHere, boolean_value is set to TRUE for enabling autocommit mode for the connection, FALSE for disabling it. setAutoCommit() method:    conn.setAutoCommit(boolean_value)  Commit() method:\nThe commit() method is used for committing the data. After the SQL statement execution, we can call the commit() method. It will commit the changes made by the SQL statement.\nSyntax: conn.commit(); Commit() method:   conn.commit(); Rollback() method:\nThe rollback() method is used to undo the changes made till the last commit has occurred. If we face any problem or exception in the SQL statements execution flow, we may roll back the transaction.\nSyntax: conn.rollback(); Rollback() method:   conn.rollback(); setSavepoint() method:\nIf you have set a savepoint in the transaction (a group of SQL statements), you can use the rollback() method to undo all the changes till the savepoint or after the savepoint(), if something goes wrong within the current transaction. The setSavepoint() method is used to create a new savepoint which refers to the current state of the database within the transaction.\nSyntax:  Savepoint sp= conn.setSavepoint(\"MysavePoint\") setSavepoint() method:   Savepoint sp= conn.setSavepoint(\"MysavePoint\") releaseSavepoint() method:\nIt is used for deleting or releasing the created savepoint.\nSyntax: conn.releaseSavepoint(\"MysavePoint\"); releaseSavepoint() method:   conn.releaseSavepoint(\"MysavePoint\");",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. Give few examples of most common exceptions in JDBC.",
        "answer": "Some of the most common JDBC exceptions are given below: java.sql.SQLException - It is the base class for JDBC exceptions.\njava.sql.BatchUpdateException \u2013 It occurs during the batch update operation. May depend on the JDBC driver type that the base SQLException may throw instead.\njava.sql.SQLWarning \u2013 It is displayed as a warning message of various SQL operations.\njava.sql.DataTruncation \u2013 This exception occurs when data values are unexpectedly truncated due to reasons independent of exceeding MaxFieldSize. java.sql.SQLException - It is the base class for JDBC exceptions. java.sql.SQLException java.sql.BatchUpdateException \u2013 It occurs during the batch update operation. May depend on the JDBC driver type that the base SQLException may throw instead. java.sql.BatchUpdateException java.sql.SQLWarning \u2013 It is displayed as a warning message of various SQL operations. java.sql.SQLWarning java.sql.DataTruncation \u2013 This exception occurs when data values are unexpectedly truncated due to reasons independent of exceeding MaxFieldSize. java.sql.DataTruncation",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What is Two phase commit in JDBC?",
        "answer": "Two-phase commit is useful for a distributed environment where numerous processes take part in the distributed transaction process. In simpler words, we can say that, if a transaction is executing and it is affecting multiple databases then a two-phase commit will be used to make sure that all databases are synchronized with each other.\nIn two-phase commit, commit or rollback is performed by two phases given below:\nCommit request phase: In this phase, the main process or co-ordinator process take a vote of all other process that they have completed their process successfully and ready to commit, if all the votes are \u201cyes\u201d then they continue for the next phase. And if \u201cNo\u201d then rollback will be performed.\nCommit phase: As per vote, if all the votes are \u201cyes\u201d then commit is done.\nIn the same way, when any transaction changes multiple databases after transaction execution, it will issue a pre-commit command on each database and all databases will send an acknowledgment. Based on acknowledgment, if all are positive transactions then it will issue the commit command otherwise rollback will be done. Two-phase commit is useful for a distributed environment where numerous processes take part in the distributed transaction process. In simpler words, we can say that, if a transaction is executing and it is affecting multiple databases then a two-phase commit will be used to make sure that all databases are synchronized with each other. In two-phase commit, commit or rollback is performed by two phases given below:\nCommit request phase: In this phase, the main process or co-ordinator process take a vote of all other process that they have completed their process successfully and ready to commit, if all the votes are \u201cyes\u201d then they continue for the next phase. And if \u201cNo\u201d then rollback will be performed.\nCommit phase: As per vote, if all the votes are \u201cyes\u201d then commit is done. Commit request phase: In this phase, the main process or co-ordinator process take a vote of all other process that they have completed their process successfully and ready to commit, if all the votes are \u201cyes\u201d then they continue for the next phase. And if \u201cNo\u201d then rollback will be performed.\nCommit phase: As per vote, if all the votes are \u201cyes\u201d then commit is done. Commit request phase: In this phase, the main process or co-ordinator process take a vote of all other process that they have completed their process successfully and ready to commit, if all the votes are \u201cyes\u201d then they continue for the next phase. And if \u201cNo\u201d then rollback will be performed. Commit request phase Commit phase: As per vote, if all the votes are \u201cyes\u201d then commit is done. Commit phase In the same way, when any transaction changes multiple databases after transaction execution, it will issue a pre-commit command on each database and all databases will send an acknowledgment. Based on acknowledgment, if all are positive transactions then it will issue the commit command otherwise rollback will be done.",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. What are the isolation levels of connections in JDBC?",
        "answer": "The transaction isolation level is a value that decides the level at which inconsistent data is permitted in a transaction, which means it represents the degree of isolation of one transaction from another. A higher level of isolation will result in improvement of data accuracy, but it might decrease the number of concurrent transactions. Similarly, a lower level of isolation permits for more concurrent transactions, but it reduces the data accuracy.\nTo ensure data integrity during transactions in JDBC, the DBMS make use of locks to prevent access to other accesses to the data which is involved in the transaction. Such locks are necessary for preventing Dirty Read, Non-Repeatable Read, and Phantom-Read in the database.\nIt is used for the locking mechanism by DBMS and can be set using setTransactionIsolation() method. You can obtain details about the level of isolation used by the connection using getTransactionIsolation() method. The transaction isolation level is a value that decides the level at which inconsistent data is permitted in a transaction, which means it represents the degree of isolation of one transaction from another. A higher level of isolation will result in improvement of data accuracy, but it might decrease the number of concurrent transactions. Similarly, a lower level of isolation permits for more concurrent transactions, but it reduces the data accuracy. To ensure data integrity during transactions in JDBC, the DBMS make use of locks to prevent access to other accesses to the data which is involved in the transaction. Such locks are necessary for preventing Dirty Read, Non-Repeatable Read, and Phantom-Read in the database. It is used for the locking mechanism by DBMS and can be set using setTransactionIsolation() method. You can obtain details about the level of isolation used by the connection using getTransactionIsolation() method.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. How to create a table dynamically from a JDBC application?",
        "answer": "We can dynamically create a table by using the following code: //import section\nimport java.sql.*;\nimport java.io.*;\npublic class CreateTableEx\n{\n public static void main(String[] args)throws Exception\n {\n   //create an objet of buffered reader\n   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n   //load and register the driver\n   Class.forName(\u201csun.jdbc.odbc.JdbcOdbcDriver\u201d);\n   //establish a connection\n   Connection con = DriverManager.getConnection(\u201cjdbc:odbc:nag\u201d,\u201dsystem\u201d,\u201dnaveen\u201d);\n   //create a statement object\n   Statement st = con.createStatement();\n   //receive dynamic input as a table name\n   System.out.println(\u201cEnter table name\u201d);\n   String tablename = br.readLine();\n   //execute SQL query\n   St.executeUpdate(\"create table\"+tablename+\"(empno number,empname varchar2(10),empsalary number,empaddress varchar2(20))\");\n   System.out.println(\u201cSuccessfully created the table\u201d);\n   //close the connection\n   con.close();\n }\n} //import section\nimport java.sql.*;\nimport java.io.*;\npublic class CreateTableEx\n{\n public static void main(String[] args)throws Exception\n {\n   //create an objet of buffered reader\n   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n   //load and register the driver\n   Class.forName(\u201csun.jdbc.odbc.JdbcOdbcDriver\u201d);\n   //establish a connection\n   Connection con = DriverManager.getConnection(\u201cjdbc:odbc:nag\u201d,\u201dsystem\u201d,\u201dnaveen\u201d);\n   //create a statement object\n   Statement st = con.createStatement();\n   //receive dynamic input as a table name\n   System.out.println(\u201cEnter table name\u201d);\n   String tablename = br.readLine();\n   //execute SQL query\n   St.executeUpdate(\"create table\"+tablename+\"(empno number,empname varchar2(10),empsalary number,empaddress varchar2(20))\");\n   System.out.println(\u201cSuccessfully created the table\u201d);\n   //close the connection\n   con.close();\n }\n} //import section import import public class CreateTableEx class CreateTableEx public static void main(String[] args)throws Exception public static void main (String[] args) throws //create an objet of buffered reader new new //load and register the driver //establish a connection //create a statement object //receive dynamic input as a table name //execute SQL query \"create table\" \"(empno number,empname varchar2(10),empsalary number,empaddress varchar2(20))\" //close the connection",
        "reference": "interviewbit.com"
    },
    {
        "question": "18. Conclusion",
        "answer": "This article covers freshers to experienced level interview questions on JDBC. We hope that this will give you an overview of JDBC interview questions. JDBC questions are an important part of any Java interview, whether it is a core Java or Java EE Interview. The explanations given in this article will enrich your knowledge and increase your understanding of JDBC. All the Best\u2026!!! References References \u201cJDBC API Tutorial and Reference\u201d by Fisher, Maydene-Ellis, Jon-Bruce, Jonathan.\n\u201cFROM ZERO TO JDBC HERO\u201d by Vivian Siahaan, Rismon Hasiholan Sianipar.\n\u201cJDBC Pocket Reference\u201d by Donald Bales.\nhttps://docs.oracle.com/javase/tutorial/jdbc/basics/index.html\nhttps://www.youtube.com/playlist?list=PLsyeobzWxl7rU7Jz3zDRpqB-EODzBbHOI \u201cJDBC API Tutorial and Reference\u201d by Fisher, Maydene-Ellis, Jon-Bruce, Jonathan. \u201cFROM ZERO TO JDBC HERO\u201d by Vivian Siahaan, Rismon Hasiholan Sianipar. \u201cJDBC Pocket Reference\u201d by Donald Bales. https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html https://www.youtube.com/playlist?list=PLsyeobzWxl7rU7Jz3zDRpqB-EODzBbHOI https://www.youtube.com/playlist?list=PLsyeobzWxl7rU7Jz3zDRpqB-EODzBbHOI Resources JMeter Interview Questions\nTechnical Interview Questions JMeter Interview Questions JMeter Interview Questions Technical Interview Questions Technical Interview Questions",
        "reference": "interviewbit.com"
    },
    {
        "question": "19. What are the different types of JDBC drivers in Java? Explain each with an example.",
        "answer": "There are four types of JDBC drivers in Java. They are: Type I: JDBC - ODBC bridge driver\nIn this, the JDBC\u2013ODBC bridge acts as an interface between the client and database server. When a user uses a Java application to send requests to the database using JDBC\u2013ODBC bridge, it converts the JDBC API into ODBC API and then sends it to the database. When the result is received from the database, it is sent to ODBC API and then to JDBC API.\nIt is platform-dependent because it uses ODBC which depends on the native library of the operating system. In this, JDBC\u2013ODBC driver should be installed in every client system and database must support for ODBC driver.'\nIt is easier to use but it gives low performance because it involves the conversion of JDBC method calls to the ODBC method calls. Type I: JDBC - ODBC bridge driver\nIn this, the JDBC\u2013ODBC bridge acts as an interface between the client and database server. When a user uses a Java application to send requests to the database using JDBC\u2013ODBC bridge, it converts the JDBC API into ODBC API and then sends it to the database. When the result is received from the database, it is sent to ODBC API and then to JDBC API.\nIt is platform-dependent because it uses ODBC which depends on the native library of the operating system. In this, JDBC\u2013ODBC driver should be installed in every client system and database must support for ODBC driver.'\nIt is easier to use but it gives low performance because it involves the conversion of JDBC method calls to the ODBC method calls. Type I: JDBC - ODBC bridge driver In this, the JDBC\u2013ODBC bridge acts as an interface between the client and database server. When a user uses a Java application to send requests to the database using JDBC\u2013ODBC bridge, it converts the JDBC API into ODBC API and then sends it to the database. When the result is received from the database, it is sent to ODBC API and then to JDBC API.\nIt is platform-dependent because it uses ODBC which depends on the native library of the operating system. In this, JDBC\u2013ODBC driver should be installed in every client system and database must support for ODBC driver.'\nIt is easier to use but it gives low performance because it involves the conversion of JDBC method calls to the ODBC method calls. In this, the JDBC\u2013ODBC bridge acts as an interface between the client and database server. When a user uses a Java application to send requests to the database using JDBC\u2013ODBC bridge, it converts the JDBC API into ODBC API and then sends it to the database. When the result is received from the database, it is sent to ODBC API and then to JDBC API. It is platform-dependent because it uses ODBC which depends on the native library of the operating system. In this, JDBC\u2013ODBC driver should be installed in every client system and database must support for ODBC driver.' It is easier to use but it gives low performance because it involves the conversion of JDBC method calls to the ODBC method calls.   Type II: Native API \u2013 Partially Java Driver:\nIt is almost similar to a Type I driver. Here, native code replaces the ODBC part. This native code part is targeted at a particular database product. It uses libraries of the client-side of the database. This Type II Driver converts the JDBC method calls to native calls of the database native API.\nWhen the database gets the requests from the user, the requests are processed and sends the results back in the native format which is then converted into JDBC format and pass it to the Java application.\nIt was instantly adopted by the database vendors because it was quick and cheaper to implement. This driver gives faster response and performance compared to the Type I driver. Type II: Native API \u2013 Partially Java Driver:\nIt is almost similar to a Type I driver. Here, native code replaces the ODBC part. This native code part is targeted at a particular database product. It uses libraries of the client-side of the database. This Type II Driver converts the JDBC method calls to native calls of the database native API.\nWhen the database gets the requests from the user, the requests are processed and sends the results back in the native format which is then converted into JDBC format and pass it to the Java application.\nIt was instantly adopted by the database vendors because it was quick and cheaper to implement. This driver gives faster response and performance compared to the Type I driver. Type II: Native API \u2013 Partially Java Driver: It is almost similar to a Type I driver. Here, native code replaces the ODBC part. This native code part is targeted at a particular database product. It uses libraries of the client-side of the database. This Type II Driver converts the JDBC method calls to native calls of the database native API.\nWhen the database gets the requests from the user, the requests are processed and sends the results back in the native format which is then converted into JDBC format and pass it to the Java application.\nIt was instantly adopted by the database vendors because it was quick and cheaper to implement. This driver gives faster response and performance compared to the Type I driver. It is almost similar to a Type I driver. Here, native code replaces the ODBC part. This native code part is targeted at a particular database product. It uses libraries of the client-side of the database. This Type II Driver converts the JDBC method calls to native calls of the database native API. When the database gets the requests from the user, the requests are processed and sends the results back in the native format which is then converted into JDBC format and pass it to the Java application. It was instantly adopted by the database vendors because it was quick and cheaper to implement. This driver gives faster response and performance compared to the Type I driver.   Type III: Network Protocol - Fully Java Driver:\nThe type III driver is completely written in Java. It is similar to the 3-tier approach to access the database. It helps to send the JDBC method calls to an intermediate server. The intermediate server communicates with the database on behalf of JDBC. The application server converts the JDBC calls either directly or indirectly to the database protocol which is vendor-specific.\nThis approach does not increase the efficiency of architecture and it is costlier, due to this most of the database vendors don\u2019t choose this driver. You need to have good knowledge about the application server for using this approach since the application server is used here. Type III: Network Protocol - Fully Java Driver:\nThe type III driver is completely written in Java. It is similar to the 3-tier approach to access the database. It helps to send the JDBC method calls to an intermediate server. The intermediate server communicates with the database on behalf of JDBC. The application server converts the JDBC calls either directly or indirectly to the database protocol which is vendor-specific.\nThis approach does not increase the efficiency of architecture and it is costlier, due to this most of the database vendors don\u2019t choose this driver. You need to have good knowledge about the application server for using this approach since the application server is used here. Type III: Network Protocol - Fully Java Driver: The type III driver is completely written in Java. It is similar to the 3-tier approach to access the database. It helps to send the JDBC method calls to an intermediate server. The intermediate server communicates with the database on behalf of JDBC. The application server converts the JDBC calls either directly or indirectly to the database protocol which is vendor-specific.\nThis approach does not increase the efficiency of architecture and it is costlier, due to this most of the database vendors don\u2019t choose this driver. You need to have good knowledge about the application server for using this approach since the application server is used here. The type III driver is completely written in Java. It is similar to the 3-tier approach to access the database. It helps to send the JDBC method calls to an intermediate server. The intermediate server communicates with the database on behalf of JDBC. The application server converts the JDBC calls either directly or indirectly to the database protocol which is vendor-specific. This approach does not increase the efficiency of architecture and it is costlier, due to this most of the database vendors don\u2019t choose this driver. You need to have good knowledge about the application server for using this approach since the application server is used here.   Type IV: Thin Driver - Fully Java Driver\nType IV driver is directly implemented and it directly converts JDBC calls into vendor-specific database protocol. Most of the JDBC Drivers used today are type IV drivers.\nIt is platform-independent since it is written fully in Java. It can be installed inside the Java Virtual Machine(JVM) of the client, so there is no need of installing any software on the client or server side. This drive architecture is having all the logic to communicate directly with the database in a single driver.\nIt provides better performance compared to other driver types. It permits easy deployment. Nowadays, this driver is developed by the database vendor itself so that programmers can use it directly without any dependencies on other sources. Type IV: Thin Driver - Fully Java Driver\nType IV driver is directly implemented and it directly converts JDBC calls into vendor-specific database protocol. Most of the JDBC Drivers used today are type IV drivers.\nIt is platform-independent since it is written fully in Java. It can be installed inside the Java Virtual Machine(JVM) of the client, so there is no need of installing any software on the client or server side. This drive architecture is having all the logic to communicate directly with the database in a single driver.\nIt provides better performance compared to other driver types. It permits easy deployment. Nowadays, this driver is developed by the database vendor itself so that programmers can use it directly without any dependencies on other sources. Type IV: Thin Driver - Fully Java Driver Type IV driver is directly implemented and it directly converts JDBC calls into vendor-specific database protocol. Most of the JDBC Drivers used today are type IV drivers.\nIt is platform-independent since it is written fully in Java. It can be installed inside the Java Virtual Machine(JVM) of the client, so there is no need of installing any software on the client or server side. This drive architecture is having all the logic to communicate directly with the database in a single driver.\nIt provides better performance compared to other driver types. It permits easy deployment. Nowadays, this driver is developed by the database vendor itself so that programmers can use it directly without any dependencies on other sources. Type IV driver is directly implemented and it directly converts JDBC calls into vendor-specific database protocol. Most of the JDBC Drivers used today are type IV drivers. It is platform-independent since it is written fully in Java. It can be installed inside the Java Virtual Machine(JVM) of the client, so there is no need of installing any software on the client or server side. This drive architecture is having all the logic to communicate directly with the database in a single driver. It provides better performance compared to other driver types. It permits easy deployment. Nowadays, this driver is developed by the database vendor itself so that programmers can use it directly without any dependencies on other sources.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "20. What are difference between ResultSet and RowSet?",
        "answer": "ResultSet RowSet\nResultSet cannot be serialized as it handles the connection to the database. RowSet is disconnected from the database so it can be serialized.\nBy default, ResultSet object is non-scrollable and non-updatable. By default, the RowSet object is scrollable and updatable.\nResultSet object is not a JavaBean object. RowSet object is a JavaBean object.\nResultSet is returned by the executeQuery() method of Statement interface Rowset extends the ResultSet interface and it is returned by calling the RowSetProvider.newFactory().createJdbcRowSet() method.\nIt is difficult to pass ResultSet from one class to another class as it has a connection with the database. It is easier to pass RowSet from one class to another class as it has no connection with the database. ResultSet RowSet\nResultSet cannot be serialized as it handles the connection to the database. RowSet is disconnected from the database so it can be serialized.\nBy default, ResultSet object is non-scrollable and non-updatable. By default, the RowSet object is scrollable and updatable.\nResultSet object is not a JavaBean object. RowSet object is a JavaBean object.\nResultSet is returned by the executeQuery() method of Statement interface Rowset extends the ResultSet interface and it is returned by calling the RowSetProvider.newFactory().createJdbcRowSet() method.\nIt is difficult to pass ResultSet from one class to another class as it has a connection with the database. It is easier to pass RowSet from one class to another class as it has no connection with the database. ResultSet RowSet ResultSet RowSet ResultSet RowSet ResultSet cannot be serialized as it handles the connection to the database. RowSet is disconnected from the database so it can be serialized.\nBy default, ResultSet object is non-scrollable and non-updatable. By default, the RowSet object is scrollable and updatable.\nResultSet object is not a JavaBean object. RowSet object is a JavaBean object.\nResultSet is returned by the executeQuery() method of Statement interface Rowset extends the ResultSet interface and it is returned by calling the RowSetProvider.newFactory().createJdbcRowSet() method.\nIt is difficult to pass ResultSet from one class to another class as it has a connection with the database. It is easier to pass RowSet from one class to another class as it has no connection with the database. ResultSet cannot be serialized as it handles the connection to the database. RowSet is disconnected from the database so it can be serialized. ResultSet cannot be serialized as it handles the connection to the database. RowSet is disconnected from the database so it can be serialized. By default, ResultSet object is non-scrollable and non-updatable. By default, the RowSet object is scrollable and updatable. By default, ResultSet object is non-scrollable and non-updatable. By default, the RowSet object is scrollable and updatable. ResultSet object is not a JavaBean object. RowSet object is a JavaBean object. ResultSet object is not a JavaBean object. RowSet object is a JavaBean object. ResultSet is returned by the executeQuery() method of Statement interface Rowset extends the ResultSet interface and it is returned by calling the RowSetProvider.newFactory().createJdbcRowSet() method. ResultSet is returned by the executeQuery() method of Statement interface executeQuery() Rowset extends the ResultSet interface and it is returned by calling the RowSetProvider.newFactory().createJdbcRowSet() method. RowSetProvider.newFactory().createJdbcRowSet() It is difficult to pass ResultSet from one class to another class as it has a connection with the database. It is easier to pass RowSet from one class to another class as it has no connection with the database. It is difficult to pass ResultSet from one class to another class as it has a connection with the database. It is easier to pass RowSet from one class to another class as it has no connection with the database.",
        "reference": "interviewbit.com"
    },
    {
        "question": "21. Explain the types of ResultSet.",
        "answer": "ResultSet refers to the row and column data contained in a ResultSet object. The object of ResultSet maintains a cursor pointing to the current row of data in the result set.\nThere are three types of ResultSet which have constants to control the movement of the cursor in backward, forward, and in a particular row. If we do not declare any ResultSet, then by default TYPE_FORWARD_ONLY will be called.  ResultSet.TYPE_FORWARD_ONLY: Using this, the cursor can only move forward from start to end in the result set.\nResultSet.TYPE_SCROLL_INSENSITIVE: Using this, the cursor can move in both forward and backward directions. Here, the result set is insensitive to the changes done in the database by others, that occur after the result set was created.\nResultSet.TYPE_SCROLL_SENSITIVE: Using this, the cursor can move in forward and backward direction, and the result set is sensitive to changes made to the database by others, that occur after the result set was created. ResultSet.TYPE_FORWARD_ONLY: Using this, the cursor can only move forward from start to end in the result set. ResultSet.TYPE_FORWARD_ONLY ResultSet.TYPE_SCROLL_INSENSITIVE: Using this, the cursor can move in both forward and backward directions. Here, the result set is insensitive to the changes done in the database by others, that occur after the result set was created. ResultSet.TYPE_SCROLL_INSENSITIVE ResultSet.TYPE_SCROLL_SENSITIVE: Using this, the cursor can move in forward and backward direction, and the result set is sensitive to changes made to the database by others, that occur after the result set was created. ResultSet.TYPE_SCROLL_SENSITIVE",
        "reference": "interviewbit.com"
    },
    {
        "question": "22. Explain JDBC API components.",
        "answer": "The java.sql package contains different interfaces and classes for JDBC API. They are:\n\nInterfaces: java.sql   Interfaces Interfaces : Connection: The object of Connection is created by using getConnection() method of DriverManager class. DriverManager is the factory for connection.\nStatement: The object of the Statement is created by using createStatement() method of the Connection class. The Connection interface is the factory for Statement.\nPreparedStatement: The PreparedStatement object is created by using prepareStatement() method of Connection class. It is used for executing the parameterized query.\nResultSet: The ResultSet object maintains a cursor pointing to a table row. At first, the cursor points before the first row. The executeQuery() method of the Statement interface returns the object of ResultSet.\nResultSetMetaData: The ResultSetMetaData interface object contains the details about the data(table) such as number of columns, name of the column, column type etc. The getMetaData() method of ResultSet returns the ResultSetMetaData object.\nDatabaseMetaData: It is an interface that has methods to get metadata of a database, like name of the database product, version of database product, driver name, name of the total number of views, name of the total number of tables, etc. The getMetaData() method that belongs to Connection interface returns the DatabaseMetaData object.\nCallableStatement: CallableStatement interface is useful for calling the stored procedures and functions. We can have business logic on the database through the usage of stored procedures and functions, which will be helpful for the improvement in the performance as these are pre-compiled. The prepareCall() method that belongs to the Connection interface returns the object of CallableStatement. Connection: The object of Connection is created by using getConnection() method of DriverManager class. DriverManager is the factory for connection. Connection Statement: The object of the Statement is created by using createStatement() method of the Connection class. The Connection interface is the factory for Statement. Statement PreparedStatement: The PreparedStatement object is created by using prepareStatement() method of Connection class. It is used for executing the parameterized query. PreparedStatement ResultSet: The ResultSet object maintains a cursor pointing to a table row. At first, the cursor points before the first row. The executeQuery() method of the Statement interface returns the object of ResultSet. ResultSet: ResultSetMetaData: The ResultSetMetaData interface object contains the details about the data(table) such as number of columns, name of the column, column type etc. The getMetaData() method of ResultSet returns the ResultSetMetaData object. ResultSetMetaData DatabaseMetaData: It is an interface that has methods to get metadata of a database, like name of the database product, version of database product, driver name, name of the total number of views, name of the total number of tables, etc. The getMetaData() method that belongs to Connection interface returns the DatabaseMetaData object. DatabaseMetaData CallableStatement: CallableStatement interface is useful for calling the stored procedures and functions. We can have business logic on the database through the usage of stored procedures and functions, which will be helpful for the improvement in the performance as these are pre-compiled. The prepareCall() method that belongs to the Connection interface returns the object of CallableStatement. CallableStatement Classes: Classes: Classes: DriverManager: It pretends to be an interface between the user and drivers. DriverManager keeps track of the available drivers and handles establishing a connection between a database and the relevant driver. It contains various methods to keep the interaction between the user and drivers.\nBLOB: BLOB stands for Binary Large Object. It represents a collection of binary data such as images, audio, and video files, etc., which is stored as a single entity in the DBMS(Database Management System).\nCLOB: CLOB stands for Character Large Object. This data type is used by multiple database management systems to store character files. It is the same as BLOB except for the difference, instead of binary data, CLOB represents character stream data such as character files, etc. DriverManager: It pretends to be an interface between the user and drivers. DriverManager keeps track of the available drivers and handles establishing a connection between a database and the relevant driver. It contains various methods to keep the interaction between the user and drivers. DriverManager BLOB: BLOB stands for Binary Large Object. It represents a collection of binary data such as images, audio, and video files, etc., which is stored as a single entity in the DBMS(Database Management System). BLOB: CLOB: CLOB stands for Character Large Object. This data type is used by multiple database management systems to store character files. It is the same as BLOB except for the difference, instead of binary data, CLOB represents character stream data such as character files, etc. CLOB:  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "23. What are the types of JDBC statements?",
        "answer": "Statements are useful for sending SQL commands to the database and receiving data from the database. There are three types of statements in JDBC. They are: Statement: It is the factory for ResultSet. It is used for general-purpose access to the database by executing the static SQL query at runtime. Example: Statement: It is the factory for ResultSet. It is used for general-purpose access to the database by executing the static SQL query at runtime. Example: Statement: Statement st = conn.createStatement( );\nResultSet rs = st.executeQuery(); Statement st = conn.createStatement( );\nResultSet rs = st.executeQuery(); PreparedStatement: It is used when we need to give input data to the query at runtime and also if we want to execute SQL statements repeatedly. It is more efficient than a statement because it involves the pre-compilation of SQL. Example: PreparedStatement: It is used when we need to give input data to the query at runtime and also if we want to execute SQL statements repeatedly. It is more efficient than a statement because it involves the pre-compilation of SQL. Example: PreparedStatement: String SQL = \"Update item SET limit = ? WHERE itemType = ?\";\n PreparedStatement  ps = conn.prepareStatement(SQL);\n ResultSet rs = ps.executeQuery(); String SQL = \"Update item SET limit = ? WHERE itemType = ?\";\n PreparedStatement  ps = conn.prepareStatement(SQL);\n ResultSet rs = ps.executeQuery(); CallableStatement: It is used to call stored procedures on the database. It is capable of accepting runtime parameters. Example: CallableStatement: It is used to call stored procedures on the database. It is capable of accepting runtime parameters. Example: CallableStatement: CallableStatement cs = con.prepareCall(\"{call SHOW_CUSTOMERS}\");\nResultSet rs = cs.executeQuery(); CallableStatement cs = con.prepareCall(\"{call SHOW_CUSTOMERS}\");\nResultSet rs = cs.executeQuery();  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "24. Explain JDBC Batch processing.",
        "answer": "Batch processing is the process of executing multiple SQL statements in one transaction. For example, consider the case of loading data from CSV(Comma-Separated Values) files to relational database tables. Instead of using Statement or PreparedStatement, we can use Batch processing which executes the bulk of queries in a single go for a database.\nAdvantages of Batch processing:\nIt will reduce the communication time and improves performance.\nBatch processing makes it easier to process a huge amount of data and consistency of data is also maintained.\nIt is much faster than executing a single statement at a time because of the fewer number of database calls.\nHow to perform Batch processing?\nTo perform Batch processing, addBatch() and executeBatch() methods are used. These 2 methods are available in the Statement and PreparedStatement classes of JDBC API. Batch processing is the process of executing multiple SQL statements in one transaction. For example, consider the case of loading data from CSV(Comma-Separated Values) files to relational database tables. Instead of using Statement or PreparedStatement, we can use Batch processing which executes the bulk of queries in a single go for a database. Advantages of Batch processing:\nIt will reduce the communication time and improves performance.\nBatch processing makes it easier to process a huge amount of data and consistency of data is also maintained.\nIt is much faster than executing a single statement at a time because of the fewer number of database calls. Advantages of Batch processing: It will reduce the communication time and improves performance.\nBatch processing makes it easier to process a huge amount of data and consistency of data is also maintained.\nIt is much faster than executing a single statement at a time because of the fewer number of database calls. It will reduce the communication time and improves performance. Batch processing makes it easier to process a huge amount of data and consistency of data is also maintained. It is much faster than executing a single statement at a time because of the fewer number of database calls. How to perform Batch processing?\nTo perform Batch processing, addBatch() and executeBatch() methods are used. These 2 methods are available in the Statement and PreparedStatement classes of JDBC API. How to perform Batch processing? ",
        "reference": "interviewbit.com"
    },
    {
        "question": "25. What is the difference between Statement and PreparedStatement?",
        "answer": "Statement PreparedStatement\nThe query is compiled every time we run the program. The query is compiled only once.\nIt is used in the situation where we need to run the SQL query without providing parameters at runtime. It is used when we want to give input parameters to the query at runtime.\nPerformance is less compared to PreparedStatement. Provides better performance than Statement, as it executes the pre-compiled SQL statements.\nIt is suitable for executing DDL statements such as CREATE, ALTER, DROP and TRUNCATE. It is suitable for executing DML statements such as INSERT, UPDATE, and DELETE.\nIt cannot be used for storing/retrieving images and files in the database. It can be used for storing/retrieving images and files in the database.\nIt executes static SQL statements. It executes pre-compiled SQL statements.\nLess secured as it enforces SQL injection. More secured as they use bind variables, which can prevent SQL injection. Statement PreparedStatement\nThe query is compiled every time we run the program. The query is compiled only once.\nIt is used in the situation where we need to run the SQL query without providing parameters at runtime. It is used when we want to give input parameters to the query at runtime.\nPerformance is less compared to PreparedStatement. Provides better performance than Statement, as it executes the pre-compiled SQL statements.\nIt is suitable for executing DDL statements such as CREATE, ALTER, DROP and TRUNCATE. It is suitable for executing DML statements such as INSERT, UPDATE, and DELETE.\nIt cannot be used for storing/retrieving images and files in the database. It can be used for storing/retrieving images and files in the database.\nIt executes static SQL statements. It executes pre-compiled SQL statements.\nLess secured as it enforces SQL injection. More secured as they use bind variables, which can prevent SQL injection. Statement PreparedStatement Statement PreparedStatement Statement PreparedStatement The query is compiled every time we run the program. The query is compiled only once.\nIt is used in the situation where we need to run the SQL query without providing parameters at runtime. It is used when we want to give input parameters to the query at runtime.\nPerformance is less compared to PreparedStatement. Provides better performance than Statement, as it executes the pre-compiled SQL statements.\nIt is suitable for executing DDL statements such as CREATE, ALTER, DROP and TRUNCATE. It is suitable for executing DML statements such as INSERT, UPDATE, and DELETE.\nIt cannot be used for storing/retrieving images and files in the database. It can be used for storing/retrieving images and files in the database.\nIt executes static SQL statements. It executes pre-compiled SQL statements.\nLess secured as it enforces SQL injection. More secured as they use bind variables, which can prevent SQL injection. The query is compiled every time we run the program. The query is compiled only once. The query is compiled every time we run the program. The query is compiled only once. It is used in the situation where we need to run the SQL query without providing parameters at runtime. It is used when we want to give input parameters to the query at runtime. It is used in the situation where we need to run the SQL query without providing parameters at runtime. It is used when we want to give input parameters to the query at runtime. Performance is less compared to PreparedStatement. Provides better performance than Statement, as it executes the pre-compiled SQL statements. Performance is less compared to PreparedStatement. Provides better performance than Statement, as it executes the pre-compiled SQL statements. It is suitable for executing DDL statements such as CREATE, ALTER, DROP and TRUNCATE. It is suitable for executing DML statements such as INSERT, UPDATE, and DELETE. It is suitable for executing DDL statements such as CREATE, ALTER, DROP and TRUNCATE. It is suitable for executing DML statements such as INSERT, UPDATE, and DELETE. It cannot be used for storing/retrieving images and files in the database. It can be used for storing/retrieving images and files in the database. It cannot be used for storing/retrieving images and files in the database. It can be used for storing/retrieving images and files in the database. It executes static SQL statements. It executes pre-compiled SQL statements. It executes static SQL statements. It executes pre-compiled SQL statements. Less secured as it enforces SQL injection. More secured as they use bind variables, which can prevent SQL injection. Less secured as it enforces SQL injection. More secured as they use bind variables, which can prevent SQL injection.",
        "reference": "interviewbit.com"
    },
    {
        "question": "26. What is DataSource in JDBC? What are its benefits?",
        "answer": "DataSource is an interface defined in javax.sql package and is used for obtaining the database connection. It can be used as a good alternative for a DriverManager class as it allows the details about the database to your application program.\nA driver that is accessed through a DataSource object, does not register itself with the DriverManager. Instead, a DataSource object is retrieved through a lookup operation and then it can be used to create a Connection object.\nBenefits of DataSource:\nCaching of PreparedStatement for faster processing\nResultSet maximum size threshold\nLogging features\nConnection timeout settings\nConnection Pooling in servlet container using the support of JNDI registry. DataSource is an interface defined in javax.sql package and is used for obtaining the database connection. It can be used as a good alternative for a DriverManager class as it allows the details about the database to your application program. javax.sql A driver that is accessed through a DataSource object, does not register itself with the DriverManager. Instead, a DataSource object is retrieved through a lookup operation and then it can be used to create a Connection object. Benefits of DataSource:\nCaching of PreparedStatement for faster processing\nResultSet maximum size threshold\nLogging features\nConnection timeout settings\nConnection Pooling in servlet container using the support of JNDI registry. Benefits of DataSource: Caching of PreparedStatement for faster processing\nResultSet maximum size threshold\nLogging features\nConnection timeout settings\nConnection Pooling in servlet container using the support of JNDI registry. Caching of PreparedStatement for faster processing ResultSet maximum size threshold Logging features Connection timeout settings Connection Pooling in servlet container using the support of JNDI registry.",
        "reference": "interviewbit.com"
    }
]