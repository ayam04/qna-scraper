[
    {
        "question": "1. What are design patterns?",
        "answer": "Design patterns are the reusable solutions that solve common problems of software development. These problems include repetitive code, redundant functions and logic etc. These help to save considerable effort and time required for the developers while developing software. Design patterns are commonly used in object-oriented software products by incorporating best practices and promoting reusability for developing robust code.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. How are design patterns different from algorithms?",
        "answer": "Both Design Patterns and Algorithms describe typical solutions to any given problem. But the main difference is that the algorithm defines a clear set of actions for achieving a goal and a design pattern provides a high-level description of any solution. Design patterns applied to two different problems might be the same but the logic of implementation would be different and is based on the requirements.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. How are design principles different from design patterns?",
        "answer": "Design principles are those principles that are followed while designing software systems for any platform by making use of any programming language. SOLID principles are the design principles that we follow as guidelines to develop robust, extensible and scalable software systems. These apply to all aspects of programming.\nDesign Patterns are the reusable template solutions for commonly occurring problems that can be customized as per the problem requirements. These are well-implemented solutions that are tested properly and are safe to use. Factory Design Pattern, Singleton pattern, Strategy patterns are a few of the examples of design patterns. Design principles are those principles that are followed while designing software systems for any platform by making use of any programming language. SOLID principles are the design principles that we follow as guidelines to develop robust, extensible and scalable software systems. These apply to all aspects of programming. Design principles Design Patterns are the reusable template solutions for commonly occurring problems that can be customized as per the problem requirements. These are well-implemented solutions that are tested properly and are safe to use. Factory Design Pattern, Singleton pattern, Strategy patterns are a few of the examples of design patterns. Design Patterns",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What are some of the design patterns used in Java\u2019s JDK library?",
        "answer": "Following are some design patterns used in Java\u2019s JDK library: design patterns Decorator pattern are used by the Wrapper classes.\nSingleton pattern is used in classes like Calendar and Runtime.\nFactory pattern is used for methods like Integer.valueOf methods in wrapper classes.\nObserver pattern is used for handling event frameworks like awt, swing etc. Decorator pattern are used by the Wrapper classes. Decorator pattern Singleton pattern is used in classes like Calendar and Runtime. Singleton pattern Factory pattern is used for methods like Integer.valueOf methods in wrapper classes. Factory pattern Observer pattern is used for handling event frameworks like awt, swing etc. Observer pattern",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What do you understand by the Open-Closed Principle (OCP)?",
        "answer": "The Open close principle states that any class, component or entity should be open for extension but closed for modification. A class can be extended via Inheritance, Interfaces, Composition whenever required instead of modifying the code of the class. Consider an instance where we have a class that calculates the area of a square. Later, we get the requirement of calculating the area of a rectangle. Here, instead of modifying the original class, we can create one base class and this base class can be extended by the new class rectangle.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What are the SOLID Principles?",
        "answer": "SOLID principles were the Object-Oriented principles introduced by Robert C. Martin in his paperwork \u201cDesign Principles and Design patterns\u201d in the year 2000. The acronym for SOLID goes as follows: SOLID principles   S - Single Responsibility Principle (SRP): The single responsibility principle ensures that every class or module should be accountable and responsible for only one functionality. There should be one and only one reason for changing any class.\nO - Open Closed Principle (OCP): Every class is open for extension but closed for modification. Here, we are allowed to extend the entities behaviour by not modifying anything in the existing source code.\nL - Liskov Substitution Principle(LSP): LSP principle states that the objects can be replaced by the subtype instances without affecting the correctness of the program.\nI - Interface Segregation Principle (ISP): The ISP principle states that we can use as many interfaces specific to the client\u2019s requirements instead of creating only one general interface. Clients should not be forced to implement the functionalities that they do not require.\nD - Dependency Inversion Principle: Here, the high-level modules should not be dependent on the lower level modules or concrete implementations. Instead, they should be dependent on the abstractions. S - Single Responsibility Principle (SRP): The single responsibility principle ensures that every class or module should be accountable and responsible for only one functionality. There should be one and only one reason for changing any class. S Single Responsibility Principle (SRP) O - Open Closed Principle (OCP): Every class is open for extension but closed for modification. Here, we are allowed to extend the entities behaviour by not modifying anything in the existing source code. O Open Closed Principle (OCP) L - Liskov Substitution Principle(LSP): LSP principle states that the objects can be replaced by the subtype instances without affecting the correctness of the program. L Liskov Substitution Principle(LSP) I - Interface Segregation Principle (ISP): The ISP principle states that we can use as many interfaces specific to the client\u2019s requirements instead of creating only one general interface. Clients should not be forced to implement the functionalities that they do not require. I Interface Segregation Principle (ISP) D - Dependency Inversion Principle: Here, the high-level modules should not be dependent on the lower level modules or concrete implementations. Instead, they should be dependent on the abstractions. D Dependency Inversion Principle",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What Is Gang of Four (GOF) in Design Patterns?",
        "answer": "Gang of Four (GOF) are the 4 superheroes who invented the concept of design patterns. These heroes are Erich Gamma, Ralph Johnson, Richard Hel and John Vlissides. These people documented the design patterns in a book called \u201cDesign Patterns: Elements of Reusable Object-Oriented Software\u201d in 1995. If not for these people, the software developers would have wasted time-solving problems of recurring nature instead of focussing on business requirements. Gang of Four software developers",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What is Inversion of Control?",
        "answer": "Inversion of control is a pattern used to decouple the dependencies between layers and components in the system. The Dependency-Injection (DI) pattern is an example of an IoC pattern that helps in removing dependencies in the code. Let us understand this with the help of an example. Consider we have a class A that makes use of class B as shown below: A B public class A{\n   private B b;\n   \n   public A(){\n       this.b = new B();\n   }\n} public class A{\n   private B b;\n   \n   public A(){\n       this.b = new B();\n   }\n} Here, we have a dependency between classes A and B. If we had the IoC pattern implemented, we would not have used the new operator to assign value to the dependent variable. It would have been something as shown below: public class A {\n   private IocB b;\n   public A(IocB b) {\n       this.b = b;\n   }\n} public class A {\n   private IocB b;\n   public A(IocB b) {\n       this.b = b;\n   }\n} We have inverted the control of handing the dependency of instantiating the object of class B to the IoC class IocB. B IocB",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What are the types of design patterns in Java?",
        "answer": "There are three types of design patterns. They are: three types Creational Patterns: These patterns provide freedom of choice between creating objects by hiding the logic. The objects constructed are decoupled from the implemented system. Some of the examples of creational patterns are - Factory design pattern, Builder design, Prototype design, Singleton design, Abstract Factory design.\nStructural Patterns: These patterns help in defining how the structures of classes and objects should be like for defining the composition between classes, interfaces and objects. Some of the examples of structural patterns are - Adaptor design, Facade design, Decorator design, proxy design etc.\nBehavioural Patterns: These patterns help to define how the objects should communicate and interact with one another. Some of the examples of behavioural patterns are - Command pattern, Iterator pattern, Observer pattern, Strategy pattern, etc. Creational Patterns: These patterns provide freedom of choice between creating objects by hiding the logic. The objects constructed are decoupled from the implemented system. Some of the examples of creational patterns are - Factory design pattern, Builder design, Prototype design, Singleton design, Abstract Factory design. Creational Patterns Structural Patterns: These patterns help in defining how the structures of classes and objects should be like for defining the composition between classes, interfaces and objects. Some of the examples of structural patterns are - Adaptor design, Facade design, Decorator design, proxy design etc. Structural Patterns Behavioural Patterns: These patterns help to define how the objects should communicate and interact with one another. Some of the examples of behavioural patterns are - Command pattern, Iterator pattern, Observer pattern, Strategy pattern, etc. Behavioural Patterns The following diagram represents the summary of the types of design patterns.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. How can you describe a design pattern?",
        "answer": "For describing a design pattern, we follow the below things: Define a pattern name and what classification of design pattern the pattern would fall to.\nDefine a Problem and what is the corresponding solution\nWhat are the variations and language-dependent alternatives for the problem that needs to be addressed?\nWhat are the real-time use cases and the efficiency of the software that uses these patterns? Define a pattern name and what classification of design pattern the pattern would fall to. Define a Problem and what is the corresponding solution What are the variations and language-dependent alternatives for the problem that needs to be addressed? What are the real-time use cases and the efficiency of the software that uses these patterns?",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. What are the advantages of Java Design Patterns?",
        "answer": "Design patterns are template-based reusable solutions to help developers work effortlessly in multiple projects. In Java, the design patterns are flexible and help to identify unwanted repetitive code easily. The architecture of the software can be customised as per the requirements. Some of the advantages of using design patterns in Java are: design patterns in Java design patterns in Java They are reusable and can be used in multiple projects.\nThey provide template solutions for defining system architecture.\nThey provide transparency to software design.\nThey are well-tested and proven means of developing robust solutions effortlessly. They are reusable and can be used in multiple projects. They provide template solutions for defining system architecture. They provide transparency to software design. They are well-tested and proven means of developing robust solutions effortlessly.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. What is the main advantage of using a prototype design pattern over object creation using a new keyword?",
        "answer": "Prototype design pattern is used for creating duplicate objects based on the prototype of the already existing object using cloning. Doing this has a positive impact on the performance of object creation. Creating objects using the new keyword requires a lot of resources and is a heavyweight process that impacts performance. Hence, the prototype design pattern is more advantageous than the object created using a new keyword. new",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What is Decorator Design Pattern?",
        "answer": "Decorator design pattern belongs to the category of structural pattern that lets users add new features to an existing object without modifying the structure. This pattern creates a class called decorator class that acts as a wrapper to the existing class by keeping the signatures of class methods intact. This pattern makes use of abstract classes and interfaces with composition for implementing the wrapper. They are mostly used to apply SRP (Single Responsibility Principle) as we divide functionalities into classes with unique concerns. This pattern is structurally similar to the chain of responsibility pattern. Following are the steps to implement decorator design pattern: Create an interface and concrete classes that implement this interface.\nCreate an abstract decorator class that implements the above interface.\nCreate a concrete decorator class that extends the above abstract class.\nUse the concrete decorator class to decorate the interface objects and verify the output. Create an interface and concrete classes that implement this interface. Create an abstract decorator class that implements the above interface. Create a concrete decorator class that extends the above abstract class. Use the concrete decorator class to decorate the interface objects and verify the output. Let us understand this with the help of an example. Here, we will be creating a Shape Interface and concrete classes- Rectangle and Triangle that implement this Shape interface. We will be creating an abstract decorator class \u201cShapeDecorator\u201d that implements the Shape interface. We will create RedColorDecorator that extends ShapeDecorator. We will be then using this decorator to implement the functionalities.   Creating \u201cShape\u201d Interface Creating \u201cShape\u201d Interface // Shape.java\n   public interface Shape {\n       void draw();\n   } // Shape.java\n   public interface Shape {\n       void draw();\n   } // Shape.java public interface Shape interface Shape void draw() void draw () Create concrete classes Rectangle.java and Triangle.java that implement Shape Interface. Create concrete classes Rectangle.java and Triangle.java that implement Shape Interface. // Rectangle.java\n   public class Rectangle implements Shape {\n       // Overriding the draw method\n       @Override public void draw()\n       {\n           System.out.println(\"Rectangle Drawn...\");\n       }\n   } // Rectangle.java\n   public class Rectangle implements Shape {\n       // Overriding the draw method\n       @Override public void draw()\n       {\n           System.out.println(\"Rectangle Drawn...\");\n       }\n   } // Rectangle.java public class Rectangle implements Shape class Rectangle implements Shape // Overriding the draw method @Override public void draw() public void draw () \"Rectangle Drawn...\" // Triangle.java\n   public class Triangle implements Shape {\n       // Overriding the draw method\n       @Override public void draw()\n       {\n           System.out.println(\"Triangle Drawn...\");\n       }\n   } // Triangle.java\n   public class Triangle implements Shape {\n       // Overriding the draw method\n       @Override public void draw()\n       {\n           System.out.println(\"Triangle Drawn...\");\n       }\n   } // Triangle.java public class Triangle implements Shape class Triangle implements Shape // Overriding the draw method @Override public void draw() public void draw () \"Triangle Drawn...\" Create ShapeDecorator abstract class that implements the Shape interface. Create ShapeDecorator abstract class that implements the Shape interface. // ShapeDecorator.java\n   public abstract class ShapeDecorator implements Shape {\n       protected Shape shapeDecorated;\n       public ShapeDecorator(Shape shapeDecorated)\n       {\n           this.shapeDecorated = shapeDecorated;\n       }\n       public void draw() { \n           shapeDecorated.draw(); \n       }\n   } // ShapeDecorator.java\n   public abstract class ShapeDecorator implements Shape {\n       protected Shape shapeDecorated;\n       public ShapeDecorator(Shape shapeDecorated)\n       {\n           this.shapeDecorated = shapeDecorated;\n       }\n       public void draw() { \n           shapeDecorated.draw(); \n       }\n   } // ShapeDecorator.java public abstract class ShapeDecorator implements Shape class ShapeDecorator implements Shape protected public ShapeDecorator(Shape shapeDecorated) public ShapeDecorator (Shape shapeDecorated) this public void draw() public void draw () Create the RedColorDecorator.java class that extends the ShapeDecorator class. Create the RedColorDecorator.java class that extends the ShapeDecorator class. public class RedColorDecorator extends ShapeDecorator {\n       public RedColorDecorator(Shape shapeDecorated)\n       {\n           super(shapeDecorated);\n       }\n       @Override \n       public void draw()\n       {\n           shapeDecorated.draw();\n           setRedBorder(shapeDecorated);\n       }\n       private void setRedBorder(Shape shapeDecorated)\n       {\n           System.out.println(\"Red color border added...\");\n       }\n   } public class RedColorDecorator extends ShapeDecorator {\n       public RedColorDecorator(Shape shapeDecorated)\n       {\n           super(shapeDecorated);\n       }\n       @Override \n       public void draw()\n       {\n           shapeDecorated.draw();\n           setRedBorder(shapeDecorated);\n       }\n       private void setRedBorder(Shape shapeDecorated)\n       {\n           System.out.println(\"Red color border added...\");\n       }\n   } public class RedColorDecorator extends ShapeDecorator class RedColorDecorator extends ShapeDecorator public RedColorDecorator(Shape shapeDecorated) public RedColorDecorator (Shape shapeDecorated) super @Override public void draw() public void draw () private void setRedBorder(Shape shapeDecorated) private void setRedBorder (Shape shapeDecorated) \"Red color border added...\" Implement the Driver class to demo the decorator class. Implement the Driver class to demo the decorator class. // Driver.java\n   public class Driver {\n       // Main driver method\n       public static void main(String[] args)\n       {\n       \n           Shape triangle = new Triangle();\n           Shape redTriangle\n               = new RedColorDecorator(new Triangle());\n           Shape redRectangle = new RedColorDecorator(new Rectangle());\n           // Draw normal triangle\n           triangle.draw();\n           System.out.println(\".........\");\n           // make the triangle red\n           redTriangle.draw();\n           System.out.println(\".........\");\n           // make the rectangle red\n           redRectangle.draw();\n           System.out.println(\".........\");\n       }\n   } // Driver.java\n   public class Driver {\n       // Main driver method\n       public static void main(String[] args)\n       {\n       \n           Shape triangle = new Triangle();\n           Shape redTriangle\n               = new RedColorDecorator(new Triangle());\n           Shape redRectangle = new RedColorDecorator(new Rectangle());\n           // Draw normal triangle\n           triangle.draw();\n           System.out.println(\".........\");\n           // make the triangle red\n           redTriangle.draw();\n           System.out.println(\".........\");\n           // make the rectangle red\n           redRectangle.draw();\n           System.out.println(\".........\");\n       }\n   } // Driver.java public class Driver class Driver // Main driver method public static void main(String[] args) public static void main (String[] args) new new new new new // Draw normal triangle \".........\" // make the triangle red \".........\" // make the rectangle red \".........\" Validate the output. The output of the above code would be: Validate the output. The output of the above code would be: Triangle Drawn...\n   .........\n   Triangle Drawn...\n   Red color border added...\n   .........\n   Rectangle Drawn...\n   Red color border added...\n   ......... Triangle Drawn...\n   .........\n   Triangle Drawn...\n   Red color border added...\n   .........\n   Rectangle Drawn...\n   Red color border added...\n   .........",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What is a Command pattern?",
        "answer": "The command pattern is a type of behavioural design pattern that transforms a request into a stand-alone object containing all the details about the request. This pattern is a data-driven pattern because we make use of the information about the request by wrapping it as an object and is passed to the invoker object as a command. The invoker object checks for the object that can handle the command and passes it to that object to execute the command. The following diagram is the UML diagram that represents the command design pattern.   We have a client that calls the invoker to run a command. We have a Command interface that acts as an abstraction to the underlying concrete classes. Let us understand this with the help of an example of remote control that has only one button. Using this button, we will be controlling the behaviour of two objects tubelight and a radio. The command to control the objects will be implemented using the command design pattern. Create Command interface: Create Command interface: // Command Interface\n   interface Command\n   {\n       public void execute();\n   } // Command Interface\n   interface Command\n   {\n       public void execute();\n   } // Command Interface interface Command interface Command public void execute() public void execute () Create Tubelight class and its command classes that extend the above interface to control the tubelight. Create Tubelight class and its command classes that extend the above interface to control the tubelight. // Tubelight class\n   class TubeLight\n   {\n       public void lightOn(){\n           System.out.println(\"TubeLight on...\");\n       }\n       public void lightOff(){\n           System.out.println(\"TubeLight off...\");\n       }\n   }\n   // Command class to turn on the tubelight\n   class TubeLightOnCommand implements Command\n   {\n       TubeLight tubeLight;\n       // The constructor is passed the light it\n       // is going to control.\n       public TubeLightOnCommand(TubeLight tubeLight){\n         this.tubeLight = tubeLight;\n       }\n       public void execute(){\n         tubeLight.lightOn();\n       }\n   }\n   // Command class to turn off the tubelight\n   class TubeLightOffCommand implements Command\n   {\n       TubeLight tubeLight;\n       public TubeLightOffCommand(TubeLight tubeLight) {\n           this.tubeLight = tubeLight;\n       }\n       public void execute() {\n           tubeLight.lightOff();\n       }\n   } // Tubelight class\n   class TubeLight\n   {\n       public void lightOn(){\n           System.out.println(\"TubeLight on...\");\n       }\n       public void lightOff(){\n           System.out.println(\"TubeLight off...\");\n       }\n   }\n   // Command class to turn on the tubelight\n   class TubeLightOnCommand implements Command\n   {\n       TubeLight tubeLight;\n       // The constructor is passed the light it\n       // is going to control.\n       public TubeLightOnCommand(TubeLight tubeLight){\n         this.tubeLight = tubeLight;\n       }\n       public void execute(){\n         tubeLight.lightOn();\n       }\n   }\n   // Command class to turn off the tubelight\n   class TubeLightOffCommand implements Command\n   {\n       TubeLight tubeLight;\n       public TubeLightOffCommand(TubeLight tubeLight) {\n           this.tubeLight = tubeLight;\n       }\n       public void execute() {\n           tubeLight.lightOff();\n       }\n   } // Tubelight class class TubeLight class TubeLight public void lightOn() public void lightOn () \"TubeLight on...\" public void lightOff() public void lightOff () \"TubeLight off...\" // Command class to turn on the tubelight class TubeLightOnCommand implements Command class TubeLightOnCommand implements Command // The constructor is passed the light it // is going to control. public TubeLightOnCommand(TubeLight tubeLight) public TubeLightOnCommand (TubeLight tubeLight) this public void execute() public void execute () // Command class to turn off the tubelight class TubeLightOffCommand implements Command class TubeLightOffCommand implements Command public TubeLightOffCommand(TubeLight tubeLight) public TubeLightOffCommand (TubeLight tubeLight) this public void execute() public void execute () Create a Radio class and its command classes that extend the above interface to control the radio. Create a Radio class and its command classes that extend the above interface to control the radio. // Radio class\n   class Radio\n   {\n       public void radioOn()\n       {\n           System.out.println(\"Radio on ...\");\n       }\n       public void radioOff()\n       {\n           System.out.println(\"Radio off...\");\n       }\n       public void setVolume(int volumeLevel)\n       {\n         // code to set the volume\n         System.out.println(\"Radio volume set to \" + volumeLevel);\n       }\n   }\n   // Command class to turn on the radio\n   class RadioOnCommand implements Command\n   {\n       Radio radio;\n       public RadioOnCommand(Radio radio)\n       {\n           this.radio = radio;\n       }\n       public void execute()\n       {\n         radio.radioOn();\n       }\n   }\n   // Command class to set the volume of the radio\n   class RadioVolumeCommand implements Command\n   {\n       Radio radio;\n       int volumeLevel;\n       public RadioVolumeCommand(Radio radio, int volumeLevel)\n       {\n           this.radio = radio;\n           this.volumeLevel=volumeLevel;\n       }\n       public void execute()\n       {\n         radio.setVolume(volumeLevel);\n       }\n   } // Radio class\n   class Radio\n   {\n       public void radioOn()\n       {\n           System.out.println(\"Radio on ...\");\n       }\n       public void radioOff()\n       {\n           System.out.println(\"Radio off...\");\n       }\n       public void setVolume(int volumeLevel)\n       {\n         // code to set the volume\n         System.out.println(\"Radio volume set to \" + volumeLevel);\n       }\n   }\n   // Command class to turn on the radio\n   class RadioOnCommand implements Command\n   {\n       Radio radio;\n       public RadioOnCommand(Radio radio)\n       {\n           this.radio = radio;\n       }\n       public void execute()\n       {\n         radio.radioOn();\n       }\n   }\n   // Command class to set the volume of the radio\n   class RadioVolumeCommand implements Command\n   {\n       Radio radio;\n       int volumeLevel;\n       public RadioVolumeCommand(Radio radio, int volumeLevel)\n       {\n           this.radio = radio;\n           this.volumeLevel=volumeLevel;\n       }\n       public void execute()\n       {\n         radio.setVolume(volumeLevel);\n       }\n   } // Radio class class Radio class Radio public void radioOn() public void radioOn () \"Radio on ...\" public void radioOff() public void radioOff () \"Radio off...\" public void setVolume(int volumeLevel) public void setVolume (int volumeLevel) int // code to set the volume \"Radio volume set to \" // Command class to turn on the radio class RadioOnCommand implements Command class RadioOnCommand implements Command public RadioOnCommand(Radio radio) public RadioOnCommand (Radio radio) this public void execute() public void execute () // Command class to set the volume of the radio class RadioVolumeCommand implements Command class RadioVolumeCommand implements Command int public RadioVolumeCommand(Radio radio, int volumeLevel) public RadioVolumeCommand (Radio radio, int volumeLevel) int this this public void execute() public void execute () Create a remote control class that has only one button and on click of the button, execute the command functionality: Create a remote control class that has only one button and on click of the button, execute the command functionality: // remote control with one button \n   class RemoteControl{\n       Command button; // only one button\n       public RemoteControl(){}\n       public void setCommand(Command command){\n           // set the command the remote will\n           // execute\n           button = command;\n       }\n       public void pressButton(){\n         // execute the command on click (call) of the button\n           button.execute();\n       }\n   } // remote control with one button \n   class RemoteControl{\n       Command button; // only one button\n       public RemoteControl(){}\n       public void setCommand(Command command){\n           // set the command the remote will\n           // execute\n           button = command;\n       }\n       public void pressButton(){\n         // execute the command on click (call) of the button\n           button.execute();\n       }\n   } // remote control with one button class RemoteControl class RemoteControl // only one button public RemoteControl() public RemoteControl () public void setCommand(Command command) public void setCommand (Command command) // set the command the remote will // execute public void pressButton() public void pressButton () // execute the command on click (call) of the button Create a Driver class to implement the pattern. Here we will be first turning on the tubelight on the first click of the button, on next click, we will be turning on the radio, then we will be setting the volume of the radio to 4 and then we will be turning off the tubelight. Create a Driver class to implement the pattern. Here we will be first turning on the tubelight on the first click of the button, on next click, we will be turning on the radio, then we will be setting the volume of the radio to 4 and then we will be turning off the tubelight. // Driver class\n   public class Driver\n   {\n       public static void main(String[] args)\n       {\n               RemoteControl remote = new RemoteControl();\n               TubeLight tubeLight = new TubeLight();\n               Radio radio = new Radio();\n               // Turn on Tubelight\n               remote.setCommand(new TubeLightOnCommand(tubeLight));\n               remote.pressButton();\n               //Turn on Radio\n               remote.setCommand(new RadioOnCommand(radio));\n               remote.pressButton();\n               //Turn off Radio\n               remote.setCommand(new RadioVolumeCommand(radio,4));\n               remote.pressButton();\n               // Turn off Tubelight\n               remote.setCommand(new TubeLightOffCommand(tubeLight));\n               remote.pressButton();\n       }\n   } // Driver class\n   public class Driver\n   {\n       public static void main(String[] args)\n       {\n               RemoteControl remote = new RemoteControl();\n               TubeLight tubeLight = new TubeLight();\n               Radio radio = new Radio();\n               // Turn on Tubelight\n               remote.setCommand(new TubeLightOnCommand(tubeLight));\n               remote.pressButton();\n               //Turn on Radio\n               remote.setCommand(new RadioOnCommand(radio));\n               remote.pressButton();\n               //Turn off Radio\n               remote.setCommand(new RadioVolumeCommand(radio,4));\n               remote.pressButton();\n               // Turn off Tubelight\n               remote.setCommand(new TubeLightOffCommand(tubeLight));\n               remote.pressButton();\n       }\n   } // Driver class public class Driver class Driver public static void main(String[] args) public static void main (String[] args) new new new // Turn on Tubelight new //Turn on Radio new //Turn off Radio new 4 // Turn off Tubelight new Validate the result of this pattern to see if it\u2019s working fine. The result of this code would be: Validate the result of this pattern to see if it\u2019s working fine. The result of this code would be: TubeLight on...\n   Radio on ...\n   Radio volume set to 4\n   TubeLight off... TubeLight on...\n   Radio on ...\n   Radio volume set to 4\n   TubeLight off... 4",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What is an Observer Design Pattern?",
        "answer": "An observer design pattern is a type of behavioural design pattern that is used for defining the one to many dependencies between the objects. It is most useful when we want to get notified about any change in the state of an object. In this pattern, when the state of one object changes, all the dependent objects are notified automatically. The object whose state is monitored is called the Subject whereas the dependents are called the Observers. In Java, we can implement this pattern by making use of the java.util.Observable class and the java.util.Observer interface. The following UML diagram represents the observer design pattern clearly: java.util.Observable class java.util.Observer   This design pattern has 3 main components: Subject - This can be an interface or an abstract class that defines operations for attaching (registerObserver()) and detaching the observers (removeObserver()) to the subject.\nConcrete Subject - This is a concrete class of the Subject. This maintains the object state and whenever any change occurs in that state, the observers are notified about it using notifyObservers() method.\nObserver - This is an interface or an abstract class that defines the operations for notifying this object (update()). One real work example of this pattern is Facebook or Twitter. Whenever a person updates the status, all the followers would get a notification about his update. An observer can get the notification of the subject as long as it is subscribed or keeping track of it. Subject - This can be an interface or an abstract class that defines operations for attaching (registerObserver()) and detaching the observers (removeObserver()) to the subject. Subject registerObserver() removeObserver() Concrete Subject - This is a concrete class of the Subject. This maintains the object state and whenever any change occurs in that state, the observers are notified about it using notifyObservers() method. Concrete Subject notifyObservers() Observer - This is an interface or an abstract class that defines the operations for notifying this object (update()). One real work example of this pattern is Facebook or Twitter. Whenever a person updates the status, all the followers would get a notification about his update. An observer can get the notification of the subject as long as it is subscribed or keeping track of it. Observer update()",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What problem does Builder Pattern try to solve?",
        "answer": "A builder pattern is a type of creational design pattern that lets to construct complex objects in a step by step manner. The pattern lets to produce different representations of an object using the same construction logic. It helps in creating immutable classes having a large set of attributes. In the Factory and Abstract Factory Design Patterns, we encounter the following issues if the object contains a lot of attributes: When the arguments are too many, the program will be error-prone while passing from the client to the Factory Class in a specific order. It becomes tedious to maintain the order of arguments when the types are the same.\nThere might be some optional attributes of the object and yet we would be forced to send all parameters and optional attributes as Null.\nWhen the object creation becomes complex due to heavy attributes, the complexity of this class would become confusing. When the arguments are too many, the program will be error-prone while passing from the client to the Factory Class in a specific order. It becomes tedious to maintain the order of arguments when the types are the same. There might be some optional attributes of the object and yet we would be forced to send all parameters and optional attributes as Null. When the object creation becomes complex due to heavy attributes, the complexity of this class would become confusing. The above problems can also be solved by using constructors of required parameters alone. But this causes an issue when there would be new parameters that are added as part of new requirements. This would result in inconsistency. That\u2019s where Builder comes into the picture. This pattern solves the issue of a large number of optional attributes and the inconsistent state by providing means to build an object in a step-by-step way and return the final object utilizing another method. Builder pattern can be implemented by following the below steps: Create a static nested class, copy all arguments from the outer class. This nested class would be called the Builder class.\nProper naming convention has to be followed while naming this builder class. For example, if the name of the class is Interviewbit, then the name of the builder would be InterviewbitBuilder.\nThe builder class should have a public constructor with all required attributes sent as parameters.\nThe builder class should have methods for setting optional parameters and return the same builder object post setting these values.\nThe last step is to have a build() method inside the builder class that returns the Object needed by the client. This would require a private constructor in the class that takes the Builder class as the parameter. Create a static nested class, copy all arguments from the outer class. This nested class would be called the Builder class.\nProper naming convention has to be followed while naming this builder class. For example, if the name of the class is Interviewbit, then the name of the builder would be InterviewbitBuilder. Proper naming convention has to be followed while naming this builder class. For example, if the name of the class is Interviewbit, then the name of the builder would be InterviewbitBuilder. Proper naming convention has to be followed while naming this builder class. For example, if the name of the class is Interviewbit, then the name of the builder would be InterviewbitBuilder. Interviewbit InterviewbitBuilder The builder class should have a public constructor with all required attributes sent as parameters. The builder class should have methods for setting optional parameters and return the same builder object post setting these values. The last step is to have a build() method inside the builder class that returns the Object needed by the client. This would require a private constructor in the class that takes the Builder class as the parameter. Following is the sample example of the builder pattern implementation. We have a User class and we will be building UserBuilder class to build the objects of the User class. class User \n{\n   //All final attributes\n   private final String firstName; // required\n   private final String lastName; // required\n   private final int age; // required\n   private final String phoneNbr; // optional\n   private final String address; // optional\n   private final String nationality; //optional\n\n   private User(UserBuilder builder) {\n       this.firstName = builder.firstName;\n       this.lastName = builder.lastName;\n       this.age = builder.age;\n       this.phoneNbr = builder.phoneNbr;\n       this.address = builder.address;\n       this.nationality = builder.nationality;\n   }\n\n   //Setters are not provided to make it immutable\n   public String getFirstName() {\n       return firstName;\n   }\n   public String getLastName() {\n       return lastName;\n   }\n   public int getAge() {\n       return age;\n   }\n   public String getPhoneNbr() {\n       return phoneNbr;\n   }\n   public String getAddress() {\n       return address;\n   }\n   public String getNationality() {\n       return nationality;\n   }\n\n   @Override\n   public String toString() {\n       return \"User: \"+this.firstName+\" \"+this.lastName+\", \"+this.age+\", \"+this.nationality+\", \"+this.phoneNbr+\", \"+this.address;\n   }\n\n   public static class UserBuilder \n   {\n       private final String firstName;\n       private final String lastName;\n       private int age;\n       private String phoneNbr;\n       private String address;\n       private String nationality;\n\n       public UserBuilder(String firstName, String lastName) {\n           this.firstName = firstName;\n           this.lastName = lastName;\n       }\n       public UserBuilder age(int age) {\n           this.age = age;\n           return this;\n       }\n       public UserBuilder phoneNbr(String phoneNbr) {\n           this.phoneNbr = phoneNbr;\n           return this;\n       }\n       public UserBuilder address(String address) {\n           this.address = address;\n           return this;\n       }\n       public UserBuilder nationality(String nationality) {\n           this.nationality = nationality;\n           return this;\n       }\n       // method to return the constructed object\n       public User build() {\n           User user =  new User(this);\n           validateUserObject(user);\n           return user;\n       }\n       private void validateUserObject(User user) {\n           //Validate of the object does not break anything\n       }\n   }\n}\npublic class Driver{\n   public static void main(String[] args) {\n       User firstUser = new User.UserBuilder(\"Harry\", \"Potter\")\n       .age(30)\n       .phoneNbr(\"1234567\")\n       .address(\"221B Baker Street - London\")\n       .build();\n    \n       System.out.println(firstUser);\n    \n       User secondUser = new User.UserBuilder(\"Ron\", \"Weasley\")\n       .age(32)\n       .phoneNbr(\"5655\")\n       //no address\n       .build();\n    \n       System.out.println(secondUser);\n    \n       User thirdUser = new User.UserBuilder(\"Hermoine\", \"Granger\").age(20).nationality(\"English\")\n       //No age\n       //No phone\n       //no address\n       .build();\n    \n       System.out.println(thirdUser);\n   }\n} class User \n{\n   //All final attributes\n   private final String firstName; // required\n   private final String lastName; // required\n   private final int age; // required\n   private final String phoneNbr; // optional\n   private final String address; // optional\n   private final String nationality; //optional\n\n   private User(UserBuilder builder) {\n       this.firstName = builder.firstName;\n       this.lastName = builder.lastName;\n       this.age = builder.age;\n       this.phoneNbr = builder.phoneNbr;\n       this.address = builder.address;\n       this.nationality = builder.nationality;\n   }\n\n   //Setters are not provided to make it immutable\n   public String getFirstName() {\n       return firstName;\n   }\n   public String getLastName() {\n       return lastName;\n   }\n   public int getAge() {\n       return age;\n   }\n   public String getPhoneNbr() {\n       return phoneNbr;\n   }\n   public String getAddress() {\n       return address;\n   }\n   public String getNationality() {\n       return nationality;\n   }\n\n   @Override\n   public String toString() {\n       return \"User: \"+this.firstName+\" \"+this.lastName+\", \"+this.age+\", \"+this.nationality+\", \"+this.phoneNbr+\", \"+this.address;\n   }\n\n   public static class UserBuilder \n   {\n       private final String firstName;\n       private final String lastName;\n       private int age;\n       private String phoneNbr;\n       private String address;\n       private String nationality;\n\n       public UserBuilder(String firstName, String lastName) {\n           this.firstName = firstName;\n           this.lastName = lastName;\n       }\n       public UserBuilder age(int age) {\n           this.age = age;\n           return this;\n       }\n       public UserBuilder phoneNbr(String phoneNbr) {\n           this.phoneNbr = phoneNbr;\n           return this;\n       }\n       public UserBuilder address(String address) {\n           this.address = address;\n           return this;\n       }\n       public UserBuilder nationality(String nationality) {\n           this.nationality = nationality;\n           return this;\n       }\n       // method to return the constructed object\n       public User build() {\n           User user =  new User(this);\n           validateUserObject(user);\n           return user;\n       }\n       private void validateUserObject(User user) {\n           //Validate of the object does not break anything\n       }\n   }\n}\npublic class Driver{\n   public static void main(String[] args) {\n       User firstUser = new User.UserBuilder(\"Harry\", \"Potter\")\n       .age(30)\n       .phoneNbr(\"1234567\")\n       .address(\"221B Baker Street - London\")\n       .build();\n    \n       System.out.println(firstUser);\n    \n       User secondUser = new User.UserBuilder(\"Ron\", \"Weasley\")\n       .age(32)\n       .phoneNbr(\"5655\")\n       //no address\n       .build();\n    \n       System.out.println(secondUser);\n    \n       User thirdUser = new User.UserBuilder(\"Hermoine\", \"Granger\").age(20).nationality(\"English\")\n       //No age\n       //No phone\n       //no address\n       .build();\n    \n       System.out.println(thirdUser);\n   }\n} class User class User //All final attributes private final // required private final // required private final int // required private final // optional private final // optional private final //optional private User(UserBuilder builder) private User (UserBuilder builder) this this this this this this //Setters are not provided to make it immutable public String getFirstName() public getFirstName () return public String getLastName() public getLastName () return public int getAge() public int getAge () return public String getPhoneNbr() public getPhoneNbr () return public String getAddress() public getAddress () return public String getNationality() public getNationality () return @Override public String toString() public toString () return \"User: \" this \" \" this \", \" this \", \" this \", \" this \", \" this public static class UserBuilder class UserBuilder private final private final private int private private private public UserBuilder(String firstName, String lastName) public UserBuilder (String firstName, String lastName) this this public UserBuilder age(int age) public age (int age) int this return this public UserBuilder phoneNbr(String phoneNbr) public phoneNbr (String phoneNbr) this return this public UserBuilder address(String address) public address (String address) this return this public UserBuilder nationality(String nationality) public nationality (String nationality) this return this // method to return the constructed object public User build() public build () new this return private void validateUserObject(User user) private void validateUserObject (User user) //Validate of the object does not break anything public class Driver class Driver public static void main(String[] args) public static void main (String[] args) new \"Harry\" \"Potter\" 30 \"1234567\" \"221B Baker Street - London\" new \"Ron\" \"Weasley\" 32 \"5655\" //no address new \"Hermoine\" \"Granger\" 20 \"English\" //No age //No phone //no address The output of the above code would be: User: Harry Potter, 30, null, 1234567, 221B Baker Street - London\nUser: Ron Weasley, 32, null, 5655, null\nUser: Hermoine Granger, 20, English, null, null User: Harry Potter, 30, null, 1234567, 221B Baker Street - London\nUser: Ron Weasley, 32, null, 5655, null\nUser: Hermoine Granger, 20, English, null, null 30 null 1234567 32 null 5655 null 20 null null",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Consider a scenario where you are writing classes for providing market data and we have the flexibility to switch to different vendors or we can be directed to the Direct Exchange Feed. How will you approach this problem to design the system?",
        "answer": "We can do this by having an interface called \u201cMarketData\u201d which will consist of the methods required by the Client. The MarketData should have the MarketDataProvider as the dependency by employing Dependency Injection. This ensures that even if the provider changes, the market data will not be impacted. The implementation of this problem is left as an exercise to the reader.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What do you understand by the Null Object pattern?",
        "answer": "In this pattern, a null object is used for replacing the check of validating if the object instance is null or not. This Null Object has a \u201cdo nothing\u201d relationship and these can be used for providing default behaviour if the data is unavailable.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What is the MVC design pattern?",
        "answer": "MVC stands for Model-View-Controller. This pattern is used for separating the application\u2019s concerns as listed below: Model - This represents the object (Java POJO) that carries the data. It can also consist of the logic of updating the controller in case the data changes.\nView - This represents the data visualization of the model.\nController - This is an interface between the Model and the View by controlling the flow of data into the model and updating the view whenever the model gets updated. This ensures that the model and the views are kept separate. Model - This represents the object (Java POJO) that carries the data. It can also consist of the logic of updating the controller in case the data changes. View - This represents the data visualization of the model. Controller - This is an interface between the Model and the View by controlling the flow of data into the model and updating the view whenever the model gets updated. This ensures that the model and the views are kept separate.   The above image represents how the request flow happens in the MVC Pattern. First, the Browser (client) sends request for a page to the controller of the server. The controller invokes the model, retrieves the data and sends the response. The response is then sent to the view for rendering. The view will be rendered and it is sent back to the client for display.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What are the components of the Composite Entity pattern?",
        "answer": "This pattern is used in EJB (Enterprise Java Beans) persistence mechanism. A composite entity represents the object graph and is an EJB entity. Whenever a composite entity is updated, the object beans that are internally dependent on this bean are updated automatically. There are 4 main components of the Composite Entity Pattern: Composite Entity - Primary entity bean that can have a coarse-grained object that is meant for persistence.\nCoarse-Grained Object - This contains the dependent objects which have their life cycle and in turn manages the lifecycle of dependent objects.\nDependent Object - This object is dependent on the coarse-grained object throughout the persistence lifecycle.\nStrategies - These represent how to implement the composite entity. Composite Entity - Primary entity bean that can have a coarse-grained object that is meant for persistence. Composite Entity Coarse-Grained Object - This contains the dependent objects which have their life cycle and in turn manages the lifecycle of dependent objects. Coarse-Grained Object Dependent Object - This object is dependent on the coarse-grained object throughout the persistence lifecycle. Dependent Object Strategies - These represent how to implement the composite entity. Strategies",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. What is a Chain of Responsibility pattern? In what scenarios to apply this pattern?",
        "answer": "Chain of Responsibility belongs to the category of a behavioural design pattern that passes requests via a chain of handlers. Whenever a request is received, the handler decides whether to process the request or pass it to the next handler of the chain. It is used for achieving loose coupling where the client request is passed through an object chain to process them.   The above image represents the UML diagram of this pattern. There are 3 components of this design, they are: Client: This is the point of request origination and the component that accesses the handler for handling the request.\nHandler: Handler can either be a class or an interface that received the request primarily and dispatches it to the chain of handlers. This Handler knows only the first handler of the chain.\nConcrete Handlers: These are the actual request handlers in sequential order. Client: This is the point of request origination and the component that accesses the handler for handling the request. Client: Handler: Handler can either be a class or an interface that received the request primarily and dispatches it to the chain of handlers. This Handler knows only the first handler of the chain. Handler: Concrete Handlers: These are the actual request handlers in sequential order. Concrete Handlers This pattern can be used in the following cases: Whenever we want to decouple the sender and the receiver of the request.\nWhenever we want multiple objects to handle a request at runtime.\nWhenever we do not want to explicitly specify handlers in the code.\nWhenever we want to issue a request to several objects without explicitly specifying handlers. Whenever we want to decouple the sender and the receiver of the request. Whenever we want multiple objects to handle a request at runtime. Whenever we do not want to explicitly specify handlers in the code. Whenever we want to issue a request to several objects without explicitly specifying handlers.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. How can you achieve thread-safe singleton patterns in Java?",
        "answer": "A thread-safe singleton class is created which helps in object initialization in the presence of multiple threads. It can be done using multiple ways: Using Enums: Enums are the simplest means of creating a thread-safe singleton class in Java because the synchronization support is inherently done by Java itself. Enums are by default final and this also helps in preventing multiple initializations at the time of serialization. Using Enums: Enums are the simplest means of creating a thread-safe singleton class in Java because the synchronization support is inherently done by Java itself. Enums are by default final and this also helps in preventing multiple initializations at the time of serialization. Using Enums: public enum ThreadSafeSingleton{\n      SINGLETON_INSTANCE;\n      public void display(){\n          System.out.println(\"Thread-safe singleton Display\");\n      }\n   }\n   // The Singleton class methods can be invoked as below\n   ThreadSafeSingleton.SINGLETON_INSTANCE.show(); public enum ThreadSafeSingleton{\n      SINGLETON_INSTANCE;\n      public void display(){\n          System.out.println(\"Thread-safe singleton Display\");\n      }\n   }\n   // The Singleton class methods can be invoked as below\n   ThreadSafeSingleton.SINGLETON_INSTANCE.show(); public enum ThreadSafeSingleton enum ThreadSafeSingleton public void display() public void display () \"Thread-safe singleton Display\" // The Singleton class methods can be invoked as below Using Static Field Initialization: Thread-safe singleton can also be created by creating the instance at the time of class loading. This is achieved by making use of static fields as the Classloader guarantees that the instances are initialized during class loading and the instance is not visible until that has been fully created. Using Static Field Initialization: Thread-safe singleton can also be created by creating the instance at the time of class loading. This is achieved by making use of static fields as the Classloader guarantees that the instances are initialized during class loading and the instance is not visible until that has been fully created. Using Static Field Initialization: public class ThreadSafeSingleton{\n      private static final ThreadSafeSingleton INSTANCE = new ThreadSafeSingleton();\n      private ThreadSafeSingleton(){ }\n      public static ThreadSafeSingleton getInstance(){\n          return INSTANCE;\n      }\n      public void display(){\n          System.out.println(\"Thread-safe Singleon\");\n      }\n   }\n   ThreadSafeSingleton.getInstance().display(); public class ThreadSafeSingleton{\n      private static final ThreadSafeSingleton INSTANCE = new ThreadSafeSingleton();\n      private ThreadSafeSingleton(){ }\n      public static ThreadSafeSingleton getInstance(){\n          return INSTANCE;\n      }\n      public void display(){\n          System.out.println(\"Thread-safe Singleon\");\n      }\n   }\n   ThreadSafeSingleton.getInstance().display(); public class ThreadSafeSingleton class ThreadSafeSingleton private static final new private ThreadSafeSingleton() private ThreadSafeSingleton () public static ThreadSafeSingleton getInstance() public static getInstance () return public void display() public void display () \"Thread-safe Singleon\" But the disadvantage of this way is that the initialization cannot be done lazily and the getInstance() method is called even before any client can call. Using synchronized keyword: We can make use of the synchronized keyword upon the getInstance method as shown below.\nIn this method, we can achieve lazy initialization, and also since we use synchronized keywords, the object initialization is thread-safe.\nThe only problem is that since the whole method is synchronized, the performance is impacted in the presence of multiple threads. Using synchronized keyword: We can make use of the synchronized keyword upon the getInstance method as shown below.\nIn this method, we can achieve lazy initialization, and also since we use synchronized keywords, the object initialization is thread-safe.\nThe only problem is that since the whole method is synchronized, the performance is impacted in the presence of multiple threads. Using synchronized keyword: In this method, we can achieve lazy initialization, and also since we use synchronized keywords, the object initialization is thread-safe.\nThe only problem is that since the whole method is synchronized, the performance is impacted in the presence of multiple threads. In this method, we can achieve lazy initialization, and also since we use synchronized keywords, the object initialization is thread-safe. The only problem is that since the whole method is synchronized, the performance is impacted in the presence of multiple threads. public class ThreadSafeSingleton\n   {\n    // Creating private instance to make it accessible only by getInstance() method\n    private static ThreadSafeSingleton instance;\n    private ThreadSafeSingleton()\n    {\n      // Making constructor private so that objects cant be initialized outside the class\n    }\n    //synchronized getInstance method\n    synchronized public static ThreadSafeSingleton getInstance(){\n      if (this.instance == null)\n      {\n        // if instance is null, initialize\n        this.instance = new ThreadSafeSingleton();\n      }\n      return this.instance;\n    }\n   } public class ThreadSafeSingleton\n   {\n    // Creating private instance to make it accessible only by getInstance() method\n    private static ThreadSafeSingleton instance;\n    private ThreadSafeSingleton()\n    {\n      // Making constructor private so that objects cant be initialized outside the class\n    }\n    //synchronized getInstance method\n    synchronized public static ThreadSafeSingleton getInstance(){\n      if (this.instance == null)\n      {\n        // if instance is null, initialize\n        this.instance = new ThreadSafeSingleton();\n      }\n      return this.instance;\n    }\n   } public class ThreadSafeSingleton class ThreadSafeSingleton // Creating private instance to make it accessible only by getInstance() method private static private ThreadSafeSingleton() private ThreadSafeSingleton () // Making constructor private so that objects cant be initialized outside the class //synchronized getInstance method synchronized public static ThreadSafeSingleton getInstance() synchronized public static getInstance () if this null // if instance is null, initialize this new return this Double-check locking: Here, we will be using a synchronized block of code within the getInstance method instead of making the whole method synchronized. This ensures that only a handful of threads have to wait only for the first time thereby not impacting the performance. Double-check locking: Here, we will be using a synchronized block of code within the getInstance method instead of making the whole method synchronized. This ensures that only a handful of threads have to wait only for the first time thereby not impacting the performance. Double-check locking: public class ThreadSafeSingleton {\n    // Creating private instance to make it accessible only by getInstance() method\n    private static ThreadSafeSingleton instance;\n    private ThreadSafeSingleton(){\n      // Making constructor private so that objects cant be initialized outside the class\n    }\n    public static ThreadSafeSingleton getInstance(){\n      if (instance == null){\n        //synchronized block of code\n        synchronized (ThreadSafeSingleton.class){\n          if(instance==null)\n          {\n            // initialize only if instance is null\n            instance = new ThreadSafeSingleton();\n          }\n        }\n      }\n      return instance;\n    }\n   } public class ThreadSafeSingleton {\n    // Creating private instance to make it accessible only by getInstance() method\n    private static ThreadSafeSingleton instance;\n    private ThreadSafeSingleton(){\n      // Making constructor private so that objects cant be initialized outside the class\n    }\n    public static ThreadSafeSingleton getInstance(){\n      if (instance == null){\n        //synchronized block of code\n        synchronized (ThreadSafeSingleton.class){\n          if(instance==null)\n          {\n            // initialize only if instance is null\n            instance = new ThreadSafeSingleton();\n          }\n        }\n      }\n      return instance;\n    }\n   } public class ThreadSafeSingleton class ThreadSafeSingleton // Creating private instance to make it accessible only by getInstance() method private static private ThreadSafeSingleton() private ThreadSafeSingleton () // Making constructor private so that objects cant be initialized outside the class public static ThreadSafeSingleton getInstance() public static getInstance () if null //synchronized block of code synchronized if null // initialize only if instance is null new return",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What would happen if we do not have a synchronized method for returning Singleton instance in a multi-threaded environment?",
        "answer": "In a multi-threaded environment, if we have a non-synchronized method for returning instances, there are chances that the method can create more than one instance. Consider that we have 2 threads and both enter the condition for checking if the instance already exists. Both threads will find that the instance has not been created and hence both will create the class instances. This goes against the principle of the Singleton pattern. Hence, in a multi-threaded environment, it is recommended to use synchronized checks.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What are some instances where we prefer abstract classes over interfaces in Java?",
        "answer": "Both Abstract classes and interfaces in Java follow the principle of writing code for interface rather than the implementation. This principle ensures that flexibility is added to the code to tackle dynamic requirements. Some of the pointers for deciding what to prefer over what are as follows: Java lets to extend only one class and let\u2019s implement multiple interfaces. If we extend one class then we cannot extend other classes. In such cases, it is better to implement the interfaces wherever possible and reserve the inheritance of classes to only important ones.\nInterfaces are used for representing the behaviour of the class. Java lets to implement multiple interfaces which is why we can take the help of interfaces to help classes have multiple behaviours at the same time.\nAbstract classes are slightly faster than interfaces. It can be used for time-critical applications.\nIn cases where there are common behaviours across the inheritance hierarchy, these can be coded at one place in abstract classes. Interfaces and abstract classes can also be used together to define a function in interface and functionality in abstract class. Java lets to extend only one class and let\u2019s implement multiple interfaces. If we extend one class then we cannot extend other classes. In such cases, it is better to implement the interfaces wherever possible and reserve the inheritance of classes to only important ones. Interfaces are used for representing the behaviour of the class. Java lets to implement multiple interfaces which is why we can take the help of interfaces to help classes have multiple behaviours at the same time. Abstract classes are slightly faster than interfaces. It can be used for time-critical applications. In cases where there are common behaviours across the inheritance hierarchy, these can be coded at one place in abstract classes. Interfaces and abstract classes can also be used together to define a function in interface and functionality in abstract class.",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. What is a Bridge Design Pattern?",
        "answer": "The bridge pattern is a type of structural design pattern that lets to split large class or closely related classes into 2 hierarchies - abstraction and implementation. These hierarchies are independent of each other and are used whenever we need to decouple an abstraction from implementation. This is called a Bridge pattern because it acts as a bridge between the abstract class and the implementation class. In this pattern, the abstract classes and the implementation classes can be altered or modified independently without affecting the other one.   The above image is the UML representation of the Bridge Pattern. There are 4 main elements of Bridge Pattern. They are: Abstraction \u2013 This is the core of the pattern and it defines its crux. This contains a reference to the implementer.\nRefined Abstraction \u2013 This extends the abstraction and takes refined details of the requirements and hides it from the implementors.\nImplementer \u2013 This is the interface for the implementation classes.\nConcrete Implementation \u2013 These are the concrete implementation classes that implement the Implementer interface. Abstraction \u2013 This is the core of the pattern and it defines its crux. This contains a reference to the implementer. Abstraction Refined Abstraction \u2013 This extends the abstraction and takes refined details of the requirements and hides it from the implementors. Refined Abstraction Implementer \u2013 This is the interface for the implementation classes. Implementer Concrete Implementation \u2013 These are the concrete implementation classes that implement the Implementer interface. Concrete Implementation",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What is a Proxy Design Pattern?",
        "answer": "Proxy design pattern falls under the category of structural design that represents the functionality of other classes. This pattern lets the developers provide a substitute for another object. This is called a proxy object. This helps to control the access to the original object and allows us to perform many tasks before or after the request reaches the original object.   As shown in the figure above, in this pattern, we have a ServiceInterface interface that has some operation. This interface is being implemented by a Service class and a Proxy class. The Service class has useful business logic and the Proxy class has a reference field pointing to the service object. Once the proxy finishes processing lazy initialization, logging, caching etc, the request will be passed to the service object. And finally, we have a client that works with the services and the proxies by using the interface. This helps to pass proxy objects to any piece of code.",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. What is an Adapter Design Pattern?",
        "answer": "The adapter design pattern falls under the category of a structural design pattern that lets incompatible objects collaborate. It acts as a wrapper between 2 different objects. The adapter catches the call for one object and transforms them to be recognizable by the second object. Let us understand this with the help of an example of a USB to Ethernet adapter that is used when we have an ethernet interface at one end and the USB interface on the other end. The USB and ethernet are incompatible with each other which is why we require an adapter. The adapter class has a Client class that expects some object type and it has an Adaptee class that offers the same feature but by exposing a different interface. Now to make these both communicate, we have an Adapter class. The client requests the Adapter by using the target interface. The Adapter class translates the request using the Adaptee Interface on the adaptee. The Client receives the results unaware of the adapter\u2019s role. This has been described in the class diagram as shown below: Class Diagram:   Let us consider that we have a MediaPlayer Interface which is implemented by the AudioPlayer class. The AudioPlayer can play mp3 format by default. Consider another interface AdvancedPlayer that is being implemented by MP4Player class that plays mp4 formats and WAVPlayer that plays wav formats. If we want to make AudioPlayer class play other formats, then we make use of the MediaAdapter class that implements the MediaPlayer Interface and uses the AdvancedPlayer objects for playing the required format. The code implementation of this scenario is as follows: //MediaPlayer.java\npublic interface MediaPlayer {\n  public void play(String format, String file);\n} //MediaPlayer.java\npublic interface MediaPlayer {\n  public void play(String format, String file);\n} //MediaPlayer.java public interface MediaPlayer interface MediaPlayer public void play(String format, String file) public void play (String format, String file) //AdvancedPlayer.java\npublic interface AdvancedPlayer { \n  public void playMp4(String file);\n  public void playWav(String file);\n} //AdvancedPlayer.java\npublic interface AdvancedPlayer { \n  public void playMp4(String file);\n  public void playWav(String file);\n} //AdvancedPlayer.java public interface AdvancedPlayer interface AdvancedPlayer public void playMp4(String file) public void playMp4 (String file) public void playWav(String file) public void playWav (String file) //Mp4Player.java\npublic class Mp4Player implements AdvancedPlayer{\n  @Override\n  public void playMp4(String file) {\n     System.out.println(\"MP4 File \"+ file + \" Playing....\");  \n  }\n  \n  @Override\n  public void playWav(String file) {\n     //do nothing\n  }\n} //Mp4Player.java\npublic class Mp4Player implements AdvancedPlayer{\n  @Override\n  public void playMp4(String file) {\n     System.out.println(\"MP4 File \"+ file + \" Playing....\");  \n  }\n  \n  @Override\n  public void playWav(String file) {\n     //do nothing\n  }\n} //Mp4Player.java public class Mp4Player implements AdvancedPlayer class Mp4Player implements AdvancedPlayer @Override public void playMp4(String file) public void playMp4 (String file) \"MP4 File \" \" Playing....\" @Override public void playWav(String file) public void playWav (String file) //do nothing //WAVPlayer.java\npublic class WAVPlayer implements AdvancedPlayer{\n  @Override\n  public void playMp4(String file) {\n     //do nothing\n  }\n  \n  @Override\n  public void playWav(String file) {\n     System.out.println(\"WAV File \"+ file + \" Playing....\");  \n  }\n} //WAVPlayer.java\npublic class WAVPlayer implements AdvancedPlayer{\n  @Override\n  public void playMp4(String file) {\n     //do nothing\n  }\n  \n  @Override\n  public void playWav(String file) {\n     System.out.println(\"WAV File \"+ file + \" Playing....\");  \n  }\n} //WAVPlayer.java public class WAVPlayer implements AdvancedPlayer class WAVPlayer implements AdvancedPlayer @Override public void playMp4(String file) public void playMp4 (String file) //do nothing @Override public void playWav(String file) public void playWav (String file) \"WAV File \" \" Playing....\" //MediaAdapter.java\npublic class MediaAdapter implements MediaPlayer {\n  AdvancedPlayer advancedPlayer;\n  public MediaAdapter(String format){\n     if(format.equalsIgnoreCase(\"mp4\") ){\n        advancedPlayer = new Mp4Player();   \n     }else if(format.equalsIgnoreCase(\"wav\") ){\n        advancedPlayer = new WAVPlayer();   \n     }\n  }\n  @Override\n  public void play(String format, String file) {\n  \n     if(format.equalsIgnoreCase(\"mp4\")){\n        advancedPlayer.playMp4(file);\n     }\n     else if(format.equalsIgnoreCase(\"wav\")){\n        advancedPlayer.playWav(file);\n     }\n  }\n} //MediaAdapter.java\npublic class MediaAdapter implements MediaPlayer {\n  AdvancedPlayer advancedPlayer;\n  public MediaAdapter(String format){\n     if(format.equalsIgnoreCase(\"mp4\") ){\n        advancedPlayer = new Mp4Player();   \n     }else if(format.equalsIgnoreCase(\"wav\") ){\n        advancedPlayer = new WAVPlayer();   \n     }\n  }\n  @Override\n  public void play(String format, String file) {\n  \n     if(format.equalsIgnoreCase(\"mp4\")){\n        advancedPlayer.playMp4(file);\n     }\n     else if(format.equalsIgnoreCase(\"wav\")){\n        advancedPlayer.playWav(file);\n     }\n  }\n} //MediaAdapter.java public class MediaAdapter implements MediaPlayer class MediaAdapter implements MediaPlayer public MediaAdapter(String format) public MediaAdapter (String format) if \"mp4\" new else if \"wav\" new @Override public void play(String format, String file) public void play (String format, String file) if \"mp4\" else if \"wav\" //AudioPlayer.java\npublic class AudioPlayer implements MediaPlayer {\n  MediaAdapter mediaAdapter;\n  @Override\n  public void play(String format, String file) {  \n     //inbuilt support to play mp3 music files\n     if(format.equalsIgnoreCase(\"mp3\")){\n        System.out.println(\"MP3 file \" + file +\" Playing...\");   \n     } \n     //Make use of Adapter to support different formats\n     else if(format.equalsIgnoreCase(\"wav\") || format.equalsIgnoreCase(\"mp4\")){\n        mediaAdapter = new MediaAdapter(format);\n        mediaAdapter.play(format, file);\n     }\n     else{\n        System.out.println(\"Format not supported\");\n     }\n  }   \n} //AudioPlayer.java\npublic class AudioPlayer implements MediaPlayer {\n  MediaAdapter mediaAdapter;\n  @Override\n  public void play(String format, String file) {  \n     //inbuilt support to play mp3 music files\n     if(format.equalsIgnoreCase(\"mp3\")){\n        System.out.println(\"MP3 file \" + file +\" Playing...\");   \n     } \n     //Make use of Adapter to support different formats\n     else if(format.equalsIgnoreCase(\"wav\") || format.equalsIgnoreCase(\"mp4\")){\n        mediaAdapter = new MediaAdapter(format);\n        mediaAdapter.play(format, file);\n     }\n     else{\n        System.out.println(\"Format not supported\");\n     }\n  }   \n} //AudioPlayer.java public class AudioPlayer implements MediaPlayer class AudioPlayer implements MediaPlayer @Override public void play(String format, String file) public void play (String format, String file) //inbuilt support to play mp3 music files if \"mp3\" \"MP3 file \" \" Playing...\" //Make use of Adapter to support different formats else if \"wav\" \"mp4\" new else \"Format not supported\" //Driver.java\npublic class Driver {\n  public static void main(String[] args) {\n     AudioPlayer audioPlayer = new AudioPlayer();\n     audioPlayer.play(\"mp3\", \"music1.mp3\");\n     audioPlayer.play(\"wav\", \"music2.wav\");\n     audioPlayer.play(\"mp4\", \"music3.mp4\");\n     audioPlayer.play(\"avi\", \"music4.avi\");\n  }\n} //Driver.java\npublic class Driver {\n  public static void main(String[] args) {\n     AudioPlayer audioPlayer = new AudioPlayer();\n     audioPlayer.play(\"mp3\", \"music1.mp3\");\n     audioPlayer.play(\"wav\", \"music2.wav\");\n     audioPlayer.play(\"mp4\", \"music3.mp4\");\n     audioPlayer.play(\"avi\", \"music4.avi\");\n  }\n} //Driver.java public class Driver class Driver public static void main(String[] args) public static void main (String[] args) new \"mp3\" \"music1.mp3\" \"wav\" \"music2.wav\" \"mp4\" \"music3.mp4\" \"avi\" \"music4.avi\" The output of this code would be: MP3 file music1.mp3 Playing...\nWAV File music2.wav Playing...\nMP4 File music3.mp4 Playing...\nFormat not supported MP3 file music1.mp3 Playing...\nWAV File music2.wav Playing...\nMP4 File music3.mp4 Playing...\nFormat not supported",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. What is a Factory Design Pattern?",
        "answer": "Factory design pattern belongs to the category of Creational Design Patterns. Here, the objects are created without exposing the logic of creation to the client. The objects refer to the common interface. Let us understand this with the help of an example. Let\u2019s consider 3 classes Square, Rectangle and Triangle. We will be using factory patterns to create objects of these three classes without exposing the creation logic by making use of ShapeFactory class. The Driver class would be passing the information like RECTANGLE/SQUARE/TRIANGLE for getting the required object. The following UML diagram represents the scenario.   Now to implement the factory design pattern for the above example, let us follow the below steps: Step 1: Create a Shape interface. Step 1: Create a Shape interface. Step 1: //Shape.java\n   public interface Shape {\n      void draw();\n   } //Shape.java\n   public interface Shape {\n      void draw();\n   } //Shape.java public interface Shape interface Shape void draw() void draw () Step 2: Create concrete classes Rectangle, Square, Triangle that implements the Shape interface. Step 2: Create concrete classes Rectangle, Square, Triangle that implements the Shape interface. Step 2: //Rectangle.java\n   public class Rectangle implements Shape {\n      @Override\n      public void draw() {\n         System.out.println(\"Rectangle Drawn\");\n      }\n   } //Rectangle.java\n   public class Rectangle implements Shape {\n      @Override\n      public void draw() {\n         System.out.println(\"Rectangle Drawn\");\n      }\n   } //Rectangle.java public class Rectangle implements Shape class Rectangle implements Shape @Override public void draw() public void draw () \"Rectangle Drawn\" //Square.java\n   public class Square implements Shape {\n      @Override\n      public void draw() {\n         System.out.println(\"Square Drawn\");\n      }\n   } //Square.java\n   public class Square implements Shape {\n      @Override\n      public void draw() {\n         System.out.println(\"Square Drawn\");\n      }\n   } //Square.java public class Square implements Shape class Square implements Shape @Override public void draw() public void draw () \"Square Drawn\" //Triangle.java\n   public class Triangle implements Shape {\n      @Override\n      public void draw() {\n         System.out.println(\"Triangle Drawn\");\n      }\n   } //Triangle.java\n   public class Triangle implements Shape {\n      @Override\n      public void draw() {\n         System.out.println(\"Triangle Drawn\");\n      }\n   } //Triangle.java public class Triangle implements Shape class Triangle implements Shape @Override public void draw() public void draw () \"Triangle Drawn\" Step 3: Create ShapeFactory class and create a method called getShapeInstance() for generating objects of the concrete classes defined above. Step 3: Create ShapeFactory class and create a method called getShapeInstance() for generating objects of the concrete classes defined above. Step 3: //ShapeFactory.java\n   public class ShapeFactory {\n      //the method will be used to get object of required shape\n      public Shape getShapeInstance(String type){\n         if(type == null){\n            return null;\n         } \n         if(type.equalsIgnoreCase(\"TRIANGLE\")){\n            return new Triangle();\n         } else if(type.equalsIgnoreCase(\"SQUARE\")){\n            return new Square();\n         } else if(type.equalsIgnoreCase(\"RECTANGLE\")){\n            return new Rectangle();\n         }\n         return null;\n      }\n   } //ShapeFactory.java\n   public class ShapeFactory {\n      //the method will be used to get object of required shape\n      public Shape getShapeInstance(String type){\n         if(type == null){\n            return null;\n         } \n         if(type.equalsIgnoreCase(\"TRIANGLE\")){\n            return new Triangle();\n         } else if(type.equalsIgnoreCase(\"SQUARE\")){\n            return new Square();\n         } else if(type.equalsIgnoreCase(\"RECTANGLE\")){\n            return new Rectangle();\n         }\n         return null;\n      }\n   } //ShapeFactory.java public class ShapeFactory class ShapeFactory //the method will be used to get object of required shape public Shape getShapeInstance(String type) public getShapeInstance (String type) if null return null if \"TRIANGLE\" return new else if \"SQUARE\" return new else if \"RECTANGLE\" return new return null Step 4: Implement the Driver class and utilise the factory class for getting the object of the required type. Step 4: Implement the Driver class and utilise the factory class for getting the object of the required type. Step 4: //Driver.java\n   public class Driver {\n      public static void main(String[] args) {\n         ShapeFactory shapeFactory = new ShapeFactory();\n         //get Triangle object and call draw()\n         Shape triangle = shapeFactory.getShape(\"Triangle\");\n         triangle.draw();\n         //get Rectangle object and call draw()\n         Shape rectangle = shapeFactory.getShape(\"RECTANGLE\");\n         rectangle.draw();\n         //get Square object and call draw()\n         Shape square = shapeFactory.getShape(\"SQUARE\");\n         square.draw();\n      }\n   } //Driver.java\n   public class Driver {\n      public static void main(String[] args) {\n         ShapeFactory shapeFactory = new ShapeFactory();\n         //get Triangle object and call draw()\n         Shape triangle = shapeFactory.getShape(\"Triangle\");\n         triangle.draw();\n         //get Rectangle object and call draw()\n         Shape rectangle = shapeFactory.getShape(\"RECTANGLE\");\n         rectangle.draw();\n         //get Square object and call draw()\n         Shape square = shapeFactory.getShape(\"SQUARE\");\n         square.draw();\n      }\n   } //Driver.java public class Driver class Driver public static void main(String[] args) public static void main (String[] args) new //get Triangle object and call draw() \"Triangle\" //get Rectangle object and call draw() \"RECTANGLE\" //get Square object and call draw() \"SQUARE\" Step 5: Validate the output\nThe output of this implementation would be: Step 5: Validate the output\nThe output of this implementation would be: Step 5:  Triangle Drawn\n  Rectangle Drawn\n  Square Drawn Triangle Drawn\n  Rectangle Drawn\n  Square Drawn The advantages of a factory design pattern are: advantages This pattern allows hiding the creation logic of the application by using interfaces and factory classes.\nIt lets to test the seamlessness of the application by using mock or stubs.\nIntroduces loose coupling in the application by allowing flexibility in the implementation of methods when new classes are introduced. This pattern allows hiding the creation logic of the application by using interfaces and factory classes. It lets to test the seamlessness of the application by using mock or stubs. Introduces loose coupling in the application by allowing flexibility in the implementation of methods when new classes are introduced.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Write a Java Program to display the pyramid as per the below design.",
        "answer": "*\n    * *\n   * * *\n  * * * *\n * * * * * *\n    * *\n   * * *\n  * * * *\n * * * * * This can be achieved by using nested loops and calculatingly adding spaces and stars as shown in the logic below: public class InterviewBitPyramid{  \n   public static void printPyramid(int n) {  \n       for (int i=0; i<n; i++){  // for number of rows \n           for (int j=n-i; j>1; j--) { \n               System.out.print(\" \"); //print space\n           }  \n           //for number of columns\n           for (int j=0; j<=i; j++ ) { \n               System.out.print(\"* \"); // print star\n           } \n           //end-line after every row\n           System.out.println();\n       } \n   } \n   \n   public static void main(String args[]){ \n       printPyramid(5); //Print Pyramid stars of 5 rows\n   }\n} public class InterviewBitPyramid{  \n   public static void printPyramid(int n) {  \n       for (int i=0; i<n; i++){  // for number of rows \n           for (int j=n-i; j>1; j--) { \n               System.out.print(\" \"); //print space\n           }  \n           //for number of columns\n           for (int j=0; j<=i; j++ ) { \n               System.out.print(\"* \"); // print star\n           } \n           //end-line after every row\n           System.out.println();\n       } \n   } \n   \n   public static void main(String args[]){ \n       printPyramid(5); //Print Pyramid stars of 5 rows\n   }\n} public class InterviewBitPyramid class InterviewBitPyramid public static void printPyramid(int n) public static void printPyramid (int n) int for int 0 // for number of rows for int 1 \" \" //print space //for number of columns for int 0 \"* \" // print star //end-line after every row public static void main(String args[]) public static void main (String args[]) 5 //Print Pyramid stars of 5 rows Output: *\n    * *\n   * * *\n  * * * *\n * * * * * *\n    * *\n   * * *\n  * * * *\n * * * * *",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Write a Java Program to display the left triangle star pattern on the system console.",
        "answer": "This can be again be achieved by using nested loops and calculatingly adding spaces and stars as shown in the logic below: public class InterviewBitLeftPyramid{\n   public static void printLeftTriangleStars(int n) { \n       int j;  \n       for(int i=0; i<n; i++){  // outer loop for number of rows(n) \n           for(j=2*(n-i); j>=0; j--){   // for spaces\n               System.out.print(\" \"); // to print space\n           } \n           for(j=0; j<=i; j++){ // for columns\n               System.out.print(\"* \"); // Print star and give space\n           }           \n           System.out.println(); // Go to next line after every row\n       } \n   }\n   public static void main(String args[]){  \n       printLeftTriangleStars(5); //print stars of 5 rows in left triangle fashion\n   }\n} public class InterviewBitLeftPyramid{\n   public static void printLeftTriangleStars(int n) { \n       int j;  \n       for(int i=0; i<n; i++){  // outer loop for number of rows(n) \n           for(j=2*(n-i); j>=0; j--){   // for spaces\n               System.out.print(\" \"); // to print space\n           } \n           for(j=0; j<=i; j++){ // for columns\n               System.out.print(\"* \"); // Print star and give space\n           }           \n           System.out.println(); // Go to next line after every row\n       } \n   }\n   public static void main(String args[]){  \n       printLeftTriangleStars(5); //print stars of 5 rows in left triangle fashion\n   }\n} public class InterviewBitLeftPyramid class InterviewBitLeftPyramid public static void printLeftTriangleStars(int n) public static void printLeftTriangleStars (int n) int int for int 0 // outer loop for number of rows(n) for 2 0 // for spaces \" \" // to print space for 0 // for columns \"* \" // Print star and give space // Go to next line after every row public static void main(String args[]) public static void main (String args[]) 5 //print stars of 5 rows in left triangle fashion Output: *\n        * *\n      * * *\n    * * * *\n  * * * * * *\n        * *\n      * * *\n    * * * *\n  * * * * *",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Write a Java program to print Diamond Number Pattern.",
        "answer": "public class InterviewBitDiamondNumber{            \n   public static void diamondNumberDisplay(int maxNum){\n     for (int i = 1; i <= maxNum; i++){\n           int n = maxNum;\n           for (int j = 1; j<= n - i; j++) {\n               System.out.print(\" \"); \n           } \n           for (int k = i; k >= 1; k--) {\n               System.out.print(k);\n           }\n           for (int l = 2; l <= i; l++) {\n               System.out.print(l); \n           } \n           System.out.println(); \n       } \n       for (int i = maxNum-1; i >= 1; i--){\n           int n = maxNum-1;\n           for (int j = 0; j<= n - i; j++) {\n               System.out.print(\" \"); \n           } \n           for (int k = i; k >= 1; k--){\n               System.out.print(k);\n           }\n           for (int l = 2; l <= i; l++){\n               System.out.print(l);\n           }\n           System.out.println();\n       }\n   }\n   public static void main(String[] args) {\n     int n = 5;\n     diamondNumberDisplay(n);\n       \n   }\n} public class InterviewBitDiamondNumber{            \n   public static void diamondNumberDisplay(int maxNum){\n     for (int i = 1; i <= maxNum; i++){\n           int n = maxNum;\n           for (int j = 1; j<= n - i; j++) {\n               System.out.print(\" \"); \n           } \n           for (int k = i; k >= 1; k--) {\n               System.out.print(k);\n           }\n           for (int l = 2; l <= i; l++) {\n               System.out.print(l); \n           } \n           System.out.println(); \n       } \n       for (int i = maxNum-1; i >= 1; i--){\n           int n = maxNum-1;\n           for (int j = 0; j<= n - i; j++) {\n               System.out.print(\" \"); \n           } \n           for (int k = i; k >= 1; k--){\n               System.out.print(k);\n           }\n           for (int l = 2; l <= i; l++){\n               System.out.print(l);\n           }\n           System.out.println();\n       }\n   }\n   public static void main(String[] args) {\n     int n = 5;\n     diamondNumberDisplay(n);\n       \n   }\n} public class InterviewBitDiamondNumber class InterviewBitDiamondNumber public static void diamondNumberDisplay(int maxNum) public static void diamondNumberDisplay (int maxNum) int for int 1 int for int 1 \" \" for int 1 for int 2 for int 1 1 int 1 for int 0 \" \" for int 1 for int 2 public static void main(String[] args) public static void main (String[] args) int 5 Output: 1\n  212\n 32123\n4321234\n543212345\n4321234\n 32123\n  212\n   1 1\n  212\n 32123\n4321234\n543212345\n4321234\n 32123\n  212\n   1 1 212 32123 4321234 543212345 4321234 32123 212 1",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Write a Java program that takes a String as an input and prints the pattern in the increasing order of odd numbers as shown in the example below:",
        "answer": "If String input is PATTERN, then the pattern will be:\n      P        (First Character Once)\n     AAA       (Second Character thrice)\n    TTTTT      (Third Character 5 times)\n   TTTTTTT            :\n  EEEEEEEEE           :\n RRRRRRRRRRR          :\nNNNNNNNNNNNNN         : If String input is PATTERN, then the pattern will be:\n      P        (First Character Once)\n     AAA       (Second Character thrice)\n    TTTTT      (Third Character 5 times)\n   TTTTTTT            :\n  EEEEEEEEE           :\n RRRRRRRRRRR          :\nNNNNNNNNNNNNN         : 5 Solution: Solution: import java.util.Scanner;\npublic class InterviewBitStringPattern{\n   public static void printStringPattern(String input){\n     for (int i = 1; i <= input.length(); i++) {\n           for (int j = input.length(); j > i; j--){\n             System.out.print(\" \");\n           }\n           for (int k = i * 2 - 1; k >= 1; k--){\n             System.out.print(input.charAt(i - 1));\n           }\n           System.out.println(\"\");\n       }\n   }\n   public static void main(String[] args) {\n       // to create a new Scanner object\n       Scanner scanner = new Scanner(System.in);\n       // to get the String from the user\n       System.out.println(\"Enter Input String: \");\n       String input = scanner.nextLine();\n       System.out.println(\"Printing Pattern.....\");\n       printStringPattern(input);\n   }\n} import java.util.Scanner;\npublic class InterviewBitStringPattern{\n   public static void printStringPattern(String input){\n     for (int i = 1; i <= input.length(); i++) {\n           for (int j = input.length(); j > i; j--){\n             System.out.print(\" \");\n           }\n           for (int k = i * 2 - 1; k >= 1; k--){\n             System.out.print(input.charAt(i - 1));\n           }\n           System.out.println(\"\");\n       }\n   }\n   public static void main(String[] args) {\n       // to create a new Scanner object\n       Scanner scanner = new Scanner(System.in);\n       // to get the String from the user\n       System.out.println(\"Enter Input String: \");\n       String input = scanner.nextLine();\n       System.out.println(\"Printing Pattern.....\");\n       printStringPattern(input);\n   }\n} import public class InterviewBitStringPattern class InterviewBitStringPattern public static void printStringPattern(String input) public static void printStringPattern (String input) for int 1 for int \" \" for int 2 1 1 1 \"\" public static void main(String[] args) public static void main (String[] args) // to create a new Scanner object new // to get the String from the user \"Enter Input String: \" \"Printing Pattern.....\" Output: Enter Input String: \nPATTERN\nPrinting Pattern.....\n     P\n    AAA\n   TTTTT\n  TTTTTTT\n EEEEEEEEE\nRRRRRRRRRRR\nNNNNNNNNNNNNN Enter Input String: \nPATTERN\nPrinting Pattern.....\n     P\n    AAA\n   TTTTT\n  TTTTTTT\n EEEEEEEEE\nRRRRRRRRRRR\nNNNNNNNNNNNNN",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Write a Java program to print Pascal\u2019s Triangle Pattern.",
        "answer": "public class Main {            \n   public static void printPascalsTriangle(int n){\n       for (int i = 0; i < n; i++) {\n             int number = 1;\n             System.out.printf(\"%\" + (n - i) * 2 + \"s\", \"\");\n             for (int j = 0; j <= i; j++) {\n                 System.out.printf(\"%4d\", number);\n                 number = number * (i - j) / (j + 1);\n             }\n             System.out.println();\n         }\n   }\n   public static void main(String[] args) {\n       int n = 8;\n       printPascalsTriangle(n);\n   }\n} public class Main {            \n   public static void printPascalsTriangle(int n){\n       for (int i = 0; i < n; i++) {\n             int number = 1;\n             System.out.printf(\"%\" + (n - i) * 2 + \"s\", \"\");\n             for (int j = 0; j <= i; j++) {\n                 System.out.printf(\"%4d\", number);\n                 number = number * (i - j) / (j + 1);\n             }\n             System.out.println();\n         }\n   }\n   public static void main(String[] args) {\n       int n = 8;\n       printPascalsTriangle(n);\n   }\n} public class Main class Main public static void printPascalsTriangle(int n) public static void printPascalsTriangle (int n) int for int 0 int 1 \"%\" 2 \"s\" \"\" for int 0 \"%4d\" 1 public static void main(String[] args) public static void main (String[] args) int 8 Output: 1\n                1   1\n              1   2   1\n            1   3   3   1\n          1   4   6   4   1\n        1   5  10  10   5   1\n      1   6  15  20  15   6   1\n    1   7  21  35  35  21   7   1 1\n                1   1\n              1   2   1\n            1   3   3   1\n          1   4   6   4   1\n        1   5  10  10   5   1\n      1   6  15  20  15   6   1\n    1   7  21  35  35  21   7   1 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 Conclusion Design Patterns ensure that the reusable solutions that are well-tested are implemented which improves the code flexibility and paves way for developing smart and extendible solutions that solve problems easily. Due to this, the demand for software developers to know the best design practices and implementation has been rising steadily. These are generally discussed in the LLD (Low-Level Design) round of the company interviews. In this article, we have covered the most commonly asked design patterns interview questions for both freshers and experienced software professionals. software developers Low-Level Design Useful Resources: Useful Resources: System Design Interview\nSystem Design\nPractice\nCoding Interview Questions\nTechnical Interview Questions System Design Interview System Design Interview System Design System Design Practice Practice Coding Interview Questions Coding Interview Questions Technical Interview Questions Technical Interview Questions",
        "reference": "interviewbit.com"
    }
]