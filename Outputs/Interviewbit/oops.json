[
    {
        "question": "1. What is the need for OOPs?",
        "answer": "There are many reasons why OOPs is mostly preferred, but the most important among them are: OOPs helps users to understand the software easily, although they don\u2019t know the actual implementation.\nWith OOPs, the readability, understandability, and maintainability of the code increase multifold.\nEven very big software can be easily written and managed easily using OOPs. OOPs helps users to understand the software easily, although they don\u2019t know the actual implementation. With OOPs, the readability, understandability, and maintainability of the code increase multifold. Even very big software can be easily written and managed easily using OOPs.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What are some major Object Oriented Programming languages?",
        "answer": "The programming languages that use and follow the Object-Oriented Programming paradigm or OOPs, are known as Object-Oriented Programming languages. Some of the major Object-Oriented Programming languages include: Java\nC++\nJavascript\nPython\nPHP Java Java Java C++ C++ C++ Javascript Javascript Javascript Python Python Python PHP PHP PHP And many more.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What are some other programming paradigms other than OOPs?",
        "answer": "Programming paradigms refers to the method of classification of programming languages based on their features. There are mainly two types of Programming Paradigms: Imperative Programming Paradigm\nDeclarative Programming Paradigm Imperative Programming Paradigm Declarative Programming Paradigm Now, these paradigms can be further classified based:\n\n1. Imperative Programming Paradigm: Imperative programming focuses on HOW to execute program logic and defines control flow as statements that change a program state. This can be further classified as:\na) Procedural Programming Paradigm: Procedural programming specifies the steps a program must take to reach the desired state, usually read in order from top to bottom.\nb) Object-Oriented Programming or OOP: Object-oriented programming (OOP) organizes programs as objects, that contain some data and have some behavior.\nc) Parallel Programming: Parallel programming paradigm breaks a task into subtasks and focuses on executing them simultaneously at the same time.\n\n2. Declarative Programming Paradigm: Declarative programming focuses on WHAT to execute and defines program logic, but not a detailed control flow. Declarative paradigm can be further classified into:\na) Logical Programming Paradigm: Logical programming paradigm is based on formal logic, which refers to a set of sentences expressing facts and rules about how to solve a problem\nb) Functional Programming Paradigm: Functional programming is a programming paradigm where programs are constructed by applying and composing functions.\nc) Database Programming Paradigm: Database programming model is used to manage data and information structured as fields, records, and files.   1. Imperative Programming Paradigm  Procedural Programming Paradigm:  Object-Oriented Programming or OOP  Parallel Programming   2. Declarative Programming Paradigm  Logical Programming Paradigm  Functional Programming Paradigm  Database Programming Paradigm  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What is meant by Structured Programming?",
        "answer": "Structured Programming refers to the method of programming which consists of a completely structured control flow. Here structure refers to a block, which contains a set of rules, and has a definitive control flow, such as (if/then/else), (while and for), block structures, and subroutines. Structured Programming Nearly all programming paradigms include Structured programming, including the OOPs model.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What are the main features of OOPs?",
        "answer": "OOPs or Object Oriented Programming mainly comprises of the below four features, and make sure you don't miss any of these: Inheritance\nEncapsulation\nPolymorphism\nData Abstraction Inheritance Encapsulation Polymorphism Data Abstraction   ",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What are some advantages of using OOPs?",
        "answer": "OOPs is very helpful in solving very complex level of problems.\nHighly complex programs can be created, handled, and maintained easily using object-oriented programming.\nOOPs, promote code reuse, thereby reducing redundancy.\nOOPs also helps to hide the unnecessary details with the help of Data Abstraction.\nOOPs, are based on a bottom-up approach, unlike the Structural programming paradigm, which uses a top-down approach.\nPolymorphism offers a lot of flexibility in OOPs. OOPs is very helpful in solving very complex level of problems. Highly complex programs can be created, handled, and maintained easily using object-oriented programming. OOPs, promote code reuse, thereby reducing redundancy. OOPs also helps to hide the unnecessary details with the help of Data Abstraction. OOPs, are based on a bottom-up approach, unlike the Structural programming paradigm, which uses a top-down approach. Polymorphism offers a lot of flexibility in OOPs.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. Why is OOPs so popular?",
        "answer": "OOPs programming paradigm is considered as a better style of programming. Not only it helps in writing a complex piece of code easily, but it also allows users to handle and maintain them easily as well. Not only that, the main pillar of OOPs - Data Abstraction, Encapsulation, Inheritance, and Polymorphism, makes it easy for programmers to solve complex scenarios. As a result of these, OOPs is so popular.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What is meant by the term OOPs?",
        "answer": "OOPs refers to Object-Oriented Programming. It is the programming paradigm that is defined using objects. Objects can be considered as real-world instances of entities like class, that have some characteristics and behaviors.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. What are access specifiers and what is their significance?",
        "answer": "Access specifiers, as the name suggests, are a special type of keywords, which are used to control or specify the accessibility of entities like classes, methods, etc. Some of the access specifiers or access modifiers include \u201cprivate\u201d, \u201cpublic\u201d, etc. These access specifiers also play a very vital role in achieving Encapsulation - one of the major features of OOPs.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Are there any limitations of Inheritance?",
        "answer": "Yes, with more powers comes more complications. Inheritance is a very powerful feature in OOPs, but it has some limitations too. Inheritance needs more time to process, as it needs to navigate through multiple classes for its implementation. Also, the classes involved in Inheritance - the base class and the child class, are very tightly coupled together. So if one needs to make some changes, they might need to do nested changes in both classes. Inheritance might be complex for implementation, as well. So if not correctly implemented, this might lead to unexpected errors or incorrect outputs.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What are the various types of inheritance?",
        "answer": "The various types of inheritance include: Single inheritance\nMultiple inheritances\nMulti-level inheritance\nHierarchical inheritance\nHybrid inheritance Single inheritance Multiple inheritances Multi-level inheritance Hierarchical inheritance Hybrid inheritance  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What is a subclass?",
        "answer": "The subclass is a part of Inheritance. The subclass is an entity, which inherits from another class. It is also known as the child class.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Define a superclass?",
        "answer": "Superclass is also a part of Inheritance. The superclass is an entity, which allows subclasses or child classes to inherit from itself.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What is an interface?",
        "answer": "An interface refers to a special type of class, which contains methods, but not their definition. Only the declaration of methods is allowed inside an interface. To use an interface, you cannot create objects. Instead, you need to implement that interface and define the methods for their implementation.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What is meant by static polymorphism?",
        "answer": "Static Polymorphism is commonly known as the Compile time polymorphism. Static polymorphism is the feature by which an object is linked with the respective function or operator based on the values during the compile time. Static or Compile time Polymorphism can be achieved through Method overloading or operator overloading.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What is meant by dynamic polymorphism?",
        "answer": "Dynamic Polymorphism or Runtime polymorphism refers to the type of Polymorphism in OOPs, by which the actual implementation of the function is decided during the runtime or execution. The dynamic or runtime polymorphism can be achieved with the help of method overriding.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What is the difference between overloading and overriding?",
        "answer": "Overloading is a compile-time polymorphism feature in which an entity has multiple implementations with the same name. For example, Method overloading and Operator overloading. Whereas Overriding is a runtime polymorphism feature in which an entity has the same name, but its implementation changes during execution. For example, Method overriding.\nImage  Image",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. How is data abstraction accomplished?",
        "answer": "Data abstraction is accomplished with the help of abstract methods or abstract classes.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. What is an abstract class?",
        "answer": "An abstract class is a special class containing abstract methods. The significance of abstract class is that the abstract methods inside it are not implemented and only declared. So as a result, when a subclass inherits the abstract class and needs to use its abstract methods, they need to define and implement them.",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. How is an abstract class different from an interface?",
        "answer": "Interface and abstract classes both are special types of classes that contain only the methods declaration and not their implementation. But the interface is entirely different from an abstract class. The main difference between the two is that when an interface is implemented, the subclass must define all its methods and provide its implementation. Whereas in object-oriented programming, when a subclass inherits from an abstract class with abstract methods, the subclass is generally required to provide concrete implementations for all of those abstract methods in the abstract class unless the subclass itself is declared as abstract. Also, an abstract class can contain abstract methods as well as non-abstract methods.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. Explain Inheritance with an example?",
        "answer": "Inheritance is one of the major features of object-oriented programming, by which an entity inherits some characteristics and behaviors of some other entity and makes them their own. Inheritance helps to improve and facilitate code reuse. Let me explain to you with a common example. Let's take three different vehicles - a car, truck, or bus. These three are entirely different from one another with their own specific characteristics and behavior. But. in all three, you will find some common elements, like steering wheel, accelerator, clutch, brakes, etc. Though these elements are used in different vehicles, still they have their own features which are common among all vehicles. This is achieved with inheritance. The car, the truck, and the bus have all inherited the features like steering wheel, accelerator, clutch, brakes, etc, and used them as their own. Due to this, they did not have to create these components from scratch, thereby facilitating code reuse.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. What is an exception?",
        "answer": "An exception can be considered as a special event, which is raised during the execution of a program at runtime, that brings the execution to a halt. The reason for the exception is mainly due to a position in the program, where the user wants to do something for which the program is not specified, like undesirable input.",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What is meant by exception handling?",
        "answer": "No one wants its software to fail or crash. Exceptions are the major reason for software failure. The exceptions can be handled in the program beforehand and prevent the execution from stopping. This is known as exception handling.\nSo exception handling is the mechanism for identifying the undesirable states that the program can reach and specifying the desirable outcomes of such states.\nTry-catch is the most common method used for handling exceptions in the program.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. What is meant by Garbage Collection in OOPs world?",
        "answer": "Object-oriented programming revolves around entities like objects. Each object consumes memory and there can be multiple objects of a class. So if these objects and their memories are not handled properly, then it might lead to certain memory-related errors and the system might fail. Garbage collection refers to this mechanism of handling the memory in the program. Through garbage collection, the unwanted memory is freed up by removing the objects that are no longer needed.",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. Can we run a Java application without implementing the OOPs concept?",
        "answer": "No. Java applications are based on Object-oriented programming models or OOPs concept, and hence they cannot be implemented without it. However, on the other hand, C++ can be implemented without OOPs, as it also supports the C-like structural programming model.",
        "reference": "interviewbit.com"
    },
    {
        "question": "18. What is Compile time Polymorphism and how is it different from Runtime Polymorphism?",
        "answer": "  Compile Time Polymorphism: Compile time polymorphism, also known as Static Polymorphism, refers to the type of Polymorphism that happens at compile time. What it means is that the compiler decides what shape or value has to be taken by the entity in the picture. Compile Time Polymorphism: Example: // In this program, we will see how multiple functions are created with the same name, \n// but the compiler decides which function to call easily at the compile time itself.\nclass CompileTimePolymorphism{\n   // 1st method with name add\n   public int add(int x, int y){ \n   return x+y;\n   }\n   // 2nd method with name add\n   public int add(int x, int y, int z){\n   return x+y+z;\n   }\n   // 3rd method with name add\n   public int add(double x, int y){ \n   return (int)x+y;\n   }\n   // 4th method with name add\n   public int add(int x, double y){ \n   return x+(int)y;\n   }\n}\nclass Test{\n   public static void main(String[] args){\n   CompileTimePolymorphism demo=new CompileTimePolymorphism();\n   // In the below statement, the Compiler looks at the argument types and decides to call method 1\n   System.out.println(demo.add(2,3));\n   // Similarly, in the below statement, the compiler calls method 2\n   System.out.println(demo.add(2,3,4));\n   // Similarly, in the below statement, the compiler calls method 4\n   System.out.println(demo.add(2,3.4));\n   // Similarly, in the below statement, the compiler calls method 3\n   System.out.println(demo.add(2.5,3)); \n   }\n} // In this program, we will see how multiple functions are created with the same name, \n// but the compiler decides which function to call easily at the compile time itself.\nclass CompileTimePolymorphism{\n   // 1st method with name add\n   public int add(int x, int y){ \n   return x+y;\n   }\n   // 2nd method with name add\n   public int add(int x, int y, int z){\n   return x+y+z;\n   }\n   // 3rd method with name add\n   public int add(double x, int y){ \n   return (int)x+y;\n   }\n   // 4th method with name add\n   public int add(int x, double y){ \n   return x+(int)y;\n   }\n}\nclass Test{\n   public static void main(String[] args){\n   CompileTimePolymorphism demo=new CompileTimePolymorphism();\n   // In the below statement, the Compiler looks at the argument types and decides to call method 1\n   System.out.println(demo.add(2,3));\n   // Similarly, in the below statement, the compiler calls method 2\n   System.out.println(demo.add(2,3,4));\n   // Similarly, in the below statement, the compiler calls method 4\n   System.out.println(demo.add(2,3.4));\n   // Similarly, in the below statement, the compiler calls method 3\n   System.out.println(demo.add(2.5,3)); \n   }\n} // In this program, we will see how multiple functions are created with the same name, // but the compiler decides which function to call easily at the compile time itself. class CompileTimePolymorphism class CompileTimePolymorphism // 1st method with name add public int add(int x, int y) public int add (int x, int y) int int return // 2nd method with name add public int add(int x, int y, int z) public int add (int x, int y, int z) int int int return // 3rd method with name add public int add(double x, int y) public int add (double x, int y) double int return int // 4th method with name add public int add(int x, double y) public int add (int x, double y) int double return int class Test class Test public static void main(String[] args) public static void main (String[] args) new // In the below statement, the Compiler looks at the argument types and decides to call method 1 2 3 // Similarly, in the below statement, the compiler calls method 2 2 3 4 // Similarly, in the below statement, the compiler calls method 4 2 3.4 // Similarly, in the below statement, the compiler calls method 3 2.5 3 In the above example, there are four versions of add methods. The first method takes two parameters while the second one takes three. For the third and fourth methods, there is a change of order of parameters. The compiler looks at the method signature and decides which method to invoke for a particular method call at compile time.\n\nRuntime Polymorphism: Runtime polymorphism, also known as Dynamic Polymorphism, refers to the type of Polymorphism that happens at the run time. What it means is it can't be decided by the compiler. Therefore what shape or value has to be taken depends upon the execution. Hence the name Runtime Polymorphism.   Runtime Polymorphism: Example: class AnyVehicle{\n   public void move(){\n   System.out.println(\u201cAny vehicle should move!!\u201d);\n   }\n}\nclass Bike extends AnyVehicle{\n   public void move(){\n   System.out.println(\u201cBike can move too!!\u201d);\n   }\n}\nclass Test{\n   public static void main(String[] args){\n   AnyVehicle vehicle = new Bike();\n   // In the above statement, as you can see, the object vehicle is of type AnyVehicle\n   // But the output of the below statement will be \u201cBike can move too!!\u201d, \n   // because the actual implementation of object \u2018vehicle\u2019 is decided during runtime vehicle.move();\n   vehicle = new AnyVehicle();\n   // Now, the output of the below statement will be \u201cAny vehicle should move!!\u201d, \n   vehicle.move();\n   }\n} class AnyVehicle{\n   public void move(){\n   System.out.println(\u201cAny vehicle should move!!\u201d);\n   }\n}\nclass Bike extends AnyVehicle{\n   public void move(){\n   System.out.println(\u201cBike can move too!!\u201d);\n   }\n}\nclass Test{\n   public static void main(String[] args){\n   AnyVehicle vehicle = new Bike();\n   // In the above statement, as you can see, the object vehicle is of type AnyVehicle\n   // But the output of the below statement will be \u201cBike can move too!!\u201d, \n   // because the actual implementation of object \u2018vehicle\u2019 is decided during runtime vehicle.move();\n   vehicle = new AnyVehicle();\n   // Now, the output of the below statement will be \u201cAny vehicle should move!!\u201d, \n   vehicle.move();\n   }\n} class AnyVehicle class AnyVehicle public void move() public void move () class Bike extends AnyVehicle class Bike extends AnyVehicle public void move() public void move () class Test class Test public static void main(String[] args) public static void main (String[] args) new // In the above statement, as you can see, the object vehicle is of type AnyVehicle // But the output of the below statement will be \u201cBike can move too!!\u201d, // because the actual implementation of object \u2018vehicle\u2019 is decided during runtime vehicle.move(); new // Now, the output of the below statement will be \u201cAny vehicle should move!!\u201d, As the method to call is determined at runtime, as shown in the above code, this is called runtime polymorphism.",
        "reference": "interviewbit.com"
    },
    {
        "question": "19. What is a class?",
        "answer": "A class can be understood as a template or a blueprint, which contains some values, known as member data or member, and some set of rules, known as behaviors or functions. So when an object is created, it automatically takes the data and functions that are defined in the class.\nTherefore the class is basically a template or blueprint for objects. Also one can create as many objects as they want based on a class.  For example, first, a car\u2019s template is created. Then multiple units of car are created based on that template.",
        "reference": "interviewbit.com"
    },
    {
        "question": "20. What is an object?",
        "answer": "An object refers to the instance of the class, which contains the instance of the members and behaviors defined in the class template. In the real world, an object is an actual entity to which a user interacts, whereas class is just the blueprint for that object. So the objects consume space and have some characteristic behavior.\nFor example, a specific car. ",
        "reference": "interviewbit.com"
    },
    {
        "question": "21. What is encapsulation?",
        "answer": "  One can visualize Encapsulation as the method of putting everything that is required to do the job, inside a capsule and presenting that capsule to the user. What it means is that by Encapsulation, all the necessary data and methods are bind together and all the unnecessary details are hidden to the normal user. So Encapsulation is the process of binding data members and methods of a program together to do a specific job, without revealing unnecessary details.\n\nEncapsulation can also be defined in two different ways:\n\n1) Data hiding: Encapsulation is the process of hiding unwanted information, such as restricting access to any member of an object.\n\n2) Data binding: Encapsulation is the process of binding the data members and the methods together as a whole, as a class.     Data hiding:   Data binding:",
        "reference": "interviewbit.com"
    },
    {
        "question": "22. What is Polymorphism?",
        "answer": "Polymorphism is composed of two words - \u201cpoly\u201d which means \u201cmany\u201d, and \u201cmorph\u201d which means \u201cshapes\u201d. Therefore Polymorphism refers to something that has many shapes.   In OOPs, Polymorphism refers to the process by which some code, data, method, or object behaves differently under different circumstances or contexts. Compile-time polymorphism and Run time polymorphism are the two types of polymorphisms in OOPs languages.",
        "reference": "interviewbit.com"
    },
    {
        "question": "23. How does C++ support Polymorphism?",
        "answer": "C++ is an Object-oriented programming language and it supports Polymorphism as well: Compile Time Polymorphism: C++ supports compile-time polymorphism with the help of features like templates, function overloading, and default arguments.\nRuntime Polymorphism: C++ supports Runtime polymorphism with the help of features like virtual functions. Virtual functions take the shape of the functions based on the type of object in reference and are resolved at runtime. Compile Time Polymorphism: C++ supports compile-time polymorphism with the help of features like templates, function overloading, and default arguments. Compile Time Polymorphism Runtime Polymorphism: C++ supports Runtime polymorphism with the help of features like virtual functions. Virtual functions take the shape of the functions based on the type of object in reference and are resolved at runtime. Runtime Polymorphism:",
        "reference": "interviewbit.com"
    },
    {
        "question": "24. What is meant by Inheritance?",
        "answer": "The term \u201cinheritance\u201d means \u201creceiving some quality or behavior from a parent to an offspring.\u201d In object-oriented programming, inheritance is the mechanism by which an object or class (referred to as a child) is created using the definition of another object or class (referred to as a parent). Inheritance not only helps to keep the implementation simpler but also helps to facilitate code reuse.",
        "reference": "interviewbit.com"
    },
    {
        "question": "25. What is Abstraction?",
        "answer": "If you are a user, and you have a problem statement, you don't want to know how the components of the software work, or how it's made. You only want to know how the software solves your problem. Abstraction is the method of hiding unnecessary details from the necessary ones. It is one of the main features of OOPs. \nFor example, consider a car. You only need to know how to run a car, and not how the wires are connected inside it. This is obtained using Abstraction. ",
        "reference": "interviewbit.com"
    },
    {
        "question": "26. How much memory does a class occupy?",
        "answer": "Classes do not consume any memory. They are just a blueprint based on which objects are created. Now when objects are created, they actually initialize the class members and methods and therefore consume memory.",
        "reference": "interviewbit.com"
    },
    {
        "question": "27. Is it always necessary to create objects from class?",
        "answer": "No. An object is necessary to be created if the base class has non-static methods. But if the class has static methods, then objects don\u2019t need to be created. You can call the class method directly in this case, using the class name.",
        "reference": "interviewbit.com"
    },
    {
        "question": "28. What is a constructor?",
        "answer": "Constructors are special methods whose name is the same as the class name. The constructors serve the special purpose of initializing the objects.\nFor example, suppose there is a class with the name \u201cMyClass\u201d, then when you instantiate this class, you pass the syntax:\nMyClass myClassObject = new MyClass();   MyClass myClassObject = new MyClass(); Now here, the method called after \u201cnew\u201d keyword - MyClass(), is the constructor of this class. This will help to instantiate the member data and methods and assign them to the object myClassObject.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "29. What are the various types of constructors in C++?",
        "answer": "The most common classification of constructors includes: Default constructor: The default constructor is the constructor which doesn\u2019t take any argument. It has no parameters. Default constructor: class ABC\n{\n   int x;\n      \n   ABC()\n   {\n       x = 0;\n   }\n} class ABC\n{\n   int x;\n      \n   ABC()\n   {\n       x = 0;\n   }\n} class ABC\n{ class ABC int 0 Parameterized constructor: The constructors that take some arguments are known as parameterized constructors. Parameterized constructor: class ABC\n{\n   int x;\n      \n   ABC(int y)\n   {\n       x = y;\n   }\n} class ABC\n{\n   int x;\n      \n   ABC(int y)\n   {\n       x = y;\n   }\n} class ABC\n{ class ABC int int Copy constructor: A copy constructor is a member function that initializes an object using another object of the same class. Copy constructor: class ABC\n{\n   int x;\n      \n   ABC(int y)\n   {\n       x = y;\n   }\n   // Copy constructor\n   ABC(ABC abc)\n   {\n       x = abc.x;\n   }\n} class ABC\n{\n   int x;\n      \n   ABC(int y)\n   {\n       x = y;\n   }\n   // Copy constructor\n   ABC(ABC abc)\n   {\n       x = abc.x;\n   }\n} class ABC\n{ class ABC int int // Copy constructor",
        "reference": "interviewbit.com"
    },
    {
        "question": "30. What is a copy constructor?",
        "answer": "Copy Constructor is a type of constructor, whose purpose is to copy an object to another. What it means is that a copy constructor will clone an object and its values, into another object, is provided that both the objects are of the same class.",
        "reference": "interviewbit.com"
    },
    {
        "question": "31. What is a destructor?",
        "answer": "Contrary to constructors, which initialize objects and specify space for them, Destructors are also special methods. But destructors free up the resources and memory occupied by an object. Destructors are automatically called when an object is being destroyed.",
        "reference": "interviewbit.com"
    },
    {
        "question": "32. Are class and structure the same? If not, what's the difference between a class and a structure?",
        "answer": "No, class and structure are not the same. Though they appear to be similar, they have differences that make them apart. For example, the structure is saved in the stack memory, whereas the class is saved in the heap memory. Also, Data Abstraction cannot be achieved with the help of structure, but with class, Abstraction is majorly used.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. What is the output of the below code?",
        "answer": "#include<iostream> \n \nusing namespace std; \nclass BaseClass1 { \npublic: \n    BaseClass1() \n    { cout << \" BaseClass1 constructor called\" << endl;  } \n}; \n \nclass BaseClass2 { \npublic: \n    BaseClass2() \n    { cout << \"BaseClass2 constructor called\" << endl;  } \n}; \n \nclass DerivedClass: public BaseClass1, public BaseClass2 { \n  public: \n   DerivedClass() \n    {  cout << \"DerivedClass constructor called\" << endl;  } \n}; \n \nint main() \n{ \n  DerivedClass derived_class; \n  return 0; \n} #include<iostream> \n \nusing namespace std; \nclass BaseClass1 { \npublic: \n    BaseClass1() \n    { cout << \" BaseClass1 constructor called\" << endl;  } \n}; \n \nclass BaseClass2 { \npublic: \n    BaseClass2() \n    { cout << \"BaseClass2 constructor called\" << endl;  } \n}; \n \nclass DerivedClass: public BaseClass1, public BaseClass2 { \n  public: \n   DerivedClass() \n    {  cout << \"DerivedClass constructor called\" << endl;  } \n}; \n \nint main() \n{ \n  DerivedClass derived_class; \n  return 0; \n} #include<iostream> include <iostream> using namespace std class BaseClass1 { class BaseClass1 public cout \" BaseClass1 constructor called\" endl class BaseClass2 { class BaseClass2 public cout \"BaseClass2 constructor called\" endl class DerivedClass: class DerivedClass public public public cout \"DerivedClass constructor called\" endl int main() int main () return 0 Output: Output: BaseClass1 constructor called\nBaseClass2 constructor called\nDerivedClass constructor called BaseClass1 constructor called\nBaseClass2 constructor called\nDerivedClass constructor called Reason:\nThe above program demonstrates Multiple inheritances. So when the Derived class\u2019s constructor is called, it automatically calls the Base class's constructors from left to right order of inheritance. Reason: ",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What will be the output of the below code?",
        "answer": "class Scaler\n{\n   static int i;\n\n   static\n   {\n       System.out.println(\u201ca\u201d);\n\n       i = 100;\n   }\n}\n\npublic class StaticBlock\n{\n   static\n   {\n       System.out.println(\u201cb\u201d);\n   }\n\n   public static void main(String[] args)\n   {\n       System.out.println(\u201cc\u201d);\n\n       System.out.println(Scaler.i);\n   }\n} class Scaler\n{\n   static int i;\n\n   static\n   {\n       System.out.println(\u201ca\u201d);\n\n       i = 100;\n   }\n}\n\npublic class StaticBlock\n{\n   static\n   {\n       System.out.println(\u201cb\u201d);\n   }\n\n   public static void main(String[] args)\n   {\n       System.out.println(\u201cc\u201d);\n\n       System.out.println(Scaler.i);\n   }\n} class Scaler class Scaler static int static 100 public class StaticBlock class StaticBlock static public static void main(String[] args) public static void main (String[] args) Output: Output: b\nc\na\n100 b\nc\na\n100 100 Reason:\nFirstly the static block inside the main-method calling class will be implemented. Hence \u2018b\u2019 will be printed first. Then the main method is called, and now the sequence is kept as expected. Reason: ",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Predict the output?",
        "answer": "#include<iostream> \nusing namespace std; \n\nclass ClassA {  \npublic: \n   ClassA(int ii = 0) : i(ii) {} \n   void show() { cout << \"i = \" << i << endl;} \nprivate: \n   int i; \n}; \n\nclass ClassB { \npublic: \n   ClassB(int xx) : x(xx) {} \n   operator ClassA() const { return ClassA(x); } \nprivate: \n   int x; \n}; \n\nvoid g(ClassA a) \n{  a.show(); } \n\nint main() { \n ClassB b(10); \n g(b); \n g(20); \n getchar(); \n return 0; \n} #include<iostream> \nusing namespace std; \n\nclass ClassA {  \npublic: \n   ClassA(int ii = 0) : i(ii) {} \n   void show() { cout << \"i = \" << i << endl;} \nprivate: \n   int i; \n}; \n\nclass ClassB { \npublic: \n   ClassB(int xx) : x(xx) {} \n   operator ClassA() const { return ClassA(x); } \nprivate: \n   int x; \n}; \n\nvoid g(ClassA a) \n{  a.show(); } \n\nint main() { \n ClassB b(10); \n g(b); \n g(20); \n getchar(); \n return 0; \n} #include<iostream> include <iostream> using namespace std class ClassA { class ClassA public int 0 void show() void show () cout \"i = \" endl private int class ClassB { class ClassB public int operator ClassA() const operator ClassA () const return private int void g(ClassA a) void g (ClassA a) int main() int main () ClassB b(10) b (10) 10 20 return 0 Output: Output: i = 10\ni = 20 i = 10\ni = 20 10 20 Reason:\nClassA contains a conversion constructor. Due to this, the objects of ClassA can have integer values. So the statement g(20) works. Also, ClassB has a conversion operator overloaded. So the statement g(b) also works. Reason: ",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What will be the output in below code?",
        "answer": "public class Demo{ \n   public static void main(String[] arr){ \n         System.out.println(\u201cMain1\u201d);\n   } \n   public static void main(String arr){  \n         System.out.println(\u201cMain2\u201d);\n   } \n} public class Demo{ \n   public static void main(String[] arr){ \n         System.out.println(\u201cMain1\u201d);\n   } \n   public static void main(String arr){  \n         System.out.println(\u201cMain2\u201d);\n   } \n} public class Demo class Demo public static void main(String[] arr) public static void main (String[] arr) public static void main(String arr) public static void main (String arr) Output: Output: Main1 Main1 Reason:\nHere the main() method is overloaded. But JVM only understands the main method which has a String[] argument in its definition. Hence Main1 is printed and the overloaded main method is ignored. Reason: ",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Predict the output?",
        "answer": "#include<iostream> \nusing namespace std; \n \nclass BaseClass{ \n   int arr[10];      \n}; \n \nclass DerivedBaseClass1: public BaseClass { }; \n \nclass DerivedBaseClass2: public BaseClass { }; \n \nclass DerivedClass: public DerivedBaseClass1, public DerivedBaseClass2{}; \n \nint main(void) \n{  \n cout<<sizeof(DerivedClass);\n return 0; \n} #include<iostream> \nusing namespace std; \n \nclass BaseClass{ \n   int arr[10];      \n}; \n \nclass DerivedBaseClass1: public BaseClass { }; \n \nclass DerivedBaseClass2: public BaseClass { }; \n \nclass DerivedClass: public DerivedBaseClass1, public DerivedBaseClass2{}; \n \nint main(void) \n{  \n cout<<sizeof(DerivedClass);\n return 0; \n} #include<iostream> include <iostream> using namespace class BaseClass{ class BaseClass int 10 class DerivedBaseClass1: class DerivedBaseClass1 public class DerivedBaseClass2: class DerivedBaseClass2 public class DerivedClass: class DerivedClass public public int main(void) int main (void) void sizeof sizeof return 0 Output: Output: If the size of the integer is 4 bytes, then the output will be 80. If the size of the integer is 4 bytes, then the output will be 80. 4 80. Reason: \nSince DerivedBaseClass1 and DerivedBaseClass2 both inherit from class BaseClass, DerivedClass contains two copies of BaseClass. Hence it results in wastage of space and a large size output. It can be reduced with the help of a virtual base class. Reason: ",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What is the output of the below program?",
        "answer": "#include<iostream> \n \nusing namespace std; \nclass A { \npublic: \n  void print() \n  { cout <<\" Inside A::\"; } \n}; \n \nclass B : public A { \npublic: \n  void print() \n  { cout <<\" Inside B\"; } \n}; \n \nclass C: public B { \n}; \n \nint main(void) \n{ \n C c; \n \n c.print(); \n return 0; \n} #include<iostream> \n \nusing namespace std; \nclass A { \npublic: \n  void print() \n  { cout <<\" Inside A::\"; } \n}; \n \nclass B : public A { \npublic: \n  void print() \n  { cout <<\" Inside B\"; } \n}; \n \nclass C: public B { \n}; \n \nint main(void) \n{ \n C c; \n \n c.print(); \n return 0; \n} #include<iostream> include <iostream> using namespace class A { class A public void print() void print () \" Inside A::\" class B : class B public public void print() void print () \" Inside B\" class C: class C public int main(void) int main (void) void print return 0 Output: Output: Inside B Inside B Reason:\nThe above program implements a Multi-level hierarchy. So the program is linearly searched up until a matching function is found. Here, it is present in both classes A and B. So class B\u2019s print() method is called. Reason:  Useful Resource Useful Resource Features of OOPS Features of OOPS",
        "reference": "interviewbit.com"
    }
]