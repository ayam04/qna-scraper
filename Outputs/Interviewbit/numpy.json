[
    {
        "question": "1. What is NumPy? Why should we use it?",
        "answer": "NumPy (also called Numerical Python) is a highly flexible, optimized, open-source package meant for array processing. It provides tools for delivering high-end performance while dealing with N-dimensional powerful array objects. It is also beneficial for performing scientific computations, mathematical, and logical operations, sorting operations, I/O functions, basic statistical and linear algebra-based operations along with random simulation and broadcasting functionalities. Due to the vast range of capabilities, NumPy has become very popular and is the most preferred package. The following image represents the uses of NumPy.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. How do you convert Pandas DataFrame to a NumPy array?",
        "answer": "The to_numpy() method of the NumPy package can be used to convert Pandas DataFrame, Index and Series objects. Consider we have a DataFrame df, we can either convert the whole Pandas DataFrame df to NumPy array or even select a subset of Pandas DataFrame to NumPy array by using the to_numpy() method as shown in the example below: import pandas as pd\nimport numpy as np\n# Pandas DataFrame\ndf = pd.DataFrame(data={'A': [3, 2, 1], 'B': [6,5,4], 'C': [9, 8, 7]}, \n                  index=['i', 'j', 'k'])\nprint(\"Pandas DataFrame: \")\nprint(df)\n\n# Convert Pandas DataFrame to NumPy Array\nnp_arr = df.to_numpy()\nprint(\"Pandas DataFrame to NumPy array: \")\nprint(np_arr)\n\n\n# Convert specific columns of Pandas DataFrame to NumPy array\narr = df[['B', 'C']].to_numpy()\nprint(\"Convert B and C columns of Pandas DataFrame to NumPy Array: \")\nprint (arr) import pandas as pd\nimport numpy as np\n# Pandas DataFrame\ndf = pd.DataFrame(data={'A': [3, 2, 1], 'B': [6,5,4], 'C': [9, 8, 7]}, \n                  index=['i', 'j', 'k'])\nprint(\"Pandas DataFrame: \")\nprint(df)\n\n# Convert Pandas DataFrame to NumPy Array\nnp_arr = df.to_numpy()\nprint(\"Pandas DataFrame to NumPy array: \")\nprint(np_arr)\n\n\n# Convert specific columns of Pandas DataFrame to NumPy array\narr = df[['B', 'C']].to_numpy()\nprint(\"Convert B and C columns of Pandas DataFrame to NumPy Array: \")\nprint (arr) import as import as # Pandas DataFrame 'A' 3 2 1 'B' 6 5 4 'C' 9 8 7 'i' 'j' 'k' print \"Pandas DataFrame: \" print # Convert Pandas DataFrame to NumPy Array print \"Pandas DataFrame to NumPy array: \" print # Convert specific columns of Pandas DataFrame to NumPy array 'B' 'C' print \"Convert B and C columns of Pandas DataFrame to NumPy Array: \" print The output of the above code is Pandas DataFrame: \n   A  B  C\ni  3  6  9\nj  2  5  8\nk  1  4  7\nPandas DataFrame to NumPy array: \n[[3 6 9]\n [2 5 8]\n [1 4 7]]\nConvert B and C columns of Pandas DataFrame to NumPy Array: \n[[6 9]\n [5 8]\n [4 7]] Pandas DataFrame: \n   A  B  C\ni  3  6  9\nj  2  5  8\nk  1  4  7\nPandas DataFrame to NumPy array: \n[[3 6 9]\n [2 5 8]\n [1 4 7]]\nConvert B and C columns of Pandas DataFrame to NumPy Array: \n[[6 9]\n [5 8]\n [4 7]] 3 6 9 2 5 8 1 4 7 3 6 9 2 5 8 1 4 7 and 6 9 5 8 4 7",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. How do you concatenate 2 NumPy arrays?",
        "answer": "Concatenating 2 arrays by adding elements to the end can be achieved by making use of the concatenate() method of the NumPy package. Syntax: np.concatenate((a1, a2, ...), axis=0, out=None) np.concatenate((a1, a2, ...), axis=0, out=None) where, a1,a2: arrays of the same shape\naxis: Represents the axis along which the arrays are joined. The default value is 0.\nout: If mentioned, it specifies the destination for placing the result. a1,a2: arrays of the same shape axis: Represents the axis along which the arrays are joined. The default value is 0. out: If mentioned, it specifies the destination for placing the result. For example: import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6]])\n\n# Concatenate with axis 0\nc = np.concatenate((a,b), axis=0)\nprint(\"With axis 0: \\n\",c )\n\n# Concatenate with axis 1 (b.T represents transpose matrix)\nd = np.concatenate((a,b.T), axis=1)\nprint(\"With axis 1: \\n\",d ) import numpy as np\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6]])\n\n# Concatenate with axis 0\nc = np.concatenate((a,b), axis=0)\nprint(\"With axis 0: \\n\",c )\n\n# Concatenate with axis 1 (b.T represents transpose matrix)\nd = np.concatenate((a,b.T), axis=1)\nprint(\"With axis 1: \\n\",d ) import as 1 2 3 4 5 6 # Concatenate with axis 0 0 print \"With axis 0: \\n\" # Concatenate with axis 1 (b.T represents transpose matrix) 1 print \"With axis 1: \\n\" The output would be: With axis 0: \n [[1 2]\n [3 4]\n [5 6]]\nWith axis 1: \n [[1 2 5]\n [3 4 6]] With axis 0: \n [[1 2]\n [3 4]\n [5 6]]\nWith axis 1: \n [[1 2 5]\n [3 4 6]] 0 1 2 3 4 5 6 1 1 2 5 3 4 6 Notice how the arrays are concatenated with different values of the axis.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. How do you multiply 2 NumPy array matrices?",
        "answer": "We can make use of the dot() for multiplying matrices represented as NumPy arrays. This is represented in the code snippet below: import numpy as np\n\n# NumPy matrices\nA = np.arange(15,24).reshape(3,3)\nB = np.arange(20,29).reshape(3,3)\nprint(\"A: \",A)\nprint(\"B: \",B)\n\n# Multiply A and B\nresult = A.dot(B)\nprint(\"Result: \", result) import numpy as np\n\n# NumPy matrices\nA = np.arange(15,24).reshape(3,3)\nB = np.arange(20,29).reshape(3,3)\nprint(\"A: \",A)\nprint(\"B: \",B)\n\n# Multiply A and B\nresult = A.dot(B)\nprint(\"Result: \", result) import as # NumPy matrices 15 24 3 3 20 29 3 3 print \"A: \" print \"B: \" # Multiply A and B print \"Result: \" Output A:  [[15 16 17]\n [18 19 20]\n [21 22 23]]\nB:  [[20 21 22]\n [23 24 25]\n [26 27 28]]\nResult:  [[1110 1158 1206]\n [1317 1374 1431]\n [1524 1590 1656]] A:  [[15 16 17]\n [18 19 20]\n [21 22 23]]\nB:  [[20 21 22]\n [23 24 25]\n [26 27 28]]\nResult:  [[1110 1158 1206]\n [1317 1374 1431]\n [1524 1590 1656]] 15 16 17 18 19 20 21 22 23 20 21 22 23 24 25 26 27 28 1110 1158 1206 1317 1374 1431 1524 1590 1656",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. How is arr[:,0] different from arr[:,[0]]",
        "answer": "arr[:,0] - Returns 0th index elements of all rows. In other words, return the first column elements. arr[:,0] import numpy as np\n\narr = np.array([[1,2,3,4],[5,6,7,8]])\nnew_arr =arr[:,0]\nprint(new_arr) import numpy as np\n\narr = np.array([[1,2,3,4],[5,6,7,8]])\nnew_arr =arr[:,0]\nprint(new_arr) Output: [1 5] [1 5] arr[:,[0]] - This returns the elements of the first column by adding extra dimension to it. arr[:,[0]] import numpy as np\n\narr = np.array([[1,2,3,4],[5,6,7,8]])\nnew_arr =arr[:,[0]]\nprint(new_arr) import numpy as np\n\narr = np.array([[1,2,3,4],[5,6,7,8]])\nnew_arr =arr[:,[0]]\nprint(new_arr) Output: [[1]\n[5]] [[1]\n[5]]",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. How do we check for an empty array (or zero elements array)?",
        "answer": "We can check for the emptiness of a NumPy array by making use of the size attribute.\nLet us consider the below example. We have NumPy array arr filled with zeros. If the size element returns zero, that means the array is empty or it only consists of zeros.  import numpy as np\narr = np.zeros((1,0))    #returns empty array\nprint(arr.size)          #returns 0 import numpy as np\narr = np.zeros((1,0))    #returns empty array\nprint(arr.size)          #returns 0 This return 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. How do you count the frequency of a given positive value appearing in the NumPy array?",
        "answer": "We can make use of the bincount() function to compute the number of times a given value is there in the array. This function accepts only positive integers and boolean expressions as the arguments. import numpy as np\narr = np.array([1, 2, 1, 3, 5, 0, 0, 0, 2, 3])\nresult = np.bincount(arr)\nprint(result) import numpy as np\narr = np.array([1, 2, 1, 3, 5, 0, 0, 0, 2, 3])\nresult = np.bincount(arr)\nprint(result) import as 1 2 1 3 5 0 0 0 2 3 print The result is: [3 2 2 2 0 1] [3 2 2 2 0 1] It has to be noted here that each element represents the count of the corresponding index value present in the original array. This is demonstrated in the below image:  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. How is np.mean() different from np.average() in NumPy?",
        "answer": "np.mean() method calculates the arithmetic mean and provides additional options for input and results. For example, it has the option to specify what data types have to be taken, where the result has to be placed etc.\nnp.average() computes the weighted average if the weights parameter is specified. In the case of weighted average, instead of considering that each data point is contributing equally to the final average, it considers that some data points have more weightage than the others (unequal contribution). np.mean() method calculates the arithmetic mean and provides additional options for input and results. For example, it has the option to specify what data types have to be taken, where the result has to be placed etc. np.average() computes the weighted average if the weights parameter is specified. In the case of weighted average, instead of considering that each data point is contributing equally to the final average, it considers that some data points have more weightage than the others (unequal contribution).",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. How can you reverse a NumPy array?",
        "answer": "There are two ways of reversing a NumPy array. Method 1: Using the slicing method: We can make use of [::-1] for reversing the array. The following example demonstrates this: Method 1: Using the slicing method: We can make use of [::-1] for reversing the array. The following example demonstrates this: Method 1: import numpy as np\n\n# create numpy array\narr = np.array([1, 2, 4, 6])\n\n# To reverse array\nreverse_arr = arr[::-1]\nprint(reverse_arr) import numpy as np\n\n# create numpy array\narr = np.array([1, 2, 4, 6])\n\n# To reverse array\nreverse_arr = arr[::-1]\nprint(reverse_arr) import as # create numpy array 1 2 4 6 # To reverse array 1 print Output: [6 4 2 1] [6 4 2 1] 6 4 2 1 Method 2: flipud function: This function is provided by NumPy to reverse the NumPy array. Let us see the below example about its usage. Method 2: flipud function: This function is provided by NumPy to reverse the NumPy array. Let us see the below example about its usage. Method 2: import numpy as np\n\n# create numpy array\narr = np.array([1, 2, 4, 5, 6])\n\n#flipud method for reversing\nreverse_arr = np.flipud(arr)\nprint(reverse_arr) import numpy as np\n\n# create numpy array\narr = np.array([1, 2, 4, 5, 6])\n\n#flipud method for reversing\nreverse_arr = np.flipud(arr)\nprint(reverse_arr) import as # create numpy array 1 2 4 5 6 #flipud method for reversing print Output: [6 5 4 2 1] [6 5 4 2 1] 6 5 4 2 1",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. How do you find the data type of the elements stored in the NumPy arrays?",
        "answer": "NumPy supports the following datatypes: i - integer\nS - string\nb - boolean\nf - float\nu - unsigned integer\nc - complex float\nm - timedelta\nM - datetime\nO - object\nU - unicode string\nV - fixed memory chunk for types such as void\nWe can make use of the dtype property that returns the type of the elements stored in the NumPy array. Let us consider the below code snippet. We create some sample arrays and we see what the data types of these arrays are. i - integer S - string b - boolean f - float u - unsigned integer c - complex float m - timedelta M - datetime O - object U - unicode string V - fixed memory chunk for types such as void\nWe can make use of the dtype property that returns the type of the elements stored in the NumPy array. Let us consider the below code snippet. We create some sample arrays and we see what the data types of these arrays are.  import numpy as np\n\narr1 = np.array([1, 2, 3, 4])\narr2 = np.array(['I', 'love', 'Interviewbit'])    # Stored as Unicode characters with length of characters ranging from 1 to 12\narr3 = np.array([1, 2, 3, 4], dtype='S')        # Creating numpy array of defined type string\n\nprint(arr1.dtype)\nprint(arr2.dtype)\nprint(arr3.dtype) import numpy as np\n\narr1 = np.array([1, 2, 3, 4])\narr2 = np.array(['I', 'love', 'Interviewbit'])    # Stored as Unicode characters with length of characters ranging from 1 to 12\narr3 = np.array([1, 2, 3, 4], dtype='S')        # Creating numpy array of defined type string\n\nprint(arr1.dtype)\nprint(arr2.dtype)\nprint(arr3.dtype) import as 1 2 3 4 'I' 'love' 'Interviewbit' # Stored as Unicode characters with length of characters ranging from 1 to 12 1 2 3 4 'S' # Creating numpy array of defined type string print print print The output will be: int64\n<U12\n|S1 int64\n<U12\n|S1",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. What are ways of creating 1D, 2D and 3D arrays in NumPy?",
        "answer": "Consider you have a normal python list. From this, we can create NumPy arrays by making use of the array function as follows: One-Dimensional array One-Dimensional array import numpy as np\n \narr = [1,2,3,4]        #python list\nnumpy_arr = np.array(arr)    #numpy array import numpy as np\n \narr = [1,2,3,4]        #python list\nnumpy_arr = np.array(arr)    #numpy array import as 1 2 3 4 #python list #numpy array Two-Dimensional array Two-Dimensional array import numpy as np\n\narr = [[1,2,3,4],[4,5,6,7]]\nnumpy_arr = np.array(arr) import numpy as np\n\narr = [[1,2,3,4],[4,5,6,7]]\nnumpy_arr = np.array(arr) import as 1 2 3 4 4 5 6 7 Three-Dimensional array Three-Dimensional array import numpy as np\n\narr = [[[1,2,3,4],[4,5,6,7],[7,8,9,10]]]\nnumpy_arr = np.array(arr) import numpy as np\n\narr = [[[1,2,3,4],[4,5,6,7],[7,8,9,10]]]\nnumpy_arr = np.array(arr) import as 1 2 3 4 4 5 6 7 7 8 9 10 Using the np.array() function, we can create NumPy arrays of any dimensions.",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What are ndarrays in NumPy?",
        "answer": "ndarray object is the core of the NumPy package. It consists of n-dimensional arrays storing elements of the same data types and also has many operations that are done in compiled code for optimised performance. These arrays have fixed sizes defined at the time of creation. Following are some of the properties of ndarrays: When the size of ndarrays is changed, it results in a new array and the original array is deleted.\nThe ndarrays are bound to store homogeneous data.\nThey provide functions to perform advanced mathematical operations in an efficient manner. When the size of ndarrays is changed, it results in a new array and the original array is deleted. The ndarrays are bound to store homogeneous data. They provide functions to perform advanced mathematical operations in an efficient manner.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. How are NumPy arrays better than Python\u2019s lists?",
        "answer": "Python lists support storing heterogeneous data types whereas NumPy arrays can store datatypes of one nature itself. NumPy provides extra functional capabilities that make operating on its arrays easier which makes NumPy array advantageous in comparison to Python lists as those functions cannot be operated on heterogeneous data.\nNumPy arrays are treated as objects which results in minimal memory usage. Since Python keeps track of objects by creating or deleting them based on the requirements, NumPy objects are also treated the same way. This results in lesser memory wastage.\nNumPy arrays support multi-dimensional arrays.\nNumPy provides various powerful and efficient functions for complex computations on the arrays.\nNumPy also provides various range of functions for BitWise Operations, String Operations, Linear Algebraic operations, Arithmetic operations etc. These are not provided on Python\u2019s default lists. Python lists support storing heterogeneous data types whereas NumPy arrays can store datatypes of one nature itself. NumPy provides extra functional capabilities that make operating on its arrays easier which makes NumPy array advantageous in comparison to Python lists as those functions cannot be operated on heterogeneous data. NumPy arrays are treated as objects which results in minimal memory usage. Since Python keeps track of objects by creating or deleting them based on the requirements, NumPy objects are also treated the same way. This results in lesser memory wastage. NumPy arrays support multi-dimensional arrays. NumPy provides various powerful and efficient functions for complex computations on the arrays. NumPy also provides various range of functions for BitWise Operations, String Operations, Linear Algebraic operations, Arithmetic operations etc. These are not provided on Python\u2019s default lists.",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. Why is NumPy preferred over Matlab, Octave, Idl or Yorick?",
        "answer": "NumPy is an open-source, high-performing library that allows complex mathematical and scientific computational capabilities. It makes use of Python language which is a high-level, easy-to-learn, general-purpose programming language. It supports the following: Powerful functions for performing complex mathematical operations on multi-dimensional matrices and arrays. The operations on ndarrays of NumPy are approximately up to 50% faster when compared to operations on native lists using loops. This efficiency is very much useful when the arrays have millions of elements.\nProvides indexing syntax to access portions of data easily in a large array.\nProvides built-in functions which help to easily perform operations related to linear algebra and statistics.\nIt takes only a few lines of code to achieve complex computations using NumPy. Powerful functions for performing complex mathematical operations on multi-dimensional matrices and arrays. The operations on ndarrays of NumPy are approximately up to 50% faster when compared to operations on native lists using loops. This efficiency is very much useful when the arrays have millions of elements. Provides indexing syntax to access portions of data easily in a large array. Provides built-in functions which help to easily perform operations related to linear algebra and statistics. It takes only a few lines of code to achieve complex computations using NumPy.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. How is vstack() different from hstack() in NumPy?",
        "answer": "Both methods are used for combining the NumPy arrays. The main difference is that the hstack method combines arrays horizontally whereas the vstack method combines arrays vertically.\nFor example, consider the below code.  import numpy as np\na = np.array([1,2,3])\nb = np.array([4,5,6])\n\n# vstack arrays\nc = np.vstack((a,b))\nprint(\"After vstack: \\n\",c)\n# hstack arrays\nd = np.hstack((a,b))\nprint(\"After hstack: \\n\",d) import numpy as np\na = np.array([1,2,3])\nb = np.array([4,5,6])\n\n# vstack arrays\nc = np.vstack((a,b))\nprint(\"After vstack: \\n\",c)\n# hstack arrays\nd = np.hstack((a,b))\nprint(\"After hstack: \\n\",d) import as 1 2 3 4 5 6 # vstack arrays print \"After vstack: \\n\" # hstack arrays print \"After hstack: \\n\" The output of this code would be: After vstack: \n[[1 2 3]\n[4 5 6]]\nAfter hstack: \n[1 2 3 4 5 6] After vstack: \n[[1 2 3]\n[4 5 6]]\nAfter hstack: \n[1 2 3 4 5 6] 1 2 3 4 5 6 1 2 3 4 5 6 Notice how after the vstack method, the arrays were combined vertically along the column and how after the hstack method, the arrays were combined horizontally along the row.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. How is fliplr different from flipud methods in NumPy?",
        "answer": "The fliplr() method is used for flipping an array in the left or right direction. The columns are preserved but the order of elements in the columns would be different than before. This has been represented in the image below:   We see that the positions of the elements are flipped left or right than their original position in the result. Syntax of fliplr: np.fliplr(arr) np.fliplr(arr) where arr is the array that has to be flipped. The flipud function also flips the array but in the up or down direction. The rows are preserved in this case but they can appear in a different order in the result. This is represented in the image below:   Here, we see that the numbers 1, 3 and 5 elements are flipped in the up/down direction in the result. The syntax for flipud: np.flipud(arr) np.flipud(arr) where arr is the array that has to be flipped.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. How will you implement the moving average for the 1D array in NumPy?",
        "answer": "We can make use of the convolve() method. Here, it leverages the way discrete convolution is computed and uses it to find the rolling mean (moving average). Here, the sequence of ones of length equal to the length of the sliding window is convolved with the array. We first define a calculate_moving_average function which performs the convolution of an array with the sequence of ones of sliding window length w. The mode of the convolve method will be \u2018valid\u2019 to generate the points only where the overlapping of the sequence is complete. import numpy as np\ndef calculate_moving_average(arr, w):\n    return np.convolve(arr, np.ones(w),'valid')/w import numpy as np\ndef calculate_moving_average(arr, w):\n    return np.convolve(arr, np.ones(w),'valid')/w The above-defined function can be then used for finding the moving average as shown in the examples below: arr1 = np.array([4,5,8,9,3,2,4,2,0,2])\nprint(\"Moving average of window length 2: \")\nav1 = calculate_moving_average(arr1, 2)\nprint(av1)\n\nprint(\"Moving average of window length 4: \")\nav2 = calculate_moving_average(arr1, 4)\nprint(av2) arr1 = np.array([4,5,8,9,3,2,4,2,0,2])\nprint(\"Moving average of window length 2: \")\nav1 = calculate_moving_average(arr1, 2)\nprint(av1)\n\nprint(\"Moving average of window length 4: \")\nav2 = calculate_moving_average(arr1, 4)\nprint(av2) Output: Moving average of window length 2: \n[4.5 6.5 8.5 6.  2.5 3.  3.  1.  1. ]\nMoving average of window length 4: \n[6.5  6.25 5.5  4.5  2.75 2.   2.  ] Moving average of window length 2: \n[4.5 6.5 8.5 6.  2.5 3.  3.  1.  1. ]\nMoving average of window length 4: \n[6.5  6.25 5.5  4.5  2.75 2.   2.  ]",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What happens when we use the arrays_split() method for splitting the NumPy array?",
        "answer": "The array_split() method is similar to the split() method as it helps in splitting a given array to multiple subarrays. The main difference is that the array_split() allows sections to be an integer which does not result in equal array division. For an array of length L, if we want it to split to N subarrays, then L % N subarrays of size (L//N + 1) and remaining subarrays are of size L//N.   In the above figure, we see there are 5 elements in the array, we want to split the array to 3 subarrays. So L % N = 5%3 = 2 subarrays of size (L//N +1) = (5//3 +1) = 2 are returned and remaining 1 subarray of size L//N = 1 is returned. Syntax: np.array_split(array, sections, axis=0) np.array_split(array, sections, axis=0) where, array - Given Input array.\nsections - List of indices or Number of subarrays to be returned.\naxis - Axis along which values have to be appended. array - Given Input array. sections - List of indices or Number of subarrays to be returned. axis - Axis along which values have to be appended. The code for the example illustrated above is: import numpy as np\narr = np.arange(5.0)\nsplit_arrs = np.array_split(arr, 3)\nsplit_arrs import numpy as np\narr = np.arange(5.0)\nsplit_arrs = np.array_split(arr, 3)\nsplit_arrs Output: [array([0., 1.]), array([2., 3.]), array([4.])] [array([0., 1.]), array([2., 3.]), array([4.])]",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What happens when the split() method is used for splitting NumPy arrays?",
        "answer": "1. np.split() : Equally splits arrays into multiple sub-arrays. It raises Value Error when the split cannot be equal. Syntax: Syntax: np.split(array, sections, axis=0) np.split(array, sections, axis=0) where, array - array that needs to be split\nsections -\nIf we give an integer X, X equal sub-arrays are obtained after dividing the array. If the split is not possible, ValueError is raised.\nFor example: array - array that needs to be split sections -\nIf we give an integer X, X equal sub-arrays are obtained after dividing the array. If the split is not possible, ValueError is raised.\nFor example: If we give an integer X, X equal sub-arrays are obtained after dividing the array. If the split is not possible, ValueError is raised.\nFor example: If we give an integer X, X equal sub-arrays are obtained after dividing the array. If the split is not possible, ValueError is raised.\nFor example: For example: For example: import numpy as np\na = np.arange(8)\nsplit_arr = np.split(a, 2)\nsplit_arr import numpy as np\na = np.arange(8)\nsplit_arr = np.split(a, 2)\nsplit_arr import as 8 2 Output [array([0, 1, 2, 3]), array([4, 5, 6, 7])] [array([0, 1, 2, 3]), array([4, 5, 6, 7])] 0 1 2 3 4 5 6 7 If we give a 1-D sorted array then the entries would represent where the array would be split along the axis. For instance if we provide [2:3] and axis as 0, then the result would be\n[arr[0:2], arr[2:3], arr[3:]]\nIf the provided index exceeds the array dimension along the given axis, then an empty subarray will be returned.\nFor example: If we give a 1-D sorted array then the entries would represent where the array would be split along the axis. For instance if we provide [2:3] and axis as 0, then the result would be\n[arr[0:2], arr[2:3], arr[3:]]\nIf the provided index exceeds the array dimension along the given axis, then an empty subarray will be returned.\nFor example:  [arr[0:2], arr[2:3], arr[3:]] If the provided index exceeds the array dimension along the given axis, then an empty subarray will be returned.\nFor example: If the provided index exceeds the array dimension along the given axis, then an empty subarray will be returned. For example: [array([0., 1., 2.]),\n array([3.]),\n array([4.]),\n array([5.]),\n array([], dtype=float64),\n array([], dtype=float64),\n array([], dtype=float64)] [array([0., 1., 2.]),\n array([3.]),\n array([4.]),\n array([5.]),\n array([], dtype=float64),\n array([], dtype=float64),\n array([], dtype=float64)] 0. 1. 2. 3. 4. 5. The output would be: import numpy as np\na = np.arange(6.0)\nsplit_arr = np.split(a, [3, 4, 5, 6, 7,8])\nsplit_arr import numpy as np\na = np.arange(6.0)\nsplit_arr = np.split(a, [3, 4, 5, 6, 7,8])\nsplit_arr import as 6.0 3 4 5 6 7 8 axis - Along what axis the array has to be split. By default, the value is 0 axis - Along what axis the array has to be split. By default, the value is 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. How is Vectorization related to Broadcasting in NumPy?",
        "answer": "Vectorization involves delegating NumPy operations internally to optimized C language functions to result in faster Python code. Whereas Broadcasting refers to the methods that allow NumPy to perform array-related arithmetic operations. The size or shape of the arrays does not matter in this case. Broadcasting solves the problem of mismatched shaped arrays by replicating the smaller array along the larger array to ensure both arrays are having compatible shapes for NumPy operations. Performing Broadcasting before Vectorization helps to vectorize operations which support arrays of different dimensions.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. How do you find the local peaks (or maxima) in a 1-D NumPy Array?",
        "answer": "Peaks are the points that are surrounded by smaller value points on either side as shown in the image below:   There are two ways of finding local maxima: Using .where() method: This method lists all positions/indices where the element value at position i is greater than the element on either side of it. This method does not check for the points that have only one neighbour. This is demonstrated in the example below: Using .where() method: import numpy as np\n# define NumPy array\narr = np.array([1, 4, 8, 1, 3, 5, 1, 6, 1, -5, -1, 19, 2])\n\n\nmaxima_peaks_positions = np.where((arr[1:-1] > arr[0:-2]) * (arr[1:-1] > arr[2:]))[0] + 1\nprint(maxima_peaks_positions) import numpy as np\n# define NumPy array\narr = np.array([1, 4, 8, 1, 3, 5, 1, 6, 1, -5, -1, 19, 2])\n\n\nmaxima_peaks_positions = np.where((arr[1:-1] > arr[0:-2]) * (arr[1:-1] > arr[2:]))[0] + 1\nprint(maxima_peaks_positions) Output: [ 2  5  7 11]] [ 2  5  7 11]] The +1 at the end of the expression is required as it finds the indexes within the slice arr[1:-1] and not the entire array arr.\nThe where() method returns a tuple of arrays where the first element is our required array. Hence we add [0] after the where method. The +1 at the end of the expression is required as it finds the indexes within the slice arr[1:-1] and not the entire array arr. +1 arr[1:-1] The where() method returns a tuple of arrays where the first element is our required array. Hence we add [0] after the where method. [0] Using combination of .diff(), .sign() and .where() method: Using combination of .diff(), .sign() and .where() method: In this method, we calculate the difference between each element using the diff() method of NumPy.\nThen we use the sign() method on the array to get the sign of difference.\nThe value can be either -1 or +1. This result is then passed on to another diff() method which returns 0, -2 or +2 value. The value 0 indicates that the points are continuously increasing or decreasing, +2 indicates minimum peak and -2 indicates maximum peak (local maxima).\nWe then identify the position or indexes of the local maxima using the where() method. The reason for using +1 at the end of where and [0] after where is the same as the explanation described in Method 1 for finding local maxima. In this method, we calculate the difference between each element using the diff() method of NumPy. Then we use the sign() method on the array to get the sign of difference. The value can be either -1 or +1. This result is then passed on to another diff() method which returns 0, -2 or +2 value. The value 0 indicates that the points are continuously increasing or decreasing, +2 indicates minimum peak and -2 indicates maximum peak (local maxima). We then identify the position or indexes of the local maxima using the where() method. The reason for using +1 at the end of where and [0] after where is the same as the explanation described in Method 1 for finding local maxima. The following code example demonstrates this: import numpy as np\n# define NumPy array\narr = np.array([1, 4, 8, 1, 3, 5, 1, 6, 1, -5, -1, 19, 2])\n\nall_peaks = np.diff(np.sign(np.diff(arr)))\nmaxima_peaks_positions = np.where(all_peaks == -2)[0] + 1\nprint(maxima_peaks_positions) import numpy as np\n# define NumPy array\narr = np.array([1, 4, 8, 1, 3, 5, 1, 6, 1, -5, -1, 19, 2])\n\nall_peaks = np.diff(np.sign(np.diff(arr)))\nmaxima_peaks_positions = np.where(all_peaks == -2)[0] + 1\nprint(maxima_peaks_positions) Output: [ 2  5  7 11]] [ 2  5  7 11]]",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What do you understand by Vectorization in NumPy?",
        "answer": "Function Vectorization technically means that the function is applied to all elements in the array. Typically, certain python functionalities on arrays (such as loops) are slower in nature because python arrays can contain elements of different data types. Since the C program expects a specific datatype, there are chances of compiler optimisation which makes C code run faster. Since NumPy arrays support storing elements of a single datatype, most of the implementations of the functions written in NumPy meant for arithmetic, logical operations etc have optimised C program code under their hood. Additionally, NumPy also helps developers create their own vectorised functions by following the below steps: Write your required function that takes array elements as parameters.\nVectorize the function by making use of the vectorize() method of the NumPy package.\nGive array inputs to the vectorized function. Write your required function that takes array elements as parameters. Vectorize the function by making use of the vectorize() method of the NumPy package. Give array inputs to the vectorized function. The below example demonstrates the process of vectorization. import numpy as np\n# Define your function\ndef add(arr1, arr2):\n    return (arr1 + arr2)\n\narr1 = np.array([1,2,3])\narr2 = np.array([4,5,6])\n\n#vectorize add method\nvectorized_add = np.vectorize(add)\n\n#call vectorized method\nresult = vectorized_add(arr1, arr2)\n\nprint(result) import numpy as np\n# Define your function\ndef add(arr1, arr2):\n    return (arr1 + arr2)\n\narr1 = np.array([1,2,3])\narr2 = np.array([4,5,6])\n\n#vectorize add method\nvectorized_add = np.vectorize(add)\n\n#call vectorized method\nresult = vectorized_add(arr1, arr2)\n\nprint(result) import as # Define your function def add(arr1, arr2): def add arr1, arr2 return 1 2 3 4 5 6 #vectorize add method #call vectorized method print The output of above code [5 7 9] [5 7 9] 5 7 9",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Write a program for interchanging two axes of the NumPy array.",
        "answer": "This can be achieved by using the swapaxes method of NumPy. The below image illustrates the meaning of swapping axes.   import numpy as np\narr = np.array([[1,2,3]])\nprint(\"Original array: \")\nprint(arr)\n\n#Swap axes\naxis_swapped_arr =  np.swapaxes(arr,0,1)\nprint(\"Transformed array: \")\nprint(axis_swapped_arr) import numpy as np\narr = np.array([[1,2,3]])\nprint(\"Original array: \")\nprint(arr)\n\n#Swap axes\naxis_swapped_arr =  np.swapaxes(arr,0,1)\nprint(\"Transformed array: \")\nprint(axis_swapped_arr) Output: Original array: \n[[1 2 3]]\nTransformed array: \n[[1]\n [2]\n [3]] Original array: \n[[1 2 3]]\nTransformed array: \n[[1]\n [2]\n [3]] Conclusion The popularity of the NumPy package has grown immensely among the data science and python developers community ever since it was first introduced in 2005 due to the wide range of high-performing functionalities it offers. This is why it becomes essential to learn and be prepared for the interview questions about this package. In this article, we have seen the most commonly asked NumPy interview questions for freshers and experienced people, along with some questions on writing python programs which make use of NumPy functions. References References https://numpy.org/\nhttps://www.w3resource.com/numpy/index.php https://numpy.org/ https://numpy.org/ https://www.w3resource.com/numpy/index.php https://www.w3resource.com/numpy/index.php Interview Guides https://www.interviewbit.com/technical-interview-questions/\nhttps://www.interviewbit.com/coding-interview-questions/\nhttps://www.interviewbit.com/mock-interview/\nhttps://www.interviewbit.com/blog/\nhttps://www.interviewbit.com/blog/pandas-vs-numpy/ https://www.interviewbit.com/technical-interview-questions/ https://www.interviewbit.com/technical-interview-questions/ https://www.interviewbit.com/coding-interview-questions/ https://www.interviewbit.com/coding-interview-questions/ https://www.interviewbit.com/mock-interview/ https://www.interviewbit.com/mock-interview/ https://www.interviewbit.com/blog/ https://www.interviewbit.com/blog/ https://www.interviewbit.com/blog/pandas-vs-numpy/",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Write a program for changing the dimension of a NumPy array.",
        "answer": "We can achieve this by overriding the shape attribute of the NumPy array. Sample Solution: import numpy as np\n\n#Create NumPy array\narr = np.array([1,2,3,4,5,6,7,8,9])\nprint(\"Original Shape: \", arr.shape)\n\n# Change the shape/dimension of the array\narr.shape = (3, 3)\nprint(\"Transformed Matrix :\")\nprint(arr)\nprint(\"Transformed Shape: \",arr.shape) import numpy as np\n\n#Create NumPy array\narr = np.array([1,2,3,4,5,6,7,8,9])\nprint(\"Original Shape: \", arr.shape)\n\n# Change the shape/dimension of the array\narr.shape = (3, 3)\nprint(\"Transformed Matrix :\")\nprint(arr)\nprint(\"Transformed Shape: \",arr.shape) Output: Original Shape:  (9,)\nTransformed Matrix :\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\nTransformed Shape:  (3, 3) Original Shape:  (9,)\nTransformed Matrix :\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\nTransformed Shape:  (3, 3) In this approach, care has to be taken w.r.t the number of elements present in the original array before changing the dimensions. Otherwise, it will result in the ValueError as shown below: import numpy as np\n\n# We have array of 8 elements\narr = np.array([1,2,3,4,5,6,7,8])\n\n# We are trying to convert the 1D array to a 3D array which expects 9 elements\narr.shape = (3, 3)\nprint(arr) import numpy as np\n\n# We have array of 8 elements\narr = np.array([1,2,3,4,5,6,7,8])\n\n# We are trying to convert the 1D array to a 3D array which expects 9 elements\narr.shape = (3, 3)\nprint(arr) Running this code would result in: 1 import numpy as np\n      2 arr = np.array([1,2,3,4,5,6,7,8])\n----> 3 arr.shape = (3, 3)\n      4 print(arr)\n\nValueError: cannot reshape array of size 8 into shape (3,3) 1 import numpy as np\n      2 arr = np.array([1,2,3,4,5,6,7,8])\n----> 3 arr.shape = (3, 3)\n      4 print(arr)\n\nValueError: cannot reshape array of size 8 into shape (3,3)",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Write a program to add a border of zeros around the existing array.",
        "answer": "For example,\nIf you have the below array:  [[ 1.  1.  1.  1.]                                                          \n [ 1.  1.  1.  1.]                                                          \n [ 1.  1.  1.  1.]] [[ 1.  1.  1.  1.]                                                          \n [ 1.  1.  1.  1.]                                                          \n [ 1.  1.  1.  1.]] The resultant array should be: (zeros on the border and 1s within it) [[ 0.  0.  0.  0.  0.  0.]                                                  \n [ 0.  1.  1.  1.  1.  0.]                                                  \n [ 0.  1.  1.  1.  1.  0.]                                                  \n [ 0.  1.  1.  1.  1.  0.]                                                  \n [ 0.  0.  0.  0.  0.  0.]] [[ 0.  0.  0.  0.  0.  0.]                                                  \n [ 0.  1.  1.  1.  1.  0.]                                                  \n [ 0.  1.  1.  1.  1.  0.]                                                  \n [ 0.  1.  1.  1.  1.  0.]                                                  \n [ 0.  0.  0.  0.  0.  0.]] Solution:-\nThis can be achieved by using the pad method of the NumPy library. Solution:-    import numpy as np\n\n# Create NumPy arrays filled with ones\nones_arr = np.ones((4,4))\n\nprint(\"Transformed array:\")\ntransformed_array = np.pad(ones_arr, pad_width=1, mode='constant', constant_values=0)\nprint(transformed_array) import numpy as np\n\n# Create NumPy arrays filled with ones\nones_arr = np.ones((4,4))\n\nprint(\"Transformed array:\")\ntransformed_array = np.pad(ones_arr, pad_width=1, mode='constant', constant_values=0)\nprint(transformed_array) Output: Transformed array:\n[[0. 0. 0. 0. 0. 0.]\n [0. 1. 1. 1. 1. 0.]\n [0. 1. 1. 1. 1. 0.]\n [0. 1. 1. 1. 1. 0.]\n [0. 1. 1. 1. 1. 0.]\n [0. 0. 0. 0. 0. 0.]] Transformed array:\n[[0. 0. 0. 0. 0. 0.]\n [0. 1. 1. 1. 1. 0.]\n [0. 1. 1. 1. 1. 0.]\n [0. 1. 1. 1. 1. 0.]\n [0. 1. 1. 1. 1. 0.]\n [0. 0. 0. 0. 0. 0.]]",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Write a program for creating an integer array with values belonging to the range 10 and 60",
        "answer": "import numpy as np\narr = np.arange(10, 60)\nprint(arr) import numpy as np\narr = np.arange(10, 60)\nprint(arr) Output: [10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\n 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57\n 58 59] [10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\n 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57\n 58 59]",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Write a program to repeat each of the elements five times for a given array.",
        "answer": "Sample Solution:- import numpy as np\n# Create Sample NumPy Array\narr = np.array(['i', 'love', 'NumPy', 'AND', 'interviewbit'], dtype=str)\n\ntransformed_array = np.char.multiply(arr, 5)\nprint(\"Transformed array:\")\nprint(transformed_array) import numpy as np\n# Create Sample NumPy Array\narr = np.array(['i', 'love', 'NumPy', 'AND', 'interviewbit'], dtype=str)\n\ntransformed_array = np.char.multiply(arr, 5)\nprint(\"Transformed array:\")\nprint(transformed_array) Output: Transformed array:\n['iiiii' 'lovelovelovelovelove' 'NumPyNumPyNumPyNumPyNumPy'\n 'ANDANDANDANDAND'\n 'interviewbitinterviewbitinterviewbitinterviewbitinterviewbit'] Transformed array:\n['iiiii' 'lovelovelovelovelove' 'NumPyNumPyNumPyNumPyNumPy'\n 'ANDANDANDANDAND'\n 'interviewbitinterviewbitinterviewbitinterviewbitinterviewbit']",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Write a program for inserting space between characters of all elements in a NumPy array.",
        "answer": "Sample Solution:- import numpy as np\n\n# Create Sample NumPy Array\narr = np.array(['i', 'love', 'NumPy', 'AND', 'interviewbit'], dtype=str)\n\ntransformed_arr = np.char.join(\" \", arr)\n\nprint(\"Transformed Array: \")\nprint(transformed_arr) import numpy as np\n\n# Create Sample NumPy Array\narr = np.array(['i', 'love', 'NumPy', 'AND', 'interviewbit'], dtype=str)\n\ntransformed_arr = np.char.join(\" \", arr)\n\nprint(\"Transformed Array: \")\nprint(transformed_arr) Output: Transformed Array: \n['i' 'l o v e' 'N u m P y' 'A N D' 'i n t e r v i e w b i t'] Transformed Array: \n['i' 'l o v e' 'N u m P y' 'A N D' 'i n t e r v i e w b i t']",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. Write a program to transform elements of a given string to a numeric string of 10 digits by making all the elements of a given string to a numeric string of 8 digits with zeros on the left.",
        "answer": "Sample Solution:- import numpy as np\n\n# Create Sample NumPy array\narr = np.array(['22', '9', '1234', '567', '89102'], dtype=str)\n\nzeroes_filled_arr = np.char.zfill(arr, 8)\nprint(\"Transformed array: \")\nprint(zeroes_filled_arr) import numpy as np\n\n# Create Sample NumPy array\narr = np.array(['22', '9', '1234', '567', '89102'], dtype=str)\n\nzeroes_filled_arr = np.char.zfill(arr, 8)\nprint(\"Transformed array: \")\nprint(zeroes_filled_arr) Output: Transformed array: \n['00000022' '00000009' '00001234' '00000567' '00089102'] Transformed array: \n['00000022' '00000009' '00001234' '00000567' '00089102']",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. Write a program to convert a string element to uppercase, lowercase, capitalise the first letter, title-case and swapcase of a given NumPy array.",
        "answer": "Sample Solution:- import numpy as np\n\n# Create Sample NumPy array\narr = np.array(['i', 'love', 'NumPy', 'AND', 'interviewbit'], dtype=str)\n\nupper_case_arr = np.char.upper(arr)\nlower_case_arr = np.char.lower(arr)\ncapitalize_case_arr = np.char.capitalize(arr)\ntitlecase_arr = np.char.title(arr)\nswapcase_arr = np.char.swapcase(arr)\n\nprint(\"Upper Conversion: \", upper_case_arr)\nprint(\"Lower Conversion: \", lower_case_arr)\nprint(\"Capitalize First Letter Conversion: \", capitalize_case_arr)\nprint(\"Titlecase Conversion: \", titlecase_arr)\nprint(\"Swapcase Conversion: \", swapcase_arr) import numpy as np\n\n# Create Sample NumPy array\narr = np.array(['i', 'love', 'NumPy', 'AND', 'interviewbit'], dtype=str)\n\nupper_case_arr = np.char.upper(arr)\nlower_case_arr = np.char.lower(arr)\ncapitalize_case_arr = np.char.capitalize(arr)\ntitlecase_arr = np.char.title(arr)\nswapcase_arr = np.char.swapcase(arr)\n\nprint(\"Upper Conversion: \", upper_case_arr)\nprint(\"Lower Conversion: \", lower_case_arr)\nprint(\"Capitalize First Letter Conversion: \", capitalize_case_arr)\nprint(\"Titlecase Conversion: \", titlecase_arr)\nprint(\"Swapcase Conversion: \", swapcase_arr) Output: Upper Conversion:  ['I' 'LOVE' 'NUMPY' 'AND' 'INTERVIEWBIT']\nLower Conversion:  ['i' 'love' 'numpy' 'and' 'interviewbit']\nCapitalize First Letter Conversion:  ['I' 'Love' 'Numpy' 'And' 'Interviewbit']\nTitlecase Conversion:  ['I' 'Love' 'Numpy' 'And' 'Interviewbit']\nSwapcase Conversion:  ['I' 'LOVE' 'nUMpY' 'and' 'INTERVIEWBIT'] Upper Conversion:  ['I' 'LOVE' 'NUMPY' 'AND' 'INTERVIEWBIT']\nLower Conversion:  ['i' 'love' 'numpy' 'and' 'interviewbit']\nCapitalize First Letter Conversion:  ['I' 'Love' 'Numpy' 'And' 'Interviewbit']\nTitlecase Conversion:  ['I' 'Love' 'Numpy' 'And' 'Interviewbit']\nSwapcase Conversion:  ['I' 'LOVE' 'nUMpY' 'and' 'INTERVIEWBIT']",
        "reference": "interviewbit.com"
    }
]