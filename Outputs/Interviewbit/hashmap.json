[
    {
        "question": "1. Explain the internal working of a HashMap.",
        "answer": "  A hashmap uses a hashtable but what many people don\u2019t know is that it is internally created using two data structures namely an array and a linked list. Whenever you declare a hashmap what is going to happen internally is that it will create an array of buckets. The buckets are referred to as nodes or you can say a linked list. These nodes contain mainly:\nThe key,\nValue\nHashcode\nAddress of the next node.\nNow, when you insert values in a key like this: A hashmap uses a hashtable but what many people don\u2019t know is that it is internally created using two data structures namely an array and a linked list. Whenever you declare a hashmap what is going to happen internally is that it will create an array of buckets. The buckets are referred to as nodes or you can say a linked list. These nodes contain mainly:\nThe key,\nValue\nHashcode\nAddress of the next node. The key,\nValue\nHashcode\nAddress of the next node. The key, Value Hashcode Address of the next node. Now, when you insert values in a key like this: map.put(\"hashmap implementation in Java\",1); map.put(\"hashmap implementation in Java\",1); Then hashcode will be calculated by the put method. This hashcode will help us to store the key at a particular index. Also, hashcode will make the process of retrieving the values faster. hashcode=hash(\u201chashmap implementation in Java\u201d); hashcode=hash(\u201chashmap implementation in Java\u201d); This hash code is further computed and will generate an index for storing the value. The value of our key will be stored at the index given by the hashcode in the form of a LinkedList. It\u2019s important to note that Java 8 introduced BST in place of a linked list to make retrieval of the key-value pairs more efficient. It\u2019s important to note that Java 8 introduced BST in place of a linked list to make retrieval of the key-value pairs more efficient.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Which property of a hashmap is used to find the intersection of two arrays?",
        "answer": "Since a hashmap stores only unique elements, this property of a hashmap can be used to find intersections i.e common elements of two arrays.\nThe approach to this problem is: first we will create a hashmap and fill the elements of the first array in it.\nThe next step is to iterate over the second array and check whether the element is present in the hashmap or not.\nIn this way, we can find all common elements of two arrays in O(n) time complexity. Since a hashmap stores only unique elements, this property of a hashmap can be used to find intersections i.e common elements of two arrays. The approach to this problem is: first we will create a hashmap and fill the elements of the first array in it. The next step is to iterate over the second array and check whether the element is present in the hashmap or not. In this way, we can find all common elements of two arrays in O(n) time complexity.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What is collision in HashMap?",
        "answer": "A collision occurs when more than one key generates the same hashCode() value.\nAn inefficient hashCode() algorithm causes considerable collisions in a hashmap.\nAn increased number of collisions can affect the performance of a hashmap. A collision occurs when more than one key generates the same hashCode() value. An inefficient hashCode() algorithm causes considerable collisions in a hashmap. An increased number of collisions can affect the performance of a hashmap.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Discuss the approach for calculating all the equal combinations formed by a pair of numbers in an array using a hashmap i.e The numbers must satisfy these two conditions: nums[i] == nums[j] and i < j Answer)",
        "answer": "You all must have studied combinations, so the concept of combinations states that every time we just have to select a pair from n numbers in an array that satisfies the given conditions and the formula for doing so is NCR which is equivalent to n*(n-1)/2.\nNow hashmap will be used for calculating the frequency of all the numbers in the array.\nWhile iterating the array we will store the frequency of every element in a hashmap.\nThe final step would be to iterate over the map and apply the formula n*(n-1)/2, where n is the frequency of each element in the array. You all must have studied combinations, so the concept of combinations states that every time we just have to select a pair from n numbers in an array that satisfies the given conditions and the formula for doing so is NCR which is equivalent to n*(n-1)/2. n*(n-1)/2 Now hashmap will be used for calculating the frequency of all the numbers in the array. While iterating the array we will store the frequency of every element in a hashmap. The final step would be to iterate over the map and apply the formula n*(n-1)/2, where n is the frequency of each element in the array. n*(n-1)/2",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. How Does Java's Capacity And Size Of Hashmap Differ?",
        "answer": "Sometimes it's confusing for students to understand the difference between capacity is size. So basically, HashMap's capacity indicates the number of entries it can hold, while its length indicates how many key-value pairs are presently in existence.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. How can iteration be performed in a HashMap?",
        "answer": "import java.util.Map;\nimport java.util.HashMap;\n \npublic class example_____iteration\n{\n    public static void main(String[] arg)\n    {\n        Map<String,String> INTERVIEW_BIT = new HashMap<String,String>();\n     \n       \n        INTERVIEW_BIT.put(\"hashmap coding interview questions\", \"AT INTERVEWBIT\");\n        INTERVIEW_BIT.put(\"hashmap programming interview questions\", \"AT INTERVEWBIT\");\n\n        \n        for (Map.Entry<String,String> entry : INTERVIEW_BIT.entrySet())\n            System.out.println(\"Key = \" + entry.getKey() +\n                             \", Value = \" + entry.getValue());\n    }\n} import java.util.Map;\nimport java.util.HashMap;\n \npublic class example_____iteration\n{\n    public static void main(String[] arg)\n    {\n        Map<String,String> INTERVIEW_BIT = new HashMap<String,String>();\n     \n       \n        INTERVIEW_BIT.put(\"hashmap coding interview questions\", \"AT INTERVEWBIT\");\n        INTERVIEW_BIT.put(\"hashmap programming interview questions\", \"AT INTERVEWBIT\");\n\n        \n        for (Map.Entry<String,String> entry : INTERVIEW_BIT.entrySet())\n            System.out.println(\"Key = \" + entry.getKey() +\n                             \", Value = \" + entry.getValue());\n    }\n} import import public class example_____iteration class example_____iteration public static void main(String[] arg) public static void main (String[] arg) new \"hashmap coding interview questions\" \"AT INTERVEWBIT\" \"hashmap programming interview questions\" \"AT INTERVEWBIT\" for \"Key = \" \", Value = \" Output: Output: Key = hashmap coding interview questions, Value = AT INTERVEWBIT\nKey = hashmap programming interview questions, Value = AT INTERVEWBIT Key = hashmap coding interview questions, Value = AT INTERVEWBIT\nKey = hashmap programming interview questions, Value = AT INTERVEWBIT",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What is the order in which keys are stored in a hashmap?",
        "answer": "There is no particular order for storing keys in a hashmap. All the keys are stored in an unsorted order.\nFor storing the elements in a particular order a Treemap can be used in Java but a hashmap does not guarantee the ordering of your elements. There is no particular order for storing keys in a hashmap. All the keys are stored in an unsorted order. For storing the elements in a particular order a Treemap can be used in Java but a hashmap does not guarantee the ordering of your elements.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. Does hashmap allow you to store null values?",
        "answer": "Yes, We can store as many null values in a hashmap as we want but only one null key can be stored not more than that. Let\u2019s see a program that depicts how we can store null values in a hashmap. import java.util.*;  \nimport java.io.*;\npublic class interviewBit {   \n        public static void main(String[] args)   \n        {   \n            HashMap hmap=new HashMap();   \n            hmap.put(1,\"Program to store null value\");   \n            hmap.put(null,\"InterviewBit\");   \n            System.out.println(hmap);   \n        }   \n    } import java.util.*;  \nimport java.io.*;\npublic class interviewBit {   \n        public static void main(String[] args)   \n        {   \n            HashMap hmap=new HashMap();   \n            hmap.put(1,\"Program to store null value\");   \n            hmap.put(null,\"InterviewBit\");   \n            System.out.println(hmap);   \n        }   \n    } import import public class interviewBit class interviewBit public static void main(String[] args) public static void main (String[] args) new 1 \"Program to store null value\" null \"InterviewBit\" OUTPUT: OUTPUT: {null=InterviewBit, 1=Program to store null value} {null=InterviewBit, 1=Program to store null value}",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. Specify whether hashmaps in Java are thread-safe or not?",
        "answer": "The answer is \"NO\" i.e java.lang.HashMap does not support thread-safety. If several threads are altering the HashMap, for example, insertions or removals, then a HashMap should not be shared with other threads.\nIf you want to implement thread-safety then you can either use a ConcurrentHashMap or by using the Collections.synchronizedMap() method.\nWhen data consistency is crucial, Collections.synchronizedMap() should be used, and ConcurrentHashMap should be used where the number of reads and write operations to be performed are less.\nSince Collections.synchronizedMap() needs every thread to attain a lock on the whole object to accomplish both read and write operations, this results in slow performance.\nWith ConcurrentHashMap, threads can simultaneously modify sections while maintaining a lock on individual segments. The answer is \"NO\" i.e java.lang.HashMap does not support thread-safety. If several threads are altering the HashMap, for example, insertions or removals, then a HashMap should not be shared with other threads. java.lang.HashMap If you want to implement thread-safety then you can either use a ConcurrentHashMap or by using the Collections.synchronizedMap() method. ConcurrentHashMap Collections.synchronizedMap() When data consistency is crucial, Collections.synchronizedMap() should be used, and ConcurrentHashMap should be used where the number of reads and write operations to be performed are less. Collections.synchronizedMap() Since Collections.synchronizedMap() needs every thread to attain a lock on the whole object to accomplish both read and write operations, this results in slow performance. Collections.synchronizedMap() With ConcurrentHashMap, threads can simultaneously modify sections while maintaining a lock on individual segments. ConcurrentHashMap",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Specify different methods of creating a hashmap in java along with implementation.",
        "answer": "Different methods of creating a hashmap are: 1) Constructing a hashmap with default capacity 1) Constructing a hashmap with default capacity Syntax: Syntax: Syntax: HashMap<String, Integer> InterviewBIt_map1 = new HashMap<String, Integer>(); HashMap<String, Integer> InterviewBIt_map1 = new HashMap<String, Integer>(); 2) Constructing a hashmap with a defined capacity i.e 50 in our example 2) Constructing a hashmap with a defined capacity i.e 50 in our example Syntax: Syntax: Syntax: HashMap<String, Integer> InterviewBIt_map2 = new HashMap<String, Integer>(50); HashMap<String, Integer> InterviewBIt_map2 = new HashMap<String, Integer>(50); 3) Specifying lead factor along with the capacity 3) Specifying lead factor along with the capacity Syntax: Syntax: Syntax: HashMap<String, Integer> InterviewBIt_map3= new HashMap<String, Integer>(50, 0.5f); HashMap<String, Integer> InterviewBIt_map3= new HashMap<String, Integer>(50, 0.5f); 4) By copying another map into our map 4) By copying another map into our map Syntax: Syntax: Syntax: HashMap<String, Integer> InterviewBIt_map4 = new HashMap<String, Integer>( InterviewBIt_map1); HashMap<String, Integer> InterviewBIt_map4 = new HashMap<String, Integer>( InterviewBIt_map1);",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. Can you store multiple keys with the same value in a hashmap?",
        "answer": "No, multiple keys with the same value can\u2019t be stored in a hashmap.\nWhen you try to insert a new key that is already present in the hashmap then overriding will happen and the old key will be replaced with the new key and a new value. No, multiple keys with the same value can\u2019t be stored in a hashmap. When you try to insert a new key that is already present in the hashmap then overriding will happen and the old key will be replaced with the new key and a new value.",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. State the differences between a Hashmap and a Hashtable in Java.",
        "answer": "HashMap Vs HashTable Parameter HashMap HashTable\nSynchronization Hashmap and HashTable are very similar to each other except for the fact that a hashmap does not allow synchronization Unlike a Hashmap, synchronization is permitted in a Hashtable\nPerformance You won't face any performance issues in a hashmap. Synchronization in a hashtable might sound like a good idea that a particular element would be thread-safe if there\u2019s concurrent access with multiple threads however, the problem with synchronizing every method that allows access to the underlying collection is that it creates performance issues. So you will have performance issues while using a hashtable\nNull values Null values are permitted in a Hashmap i.e you can store as many null values in a hashmap as you want. Unlike a Hashmap, Null values are not permitted in a hashtable \nNull keys While using a Hashmap you can store only one null key not more than that.\nIn a Hashtable null keys, as well as null values, are not allowed similar to a ConcurrentHashmap.\n\n  Iterators We can use iterators for looping through the key and value pairs in a Hashmap. We can use enumerators, as well as iterators, for looping through the key and value pairs in a Hashtable. Parameter HashMap HashTable\nSynchronization Hashmap and HashTable are very similar to each other except for the fact that a hashmap does not allow synchronization Unlike a Hashmap, synchronization is permitted in a Hashtable\nPerformance You won't face any performance issues in a hashmap. Synchronization in a hashtable might sound like a good idea that a particular element would be thread-safe if there\u2019s concurrent access with multiple threads however, the problem with synchronizing every method that allows access to the underlying collection is that it creates performance issues. So you will have performance issues while using a hashtable\nNull values Null values are permitted in a Hashmap i.e you can store as many null values in a hashmap as you want. Unlike a Hashmap, Null values are not permitted in a hashtable \nNull keys While using a Hashmap you can store only one null key not more than that.\nIn a Hashtable null keys, as well as null values, are not allowed similar to a ConcurrentHashmap.\n\n  Iterators We can use iterators for looping through the key and value pairs in a Hashmap. We can use enumerators, as well as iterators, for looping through the key and value pairs in a Hashtable. Parameter HashMap HashTable Parameter HashMap HashTable Parameter HashMap HashTable Synchronization Hashmap and HashTable are very similar to each other except for the fact that a hashmap does not allow synchronization Unlike a Hashmap, synchronization is permitted in a Hashtable\nPerformance You won't face any performance issues in a hashmap. Synchronization in a hashtable might sound like a good idea that a particular element would be thread-safe if there\u2019s concurrent access with multiple threads however, the problem with synchronizing every method that allows access to the underlying collection is that it creates performance issues. So you will have performance issues while using a hashtable\nNull values Null values are permitted in a Hashmap i.e you can store as many null values in a hashmap as you want. Unlike a Hashmap, Null values are not permitted in a hashtable \nNull keys While using a Hashmap you can store only one null key not more than that.\nIn a Hashtable null keys, as well as null values, are not allowed similar to a ConcurrentHashmap.\n\n  Iterators We can use iterators for looping through the key and value pairs in a Hashmap. We can use enumerators, as well as iterators, for looping through the key and value pairs in a Hashtable. Synchronization Hashmap and HashTable are very similar to each other except for the fact that a hashmap does not allow synchronization Unlike a Hashmap, synchronization is permitted in a Hashtable Synchronization Hashmap and HashTable are very similar to each other except for the fact that a hashmap does not allow synchronization Unlike a Hashmap, synchronization is permitted in a Hashtable Performance You won't face any performance issues in a hashmap. Synchronization in a hashtable might sound like a good idea that a particular element would be thread-safe if there\u2019s concurrent access with multiple threads however, the problem with synchronizing every method that allows access to the underlying collection is that it creates performance issues. So you will have performance issues while using a hashtable Performance You won't face any performance issues in a hashmap. Synchronization in a hashtable might sound like a good idea that a particular element would be thread-safe if there\u2019s concurrent access with multiple threads however, the problem with synchronizing every method that allows access to the underlying collection is that it creates performance issues. So you will have performance issues while using a hashtable Null values Null values are permitted in a Hashmap i.e you can store as many null values in a hashmap as you want. Unlike a Hashmap, Null values are not permitted in a hashtable Null values Null values are permitted in a Hashmap i.e you can store as many null values in a hashmap as you want. Unlike a Hashmap, Null values are not permitted in a hashtable Null keys While using a Hashmap you can store only one null key not more than that.\nIn a Hashtable null keys, as well as null values, are not allowed similar to a ConcurrentHashmap. Null keys While using a Hashmap you can store only one null key not more than that. In a Hashtable null keys, as well as null values, are not allowed similar to a ConcurrentHashmap. In a Hashtable null keys, as well as null values, are not allowed similar to a ConcurrentHashmap.   Iterators We can use iterators for looping through the key and value pairs in a Hashmap. We can use enumerators, as well as iterators, for looping through the key and value pairs in a Hashtable. Iterators We can use iterators for looping through the key and value pairs in a Hashmap. We can use enumerators, as well as iterators, for looping through the key and value pairs in a Hashtable.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What is the time complexity in terms of big o notation of pushing and retrieving an element from a hashmap?",
        "answer": "Time complexity is the measure of the number of CPU cycles utilized by a program to execute.\nHashmap time complexity for pushing and retrieving the elements is the order of 1 i.e O(1) using put and get methods respectively. Time complexity is the measure of the number of CPU cycles utilized by a program to execute. Hashmap time complexity for pushing and retrieving the elements is the order of 1 i.e O(1) using put and get methods respectively.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. What is the maximum number of entries you can store in HashMap?",
        "answer": "HashMap does not have a maximum number of entries because when the bucket is full, the keys will be added to a linked list, which can store forever until all the memory you have is consumed.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What factors determine the performance of a hashmap?",
        "answer": "The performance or efficiency of a hashmap depends basically on two things that are: Capacity - Capacity is defined as the total number of buckets present in a Hashmap and Sixteen is the default capacity when a Hashmap is created by the user. The capacity can be increased when more key-value pairs are added to the hashmap.\nLoad Factor - As discussed in the previous point the capacity of the map can be increased but when should the hashmap increase its capacity? Capacity - Capacity is defined as the total number of buckets present in a Hashmap and Sixteen is the default capacity when a Hashmap is created by the user. The capacity can be increased when more key-value pairs are added to the hashmap. Capacity - Load Factor - As discussed in the previous point the capacity of the map can be increased but when should the hashmap increase its capacity? Load Factor - This is decided by the load factor and its default value is seventy-five per cent.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. How can a hashmap be used to check whether two given arrays are equal or not i.e they contain the same elements or not? Given the arrays can be unsorted.",
        "answer": "A hashmap can be easily used to check whether the given arrays are equal or not.\nFirst, create a hashmap and using a for loop fill the frequency of each and every element of array 1 in the hashmap.\nNow, make another loop and decrement the frequency of each and every element of the second array in the hashmap.\nIn the next step, iterate over the hashmap and check whether all the frequencies are zero or not. Even if any frequency is 1 return false else return true. A hashmap can be easily used to check whether the given arrays are equal or not. First, create a hashmap and using a for loop fill the frequency of each and every element of array 1 in the hashmap. Now, make another loop and decrement the frequency of each and every element of the second array in the hashmap. In the next step, iterate over the hashmap and check whether all the frequencies are zero or not. Even if any frequency is 1 return false else return true.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Distinguish between a hashmap and a Treemap.",
        "answer": "Hashmap Treemap\nIn a hashmap, no ordering of elements is maintained The ordering, of elements, is maintained in a treemap.\nWe can store as many null values in a hashmap as we want but only 1 null key can be stored  We cannot store any null values or keys in a treemap.\nHashmap is Fast since no ordering of elements is maintained therefore elements can be inserted and retrieved in constant time. Treemap is slow and most of the functions take logarithmic time.\nHashmap uses arrays and LinkedList which forms a hashtable for its implementation internally. Treemap is implemented with the help of red-black trees. Hashmap Treemap\nIn a hashmap, no ordering of elements is maintained The ordering, of elements, is maintained in a treemap.\nWe can store as many null values in a hashmap as we want but only 1 null key can be stored  We cannot store any null values or keys in a treemap.\nHashmap is Fast since no ordering of elements is maintained therefore elements can be inserted and retrieved in constant time. Treemap is slow and most of the functions take logarithmic time.\nHashmap uses arrays and LinkedList which forms a hashtable for its implementation internally. Treemap is implemented with the help of red-black trees. Hashmap Treemap Hashmap Treemap Hashmap Treemap In a hashmap, no ordering of elements is maintained The ordering, of elements, is maintained in a treemap.\nWe can store as many null values in a hashmap as we want but only 1 null key can be stored  We cannot store any null values or keys in a treemap.\nHashmap is Fast since no ordering of elements is maintained therefore elements can be inserted and retrieved in constant time. Treemap is slow and most of the functions take logarithmic time.\nHashmap uses arrays and LinkedList which forms a hashtable for its implementation internally. Treemap is implemented with the help of red-black trees. In a hashmap, no ordering of elements is maintained The ordering, of elements, is maintained in a treemap. In a hashmap, no ordering of elements is maintained The ordering, of elements, is maintained in a treemap. We can store as many null values in a hashmap as we want but only 1 null key can be stored  We cannot store any null values or keys in a treemap. We can store as many null values in a hashmap as we want but only 1 null key can be stored We cannot store any null values or keys in a treemap. Hashmap is Fast since no ordering of elements is maintained therefore elements can be inserted and retrieved in constant time. Treemap is slow and most of the functions take logarithmic time. Hashmap is Fast since no ordering of elements is maintained therefore elements can be inserted and retrieved in constant time. Treemap is slow and most of the functions take logarithmic time. Hashmap uses arrays and LinkedList which forms a hashtable for its implementation internally. Treemap is implemented with the help of red-black trees. Hashmap uses arrays and LinkedList which forms a hashtable for its implementation internally. Treemap is implemented with the help of red-black trees.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Which is the best technique to handle collision in a hashmap.",
        "answer": "As part of its collision handling, HashMap employs chaining. In chaining, a linked list is used for placing the key-value pairs inserted into the map with the value already present to avoid collision in the map at a bucket location as the newly inserted value is placed in front of the linked list.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Define LinkedHashMap in Java",
        "answer": "A linked HashMap is implemented in a similar way to a hashmap but contains a doubly LinkedList for querying through all the key-value pairs.\nLinkedHashMap stores the key-value pair in order, unlike a hashmap.\nYou can retrieve the data in the same order as they were inserted in the map i.e the key which was inserted first can be taken out first. A linked HashMap is implemented in a similar way to a hashmap but contains a doubly LinkedList for querying through all the key-value pairs. LinkedHashMap stores the key-value pair in order, unlike a hashmap. You can retrieve the data in the same order as they were inserted in the map i.e the key which was inserted first can be taken out first. Implementation of LinkedHashMap for understanding how we can insert and retrieve key and value pairs easily: Implementation of LinkedHashMap for understanding how we can insert and retrieve key and value pairs easily: import java.util.LinkedHashMap;\npublic class InterviewBit {\n\npublic static void main(String[] args) {\n\nLinkedHashMap m = new LinkedHashMap();\n\nm.put(\"Linked\", new Integer(1));\nm.put(\"Map\", new Integer(2));\n\nObject lobj = m.get(\"Linked\");\nSystem.out.println(lobj);\n}\n} import java.util.LinkedHashMap;\npublic class InterviewBit {\n\npublic static void main(String[] args) {\n\nLinkedHashMap m = new LinkedHashMap();\n\nm.put(\"Linked\", new Integer(1));\nm.put(\"Map\", new Integer(2));\n\nObject lobj = m.get(\"Linked\");\nSystem.out.println(lobj);\n}\n} import public class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) new \"Linked\" new 1 \"Map\" new 2 \"Linked\" The output of the above program will be 1.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. Distinguish between a Hashmap and ConcurrentHashMap in Java along with the implementation of both.",
        "answer": "Hashmap vs ConcurrentHashMap: Hashmap vs ConcurrentHashMap: ThreadSafe: One of the most significant differences between both is that a Cocurrenthashmap is synchronized internally and thread-safe which makes it suitable for a multithreaded environment whereas a hashmap is non-synchronized as well non-thread-safe which makes it unsuitable for a multithreaded environment.\nNull Keys And Null Values: As we all know, data is kept in the form of key and value pairs in a hashmap and we can store as many null values in a hashmap as we want but only 1 null key can be stored whereas in a concurrent hashmap null keys, as well as null values, are not permitted. ThreadSafe: One of the most significant differences between both is that a Cocurrenthashmap is synchronized internally and thread-safe which makes it suitable for a multithreaded environment whereas a hashmap is non-synchronized as well non-thread-safe which makes it unsuitable for a multithreaded environment. ThreadSafe: Null Keys And Null Values: As we all know, data is kept in the form of key and value pairs in a hashmap and we can store as many null values in a hashmap as we want but only 1 null key can be stored whereas in a concurrent hashmap null keys, as well as null values, are not permitted. Null Keys And Null Values: Implementations Implementations Hashmap Implementation: Hashmap Implementation: Hashmap Implementation import java.util.*;  \nimport java.io.*;\npublic class interviewBit {   \n        public static void main(String[] args)   \n        {   \n            HashMap hmap=new HashMap();   \n            hmap.put(91,\"Hashmap Implementation\");   \n            hmap.put(92,\"in \");   \n            hmap.put(93,\"Java\");   \n            hmap.put(null,\"InterviewBit\");   \n            System.out.println(hmap);   \n        }   \n    } import java.util.*;  \nimport java.io.*;\npublic class interviewBit {   \n        public static void main(String[] args)   \n        {   \n            HashMap hmap=new HashMap();   \n            hmap.put(91,\"Hashmap Implementation\");   \n            hmap.put(92,\"in \");   \n            hmap.put(93,\"Java\");   \n            hmap.put(null,\"InterviewBit\");   \n            System.out.println(hmap);   \n        }   \n    } import import public class interviewBit class interviewBit public static void main(String[] args) public static void main (String[] args) new 91 \"Hashmap Implementation\" 92 \"in \" 93 \"Java\" null \"InterviewBit\" OUTPUT: OUTPUT: java -cp /tmp/ZPv88JJ0D2 interviewBit\n{null=InterviewBit, 91=Hashmap Implementation, 92=in , 93=Java} java -cp /tmp/ZPv88JJ0D2 interviewBit\n{null=InterviewBit, 91=Hashmap Implementation, 92=in , 93=Java} ConcurrentHashMap implementation: ConcurrentHashMap implementation: ConcurrentHashMap implementation: For implementing ConcurrentHashmap we have to import the concurrent package. import java.util.concurrent.ConcurrentHashMap;  \npublic class interviewBit {   \n        public static void main(String[] args)   \n        {   \n            ConcurrentHashMap hmap=new ConcurrentHashMap();   \n            hmap.put(91,\"Hashmap Implementation\");   \n            hmap.put(92,\"in \");   \n            hmap.put(93,\"Java\");   \n            hmap.put(null,\"InterviewBit\");   \n            System.out.println(hmap);   \n        }   \n    } import java.util.concurrent.ConcurrentHashMap;  \npublic class interviewBit {   \n        public static void main(String[] args)   \n        {   \n            ConcurrentHashMap hmap=new ConcurrentHashMap();   \n            hmap.put(91,\"Hashmap Implementation\");   \n            hmap.put(92,\"in \");   \n            hmap.put(93,\"Java\");   \n            hmap.put(null,\"InterviewBit\");   \n            System.out.println(hmap);   \n        }   \n    } import public class interviewBit class interviewBit public static void main(String[] args) public static void main (String[] args) new 91 \"Hashmap Implementation\" 92 \"in \" 93 \"Java\" null \"InterviewBit\" OUTPUT: OUTPUT: java -cp /tmp/ZPv88JJ0D2 interviewBit\nException in thread \"main\" java.lang.NullPointerException\nat java.base/java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1011)\nat java.base/java.util.concurrent.ConcurrentHashMap.put(ConcurrentHashMap.java:1006)\n at interviewBit.main(interviewBit.java:12) java -cp /tmp/ZPv88JJ0D2 interviewBit\nException in thread \"main\" java.lang.NullPointerException\nat java.base/java.util.concurrent.ConcurrentHashMap.putVal(ConcurrentHashMap.java:1011)\nat java.base/java.util.concurrent.ConcurrentHashMap.put(ConcurrentHashMap.java:1006)\n at interviewBit.main(interviewBit.java:12) As we can observe from the above outputs we can store the null value in the hashmap but it can\u2019t be stored in a ConcurrentHashMap as it gives NullPinterException.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. As we know that hashcodes are generated for each and every key but what happens when the same hashcode is generated for distinct keys?",
        "answer": "When the same hashcode is generated for distinct keys then a collision will occur as the bucket address of the two keys will be the same.\nWe have discussed that internally hashmap uses a linked list therefore the linked list will store them all together. When the same hashcode is generated for distinct keys then a collision will occur as the bucket address of the two keys will be the same. We have discussed that internally hashmap uses a linked list therefore the linked list will store them all together.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Write a program to make a hashmap synchronized in java.",
        "answer": "Collections.synchronizedMap() method is used for making a hashmap synchronized in java. Collections.synchronizedMap() Here is the implementation: Here is the implementation: import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n  \npublic class JavaHashMapPrograms \n{    \n    public static void main(String[] args) \n    {\n         \n        HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n        Map<String, Integer> syncMap = Collections.synchronizedMap(InterviewBit_map);\n    }  } import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n  \npublic class JavaHashMapPrograms \n{    \n    public static void main(String[] args) \n    {\n         \n        HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n        Map<String, Integer> syncMap = Collections.synchronizedMap(InterviewBit_map);\n    }  } Useful Resources Data Structure Interview Questions\nDSA Tutorial\nJava String Interview Questions\nJava Interview Questions for 5 Years Experience\nJava Interview Questions\nJava Cheat Sheet\nArray Interview Questions\nJava Collections Interview Questions\nComplete Interview Preparation Guide\nHashmap vs Hashtable Data Structure Interview Questions Data Structure Interview Questions DSA Tutorial DSA Tutorial Java String Interview Questions Java String Interview Questions Java Interview Questions for 5 Years Experience Java Interview Questions for 5 Years Experience Java Interview Questions Java Interview Questions Java Cheat Sheet Java Cheat Sheet Array Interview Questions Array Interview Questions Java Collections Interview Questions Java Collections Interview Questions Complete Interview Preparation Guide Complete Interview Preparation Guide Hashmap vs Hashtable Hashmap vs Hashtable",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Which method is used for removing or deleting all the key-value pairs? Write a program for removing all the key-value pairs from a HashMap.",
        "answer": "Clear() method is used for removing or deleting all the key-value pairs. Clear() Implementation: Implementation: import java.util.HashMap;\n \npublic class InterviewBit\n{    \n    public static void main(String[] args) \n    {\n         HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n         \n        InterviewBit_map.put(\"X\", 1);\n         \n        InterviewBit_map.put(\"Y\", 2);\n         \n        InterviewBit_map.put(\"Z\", 3);\n         \n        InterviewBit_map.put(\"W\", 4);\n        \n        InterviewBit_map.clear();\n         \n        System.out.println(InterviewBit_map.size());       //Output : 0\n    }   \n} import java.util.HashMap;\n \npublic class InterviewBit\n{    \n    public static void main(String[] args) \n    {\n         HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n         \n        InterviewBit_map.put(\"X\", 1);\n         \n        InterviewBit_map.put(\"Y\", 2);\n         \n        InterviewBit_map.put(\"Z\", 3);\n         \n        InterviewBit_map.put(\"W\", 4);\n        \n        InterviewBit_map.clear();\n         \n        System.out.println(InterviewBit_map.size());       //Output : 0\n    }   \n} import public class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) new \"X\" 1 \"Y\" 2 \"Z\" 3 \"W\" 4 //Output : 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Design and implement a class which contains two function find() as well as add()",
        "answer": "The find function will check whether any pair exists whose sum is equal to a given value in O(N) average time whereas add function will be used for adding any element in O(1) average time. The find function will check whether any pair exists whose sum is equal to a given value in O(N) average time whereas add function will be used for adding any element in O(1) average time. A hashmap will be the best choice for meeting our requirements as adding an element can be performed in O(1) time whereas searching or finding an element can be performed in O(N) time. Implementation: Implementation: public class TwoSum {\n    HashMap<Integer, Integer> our_map;\n\n    public TwoSum() {\n        our_map = new HashMap<>();\n    }\n\n    public void add(int number) {\n        our_map.put(number, our_map.getOrDefault(number, 0) + 1);\n    }\n\n    public boolean find(int data) {\n        for (Integer key : our_map.keySet()) {\n            int complement = data - key;\n            int freq_comp = freq.getOrDefault(complement, 0);\n\n            if (data - key == key) {\n                if (freq_comp >= 2)\n                    return true;\n            } else {\n                if (freq_comp >= 1)\n                    return true;\n            }\n        }\n        return false;\n    }\n} public class TwoSum {\n    HashMap<Integer, Integer> our_map;\n\n    public TwoSum() {\n        our_map = new HashMap<>();\n    }\n\n    public void add(int number) {\n        our_map.put(number, our_map.getOrDefault(number, 0) + 1);\n    }\n\n    public boolean find(int data) {\n        for (Integer key : our_map.keySet()) {\n            int complement = data - key;\n            int freq_comp = freq.getOrDefault(complement, 0);\n\n            if (data - key == key) {\n                if (freq_comp >= 2)\n                    return true;\n            } else {\n                if (freq_comp >= 1)\n                    return true;\n            }\n        }\n        return false;\n    }\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Which method is used for finding out the total number of key-value pairs present in a hashmap?Give example.",
        "answer": "Size() method is used for finding out the total number of key-value pairs present in a hashmap. Size() Example: Example: import java.util.HashMap;\n \npublic class InterviewBit\n{    \n    public static void main(String[] args) \n    {\n         HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n         \n        InterviewBit_map.put(\"X\", 1);\n         \n        InterviewBit_map.put(\"Y\", 2);\n         \n        InterviewBit_map.put(\"Z\", 3);\n         \n        InterviewBit_map.put(\"W\", 4);\n         \n        System.out.println(InterviewBit_map.size());       //Output : 4\n    }   \n} import java.util.HashMap;\n \npublic class InterviewBit\n{    \n    public static void main(String[] args) \n    {\n         HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n         \n        InterviewBit_map.put(\"X\", 1);\n         \n        InterviewBit_map.put(\"Y\", 2);\n         \n        InterviewBit_map.put(\"Z\", 3);\n         \n        InterviewBit_map.put(\"W\", 4);\n         \n        System.out.println(InterviewBit_map.size());       //Output : 4\n    }   \n} import public class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) new \"X\" 1 \"Y\" 2 \"Z\" 3 \"W\" 4 //Output : 4",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Which method is used for checking whether a particular key or a value is present in a HashMap or not? Write a program for checking whether a particular key or a value is present in a HashMap or not. If present return true else return false.",
        "answer": "ContainsKey() and ContainsValue() methods are used for checking whether a particular key or a value is present in a map or not. ContainsKey() ContainsValue() import java.util.HashMap;\npublic class InterviewBit\n{    \n    public static void main(String[] args) \n    {\n         HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n         \n        InterviewBit_map.put(\"X\", 1);\n         \n        InterviewBit_map.put(\"Y\", 2);\n         \n        InterviewBit_map.put(\"Z\", 3);\n         \n        InterviewBit_map.put(\"W\", 4);\n         \n        int value = InterviewBit_map.get(\"Y\");\n         \n        System.out.println(InterviewBit_map.containsKey(\"X\"));    //Output : true\n    }   \n} import java.util.HashMap;\npublic class InterviewBit\n{    \n    public static void main(String[] args) \n    {\n         HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n         \n        InterviewBit_map.put(\"X\", 1);\n         \n        InterviewBit_map.put(\"Y\", 2);\n         \n        InterviewBit_map.put(\"Z\", 3);\n         \n        InterviewBit_map.put(\"W\", 4);\n         \n        int value = InterviewBit_map.get(\"Y\");\n         \n        System.out.println(InterviewBit_map.containsKey(\"X\"));    //Output : true\n    }   \n} import public class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) new \"X\" 1 \"Y\" 2 \"Z\" 3 \"W\" 4 int \"Y\" \"X\" //Output : true",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. 4 sum using hashmap: You will be given four arrays arr1, arr2, arr3, and arr4 all of length n,you have to return the count of tuples (i, j, k, l) satisfying the conditions: 0 <= i, j, k, l < n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0",
        "answer": "Approach: Approach: 2 nested loops will be required for implementing this.\nWe will start by creating  a hashmap\nNext, all possible sums of 2 elements will be calculated and stored in the map using the nested loops we created earlier.\nNow again the nested loop will be used for calculating the sum of 2 elements of the other two arrays.\nOnce we find out all the combinations of the sum, we take the complement of that sum and find that in our hashmap.\nIf the complement is found then the count of tuples will be increased by 1 every time\nThe time complexity will be O(N2) 2 nested loops will be required for implementing this. We will start by creating  a hashmap Next, all possible sums of 2 elements will be calculated and stored in the map using the nested loops we created earlier. Now again the nested loop will be used for calculating the sum of 2 elements of the other two arrays. Once we find out all the combinations of the sum, we take the complement of that sum and find that in our hashmap. If the complement is found then the count of tuples will be increased by 1 every time The time complexity will be O(N2) Implementation: Implementation: import java.util.*;\n\nclass Solution {\n    public int fourSumCount(int[] arr1, int[] arr2, int[] arr3, int[] arr4) {\n        HashMap<Integer, Integer> AB = new HashMap<>();\n        for (int val1 : arr1)\n            for (int val2 : arr2)\n                AB.put(val1 + val2, AB.getOrDefault(val1 + val2, 0) + 1);\n\n        int count = 0;\n        for (int val3 : arr3)\n            for (int val4 : arr4)\n                count += AB.getOrDefault(-val3 - val4, 0);\n\n        return count;\n    }\n} import java.util.*;\n\nclass Solution {\n    public int fourSumCount(int[] arr1, int[] arr2, int[] arr3, int[] arr4) {\n        HashMap<Integer, Integer> AB = new HashMap<>();\n        for (int val1 : arr1)\n            for (int val2 : arr2)\n                AB.put(val1 + val2, AB.getOrDefault(val1 + val2, 0) + 1);\n\n        int count = 0;\n        for (int val3 : arr3)\n            for (int val4 : arr4)\n                count += AB.getOrDefault(-val3 - val4, 0);\n\n        return count;\n    }\n} import class Solution class Solution public int fourSumCount(int[] arr1, int[] arr2, int[] arr3, int[] arr4) public int fourSumCount (int[] arr1, int[] arr2, int[] arr3, int[] arr4) int int int int new for int for int 0 1 int 0 for int for int 0 return",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. Write a program to find the highest frequency of a character in a given string",
        "answer": "You will be given a string and you are required to find the character which occurs the most number of times using a hashmap. Approach: Approach: First of all, you are required to create a Hashmap.\nAfter that iterate over the string and check for each and every character whether it is present in the hashmap or not.\nIf the character is not present in the hashmap then insert it else increase the frequency of the character.\nOnce the hashmap is filled with the frequency of all the characters in the string, loop over the map and checks for the highest frequency character present on the map. First of all, you are required to create a Hashmap. After that iterate over the string and check for each and every character whether it is present in the hashmap or not. If the character is not present in the hashmap then insert it else increase the frequency of the character. Once the hashmap is filled with the frequency of all the characters in the string, loop over the map and checks for the highest frequency character present on the map. Implementation: Implementation: import java.io.*;\nimport java.util.*;\n\npublic class InterviewBit {\n\n    public static void main(String[] args) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String str = br.readLine();\n        \n        //Creating  a hashmap\n        HashMap<Character, Integer> frequency_map = new HashMap<>();\n        for(int i = 0; i < str.length(); i++){\n            Character ch = str.charAt(i);\n            if(frequency_map.containsKey(ch) == true){\n                int old_freq = frequency_map.get(ch);\n                int new_freq = old_freq + 1;\n                frequency_map.put(ch, new_freq);\n            } else {\n                frequency_map.put(ch, 1);\n            }\n        }\n\n        Set<Character> keys = frequency_map.keySet();\n        Character c = str.charAt(0);\n        for(Character key : keys){\n            if(frequency_map.get(key) > frequency_map.get(c)){\n                c = key;\n            }\n        }\n\n        System.out.println(c);\n    }\n} import java.io.*;\nimport java.util.*;\n\npublic class InterviewBit {\n\n    public static void main(String[] args) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String str = br.readLine();\n        \n        //Creating  a hashmap\n        HashMap<Character, Integer> frequency_map = new HashMap<>();\n        for(int i = 0; i < str.length(); i++){\n            Character ch = str.charAt(i);\n            if(frequency_map.containsKey(ch) == true){\n                int old_freq = frequency_map.get(ch);\n                int new_freq = old_freq + 1;\n                frequency_map.put(ch, new_freq);\n            } else {\n                frequency_map.put(ch, 1);\n            }\n        }\n\n        Set<Character> keys = frequency_map.keySet();\n        Character c = str.charAt(0);\n        for(Character key : keys){\n            if(frequency_map.get(key) > frequency_map.get(c)){\n                c = key;\n            }\n        }\n\n        System.out.println(c);\n    }\n} import import public class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) new new //Creating  a hashmap new for int 0 if true int int 1 else 1 0 for if",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. Write a program to show how can we retrieve values from a hashmap and state which method is used for it.",
        "answer": "The get() method is used for retrieving the values from the hashmap. Implementation: Implementation: import java.util.HashMap;\npublic class InterviewBit\n{    \n    public static void main(String[] args) \n\n    {\n         HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n        InterviewBit_map.put(\"X\", 1);\n        InterviewBit_map.put(\"Y\", 2);\n        InterviewBit_map.put(\"Z\", 3);\n        InterviewBit_map.put(\"W\", 4);\n        int value = InterviewBit_map.get(\"Y\");\n        System.out.println(value);       //Output : 2\n    }   \n} import java.util.HashMap;\npublic class InterviewBit\n{    \n    public static void main(String[] args) \n\n    {\n         HashMap<String, Integer> InterviewBit_map = new HashMap<String, Integer>();\n        InterviewBit_map.put(\"X\", 1);\n        InterviewBit_map.put(\"Y\", 2);\n        InterviewBit_map.put(\"Z\", 3);\n        InterviewBit_map.put(\"W\", 4);\n        int value = InterviewBit_map.get(\"Y\");\n        System.out.println(value);       //Output : 2\n    }   \n} import public class InterviewBit class InterviewBit public static void main(String[] args) public static void main (String[] args) new \"X\" 1 \"Y\" 2 \"Z\" 3 \"W\" 4 int \"Y\" //Output : 2",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. You will be given an unsorted array of integers and a target t. How will you implement a program using a Hashmap to find the position of two numbers whose sum equals target t?",
        "answer": "Approach: Approach: A general approach for solving such kinds of problems is that first, you have to create a map of Integers.\nThen iterate through the given array and subtract the current value in the array from the given target.\nLook for that value in the hashmap simultaneously.\nIf the value is found in the map then return the index of these 2 numbers else insert the current element of the array as the key and its index as the value in the Hashmap. A general approach for solving such kinds of problems is that first, you have to create a map of Integers. Then iterate through the given array and subtract the current value in the array from the given target. Look for that value in the hashmap simultaneously. If the value is found in the map then return the index of these 2 numbers else insert the current element of the array as the key and its index as the value in the Hashmap. Implementation: Implementation: class InterviewBit{\n    public int[] target(int[] nums, int t) {\n        HashMap<Integer, Integer> find_complement = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (find_complement.containsKey(t - nums[i]) == true) {\n                return new int[] { find_complement.get(t - nums[i]), i };\n            }\n            find_complement.put(nums[i], i);\n        }\n        return null;\n    }\n} class InterviewBit{\n    public int[] target(int[] nums, int t) {\n        HashMap<Integer, Integer> find_complement = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (find_complement.containsKey(t - nums[i]) == true) {\n                return new int[] { find_complement.get(t - nums[i]), i };\n            }\n            find_complement.put(nums[i], i);\n        }\n        return null;\n    }\n} class InterviewBit class InterviewBit public int int int new for int 0 if true return new int return null",
        "reference": "interviewbit.com"
    }
]