[
    {
        "question": "1. What are the primitive types in TypeScript?",
        "answer": "TypeScript has three primitive types that are frequently used: string, number, and boolean. These correspond to the similarly named types in JavaScript. string: represents text values such as \u201cjavascript\u201d, \u201ctypescript\u201d, etc.\nnumber: represents numeric values like 1, 2, 32, 43, etc.\nboolean: represents a variable that can have either a \u2018true\u2019 or \u2018false\u2019 value. string: represents text values such as \u201cjavascript\u201d, \u201ctypescript\u201d, etc. string number: represents numeric values like 1, 2, 32, 43, etc. number boolean: represents a variable that can have either a \u2018true\u2019 or \u2018false\u2019 value. boolean:  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Explain how the arrays work in TypeScript.",
        "answer": "We use arrays to store values of the same type. Arrays are ordered and indexed collections of values. The indexing starts at 0, i.e., the first element has index 0, the second has index 1, and so on. Here is the syntax to declare and initialize an array in TypeScript. let values: number[] = [];\nvalues[0] = 10;\nvalues[1] = 20;\nvalues[2] = 30; let values: number[] = [];\nvalues[0] = 10;\nvalues[1] = 20;\nvalues[2] = 30; You can also create an array using the short-hand syntax as follows: let values: number[] = [15, 20, 25, 30]; let values: number[] = [15, 20, 25, 30]; TypeScript provides an alternate syntax to specify the Array type. let values: Array<number> = [15, 20, 25, 30]; let values: Array<number> = [15, 20, 25, 30];",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What is any type, and when to use it?",
        "answer": "There are times when you want to store a value in a variable but don\u2019t know the type of that variable in advance. For example, the value is coming from an API call or the user input. The \u2018any\u2019 type allows you to assign a value of any type to the variable of type any. let person: any = \"Foo\"; let person: any = \"Foo\"; Here is an example that demonstrates the usage of any type. // json may come from a third-party API\nconst employeeData: string = `{\"name\": \"John Doe\", \"salary\": 60000}`;\n\n// parse JSON to build employee object\nconst employee: any = JSON.parse(employeeData);\n\nconsole.log(employee.name);\nconsole.log(employee.salary); // json may come from a third-party API\nconst employeeData: string = `{\"name\": \"John Doe\", \"salary\": 60000}`;\n\n// parse JSON to build employee object\nconst employee: any = JSON.parse(employeeData);\n\nconsole.log(employee.name);\nconsole.log(employee.salary); TypeScript assumes a variable is of type any when you don\u2019t explicitly provide the type, and the compiler cannot infer the type from the surrounding context. any",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What is void, and when to use the void type?",
        "answer": "The void indicates the absence of type on a variable. It acts as the opposite type to any. It is especially useful in functions that don\u2019t return a value. function notify(): void {\n  alert(\"The user has been notified.\");\n} function notify(): void {\n  alert(\"The user has been notified.\");\n} If a variable is of type void, you can only assign the null or undefined values to that variable.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What is an unknown type, and when to use it in TypeScript?",
        "answer": "The unknown type is the type-safe counterpart of any type. You can assign anything to the unknown, but the unknown isn\u2019t assignable to anything but itself and any, without performing a type assertion of a control-flow-based narrowing. You cannot perform any operations on a variable of an unknown type without first asserting or narrowing it to a more specific type. Consider the following example. We create the foo variable of unknown type and assign a string value to it. If we try to assign that unknown variable to a string variable bar, the compiler gives an error. let foo: unknown = \"Akshay\";\nlet bar: string = foo; // Type 'unknown' is not assignable to type 'string'.(2322) let foo: unknown = \"Akshay\";\nlet bar: string = foo; // Type 'unknown' is not assignable to type 'string'.(2322) You can narrow down a variable of an unknown type to something specific by doing typeof checks or comparison checks or using type guards. For example, we can get rid of the above error by let foo: unknown = \"Akshay\";\nlet bar: string = foo as string; let foo: unknown = \"Akshay\";\nlet bar: string = foo as string;",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What are the different keywords to declare variables in TypeScript?",
        "answer": "var: Declares a function-scoped or global variable. You can optionally set its value during the declaration. Its behavior and scoping rules are similar to the var keyword in JavaScript. For example, var: var foo = \"bar\"; var foo = \"bar\"; let: Declares a block-scoped local variable. Similar to var, you can optionally set the value of a variable during the declaration. For example, let: let a = 5;\n\nif (true) {\n  let a = 10;\n  console.log(a);  // 10\n}\nconsole.log(a);  // 5 let a = 5;\n\nif (true) {\n  let a = 10;\n  console.log(a);  // 10\n}\nconsole.log(a);  // 5 const: Declares a block-scoped constant value that cannot be changed after it\u2019s initialized.  For example, const: const a = 5;\n\nif (true) {\n  a = 10; // Error: Cannot assign to 'a' because it is a constant.(2588)\n} const a = 5;\n\nif (true) {\n  a = 10; // Error: Cannot assign to 'a' because it is a constant.(2588)\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. Explain the arrow function syntax in TypeScript.",
        "answer": "Arrow functions provide a short and convenient syntax to declare functions. They are also called lambdas in other programming languages. Consider a regular function that adds two numbers and returns a number. function add(x: number, y: number): number {\nlet sum = x + y;\nreturn sum;\n} function add(x: number, y: number): number {\nlet sum = x + y;\nreturn sum;\n} Using arrow functions syntax, the same function can be defined as: let add = (x: number, y: number): number => {\nlet sum = x + y;\nreturn sum;\n} let add = (x: number, y: number): number => {\nlet sum = x + y;\nreturn sum;\n} You can further simplify the syntax by getting rid of the brackets and the return statement. This is allowed when the function body consists of only one statement. For example, if we remove the temporary sum variable, we can rewrite the above function as: let add = (x: number, y: number): number => x + y; let add = (x: number, y: number): number => x + y; Arrow functions are often used to create anonymous callback functions in TypeScript. Consider the example below that loops over and filters an array of numbers and returns an array containing multiples of five. The filter function takes an arrow function. let numbers = [3, 5, 9, 15, 34, 35];\n\nlet fiveMultiples = numbers.filter(num => (num % 5) == 0);\n\nconsole.log(fiveMultiples);  // [5, 15, 35] let numbers = [3, 5, 9, 15, 34, 35];\n\nlet fiveMultiples = numbers.filter(num => (num % 5) == 0);\n\nconsole.log(fiveMultiples);  // [5, 15, 35]",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. Provide the syntax of a function with the type annotations.",
        "answer": "Functions are blocks of code to perform a specific code. Functions can optionally take one or more arguments, process them, and optionally return a value. Here\u2019s the TypeScript syntax to create and call a function. function greet(name: string): string {\n  return `Hello, ${name}`;\n}\n\nlet greeting = greet(\"Anders\");\nconsole.log(greeting);  // \"Hello, Anders\" function greet(name: string): string {\n  return `Hello, ${name}`;\n}\n\nlet greeting = greet(\"Anders\");\nconsole.log(greeting);  // \"Hello, Anders\"",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. How to create objects in TypeScript?",
        "answer": "Objects are dictionary-like collections of keys and values. The keys have to be unique. They are similar to arrays and are also sometimes called associative arrays. However, an array uses numbers to index the values, whereas an object allows you to use any other type as the key. In TypeScript, an Object type refers to any value with properties. It can be defined by simply listing the properties and their types. For example, let pt: { x: number; y: number } = {\n  x: 10,\n  y: 20\n}; let pt: { x: number; y: number } = {\n  x: 10,\n  y: 20\n};",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. How to specify optional properties in TypeScript?",
        "answer": "An object type can have zero or more optional properties by adding a \u2018?\u2019 after the property name. let pt: { x: number; y: number; z?: number } = {\n  x: 10,\n  y: 20\n};\nconsole.log(pt); let pt: { x: number; y: number; z?: number } = {\n  x: 10,\n  y: 20\n};\nconsole.log(pt); In the example above, because the property \u2018z\u2019 is marked as optional, the compiler won\u2019t complain if we don\u2019t provide it during the initialization.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. Explain the concept of null and its use in TypeScript.",
        "answer": "In programming, a null value indicates an absence of value. A null variable doesn\u2019t point to any object. Hence you cannot access any properties on the variable or call a method on it. In TypeScript, the null value is indicated by the \u2018null\u2019 keyword. You can check if a value is null as follows: function greet(name: string | null) {\nif (name === null) {\n  console.log(\"Name is not provided\");\n} else {\n  console.log(\"Good morning, \" + name.toUpperCase());\n}\n}\n\nvar foo = null;\ngreet(foo); // \"Name is not provided\"\n\nfoo = \"Anders\";\ngreet(foo);  // \"Good morning, ANDERS\" function greet(name: string | null) {\nif (name === null) {\n  console.log(\"Name is not provided\");\n} else {\n  console.log(\"Good morning, \" + name.toUpperCase());\n}\n}\n\nvar foo = null;\ngreet(foo); // \"Name is not provided\"\n\nfoo = \"Anders\";\ngreet(foo);  // \"Good morning, ANDERS\"",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What is undefined in TypeScript?",
        "answer": "When a variable is declared without initialization, it\u2019s assigned the undefined value. It\u2019s not very useful on its own. A variable is undefined if it\u2019s declared, but no value has been assigned to it. In contrast, null is assigned to a variable, and it represents no value. console.log(null == null); // true\nconsole.log(undefined == undefined); // true\nconsole.log(null == undefined); // true, with type-conversion\nconsole.log(null === undefined); // false, without type-conversion\nconsole.log(0 == undefined); // false\nconsole.log('' == undefined); // false\nconsole.log(false == undefined); // false console.log(null == null); // true\nconsole.log(undefined == undefined); // true\nconsole.log(null == undefined); // true, with type-conversion\nconsole.log(null === undefined); // false, without type-conversion\nconsole.log(0 == undefined); // false\nconsole.log('' == undefined); // false\nconsole.log(false == undefined); // false",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. Explain the purpose of the never type in TypeScript.",
        "answer": "As the name suggests, the never type represents the type of values that never occur. For example, a function that never returns a value or that always throws an exception can mark its return type as never. function error(message: string): never {\nthrow new Error(message);\n} function error(message: string): never {\nthrow new Error(message);\n} You might wonder why we need a \u2018never\u2019 type when we already have \u2018void\u2019. Though both types look similar, they represent two very different concepts. A function that doesn't return a value implicitly returns the value undefined in JavaScript. Hence, even though we are saying it\u2019s not returning anything, it\u2019s returning \u2018undefined\u2019. We usually ignore the return value in these cases. Such a function is inferred to have a void return type in TypeScript. // This function returns undefined\nfunction greet(name: string) {\nconsole.log(`Hello, ${name}`);\n}\n\nlet greeting = greet(\"David\");\nconsole.log(greeting);  // undefined // This function returns undefined\nfunction greet(name: string) {\nconsole.log(`Hello, ${name}`);\n}\n\nlet greeting = greet(\"David\");\nconsole.log(greeting);  // undefined In contrast, a function that has a never return type never returns. It doesn't return undefined, either. There are 2 cases where functions should return never type: In an unending loop e.g a while(true){} type loop.\nA function that throws an error e.g function foo(){throw new Exception('Error message')} In an unending loop e.g a while(true){} type loop. A function that throws an error e.g function foo(){throw new Exception('Error message')}",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. Explain how enums work in TypeScript?",
        "answer": "Enums allow us to create named constants. It is a simple way to give more friendly names to numeric constant values. An enum is defined by the keyword enum, followed by its name and the members. Consider the following example that defines an enum Team with four values in it. enum Team {\nAlpha,\nBeta,\nGamma,\nDelta\n}\nlet t: Team = Team.Delta; enum Team {\nAlpha,\nBeta,\nGamma,\nDelta\n}\nlet t: Team = Team.Delta; By default, the enums start the numbering at 0. You can override the default numbering by explicitly assigning the values to its members. TypeScript also lets you create enums with string values as follows: enum Author {\n  Anders = \"Anders\",\n  Hejlsberg = \"Hejlsberg\"\n}; enum Author {\n  Anders = \"Anders\",\n  Hejlsberg = \"Hejlsberg\"\n};",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What is the typeof operator? How is it used in TypeScript?",
        "answer": "Similar to JavaScript, the typeof operator in TypeScript returns the type of the operand as a string. console.log(typeof 10);  // \"number\"\n\nconsole.log(typeof 'foo');  // \"string\"\n\nconsole.log(typeof false);  // \"boolean\"\n\nconsole.log(typeof bar);  // \"undefined\" console.log(typeof 10);  // \"number\"\n\nconsole.log(typeof 'foo');  // \"string\"\n\nconsole.log(typeof false);  // \"boolean\"\n\nconsole.log(typeof bar);  // \"undefined\" In TypeScript, you can use the typeof operator in a type context to refer to the type of a property or a variable. let greeting = \"hello\";\nlet typeOfGreeting: typeof greeting;  // similar to let typeOfGreeting: string let greeting = \"hello\";\nlet typeOfGreeting: typeof greeting;  // similar to let typeOfGreeting: string",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. What are the rest parameters and arguments in TypeScript?",
        "answer": "A rest parameter allows a function to accept an indefinite number of arguments as an array. It is denoted by the \u2018\u2026\u2019 syntax and indicates that the function can accept one or more arguments. function add(...values: number[]) {\nlet sum = 0;\nvalues.forEach(val => sum += val);\nreturn sum;\n}\nconst sum = add(5, 10, 15, 20);\nconsole.log(sum);  // 50 function add(...values: number[]) {\nlet sum = 0;\nvalues.forEach(val => sum += val);\nreturn sum;\n}\nconst sum = add(5, 10, 15, 20);\nconsole.log(sum);  // 50 In contrast, the rest arguments allow a function caller to provide a variable number of arguments from an array. Consider the following example. const first = [1, 2, 3];\nconst second = [4, 5, 6];\n\nfirst.push(...second);\nconsole.log(first);  // [1, 2, 3, 4, 5, 6] const first = [1, 2, 3];\nconst second = [4, 5, 6];\n\nfirst.push(...second);\nconsole.log(first);  // [1, 2, 3, 4, 5, 6]",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. What is parameter destructuring?",
        "answer": "Parameter destructing allows a function to unpack the object provided as an argument into one or more local variables. function multiply({ a, b, c }: { a: number; b: number; c: number }) {\nconsole.log(a * b * c);\n}\n\nmultiply({ a: 1, b: 2, c: 3 });\n\nYou can simplify the above code by using an interface or a named type, as follows:\ntype ABC = { a: number; b: number; c: number };\n\nfunction multiply({ a, b, c }: ABC) {\nconsole.log(a * b * c);\n}\n\nmultiply({ a: 1, b: 2, c: 3 }); function multiply({ a, b, c }: { a: number; b: number; c: number }) {\nconsole.log(a * b * c);\n}\n\nmultiply({ a: 1, b: 2, c: 3 });\n\nYou can simplify the above code by using an interface or a named type, as follows:\ntype ABC = { a: number; b: number; c: number };\n\nfunction multiply({ a, b, c }: ABC) {\nconsole.log(a * b * c);\n}\n\nmultiply({ a: 1, b: 2, c: 3 });",
        "reference": "interviewbit.com"
    },
    {
        "question": "18. Explain the TypeScript class syntax.",
        "answer": "TypeScript fully supports classes. The TypeScript syntax for class declaration is similar to that of JavaScript, with the added type support for the member declarations. Here is a simple class that defines an Employee type. class Employee {\n  name: string;\n  salary: number;\n\n  constructor(name: string, salary: number) {\n          this.name = name;\n          this.salary = salary;\n  }\n  promote() : void {\n    this.salary += 10000;\n  }\n} class Employee {\n  name: string;\n  salary: number;\n\n  constructor(name: string, salary: number) {\n          this.name = name;\n          this.salary = salary;\n  }\n  promote() : void {\n    this.salary += 10000;\n  }\n} You can create an instance (or object) of a class by using the new keyword. // Create a new employee\nlet john = new Employee(\"John\", 60000);\n\nconsole.log(john.salary);  // 60000\njohn.promote();\nconsole.log(john.salary);  // 70000 // Create a new employee\nlet john = new Employee(\"John\", 60000);\n\nconsole.log(john.salary);  // 60000\njohn.promote();\nconsole.log(john.salary);  // 70000",
        "reference": "interviewbit.com"
    },
    {
        "question": "19. Provide the syntax for optional parameters in TypeScript.",
        "answer": "A function can mark one or more of its parameters as optional by suffixing its name with \u2018?\u2019. In the example below, the parameter greeting is marked optional. function greet(name: string, greeting?: string) {\nif (!greeting)\n  greeting = \"Hello\";\n\nconsole.log(`${greeting}, ${name}`);\n}\n\ngreet(\"John\", \"Hi\");  // Hi, John\ngreet(\"Mary\", \"Hola\");  // Hola, Mary\ngreet(\"Jane\");  // Hello, Jane function greet(name: string, greeting?: string) {\nif (!greeting)\n  greeting = \"Hello\";\n\nconsole.log(`${greeting}, ${name}`);\n}\n\ngreet(\"John\", \"Hi\");  // Hi, John\ngreet(\"Mary\", \"Hola\");  // Hola, Mary\ngreet(\"Jane\");  // Hello, Jane",
        "reference": "interviewbit.com"
    },
    {
        "question": "20. What is the purpose of the tsconfig.json file?",
        "answer": "A tsconfig.json file in a directory marks that directory as the root of a TypeScript project. It provides the compiler options to compile the project. Here is a sample tsconfig.json file: {\n \"compilerOptions\": {\n   \"module\": \"system\",\n   \"noImplicitAny\": true,\n   \"removeComments\": true,\n   \"outFile\": \"../../built/local/tsc.js\",\n   \"sourceMap\": true\n },\n \"include\": [\"src/**/*\"],\n \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]\n} {\n \"compilerOptions\": {\n   \"module\": \"system\",\n   \"noImplicitAny\": true,\n   \"removeComments\": true,\n   \"outFile\": \"../../built/local/tsc.js\",\n   \"sourceMap\": true\n },\n \"include\": [\"src/**/*\"],\n \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. How to enforce strict null checks in TypeScript?",
        "answer": "Null pointers are one of the most common sources of unexpected runtime errors in programming. TypeScript helps you avoid them to a large degree by enforcing strict null checks. You can enforce strict null checks in two ways: providing the --strictNullChecks flag to the TypeScript (tsc) compiler\nsetting the strictNullChecks property to true in the tsconfig.json configuration file. providing the --strictNullChecks flag to the TypeScript (tsc) compiler setting the strictNullChecks property to true in the tsconfig.json configuration file. When the flag is false, TypeScript ignores null and undefined values in the code. When it is true, null and undefined have their distinct types. The compiler throws a type error if you try to use them where a concrete value is expected.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Does TypeScript support static classes? If not, why?",
        "answer": "TypeScript doesn\u2019t support static classes, unlike the popular object-oriented programming languages like C# and Java. These languages need static classes because all code, i.e., data and functions, need to be inside a class and cannot exist independently. Static classes provide a way to allow these functions without associating them with any objects. In TypeScript, you can create any data and functions as simple objects without creating a containing class. Hence TypeScript doesn\u2019t need static classes. A singleton class is just a simple object in TypeScript.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What are type assertions in TypeScript?",
        "answer": "Sometimes, you as a programmer might know more about the type of a variable than TypeScript can infer. Usually, this happens when you know the type of an object is more specific than its current type. In such cases, you can tell the TypeScript compiler not to infer the type of the variable by using type assertions. TypeScript provides two forms to assert the types. as syntax: as syntax: let value: unknown = \"Foo\";\nlet len: number = (value as string).length; let value: unknown = \"Foo\";\nlet len: number = (value as string).length; <> syntax: <> syntax: let value: unknown = \"Foo\";\nlet len: number = (<string>value).length; let value: unknown = \"Foo\";\nlet len: number = (<string>value).length; Type assertions are similar to typecasting in other programming languages such as C# or Java. However, unlike those languages, there\u2019s no runtime penalty of boxing and unboxing variables to fit the types. Type assertions simply let the TypeScript compiler know the type of the variable.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Explain how tuple destructuring works in TypeScript.",
        "answer": "You can destructure tuple elements by using the assignment operator (=). The destructuring variables get the types of the corresponding tuple elements. let employeeRecord: [string, number] = [\"John Doe\", 50000];\nlet [emp_name, emp_salary] = employeeRecord;\nconsole.log(`Name: ${emp_name}`);  // \"Name: John Doe\"\nconsole.log(`Salary: ${emp_salary}`);  // \"Salary: 50000\" let employeeRecord: [string, number] = [\"John Doe\", 50000];\nlet [emp_name, emp_salary] = employeeRecord;\nconsole.log(`Name: ${emp_name}`);  // \"Name: John Doe\"\nconsole.log(`Salary: ${emp_salary}`);  // \"Salary: 50000\" After destructuring, you can\u2019t assign a value of a different type to the destructured variable. For example, emp_name = true;  // Type 'boolean' is not assignable to type 'string'.(2322) emp_name = true;  // Type 'boolean' is not assignable to type 'string'.(2322)",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Explain the tuple types in TypeScript.",
        "answer": "Tuples are a special type in TypeScript. They are similar to arrays with a fixed number of elements with a known type. However, the types need not be the same. // Declare a tuple type and initialize it\nlet values: [string, number] = [\"Foo\", 15];\n\n// Type 'boolean' is not assignable to type 'string'.(2322)\n// Type 'string' is not assignable to type 'number'.(2322)\nlet wrongValues: [string, number] = [true, \"hello\"]; // Error // Declare a tuple type and initialize it\nlet values: [string, number] = [\"Foo\", 15];\n\n// Type 'boolean' is not assignable to type 'string'.(2322)\n// Type 'string' is not assignable to type 'number'.(2322)\nlet wrongValues: [string, number] = [true, \"hello\"]; // Error Since TypeScript 3.0, a tuple can specify one or more optional types using the ? as shown below. let values: [string, number, boolean?] = [\"Foo\", 15]; let values: [string, number, boolean?] = [\"Foo\", 15];",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What are type aliases? How do you create one?",
        "answer": "Type aliases give a new, meaningful name for a type. They don\u2019t create new types but create new names that refer to that type. For example, you can alias a union type to avoid typing all the types everywhere that value is being used. type alphanumeric = string | number;\nlet value: alphanumeric = \"\";\nvalue = 10; type alphanumeric = string | number;\nlet value: alphanumeric = \"\";\nvalue = 10;",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What are intersection types?",
        "answer": "Intersection types let you combine the members of two or more types by using the \u2018&\u2019 operator. This allows you to combine existing types to get a single type with all the features you need. The following example creates a new type Supervisor that has the members of types Employee and Manager. interface Employee {\nwork: () => string;\n}\n\ninterface Manager {\nmanage: () => string;\n}\n\ntype Supervisor = Employee & Manager;\n\n// john can both work and manage\nlet john: Supervisor; interface Employee {\nwork: () => string;\n}\n\ninterface Manager {\nmanage: () => string;\n}\n\ntype Supervisor = Employee & Manager;\n\n// john can both work and manage\nlet john: Supervisor;",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What are union types in TypeScript?",
        "answer": "A union type is a special construct in TypeScript that indicates that a value can be one of several types. A vertical bar (|) separates these types. Consider the following example where the variable value belongs to a union type consisting of strings and numbers. The value is initialized to string \u201cFoo\u201d. Because it can only be a string or a number, we can change it to a number later, and the TypeScript compiler doesn\u2019t complain. let value: string | number = \"Foo\";\nvalue = 10;  // Okay let value: string | number = \"Foo\";\nvalue = 10;  // Okay However, if we try to set the value to a type not included in the union types, we get the following error. value = true;  // Type 'boolean' is not assignable to type 'string | number'.(2322) value = true;  // Type 'boolean' is not assignable to type 'string | number'.(2322) Union types allow you to create new types out of existing types. This removes a lot of boilerplate code as you don\u2019t have to create new classes and type hierarchies.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What are anonymous functions? Provide their syntax in TypeScript.",
        "answer": "An anonymous function is a function without a name. Anonymous functions are typically used as callback functions, i.e., they are passed around to other functions, only to be invoked by the other function at a later point in time. For example, setTimeout(function () {\n  console.log('Run after 2 seconds')\n}, 2000);\n\nYou can invoke an anonymous function as soon as it\u2019s created. It\u2019s called \u2018immediately invoked function execution (IIFE)\u2019, For example:\n(function() {\n  console.log('Invoked immediately after creation');\n})(); setTimeout(function () {\n  console.log('Run after 2 seconds')\n}, 2000);\n\nYou can invoke an anonymous function as soon as it\u2019s created. It\u2019s called \u2018immediately invoked function execution (IIFE)\u2019, For example:\n(function() {\n  console.log('Invoked immediately after creation');\n})();",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. What are abstract classes? When should you use one?",
        "answer": "Abstract classes are similar to interfaces in that they specify a contract for the objects, and you cannot instantiate them directly. However, unlike interfaces, an abstract class may provide implementation details for one or more of its members. An abstract class marks one or more of its members as abstract. Any classes that extend an abstract class have to provide an implementation for the abstract members of the superclass. Here is an example of an abstract class Writer with two member functions. The write() method is marked as abstract, whereas the greet() method has an implementation. Both the FictionWriter and RomanceWriter classes that extend from Writer have to provide their specific implementation for the write method. abstract class Writer {\nabstract write(): void;\n\ngreet(): void {\n  console.log(\"Hello, there. I am a writer.\");\n}\n}\n\nclass FictionWriter extends Writer {\nwrite(): void {\n  console.log(\"Writing a fiction.\");\n}\n}\n\nclass RomanceWriter extends Writer {\nwrite(): void {\n  console.log(\"Writing a romance novel.\");\n}\n}\n\nconst john = new FictionWriter();\njohn.greet();  // \"Hello, there. I am a writer.\"\njohn.write();  // \"Writing a fiction.\"\n\nconst mary = new RomanceWriter();\nmary.greet();  // \"Hello, there. I am a writer.\"\nmary.write();  // \"Writing a romance novel.\" abstract class Writer {\nabstract write(): void;\n\ngreet(): void {\n  console.log(\"Hello, there. I am a writer.\");\n}\n}\n\nclass FictionWriter extends Writer {\nwrite(): void {\n  console.log(\"Writing a fiction.\");\n}\n}\n\nclass RomanceWriter extends Writer {\nwrite(): void {\n  console.log(\"Writing a romance novel.\");\n}\n}\n\nconst john = new FictionWriter();\njohn.greet();  // \"Hello, there. I am a writer.\"\njohn.write();  // \"Writing a fiction.\"\n\nconst mary = new RomanceWriter();\nmary.greet();  // \"Hello, there. I am a writer.\"\nmary.write();  // \"Writing a romance novel.\"",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. How to make object properties immutable in TypeScript? (hint: readonly)",
        "answer": "You can mark object properties as immutable by using the readonly keyword before the property name. For example: interface Coordinate {\nreadonly x: number;\nreadonly y: number;\n} interface Coordinate {\nreadonly x: number;\nreadonly y: number;\n} When you mark a property as readonly, it can only be set when you initialize the object. Once the object is created, you cannot change it. let c: Coordinate = { x: 5, y: 15 };\nc.x = 20; // Cannot assign to 'x' because it is a read-only property.(2540) let c: Coordinate = { x: 5, y: 15 };\nc.x = 20; // Cannot assign to 'x' because it is a read-only property.(2540)",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What is a type declaration file?",
        "answer": "A typical TypeScript project references other third-party TypeScript libraries such as JQuery to perform routine tasks. Having type information for the library code helps you in coding by providing detailed information about the types, method signatures, etc., and provides IntelliSense. A type declaration file is a text file ending with a .d.ts extension providing a way to declare the existence of some types or values without actually providing implementations for those values. It contains the type declarations but doesn\u2019t have any source code. It doesn\u2019t produce a .js file after compilation.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What are triple-slash directives?",
        "answer": "Triple-slash directives are single-line comments that contain a single XML tag. TypeScript uses this XML tag as a compiler directive. You can only place a triple-slash directive at the top of the containing file. Only single or multi-line comments can come before a triple-slash directive. TypeScript treats them as regular comments if it occurs in the middle of a code block, after a statement. The primary use of triple-slash directives is to include other files in the compilation process. For example, the following directive instructs the compiler to include a file specified by the path in the containing TypeScript file. /// <reference path=\"...\" /> /// <reference path=\"...\" /> Triple-slash directives also order the output when using --out or --outFile. The output files are produced to the output file location in the same order as the input files.",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. Explain the purpose of the \u2018in\u2019 operator.",
        "answer": "The in operator is used to find if a property is in the specified object. It returns true if the property belongs to the object. Otherwise, it returns false. const car = { make: 'Hyundai', model: 'Elantra', year: 2017 };\nconsole.log('model' in car);  // true\nconsole.log('test' in car);  // false const car = { make: 'Hyundai', model: 'Elantra', year: 2017 };\nconsole.log('model' in car);  // true\nconsole.log('test' in car);  // false",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What are the \u2018implements\u2019 clauses in TypeScript?",
        "answer": "An implements clause is used to check that a class satisfies the contract specified by an interface. If a class implements an interface and doesn\u2019t implement that interface, the TypeScript compiler issues an error. interface Runnable {\nrun(): void;\n}\n\nclass Job implements Runnable {\nrun() {\n  console.log(\"running the scheduled job!\");\n}\n}\n\n// Class 'Task' incorrectly implements interface 'Runnable'.\n// Property 'run' is missing in type 'Task' but required in type 'Runnable'.(2420)\nclass Task implements Runnable {\nperform() {\n  console.log(\"pong!\");\n}\n} interface Runnable {\nrun(): void;\n}\n\nclass Job implements Runnable {\nrun() {\n  console.log(\"running the scheduled job!\");\n}\n}\n\n// Class 'Task' incorrectly implements interface 'Runnable'.\n// Property 'run' is missing in type 'Task' but required in type 'Runnable'.(2420)\nclass Task implements Runnable {\nperform() {\n  console.log(\"pong!\");\n}\n} A class can implement more than one interface. In this case, the class has to specify all the contracts of those interfaces.",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. What are string literal types?",
        "answer": "In TypeScript, you can refer to specific strings and numbers as types. let foo: \"bar\" = \"bar\";\n\n// OK\nfoo = \"bar\";\n\n// Error: Type '\"baz\"' is not assignable to type '\"bar\"'.(2322)\nfoo = \"baz\"; let foo: \"bar\" = \"bar\";\n\n// OK\nfoo = \"bar\";\n\n// Error: Type '\"baz\"' is not assignable to type '\"bar\"'.(2322)\nfoo = \"baz\"; String literal types on their own are not that useful. However, you can combine them into unions. This allows you to specify all the string values that a variable can take, in turn acting like enums. This can be useful for function parameters. function greet(name: string, greeting: \"hi\" | \"hello\" | \"hola\") {\n// ...\n}\n\ngreet(\"John\", \"hello\");\n\n// Error: Argument of type '\"Howdy?\"' is not assignable to parameter of type '\"hi\" | \"hello\" | \"hola\"'.(2345)\ngreet(\"Mary\", \"Howdy?\"); function greet(name: string, greeting: \"hi\" | \"hello\" | \"hola\") {\n// ...\n}\n\ngreet(\"John\", \"hello\");\n\n// Error: Argument of type '\"Howdy?\"' is not assignable to parameter of type '\"hi\" | \"hello\" | \"hola\"'.(2345)\ngreet(\"Mary\", \"Howdy?\"); String literal types can help us spell-check the string values.",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. What are template literal types?",
        "answer": "Template literal types are similar to the string literal types. You can combine them with concrete, literal types to produce a new string literal type. Template literal types allow us to use the string literal types as building blocks to create new string literal types. type Point = \"GraphPoint\";\n\n// type Shape = \"Grid GraphPoint\"\ntype Shape = `Grid ${Point}`; type Point = \"GraphPoint\";\n\n// type Shape = \"Grid GraphPoint\"\ntype Shape = `Grid ${Point}`; Template literal types can also expand into multiple strings via unions. It helps us create the set of every possible string literal that each union member can represent. type Color = \"green\" | \"yellow\";\ntype Quantity = \"five\" | \"six\";\n\n// type ItemTwo = \"five item\" | \"six item\" | \"green item\" | \"yellow item\"\ntype ItemOne = `${Quantity | Color} item`; type Color = \"green\" | \"yellow\";\ntype Quantity = \"five\" | \"six\";\n\n// type ItemTwo = \"five item\" | \"six item\" | \"green item\" | \"yellow item\"\ntype ItemOne = `${Quantity | Color} item`;",
        "reference": "interviewbit.com"
    },
    {
        "question": "18. Explain the concept of inheritance in TypeScript.",
        "answer": "Inheritance allows a class to extend another class and reuse and modify the behavior defined in the other class. The class which inherits another class is called the derived class, and the class getting inherited is called the base class. In TypeScript, a class can only extend one class. TypeScript uses the keyword \u2018extends\u2019 to specify the relationship between the base class and the derived classes. class Rectangle {\nlength: number;\nbreadth: number\n\nconstructor(length: number, breadth: number) {\n  this.length = length;\n  this.breadth = breadth\n}\n\narea(): number {\n  return this.length * this.breadth;\n}\n}\n\nclass Square extends Rectangle {\nconstructor(side: number) {\n  super(side, side);\n}\n\nvolume() {\n  return \"Square doesn't have a volume!\"\n}\n}\n\nconst sq = new Square(10);\n\nconsole.log(sq.area());  // 100\nconsole.log(sq.volume());  // \"Square doesn't have a volume!\" class Rectangle {\nlength: number;\nbreadth: number\n\nconstructor(length: number, breadth: number) {\n  this.length = length;\n  this.breadth = breadth\n}\n\narea(): number {\n  return this.length * this.breadth;\n}\n}\n\nclass Square extends Rectangle {\nconstructor(side: number) {\n  super(side, side);\n}\n\nvolume() {\n  return \"Square doesn't have a volume!\"\n}\n}\n\nconst sq = new Square(10);\n\nconsole.log(sq.area());  // 100\nconsole.log(sq.volume());  // \"Square doesn't have a volume!\" In the above example, because the class Square extends functionality from Rectangle, we can create an instance of square and call both the area() and volume() methods.",
        "reference": "interviewbit.com"
    },
    {
        "question": "19. What are conditional types? How do you create them?",
        "answer": "A conditional type allows you to dynamically select one of two possible types based on a condition. The condition is expressed as a type relationship test. C extends B ? TypeX : TypeY C extends B ? TypeX : TypeY Here, if type C extends B, the value of the above type is TypeX. Otherwise, it is TypeY.",
        "reference": "interviewbit.com"
    },
    {
        "question": "20. What is the Function type in TypeScript?",
        "answer": "Function is a global type in TypeScript. It has properties like bind, call, and apply, along with the other properties present on all function values. function perform(fn: Function) {\nfn(10);\n} function perform(fn: Function) {\nfn(10);\n} You can always call a value of the Function type, and it returns a value of \u2018any\u2019 type.",
        "reference": "interviewbit.com"
    },
    {
        "question": "21. List some of the utility types provided by TypeScript and explain their usage.",
        "answer": "TypeScript provides various utility types that make common type transformations easy. These utility types are available globally. Here are some of the essential utility types included in TypeScript. Utility Type Description\nPartial<Type> Constructs a type with all properties of Type set to optional.\nRequired<Type> Constructs a type consisting of all properties of Type set to required.\nReadonly<Type>  Constructs a type with all properties of Type set to readonly.\nRecord<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type. Utility Type Description\nPartial<Type> Constructs a type with all properties of Type set to optional.\nRequired<Type> Constructs a type consisting of all properties of Type set to required.\nReadonly<Type>  Constructs a type with all properties of Type set to readonly.\nRecord<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type. Utility Type Description Utility Type Description Utility Type Description Partial<Type> Constructs a type with all properties of Type set to optional.\nRequired<Type> Constructs a type consisting of all properties of Type set to required.\nReadonly<Type>  Constructs a type with all properties of Type set to readonly.\nRecord<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type. Partial<Type> Constructs a type with all properties of Type set to optional. Partial<Type> Constructs a type with all properties of Type set to optional. Required<Type> Constructs a type consisting of all properties of Type set to required. Required<Type> Constructs a type consisting of all properties of Type set to required. Readonly<Type>  Constructs a type with all properties of Type set to readonly. Readonly<Type> Constructs a type with all properties of Type set to readonly. Record<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type. Record<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type.",
        "reference": "interviewbit.com"
    },
    {
        "question": "22. Explain the various ways to control member visibility in TypeScript.",
        "answer": "TypeScript provides three keywords to control the visibility of class members, such as properties or methods. public: You can access a public member anywhere outside the class. All class members are public by default. \nprotected: A protected member is visible only to the subclasses of the class containing that member. Outside code that doesn\u2019t extend the container class can\u2019t access a protected member. \nprivate: A private member is only visible inside the class. No outside code can access the private members of a class. public: You can access a public member anywhere outside the class. All class members are public by default. public: protected: A protected member is visible only to the subclasses of the class containing that member. Outside code that doesn\u2019t extend the container class can\u2019t access a protected member. protected: private: A private member is only visible inside the class. No outside code can access the private members of a class. private:",
        "reference": "interviewbit.com"
    },
    {
        "question": "23. Explain the different variants of the for loop in TypeScript.",
        "answer": "TypeScript provides the following three ways to loop over collections. \u2018for\u2019 loop \u2018for\u2019 loop let values = [10, \"foo\", true];\n\nfor(let i=0; i<values.length; i++) {\n  console.log(values[i]);  // 10, \"foo\", true\n} let values = [10, \"foo\", true];\n\nfor(let i=0; i<values.length; i++) {\n  console.log(values[i]);  // 10, \"foo\", true\n} \u2018forEach\u2019 function \u2018forEach\u2019 function let values = [10, \"foo\", true];\nvalues.forEach(val => {\n    console.log(val);  // 10, \"foo\", true\n}) let values = [10, \"foo\", true];\nvalues.forEach(val => {\n    console.log(val);  // 10, \"foo\", true\n}) \u2018for..of\u2019 statement \u2018for..of\u2019 statement let values = [10, \"foo\", true];\nfor (let val of values) {\nconsole.log(val); // 10, \"foo\", true\n} let values = [10, \"foo\", true];\nfor (let val of values) {\nconsole.log(val); // 10, \"foo\", true\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "24. Explain the symbol type in TypeScript.",
        "answer": "Symbols were introduced in ES6 and are supported by TypeScript. Similar to numbers and strings, symbols are primitive types. You can use Symbols to create unique properties for objects. You can create symbol values by calling the Symbol() constructor, optionally providing a string key. let foo = Symbol();\nlet bar = Symbol(\"bar\"); // optional string key let foo = Symbol();\nlet bar = Symbol(\"bar\"); // optional string key A key characteristic of symbols is that they are unique and immutable. let foo = Symbol(\"foo\");\nlet newFoo = Symbol(\"foo\");\n\nlet areEqual = foo === newFoo;\nconsole.log(areEqual);  // false, symbols are unique let foo = Symbol(\"foo\");\nlet newFoo = Symbol(\"foo\");\n\nlet areEqual = foo === newFoo;\nconsole.log(areEqual);  // false, symbols are unique",
        "reference": "interviewbit.com"
    },
    {
        "question": "25. Explain how optional chaining works in TypeScript.",
        "answer": "Optional chaining allows you to access properties and call methods on them in a chain-like fashion. You can do this using the \u2018?.\u2019 operator. TypeScript immediately stops running some expression if it runs into a \u2018null\u2019 or \u2018undefined\u2019 value and returns \u2018undefined\u2019 for the entire expression chain. Using optional chaining, the following expression let x = foo === null || foo === undefined ? undefined : foo.bar.baz(); let x = foo === null || foo === undefined ? undefined : foo.bar.baz(); can be expressed as: let x = foo?.bar.baz(); let x = foo?.bar.baz();",
        "reference": "interviewbit.com"
    },
    {
        "question": "26. Provide the TypeScript syntax to create function overloads.",
        "answer": "Function overloading allows us to define multiple functions with the same name, as long as their number of parameters or the types of parameters are different. The following example defines two overloads for the function buildDate. The first overload takes a number as a parameter, whereas the second takes three numbers as parameters. These are called overload signatures. The body of the function also called an implementation signature, follows the overload signatures. You can\u2019t call this signature directly, as it\u2019s not visible from the outside. It should be compatible with the overload signatures. function buildDate(timestamp: number): Date;\nfunction buildDate(m: number, d: number, y: number): Date;\nfunction buildDate(mOrTimestamp: number, d?: number, y?: number): Date {\nif (d !== undefined && y !== undefined) {\n  return new Date(y, mOrTimestamp, d);\n} else {\n  return new Date(mOrTimestamp);\n}\n}\n\nconst d1 = buildDate(87654321);\nconst d2 = buildDate(2, 2, 2); function buildDate(timestamp: number): Date;\nfunction buildDate(m: number, d: number, y: number): Date;\nfunction buildDate(mOrTimestamp: number, d?: number, y?: number): Date {\nif (d !== undefined && y !== undefined) {\n  return new Date(y, mOrTimestamp, d);\n} else {\n  return new Date(mOrTimestamp);\n}\n}\n\nconst d1 = buildDate(87654321);\nconst d2 = buildDate(2, 2, 2);",
        "reference": "interviewbit.com"
    },
    {
        "question": "27. What is meant by type inference?",
        "answer": "TypeScript can infer the type of a variable when you don\u2019t provide an explicit type. This is known as type inference. This is usually done when the variables or parameters are initialized during the declaration. For example, TypeScript knows that the variable foo is a string, even though we don\u2019t mention string as a type. let foo = \"this is a string\";\nconsole.log(typeof foo);  // \"string\" let foo = \"this is a string\";\nconsole.log(typeof foo);  // \"string\"",
        "reference": "interviewbit.com"
    },
    {
        "question": "28. What is meant by contextual typing?",
        "answer": "When the TypeScript compiler uses the location (or context) of a variable to infer its type, it\u2019s called contextual typing. In the following example, TypeScript uses the Window.onmousedown function type information to infer the type of the function expression on the right-hand side of the assignment. This allows it to infer the type of the e parameter, which does have a button property but not a property named foo. window.onmousedown = function (e) {\nconsole.log(e.button); //<- OK\nconsole.log(e.foo); //<- Error!\n}; window.onmousedown = function (e) {\nconsole.log(e.button); //<- OK\nconsole.log(e.foo); //<- Error!\n};",
        "reference": "interviewbit.com"
    },
    {
        "question": "29. What is the purpose of noImplicitAny?",
        "answer": "Usually, when we don\u2019t provide any type on a variable, TypeScript assumes \u2018any\u2019 type. For example, TypeScript compiles the following code, assuming the parameter \u2018s\u2019 is of any type. It works as long as the caller passes a string. s\u2019 function parse(s) {\nconsole.log(s.split(' '));\n}\nparse(\"Hello world\");  // [\"Hello\", \"world\"] function parse(s) {\nconsole.log(s.split(' '));\n}\nparse(\"Hello world\");  // [\"Hello\", \"world\"] However, the code breaks down as soon as we pass a number or other type than a string that doesn\u2019t have a split() method on it. For example, function parse(s) {\nconsole.log(s.split(' '));  // [ERR]: s.split is not a function\n}\nparse(10); function parse(s) {\nconsole.log(s.split(' '));  // [ERR]: s.split is not a function\n}\nparse(10); noImplicitAny is a compiler option that you set in the tsconfig.json file. It forces the TypeScript compiler to raise an error whenever it infers a variable is of any type. This prevents us from accidentally causing similar errors. noImplicitAny Parameter 's' implicitly has an 'any' type.(7006)\nfunction parse(s) {\nconsole.log(s.split(' '));  // [ERR]: s.split is not a function\n} Parameter 's' implicitly has an 'any' type.(7006)\nfunction parse(s) {\nconsole.log(s.split(' '));  // [ERR]: s.split is not a function\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "30. What is an interface?",
        "answer": "An interface defines a contract by specifying the type of data an object can have and its operations. In TypeScript, you can specify an object\u2019s shape by creating an interface and using it as its type. It\u2019s also called \u201cduck typing\u201d. In TypeScript, you can create and use an interface as follows: interface Employee {\nname: string;\nsalary: number;\n}\n\nfunction process(employee: Employee) {\nconsole.log(`${employee.name}'s salary = ${employee.salary}`);\n}\n\nlet john: Employee = {\nname: \"John Doe\",\nsalary: 150000\n}\n\nprocess(john);  // \"John Doe's salary = 150000\" interface Employee {\nname: string;\nsalary: number;\n}\n\nfunction process(employee: Employee) {\nconsole.log(`${employee.name}'s salary = ${employee.salary}`);\n}\n\nlet john: Employee = {\nname: \"John Doe\",\nsalary: 150000\n}\n\nprocess(john);  // \"John Doe's salary = 150000\" Interfaces are an effective way to specify contracts within your code as well as outside your code.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Conclusion",
        "answer": "TypeScript has been increasing in popularity for the last few years, and many large organizations and popular frameworks have adopted TypeScript to manage their large JavaScript codebases. It\u2019s a valuable skill to have as a developer. In this article, we explored the questions that a developer might get asked in an interview. We have provided simple code examples to cement the concepts further. Finally, you can use the multiple-choice questions at the end of the article to test your understanding of the various topics in TypeScript. Reference: TypeScript Documentation\nAngular Interview Questions and Answers\nJavaScript Interview Questions\nDifference between Typescript and Javascript TypeScript Documentation TypeScript Documentation Angular Interview Questions and Answers Angular Interview Questions and Answers JavaScript Interview Questions JavaScript Interview Questions Difference between Typescript and Javascript Difference between Typescript and Javascript",
        "reference": "interviewbit.com"
    }
]