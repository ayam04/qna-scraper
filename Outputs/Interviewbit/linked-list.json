[
    {
        "question": "1. How will you modify a linked list of integers so that all even numbers appear before all odd numbers in the modified linked list? Also, keep the even and odd numbers in the same order.",
        "answer": "Example:\nInput: 17->15->8->12->10->5->4->1->7->6->NULL\nOutput: 8->12->10->4->6->17->15->5->1->7->NULL Example:   Algorithm:\nThe approach is to divide the linked list into two sections, one with all even nodes and the other with all odd nodes. In order to split the Linked List, traverse the original Linked List and move all odd nodes to a new Linked List. The original list will include all the even nodes at the end of the loop, while the odd node list will have all the odd nodes. We must place all the odd nodes at the end of the odd node list to maintain the same ordering of all nodes. And, in order to do it in real-time, we'll need to maintain track of the last pointer in the odd node list. Finally, the odd node linked list is to be attached after the even node linked list. Algorithm:  Implementation: Implementation: Node* separateEvenOdd(struct Node *head)\n{\n   // Starting node of the list having\n   // even values\n   Node *evenStart = NULL;\n    \n   // Starting node of the list having odd values\n   Node *oddStart = NULL;\n    \n   // Ending node of the list having even values\n   Node *evenEnd = NULL;\n    \n   // Ending node of the list having odd values\n   Node *oddEnd = NULL;\n    \n   // Node for list traversal.\n   Node *currentNode;\n    \n   for(currentNode = head; currentNode != NULL; currentNode = currentNode -> next)\n   {\n       int value = currentNode -> value;\n        \n       // If the current value is even, add\n       // it to the list of even values.\n       if(value % 2 != 0) \n       {\n          if(oddStart != NULL)\n           {\n               oddEnd -> next = currentNode;\n               oddEnd = oddEnd -> next;\n           }\n           else\n           {\n               oddStart = currentNode;\n               oddEnd = oddStart;               \n           }\n       }\n        \n       // If current value is odd, add\n       // it to the list of odd values.\n       else\n       {\n           if(evenStart != NULL)\n           {\n               evenEnd -> next = currentNode;\n               evenEnd = evenEnd -> next;               \n           }\n            \n           else\n           {\n              evenStart = currentNode;\n              evenEnd = evenStart;\n           }\n       }\n                    \n  }\n    \n   // If any of the two- odd list or even list is empty,\n   // no change is required\n   if(!oddStart || !evenStart)\n   {\n       return;\n   }\n    \n   // Add the odd list after the even list.    \n   evenEnd -> next = oddStart;\n   oddEnd -> next = NULL;\n    \n   // Modify the head pointer to\n   // the start of the even list.\n   head = evenStart;\n   return head;\n} Node* separateEvenOdd(struct Node *head)\n{\n   // Starting node of the list having\n   // even values\n   Node *evenStart = NULL;\n    \n   // Starting node of the list having odd values\n   Node *oddStart = NULL;\n    \n   // Ending node of the list having even values\n   Node *evenEnd = NULL;\n    \n   // Ending node of the list having odd values\n   Node *oddEnd = NULL;\n    \n   // Node for list traversal.\n   Node *currentNode;\n    \n   for(currentNode = head; currentNode != NULL; currentNode = currentNode -> next)\n   {\n       int value = currentNode -> value;\n        \n       // If the current value is even, add\n       // it to the list of even values.\n       if(value % 2 != 0) \n       {\n          if(oddStart != NULL)\n           {\n               oddEnd -> next = currentNode;\n               oddEnd = oddEnd -> next;\n           }\n           else\n           {\n               oddStart = currentNode;\n               oddEnd = oddStart;               \n           }\n       }\n        \n       // If current value is odd, add\n       // it to the list of odd values.\n       else\n       {\n           if(evenStart != NULL)\n           {\n               evenEnd -> next = currentNode;\n               evenEnd = evenEnd -> next;               \n           }\n            \n           else\n           {\n              evenStart = currentNode;\n              evenEnd = evenStart;\n           }\n       }\n                    \n  }\n    \n   // If any of the two- odd list or even list is empty,\n   // no change is required\n   if(!oddStart || !evenStart)\n   {\n       return;\n   }\n    \n   // Add the odd list after the even list.    \n   evenEnd -> next = oddStart;\n   oddEnd -> next = NULL;\n    \n   // Modify the head pointer to\n   // the start of the even list.\n   head = evenStart;\n   return head;\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. A given linked list is sorted based on absolute values. Write a function to sort the list based on actual values in O(n) time.",
        "answer": "  All the negative elements can be found in the reverse order. Therefore, as we traverse the list, whenever we find an element that is out of order, it is moved to the front of the linked list. Auxiliary Space: O(1) Implementation: Implementation: void sortList(Node** head)\n{\n   // Initialize the previous and the current nodes\n   Node* previous = (*head);\n   Node* current;\n\n   // list traversal\n   for(current = (*head)->next; current != NULL; current = current->next)\n   {\n       // continue if the current element\n       // is at its right place\n       if (current->value >= previous->value)\n       {\n          previous = current;\n       }\n        \n       // If current is smaller than previous, then\n       // it must be moved to head\n       else\n       {\n          // Detach current from the linked list\n           previous->next = current->next;\n\n           // Move the current node to the beginning\n           current->next = (*head);\n           (*head) = current;\n\n           // Update current\n           current = previous;\n          \n        }\n   }\n} void sortList(Node** head)\n{\n   // Initialize the previous and the current nodes\n   Node* previous = (*head);\n   Node* current;\n\n   // list traversal\n   for(current = (*head)->next; current != NULL; current = current->next)\n   {\n       // continue if the current element\n       // is at its right place\n       if (current->value >= previous->value)\n       {\n          previous = current;\n       }\n        \n       // If current is smaller than previous, then\n       // it must be moved to head\n       else\n       {\n          // Detach current from the linked list\n           previous->next = current->next;\n\n           // Move the current node to the beginning\n           current->next = (*head);\n           (*head) = current;\n\n           // Update current\n           current = previous;\n          \n        }\n   }\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Given a linked list and a number n, you have to find the sum of the last n nodes of the linked list in a single traversal. Explain your approach in brief.",
        "answer": "The use of two-pointers will require a single traversal. We will have to maintain two pointers \u2013 reference pointer and main pointer. Both these pointers will be initialized to head. First, the reference pointer will be moved to n nodes from the head, and while traversing, we will keep adding the values and store them into a variable called sum1. Now both the pointers will move simultaneously until the reference pointer reaches the end of the list and while traversing, we will keep adding the values of the nodes. The reference pointer is storing this sum in the variable sum1, and the main pointer will be storing it in sum2. Now, (sum1 \u2013 sum2) is the answer, that is the required sum of the last n nodes. int getSum(Node* head, int n)\n{\n   if (n <= 0)\n       return 0;\n\n   int sum1 = 0, sum2 = 0;\n   struct Node* ptr1 = head;\n   struct Node* ptr2 = head;\n\n   // the sum of the first n nodes is to be calculated\n   for (ptr1 = head; ptr1 != NULL; ptr1 = ptr1->next;) \n   {                  \n       sum += ptr1->value;\n       n--;\n       if(n == 0)\n         break;\n   }\n   // now there is a distance of n nodes between the two pointers\n   // move to the end of the linked list\n   while (ptr1 != NULL) \n   { \n       // sum of all the nodes\n       sum1 += ptr1->value;\n       // sum of the first length -  n nodes\n       sum2 += ptr2->value;\n\n       ptr1 = ptr2->next;\n       ptr2 = ptr2->next;\n   }\n\n   // returning the required sum\n   return (sum1 - sum2);\n} int getSum(Node* head, int n)\n{\n   if (n <= 0)\n       return 0;\n\n   int sum1 = 0, sum2 = 0;\n   struct Node* ptr1 = head;\n   struct Node* ptr2 = head;\n\n   // the sum of the first n nodes is to be calculated\n   for (ptr1 = head; ptr1 != NULL; ptr1 = ptr1->next;) \n   {                  \n       sum += ptr1->value;\n       n--;\n       if(n == 0)\n         break;\n   }\n   // now there is a distance of n nodes between the two pointers\n   // move to the end of the linked list\n   while (ptr1 != NULL) \n   { \n       // sum of all the nodes\n       sum1 += ptr1->value;\n       // sum of the first length -  n nodes\n       sum2 += ptr2->value;\n\n       ptr1 = ptr2->next;\n       ptr2 = ptr2->next;\n   }\n\n   // returning the required sum\n   return (sum1 - sum2);\n} Time Complexity is O(n) and space complexity is O(1).",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. How will you find the middle element of a singly linked list without iterating the list more than once?",
        "answer": "To solve this problem, we can use the two-pointer method. You have two pointers, one fast and one slow, in the two-pointer approach. The fast pointer travels two nodes per step, while the slow pointer only moves one. The slow pointer will point to the middle node of the linked list when the fast pointer points to the last node, i.e. when the next node is null. Node* getMiddle(Node *head)\n{\n     struct Node *slow = head;\n     struct Node *fast = head;\n \n     if (head)\n     {\n         while (fast != NULL && fast->next != NULL)\n         {\n             fast = fast->next->next;\n             slow = slow->next;\n         }\n     }\n     return slow;\n} Node* getMiddle(Node *head)\n{\n     struct Node *slow = head;\n     struct Node *fast = head;\n \n     if (head)\n     {\n         while (fast != NULL && fast->next != NULL)\n         {\n             fast = fast->next->next;\n             slow = slow->next;\n         }\n     }\n     return slow;\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. A linked list of coordinates is given, with neighboring points forming either a vertical or horizontal line. Remove points in between the starting and ending points of the horizontal or vertical line from the linked list.",
        "answer": "  The objective is to keep track of the current node, the next node, and the node after that. Continue deleting the next node when it is the same as the next-next node. We must keep a watch on the shifting of pointers and check for NULL values throughout the entire procedure. Time Complexity is O(n).\nSpace Complexity is O(1)  Implementation: Implementation: void deleteNode(Node *head, Node *t)\n{\n   head->next = t->next;\n   t->next = NULL;\n   free(t);\n}\n\n// This function deletes the intermediate nodes in a sequence of\n// horizontal and vertical line segments represented by a\n// linked list.\nNode* deleteMiddleNodes(Node *head)\n{\n   if (head == NULL || head->next == NULL || head->next->next == NULL)\n       return head;\n\n   Node* t = head->next;\n   Node *tt = t->next;\n\n   // Check whether this is a vertical line or horizontal line\n   if (t->y == head->y)     \n   {\n       // Find intermediate nodes with same y value, and delete them\n       while (tt != NULL && t->y == tt->y)\n       {\n           deleteNode(head, t);\n\n           // Update t and tt for the next iteration\n           t = tt;\n           tt = tt->next;\n       }\n   }\n       // check for vertical line\n   else if (t->x == head->x)\n   {\n       // Find intermediate nodes with same x value, and delete them\n       while (tt != NULL && t->x == tt->x)\n       {\n           deleteNode(head, t);\n\n           // Update t and tt for the next iteration\n           t = tt;\n           tt = tt->next;\n       }\n   }\n   // Adjacent points must either have same x or same y\n   else \n   {\n       cout<<\"Given linked list is not valid\";\n       return NULL;\n   }\n\n   // Recursion for the next segment\n   deleteMiddleNodes(head->next);\n\n   return head;\n} void deleteNode(Node *head, Node *t)\n{\n   head->next = t->next;\n   t->next = NULL;\n   free(t);\n}\n\n// This function deletes the intermediate nodes in a sequence of\n// horizontal and vertical line segments represented by a\n// linked list.\nNode* deleteMiddleNodes(Node *head)\n{\n   if (head == NULL || head->next == NULL || head->next->next == NULL)\n       return head;\n\n   Node* t = head->next;\n   Node *tt = t->next;\n\n   // Check whether this is a vertical line or horizontal line\n   if (t->y == head->y)     \n   {\n       // Find intermediate nodes with same y value, and delete them\n       while (tt != NULL && t->y == tt->y)\n       {\n           deleteNode(head, t);\n\n           // Update t and tt for the next iteration\n           t = tt;\n           tt = tt->next;\n       }\n   }\n       // check for vertical line\n   else if (t->x == head->x)\n   {\n       // Find intermediate nodes with same x value, and delete them\n       while (tt != NULL && t->x == tt->x)\n       {\n           deleteNode(head, t);\n\n           // Update t and tt for the next iteration\n           t = tt;\n           tt = tt->next;\n       }\n   }\n   // Adjacent points must either have same x or same y\n   else \n   {\n       cout<<\"Given linked list is not valid\";\n       return NULL;\n   }\n\n   // Recursion for the next segment\n   deleteMiddleNodes(head->next);\n\n   return head;\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Construct a doubly linked list out of a ternary tree.",
        "answer": "A ternary tree is similar to a binary tree, except that instead of two nodes, it has three: left, middle, and right. The attributes of the doubly linked list should be as follows: The ternary tree's left pointer should be used as the previous pointer in a doubly-linked list.\nThe ternary tree's middle pointer should not point to anything.\nThe ternary tree's right pointer should be the doubly linked list's next pointer.\nEach ternary tree node is entered into a doubly-linked list before its subtrees, with the left child of each node being inserted first, followed by the middle and right child (if any). The ternary tree's left pointer should be used as the previous pointer in a doubly-linked list. The ternary tree's middle pointer should not point to anything. The ternary tree's right pointer should be the doubly linked list's next pointer. Each ternary tree node is entered into a doubly-linked list before its subtrees, with the left child of each node being inserted first, followed by the middle and right child (if any).   The approach is to make a preorder traversal of the tree. When we visit a node, we will use a tail pointer to insert it into a doubly-linked list at the end. That's how we keep the required insertion order. Then, in that order, we call for the left child, middle child, and right child. Implementation: Implementation: //Utility function that creates a doubly linked list\n//by inserting the current node at the end of the doubly\n//linked list by employing a tail pointer\nvoid push(Node** tail_reference, Node* n)\n{\n   // the tail pointer is to be initialized\n   if (*tail_reference == NULL)\n   {\n       *tail_reference = n;\n\n       // set left, middle and right child to point\n       // to NULL\n       n->left = NULL;\n       n->middle = NULL;\n       n->right = NULL;\n\n       return;\n   }\n\n   // using tail pointer, insert node in the end \n   (*tail_reference)->right = n;\n   // the middle and right child are set to point to NULL\n   n->right = NULL;\n   n->middle = NULL;\n\n   // set previous of the node\n   n->left = (*tail_reference);\n\n    \n   // now tail pointer is pointing to the inserted node\n   (*tail_reference) = n;\n}\n\n// From a ternary tree, create a doubly linked list,\n// by making a preorder traversal of the tree\nNode* ternaryTreeToList(Node** head_reference, Node* root)\n{\n   // Base case\n   if (!root)\n       return NULL;\n\n   //a static tail pointer to be created\n   static Node* tail = NULL;\n\n   // left, middle and right nodes to be stored\n   // for future calls.\n   Node* left = root->left;\n   Node* middle = root->middle;\n   Node* right = root->right;\n\n   // set the head of the doubly linked list\n   // as the root of the ternary tree\n   if (*head_reference == NULL)\n       *head_reference = root;\n\n   // push the current node in the end of the doubly linked list\n   push(&tail, root);\n\n   //recursion for left, middle and right child\n   ternaryTreeToList(head_reference, left);\n   ternaryTreeToList(head_reference, middle);\n   ternaryTreeToList(head_reference, right);\n} //Utility function that creates a doubly linked list\n//by inserting the current node at the end of the doubly\n//linked list by employing a tail pointer\nvoid push(Node** tail_reference, Node* n)\n{\n   // the tail pointer is to be initialized\n   if (*tail_reference == NULL)\n   {\n       *tail_reference = n;\n\n       // set left, middle and right child to point\n       // to NULL\n       n->left = NULL;\n       n->middle = NULL;\n       n->right = NULL;\n\n       return;\n   }\n\n   // using tail pointer, insert node in the end \n   (*tail_reference)->right = n;\n   // the middle and right child are set to point to NULL\n   n->right = NULL;\n   n->middle = NULL;\n\n   // set previous of the node\n   n->left = (*tail_reference);\n\n    \n   // now tail pointer is pointing to the inserted node\n   (*tail_reference) = n;\n}\n\n// From a ternary tree, create a doubly linked list,\n// by making a preorder traversal of the tree\nNode* ternaryTreeToList(Node** head_reference, Node* root)\n{\n   // Base case\n   if (!root)\n       return NULL;\n\n   //a static tail pointer to be created\n   static Node* tail = NULL;\n\n   // left, middle and right nodes to be stored\n   // for future calls.\n   Node* left = root->left;\n   Node* middle = root->middle;\n   Node* right = root->right;\n\n   // set the head of the doubly linked list\n   // as the root of the ternary tree\n   if (*head_reference == NULL)\n       *head_reference = root;\n\n   // push the current node in the end of the doubly linked list\n   push(&tail, root);\n\n   //recursion for left, middle and right child\n   ternaryTreeToList(head_reference, left);\n   ternaryTreeToList(head_reference, middle);\n   ternaryTreeToList(head_reference, right);\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. The task is to determine pairs in a doubly-linked list whose sum equals the provided value \u2018val\u2019 without consuming any extra space for a given sorted doubly-linked list of positive distinct entries. The expected complexities are O(n) time and O(1) space.",
        "answer": "The approach is as follows: Two pointer variables are to be initialized to find the possible elements in the sorted doubly linked list. Initialize num1 with the head of the doubly linked list,i.e., num1=head, and num2 with the last node of the doubly linked list, i.e., num2=lastNode.\nIf the current sum of num1 and num2 is less than Val, then we advance num1 in the forward direction. If the current total of the num1 and num2 is greater than x, then num2 is moved in the backward direction.\nWhen the two pointers cross each other (num2->next = num1) or they become equal (num1 == num2), the loop ends. The condition \"num1==num2\" will handle the circumstance where no such pairs are present. Two pointer variables are to be initialized to find the possible elements in the sorted doubly linked list. Initialize num1 with the head of the doubly linked list,i.e., num1=head, and num2 with the last node of the doubly linked list, i.e., num2=lastNode. If the current sum of num1 and num2 is less than Val, then we advance num1 in the forward direction. If the current total of the num1 and num2 is greater than x, then num2 is moved in the backward direction. When the two pointers cross each other (num2->next = num1) or they become equal (num1 == num2), the loop ends. The condition \"num1==num2\" will handle the circumstance where no such pairs are present. Implementation: Implementation: vector<pair<int,int>> sumPair(struct Node *head, int val)\n{\n   // Two pointers are to be set, one to the beginning\n   // and the other to the last of the DLL.\n   struct Node *num1 = head;\n   struct Node *num2 = head;\n   while (num2->next != NULL)  //to get to the last node\n       num2 = num2->next;\n   \n   vector<pair<int,int>> ans;\n   // The loop ends when two pointers\n   // cross each other or they are equal\n   while (num1 != num2 && num2->next != num1)\n   {\n       if ((num1->value + num2->value) == val)\n       {\n           ans.push_back(make_pair(num1->value,num2->value));\n           \n           // move num1 in the forward direction\n           num1 = num1->next;\n\n           // move num2 in the backward direction\n           num2 = num2->prev;\n       }\n       else\n       {\n           if ((num1->value + num2->value) > val)\n               num2 = num2->prev;\n           else\n               num1 = num1->next;\n       }\n   }\n\n  return ans;\n} vector<pair<int,int>> sumPair(struct Node *head, int val)\n{\n   // Two pointers are to be set, one to the beginning\n   // and the other to the last of the DLL.\n   struct Node *num1 = head;\n   struct Node *num2 = head;\n   while (num2->next != NULL)  //to get to the last node\n       num2 = num2->next;\n   \n   vector<pair<int,int>> ans;\n   // The loop ends when two pointers\n   // cross each other or they are equal\n   while (num1 != num2 && num2->next != num1)\n   {\n       if ((num1->value + num2->value) == val)\n       {\n           ans.push_back(make_pair(num1->value,num2->value));\n           \n           // move num1 in the forward direction\n           num1 = num1->next;\n\n           // move num2 in the backward direction\n           num2 = num2->prev;\n       }\n       else\n       {\n           if ((num1->value + num2->value) > val)\n               num2 = num2->prev;\n           else\n               num1 = num1->next;\n       }\n   }\n\n  return ans;\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. Given a 2-D matrix. You need to convert it into a linked list matrix such that each node is linked to its next right and down node and display it.",
        "answer": "  The idea is to create a new node for each element of the matrix and then create its next down and right nodes in a recursive manner. Implementation: Implementation: Node* construct(int A[][3], int m, int n, int i, int j)\n{\n   // check if i or j is out of bounds\n   if (i > n - 1 || j > m - 1)\n       return NULL;\n\n   // a new node for current i and j is created\n   // and its down and right pointers are\n   //recursively allocated\n   Node* t = new Node();\n   t->value = A[i][j];\n   t->right = construct(A, m, n, i, j + 1);\n   t->down  = construct(A, m, n, i + 1, j);\n   return t;\n}\n\n// function to display linked list data\nvoid printData(Node* head)\n{\n   // pointer to move down\n   Node* d;\n   // pointer to move down\n   \n   Node* r;\n\n   // loop till node->down is not NULL\n   for( d = head; d!=NULL; d = d->down)\n   {\n       for( r = d; r!=NULL; r = r->right)\n       {\n       // loop till node->right is not NULL\n           cout << r->value << \" \";\n           \n       }\n       cout << endl;\n      \n   }\n} Node* construct(int A[][3], int m, int n, int i, int j)\n{\n   // check if i or j is out of bounds\n   if (i > n - 1 || j > m - 1)\n       return NULL;\n\n   // a new node for current i and j is created\n   // and its down and right pointers are\n   //recursively allocated\n   Node* t = new Node();\n   t->value = A[i][j];\n   t->right = construct(A, m, n, i, j + 1);\n   t->down  = construct(A, m, n, i + 1, j);\n   return t;\n}\n\n// function to display linked list data\nvoid printData(Node* head)\n{\n   // pointer to move down\n   Node* d;\n   // pointer to move down\n   \n   Node* r;\n\n   // loop till node->down is not NULL\n   for( d = head; d!=NULL; d = d->down)\n   {\n       for( r = d; r!=NULL; r = r->right)\n       {\n       // loop till node->right is not NULL\n           cout << r->value << \" \";\n           \n       }\n       cout << endl;\n      \n   }\n} Time Complexity: O(m * n)\nSpace Complexity: O(1), ignoring the space required for the final answer. ",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. Extract all leaves from a Binary Tree into a Doubly Linked List (DLL).",
        "answer": "It's worth noting that the DLL must be created in place. Assume that the DLL and Binary Tree node structures are identical, with the exception that the meanings of the left and right pointers. Left denotes the previous pointer, whereas right denotes the next pointer in DLL.   All of the leaves must be traversed and connected by adjusting the left and right pointers. By adjusting the left or right pointers in parent nodes, we can also delete them from the Binary Tree. There are numerous options for resolving this issue. We add leaves to the beginning of the current linked list and update the list's head using the pointer to head pointer in the following code. We must process leaves in reverse order because we insert from the beginning. We traverse the right subtree first, then the left subtree, in reverse order. To update the left and right pointers in parent nodes, we employ return values. Implementation: Implementation: // The function extracts all the\n// leaves from a given Binary Tree.\n// The function returns new root of\n// the Binary Tree. The function also sets\n// *head_reference as the head of the DLL.\n// The left pointer of the tree is used as prev \n// and the right pointer is used as next in the DLL.\nNode* extractLeaf(Node **head_reference, Node *root)\n{\n  if (!root) \n      return NULL;\n\n  if (root->right == NULL && root->left == NULL)\n  {\n      // This node will be added to the doubly linked \n      // list of leaves. We will have to\n      // set the right pointer of this node\n      // as the previous head of DLL. We\n      // don't need to set the left pointer \n      // as the left is already NULL.\n      root->right = *head_reference;\n\n      // Change the left pointer of previous head\n      if (*head_reference) \n         (*head_reference)->left = root;\n\n      // Change the head of the linked list\n      *head_reference = root;\n\n      return NULL;\n  }\n\n  // Recursion for right and left subtrees\n  root->right = extractLeaf(&head_reference, root->right);\n  root->left = extractLeaf(&head_reference, root->lef);\n\n  return root;\n} // The function extracts all the\n// leaves from a given Binary Tree.\n// The function returns new root of\n// the Binary Tree. The function also sets\n// *head_reference as the head of the DLL.\n// The left pointer of the tree is used as prev \n// and the right pointer is used as next in the DLL.\nNode* extractLeaf(Node **head_reference, Node *root)\n{\n  if (!root) \n      return NULL;\n\n  if (root->right == NULL && root->left == NULL)\n  {\n      // This node will be added to the doubly linked \n      // list of leaves. We will have to\n      // set the right pointer of this node\n      // as the previous head of DLL. We\n      // don't need to set the left pointer \n      // as the left is already NULL.\n      root->right = *head_reference;\n\n      // Change the left pointer of previous head\n      if (*head_reference) \n         (*head_reference)->left = root;\n\n      // Change the head of the linked list\n      *head_reference = root;\n\n      return NULL;\n  }\n\n  // Recursion for right and left subtrees\n  root->right = extractLeaf(&head_reference, root->right);\n  root->left = extractLeaf(&head_reference, root->lef);\n\n  return root;\n} Time Complexity: O(n)\nSpace Complexity: O(1), ignoring the recursion stack space ",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Write a program to delete all odd positioned nodes from a circular linked list. (Consider 1-based indexing).",
        "answer": "  The approach is to begin traversing the circular linked list by keeping track of the current node's position using a count variable. Delete the current node if it is at an odd position. Implementation: Implementation: // l is the length of the linked list\nvoid DeleteAllOddNodes(struct Node** head_reference, int l)\n{\n   int cnt = 0;\n   struct Node *prev = *head_reference, *next = *head_reference;\n\n   // check if the list is empty\n   if (*head_reference == NULL) \n   {\n       cout<<\"List is empty\"<<endl;\n       return;\n   }\n\n   // check if there is a single node in the list\n   if (l == 1) \n   {\n       // Function to delete first node\n       *head_reference=NULL;\n       return;\n   }\n\n   while (l > 0) \n   {\n       // delete first position node as it is odd\n       if (cnt == 0) \n       {\n           struct Node *t1 = *head_reference, *t2 = *head_reference;\n           if (t1->next == t1) \n           {\n              *head_reference = NULL;\n           }\n           while(t1->next!=*head_reference)\n           {\n              t1 = t1->next;\n              t2 = t1->next;\n           }\n           t1->next = t2->next;\n           *head_reference = t1->next;\n           free(t2);\n       }\n\n       // if the position is odd, delete that node\n       if (cnt % 2 == 0 && cnt != 0) \n       {\n           struct Node* tmp = head_reference;\n           if (head_reference == prev) \n           {\n               head_reference = prev->next;\n           }\n           while (tmp->next != prev) \n           {\n               tmp = tmp->next;\n           }\n           tmp->next = prev->next;\n           free(prev);\n       }\n\n       prev = prev->next;\n       next = prev->next;\n       \n       cnt++;\n       l--;       \n   }\nturn;\n   re} // l is the length of the linked list\nvoid DeleteAllOddNodes(struct Node** head_reference, int l)\n{\n   int cnt = 0;\n   struct Node *prev = *head_reference, *next = *head_reference;\n\n   // check if the list is empty\n   if (*head_reference == NULL) \n   {\n       cout<<\"List is empty\"<<endl;\n       return;\n   }\n\n   // check if there is a single node in the list\n   if (l == 1) \n   {\n       // Function to delete first node\n       *head_reference=NULL;\n       return;\n   }\n\n   while (l > 0) \n   {\n       // delete first position node as it is odd\n       if (cnt == 0) \n       {\n           struct Node *t1 = *head_reference, *t2 = *head_reference;\n           if (t1->next == t1) \n           {\n              *head_reference = NULL;\n           }\n           while(t1->next!=*head_reference)\n           {\n              t1 = t1->next;\n              t2 = t1->next;\n           }\n           t1->next = t2->next;\n           *head_reference = t1->next;\n           free(t2);\n       }\n\n       // if the position is odd, delete that node\n       if (cnt % 2 == 0 && cnt != 0) \n       {\n           struct Node* tmp = head_reference;\n           if (head_reference == prev) \n           {\n               head_reference = prev->next;\n           }\n           while (tmp->next != prev) \n           {\n               tmp = tmp->next;\n           }\n           tmp->next = prev->next;\n           free(prev);\n       }\n\n       prev = prev->next;\n       next = prev->next;\n       \n       cnt++;\n       l--;       \n   }\nturn;\n   re} Time Complexity: O(n^2)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. Why is merge sort a better option than quicksort for linked lists?",
        "answer": "When it comes to linked lists, there are a few things to keep in mind. The issue is unique due to the memory allocation differences between arrays and linked lists. Unlike arrays, linked list nodes in memory may not be adjacent.\nWe can insert items in the middle of a linked list in O(1) extra space and O(1) time if we are given a reference/pointer to the previous node, unlike an array. As a result, the merge sort operation can be accomplished without the need for additional linked list space.\nWe can do random access in arrays since the elements are continuous in memory. In contrast to arrays, we can't access a linked list at random.\nQuick Sort necessitates a great deal of this type of access. Because we don't have a continuous block of memory, we have to travel from the head to the i'th node to get to the i'th index in a linked list. Merge sort accesses data in a sequential manner, with less requirement for random access. When it comes to linked lists, there are a few things to keep in mind. The issue is unique due to the memory allocation differences between arrays and linked lists. Unlike arrays, linked list nodes in memory may not be adjacent. We can insert items in the middle of a linked list in O(1) extra space and O(1) time if we are given a reference/pointer to the previous node, unlike an array. As a result, the merge sort operation can be accomplished without the need for additional linked list space. We can do random access in arrays since the elements are continuous in memory. In contrast to arrays, we can't access a linked list at random. Quick Sort necessitates a great deal of this type of access. Because we don't have a continuous block of memory, we have to travel from the head to the i'th node to get to the i'th index in a linked list. Merge sort accesses data in a sequential manner, with less requirement for random access.",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What algorithm will you implement to find similar elements from two Linked Lists given and return the result in the form of a Linked List? Assume there are no duplicates.",
        "answer": "Create an empty hash table and set the result list to NULL. While traversing List1, insert the element in the hash table for each element visited in List1. While traversing List2, look for the entries in the hash table for each element visited in List2. If the element is already existing, add it to the result list. If the element isn't present, it is to be ignored. The overall time and space complexity are linear. Node* getIntersection(Node* head1, Node* head2)\n{\n       unordered_map < int > m;\n       Node* n1 = head1;\n       Node* n2 = head2;\n       Node* head = NULL;\n\n       // loop stores all the elements of list1 in hset\n       while (n1) \n       {\n           m[n1->value] = 1;\n           n1 = n1->next;\n       }\n\n       // For every element of list2 present in hset\n       // loop inserts the element into the result\n       while (n2 != null) \n       {\n           if (m[n2->value] == 1)\n           {\n               Node* temp = new Node();\n               temp->value = n2->value;\n               temp->next = head;\n               head = temp;\n           }\n           n2 = n2->next;\n       }\n       return head;\n} Node* getIntersection(Node* head1, Node* head2)\n{\n       unordered_map < int > m;\n       Node* n1 = head1;\n       Node* n2 = head2;\n       Node* head = NULL;\n\n       // loop stores all the elements of list1 in hset\n       while (n1) \n       {\n           m[n1->value] = 1;\n           n1 = n1->next;\n       }\n\n       // For every element of list2 present in hset\n       // loop inserts the element into the result\n       while (n2 != null) \n       {\n           if (m[n2->value] == 1)\n           {\n               Node* temp = new Node();\n               temp->value = n2->value;\n               temp->next = head;\n               head = temp;\n           }\n           n2 = n2->next;\n       }\n       return head;\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. How will you remove a cycle from a linked list?",
        "answer": "One method of identifying the cycle is Floyd's cycle detect technique, popularly known as the tortoise and hare algorithm since it uses two pointers/references that move at opposite speeds. If there is a cycle, after a limited number of steps, the two pointers (say, slow and fast) will point to the same element. It's interesting to note that the element where they meet will be the same distance from the loop's start (continuing to traverse the list in the same, forward direction) as the loop's start is from the list's head. That is, if the linear component of the list contains k elements, the two pointers will meet inside a loop of length m at a location m-k from the loop's start or k elements from the loop's 'end' (of course, it's a loop, so there is no 'end' - it's just the \u2018start' again). That gives us a technique to find the loop's beginning. Once a cycle has been detected, keep fast pointing to the element where the loop for the previous step ended, but reset slow to point back to the beginning of the list. Now, one element at a time, move each pointer. Fast will keep looping because it started inside the loop. Slow and fast will meet again after k steps (equivalent to the distance between the start of the loop and the head of the list). This will serve as a pointer to the beginning of the loop. It's now simple to set slow (or fast) to point to the loop's starting element and traverse the loop until slow returns to the starting element. Slow is referring to the 'last' element list at this point, and its next pointer can be adjusted to null. Implementation: Implementation: Node* getLastNode(Node* head) \n{\n   Node* slow = head;\n   Node* fast = head;\n   // find the intersection point using Tortoise and Hare algorithm\n   while (fast->next != NULL) \n   { \n       slow = slow->next; \n       fast = fast->next->next; \n       if (slow == fast) \n           break; \n   }\n   //check if there is no loop\n   if (fast->next == NULL) \n   {\n       return NULL;\n   }\n   slow = head; \n   // run this loop till both the references are one short of the start of the loop\n   while (slow->next != fast->next) \n   { \n       slow = slow->next; \n       fast = fast->next; \n   }\n   // Now the fast pointer is pointing to the start of the loop \n   return fast;\n}\nNode* getLastNode = findStartOfLoop(head);\ngetLastNode->next = null; Node* getLastNode(Node* head) \n{\n   Node* slow = head;\n   Node* fast = head;\n   // find the intersection point using Tortoise and Hare algorithm\n   while (fast->next != NULL) \n   { \n       slow = slow->next; \n       fast = fast->next->next; \n       if (slow == fast) \n           break; \n   }\n   //check if there is no loop\n   if (fast->next == NULL) \n   {\n       return NULL;\n   }\n   slow = head; \n   // run this loop till both the references are one short of the start of the loop\n   while (slow->next != fast->next) \n   { \n       slow = slow->next; \n       fast = fast->next; \n   }\n   // Now the fast pointer is pointing to the start of the loop \n   return fast;\n}\nNode* getLastNode = findStartOfLoop(head);\ngetLastNode->next = null; Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. How will you convert a binary tree into a doubly-linked list?",
        "answer": "In a converted doubly linked list, the left and right pointers in nodes of a binary tree will be used as previous and next pointers, respectively. The nodes in the doubly linked list must be in the same order as the provided Binary Tree's Inorder. The head node of the doubly linked list must be the first node of Inorder traversal (leftmost node in the binary tree).   void btToDLL(Node *root, Node **head_reference, Node **previous)\n{\n   if (!root) \n      return;\n\n   // Recursive conversion of left subtree\n   btToDLL(root->left, head_reference, previous);\n\n   if (*head_reference == NULL)\n       *head_reference = root;\n   else\n   {\n       root->left = *previous;\n       *previous->right = root;\n   }\n   *previous = root;\n\n   // Recursive conversion of right subtree\n   btToDLL(root->right, head_reference, previous);\n} void btToDLL(Node *root, Node **head_reference, Node **previous)\n{\n   if (!root) \n      return;\n\n   // Recursive conversion of left subtree\n   btToDLL(root->left, head_reference, previous);\n\n   if (*head_reference == NULL)\n       *head_reference = root;\n   else\n   {\n       root->left = *previous;\n       *previous->right = root;\n   }\n   *previous = root;\n\n   // Recursive conversion of right subtree\n   btToDLL(root->right, head_reference, previous);\n} Time Complexity: O(n)\nAuxiliary Space: O(1) Time Complexity: O(n) Auxiliary Space: O(1)",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Given a linked list with each node representing a linked list and two pointers of its type given below. You need to flatten the lists into a single linked list. The flattened linked list also needs to be sorted. Discuss the approach.",
        "answer": "Pointer to the next node in the main list (the \"right\" pointer).\nPointer to a linked list, this node being the head (the 'down' pointer). Pointer to the next node in the main list (the \"right\" pointer). Pointer to the next node in the main list (the \"right\" pointer). Pointer to a linked list, this node being the head (the 'down' pointer). Pointer to a linked list, this node being the head (the 'down' pointer).   The approach is to use the merge() procedure of merge sort for linked lists. To merge lists one by one, we use merge(). We merge() the current list with the flattened list recursively.\nThe flattened list's nodes are linked via the down pointer.  Another approach is to use heaps. It is important to notice that there are N nodes connecting in a downward manner from each top node, but those downward nodes are in sorted order. As a result, the objective is to sort everything in ascending order (or decreasing order). Push all the heads of the linked lists in the priority queue's downward list.\nPop the node with the smallest priority from the priority queue.\nCheck the node's location so that the next node which is being pointed by the current node can be inserted into the priority queue.\nPop the smallest element once more and push the next node pointed by the current node until the heap is empty.\nContinue to add node data to a new linked list that is popped out to the new list.\nPrint the above-mentioned linked list. Push all the heads of the linked lists in the priority queue's downward list. Pop the node with the smallest priority from the priority queue. Check the node's location so that the next node which is being pointed by the current node can be inserted into the priority queue. Pop the smallest element once more and push the next node pointed by the current node until the heap is empty. Continue to add node data to a new linked list that is popped out to the new list. Print the above-mentioned linked list. struct cmp {\n   bool operator()(Node* x, Node* y)\n   {\n       return x->value > y->value;\n   }\n};\n\n//the following function returns the flattened linked list\u2019s root\nNode* flattenList(Node* root)\n{\n   Node* p = root;\n   Node* head = NULL;\n\n   // this min heap returns the current smallest element in the heap\n   priority_queue < Node*, vector <Node*>, cmp > pqueue;\n\n   // the head nodes of every\n   // downward linked list is pushed into the heap\n   while (p) \n   {\n       pqueue.push(p);\n       p = p->right;\n   }\n\n   while (!pqueue.empty()) \n   { \n       // pop out the topmost node\n       Node* t = pqueue.top();\n       pqueue.pop();\n\n       if (t->down) \n       {\n           pqueue.push(t->down);\n       }\n\n       // Create the required linked list\n       if (head != NULL) \n           p->down = t;\n       else \n           head = t;\n           \n       p = t;\n       p->right = NULL;\n       \n   }\n\n   // Pointer to head node\n   return head;\n}\nvoid printList(Node* head)\n{\n   while (head != NULL) \n   {\n       cout << head->value << \u201d \u201c << endl;\n       head = head->down;\n   }\n} struct cmp {\n   bool operator()(Node* x, Node* y)\n   {\n       return x->value > y->value;\n   }\n};\n\n//the following function returns the flattened linked list\u2019s root\nNode* flattenList(Node* root)\n{\n   Node* p = root;\n   Node* head = NULL;\n\n   // this min heap returns the current smallest element in the heap\n   priority_queue < Node*, vector <Node*>, cmp > pqueue;\n\n   // the head nodes of every\n   // downward linked list is pushed into the heap\n   while (p) \n   {\n       pqueue.push(p);\n       p = p->right;\n   }\n\n   while (!pqueue.empty()) \n   { \n       // pop out the topmost node\n       Node* t = pqueue.top();\n       pqueue.pop();\n\n       if (t->down) \n       {\n           pqueue.push(t->down);\n       }\n\n       // Create the required linked list\n       if (head != NULL) \n           p->down = t;\n       else \n           head = t;\n           \n       p = t;\n       p->right = NULL;\n       \n   }\n\n   // Pointer to head node\n   return head;\n}\nvoid printList(Node* head)\n{\n   while (head != NULL) \n   {\n       cout << head->value << \u201d \u201c << endl;\n       head = head->down;\n   }\n} Time Complexity : O(nlogn)\nSpace Complexity : O(n)  Conclusion: We hope that this article has helped you learn the fundamentals and advanced questions of linked lists. These questions cover the most important concepts related to linked lists which will help you in both interview and understanding this data structure in depth. Useful Resources Linked List MCQ\nApplication of Linked List\nTypes of Linked List Linked List MCQ Linked List MCQ Application of Linked List Application of Linked List Types of Linked List Types of Linked List ",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. In a standard Doubly Linked List, two address fields are required to contain the addresses of previous and next nodes. Can you create a doubly linked list using only one space for the address field with every node?",
        "answer": "Yes, there is a memory-saving version of the Doubly Linked List that uses only one space for the address field in each node. Because the list uses the bitwise XOR operation to save space for one address, it is known as the XOR Linked List or Memory Efficient. Instead of storing actual memory addresses, each node in the XOR linked list stores the XOR of previous and next node addresses. In the XOR representation, let's call the address variable npx (XOR of next and previous). We can traverse the XOR Linked List in both forward and reverse directions while traversing it. We must remember the address of the previously visited node when traversing the list in order to determine the address of the next node. Node W: \nnpx = 0 XOR add(X)  Node X: \nnpx = add(W) XOR add(Y)  Node Y: \nnpx = add(X) XOR add(Z)  Node Z: \nnpx = add(Y) XOR 0  Calculation: Calculation: npx(Y) XOR add(X) \n=> (add(X) XOR add(Z)) XOR add(X)              // npx(Y) = add(X) XOR add(Z)\n=> add(X) XOR add(Z) XOR add(X)                // w^x = w^x and (w^x)^y = w^(x^y)\n=> add(Z) XOR 0                                             // x^x = 0\n=> add(Z)                                                         // x^0 = x    ",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Given a singly linked list with an additional \"arbitrary\" pointer at each node that currently points to NULL. What algorithm will you implement to make the \"arbitrary\" pointer point to the next node with a greater value?",
        "answer": "  A simple solution is to go through all nodes one by one, finding the node with the next bigger value than the current node and changing the next pointer for each node. This solution has an O time complexity (n^2). An Efficient Solution takes O(nLogn) time to complete. The approach is to use Merge Sort for linked lists. Traverse input list and for each node, copy the next pointer to arbit pointer.\nSort the linked list formed by arbit pointers using Merge Sort. Traverse input list and for each node, copy the next pointer to arbit pointer. Sort the linked list formed by arbit pointers using Merge Sort. Here, all of the merge sort methods are altered to work with arbit pointers rather than the next pointers.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Given a linked list, find the length of the longest palindrome list that appears in that linked list using O(1) extra space.",
        "answer": "The concept is built on reversing a linked list iteratively. We loop through the given linked list, reversing each prefix of the linked list one by one from the left. We discover the longest common list beginning with the reversed prefix and the list after the reversed prefix, after reversing a prefix. Time complexity is O(n^2). Implementation: Implementation: int calcCommon(Node *x, Node *y)\n{\n   int cnt = 0;\n\n   // count common in the list starting\n   // from node x and y\n  while (1)\n  {\n       // increase the count by one for same values\n       if (x->value == y->value)\n           cnt++;\n       else\n           break;\n       x = x->next;\n       y = y->next;\n  }\n  return cnt;\n}\n\n// Returns length of the longest palindrome sublist\nint maxPalindrome(Node *head)\n{\n   Node *previous = NULL, *current = head;\n   int answer = 0;\n   // loop running till the end of the linked list\n   while (1)\n   {\n       if(current==NULL)\n          break;\n       // reversed sublist from head to current\n       Node *next = current->next;\n       current->next = previous;\n\n       // check for odd length palindrome\n       answer = max(result, 2*calcCommon(previous, next)+1);\n\n       // check for even length palindrome\n       answer = max(result, 2*calcCommon(current, next));\n\n       // update previous and current for next iteration\n       previous = current;\n       current = next;\n   }\n   return answer;\n} int calcCommon(Node *x, Node *y)\n{\n   int cnt = 0;\n\n   // count common in the list starting\n   // from node x and y\n  while (1)\n  {\n       // increase the count by one for same values\n       if (x->value == y->value)\n           cnt++;\n       else\n           break;\n       x = x->next;\n       y = y->next;\n  }\n  return cnt;\n}\n\n// Returns length of the longest palindrome sublist\nint maxPalindrome(Node *head)\n{\n   Node *previous = NULL, *current = head;\n   int answer = 0;\n   // loop running till the end of the linked list\n   while (1)\n   {\n       if(current==NULL)\n          break;\n       // reversed sublist from head to current\n       Node *next = current->next;\n       current->next = previous;\n\n       // check for odd length palindrome\n       answer = max(result, 2*calcCommon(previous, next)+1);\n\n       // check for even length palindrome\n       answer = max(result, 2*calcCommon(current, next));\n\n       // update previous and current for next iteration\n       previous = current;\n       current = next;\n   }\n   return answer;\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Given a value x and a sorted doubly linked list of different nodes (no two nodes have the same data). Count the number of triplets in the list that add up to x. The expected time complexity is O(n^2) and the expected space complexity is O(1).",
        "answer": "Following the approach os using two pointers: From left to right, traverse the doubly linked list. Initialize two pointers for each current node during the traversal: first = pointer to the node next to the current node, and last = pointer to the list's last node. Count the number of pairs in the list that add up to the value (x \u2013 the current node's data) from the first to the last pointer (algorithm described in Q8). This number should be added to the total count of triplets. Pointer to the last node can be retrieved only once at the beginning. Implementation: Implementation: int pairCount(struct Node* num1, struct Node* num2, int val)\n{\n   int cnt = 0;\n   // The loop terminates when either of two the pointers\n   // become NULL, or they cross each other or they become equal\n   while (num1 != NULL && num2 != NULL &&\n          num1 != num2 && num2->next != num1) \n   {\n\n       // pair found\n       if ((num1->value + num2->value) == val) \n       {\n\n           cnt++;\n\n           // second is moved in backward direction\n           num2 = num2->prev;\n           // first is moved in forward direction\n           num1 = num1->next;\n       }\n       // else first is moved in forward direction\n       else if ((num1->value + num2->value) < val)\n           num1 = num1->next;\n   \n       // if sum is greater than 'value'\n       // second is moved in backward direction\n       else\n           num2 = num2->prev;\n     }\n\n   // required number of pairs\n   return cnt;\n}\n\n// function to count triplets in a sorted DLL\n// whose sum equals a given value 'x'\nint tripletCount(struct Node* head, int x)\n{\n   // check if the list is empty\n   if (!head)\n       return 0;\n   int cnt = 0;\n   struct Node* current = head;\n   struct Node* last = head;\n   struct Node* first;\n   // get pointer to the last node of the doubly linked list\n   \n   while (last->next)\n       last = last->next;\n\n   // traverse the doubly linked list\n   \n   while (current) \n   { \n       // for every current node\n       first = current->next;\n\n       // count the number of pairs with sum(x - current->data) in the range\n       // first to last and add it to the 'cnt' of triplets\n       cnt += pairCount(first, last, x - current->value);\n       current = current->next;\n   }\n\n   // required number of triplets\n   return cnt;\n} int pairCount(struct Node* num1, struct Node* num2, int val)\n{\n   int cnt = 0;\n   // The loop terminates when either of two the pointers\n   // become NULL, or they cross each other or they become equal\n   while (num1 != NULL && num2 != NULL &&\n          num1 != num2 && num2->next != num1) \n   {\n\n       // pair found\n       if ((num1->value + num2->value) == val) \n       {\n\n           cnt++;\n\n           // second is moved in backward direction\n           num2 = num2->prev;\n           // first is moved in forward direction\n           num1 = num1->next;\n       }\n       // else first is moved in forward direction\n       else if ((num1->value + num2->value) < val)\n           num1 = num1->next;\n   \n       // if sum is greater than 'value'\n       // second is moved in backward direction\n       else\n           num2 = num2->prev;\n     }\n\n   // required number of pairs\n   return cnt;\n}\n\n// function to count triplets in a sorted DLL\n// whose sum equals a given value 'x'\nint tripletCount(struct Node* head, int x)\n{\n   // check if the list is empty\n   if (!head)\n       return 0;\n   int cnt = 0;\n   struct Node* current = head;\n   struct Node* last = head;\n   struct Node* first;\n   // get pointer to the last node of the doubly linked list\n   \n   while (last->next)\n       last = last->next;\n\n   // traverse the doubly linked list\n   \n   while (current) \n   { \n       // for every current node\n       first = current->next;\n\n       // count the number of pairs with sum(x - current->data) in the range\n       // first to last and add it to the 'cnt' of triplets\n       cnt += pairCount(first, last, x - current->value);\n       current = current->next;\n   }\n\n   // required number of triplets\n   return cnt;\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Let's say there are two lists of varying lengths that merge at a certain point; how do we know where the merging point is?",
        "answer": "  You begin with List 1 and assume that the NULL at the end is a pointer to the start of List 2, giving the illusion of a cyclic list. After that, the algorithm will inform you how far down List 1 the merging is. Make an iterator pointer that runs forward until it reaches the end of the list, then jumps to the start of the opposite list, and so on.\nMake two of them, each pointing to two different heads.\nEach time you advance the pointers by one, they will eventually meet in the intersection point (IP). After one or two passes, this will occur. Make an iterator pointer that runs forward until it reaches the end of the list, then jumps to the start of the opposite list, and so on. Make two of them, each pointing to two different heads. Each time you advance the pointers by one, they will eventually meet in the intersection point (IP). After one or two passes, this will occur. Count the number of nodes traversed from head1-> tail1-> head2 -> intersection point and head2-> tail2-> head1 -> intersection point to have a better understanding. Both will be equal (Draw diff types of linked lists to verify this). The reason for this is that both pointers must traverse identical distances (head1->IP + head2->IP) before returning to IP. As a result, by the time it reaches IP, both pointers will be equal, and we will have arrived at the merging point. Node* getIP(Node* head1, Node* head2)\n{\n   // two pointers ptr1 and ptr2\n   // at the heads of the two lists\n   Node* p1 = head1;\n   Node* p2 = head2;\n\n   if (p1 == NULL || p2 == NULL)\n      return NULL;\n    \n   // the two lists are to be traversed until we reach the IP \n   while (p1 != p2) \n   { \n       p1 = p1->next;\n       p2 = p2->next;\n       \n       // When p1 reaches the end of the list, it is\n       // redirected to head2.\n       if (p1 == NULL)  \n           p1 = head2;\n       \n       // When p2 reaches the end of the list, it is\n       // redirected to head1.\n       if (p2 == NULL)\n           p2 = head1;\n       \n       // If at any node p1 meets p2, we have got our IP.\n       if (p1 == p2) \n           return p2;\n       \n   }\n\n   return p2;\n} Node* getIP(Node* head1, Node* head2)\n{\n   // two pointers ptr1 and ptr2\n   // at the heads of the two lists\n   Node* p1 = head1;\n   Node* p2 = head2;\n\n   if (p1 == NULL || p2 == NULL)\n      return NULL;\n    \n   // the two lists are to be traversed until we reach the IP \n   while (p1 != p2) \n   { \n       p1 = p1->next;\n       p2 = p2->next;\n       \n       // When p1 reaches the end of the list, it is\n       // redirected to head2.\n       if (p1 == NULL)  \n           p1 = head2;\n       \n       // When p2 reaches the end of the list, it is\n       // redirected to head1.\n       if (p2 == NULL)\n           p2 = head1;\n       \n       // If at any node p1 meets p2, we have got our IP.\n       if (p1 == p2) \n           return p2;\n       \n   }\n\n   return p2;\n} OR Make a circular linked list by traversing the first linked list (counting the elements). (Keep track of the last node so we can break the circle later.)\nReframe the issue as locating the loop in the second linked list.\nWe already know the length of the loop which is equal to the length of the first linked list. We have to traverse those many numbers of nodes in the second list first, and then another pointer should be started from the beginning of the second list. We have to continue traversing until they meet, and that is the required intersection point.\nThe circle should be removed from the linked list. Make a circular linked list by traversing the first linked list (counting the elements). (Keep track of the last node so we can break the circle later.) Reframe the issue as locating the loop in the second linked list. We already know the length of the loop which is equal to the length of the first linked list. We have to traverse those many numbers of nodes in the second list first, and then another pointer should be started from the beginning of the second list. We have to continue traversing until they meet, and that is the required intersection point. The circle should be removed from the linked list. Both the approaches have O(n+m) time and O(1) space complexity.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. Given two polynomial expressions represented by linked lists. You need to write a function that adds these lists, that is, adds the coefficients that have the same variable powers.",
        "answer": "  Implementation: Implementation: struct Node \n{\n   int coefficient;\n   int power;\n   struct Node* next;\n};\n\nvoid createNode(int x, int y, struct Node** t)\n{\n   struct Node *v, *z;\n   z = *t;\n   if (z == NULL) \n   {\n       v = new Node;\n       v->coefficient = x;\n       v->power = y;\n       *t = v;\n       v->next = new Node;\n       v = v->next;\n       v->next = NULL;\n   }\n   else \n   {\n       v->coefficient = x;\n       v->power = y;\n       v->next = new Node;\n       v = v->next;\n       v->next = NULL;\n   }\n}\n\n// Function to add two polynomial expressions\nvoid polyAdd(struct Node* poly1, struct Node* poly2,\n            struct Node* poly)\n{\n   while (poly1->next && poly2->next) \n   {\n       // If the power of the 1st polynomial is greater than that of 2nd,\n       // then store 1st as it is and move its pointer\n       if (poly2->power < poly1->power) \n       {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient;\n           poly1 = poly1->next;\n       }\n\n       // If the power of the 2nd polynomial is greater than that of 1st,\n       // then store 2nd as it is and move its pointer\n       else if (poly1->power < poly2->power) \n       {\n           poly->power = poly2->power;\n           poly->coefficient = poly2->coefficient;\n           poly2 = poly2->next;\n       }\n\n       // If power of both polynomial expressions is same then\n       // add their coefficients\n       else \n       {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient + poly2->coefficient;\n           poly1 = poly1->next;\n           poly2 = poly2->next;\n       }\n\n       poly->next = new Node;\n       poly = poly->next;\n       poly->next = NULL;\n   }\n   while (poly1->next || poly2->next) \n   {\n       if (poly1->next) {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient;\n           poly1 = poly1->next;\n       }\n       if (poly2->next) \n       {\n           poly->power = poly2->power;\n           poly->coefficient = poly2->coefficient;\n           poly2 = poly2->next;\n       }\n       poly->next = new Node;\n       poly = poly->next;\n       poly->next = NULL;\n   }\n} struct Node \n{\n   int coefficient;\n   int power;\n   struct Node* next;\n};\n\nvoid createNode(int x, int y, struct Node** t)\n{\n   struct Node *v, *z;\n   z = *t;\n   if (z == NULL) \n   {\n       v = new Node;\n       v->coefficient = x;\n       v->power = y;\n       *t = v;\n       v->next = new Node;\n       v = v->next;\n       v->next = NULL;\n   }\n   else \n   {\n       v->coefficient = x;\n       v->power = y;\n       v->next = new Node;\n       v = v->next;\n       v->next = NULL;\n   }\n}\n\n// Function to add two polynomial expressions\nvoid polyAdd(struct Node* poly1, struct Node* poly2,\n            struct Node* poly)\n{\n   while (poly1->next && poly2->next) \n   {\n       // If the power of the 1st polynomial is greater than that of 2nd,\n       // then store 1st as it is and move its pointer\n       if (poly2->power < poly1->power) \n       {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient;\n           poly1 = poly1->next;\n       }\n\n       // If the power of the 2nd polynomial is greater than that of 1st,\n       // then store 2nd as it is and move its pointer\n       else if (poly1->power < poly2->power) \n       {\n           poly->power = poly2->power;\n           poly->coefficient = poly2->coefficient;\n           poly2 = poly2->next;\n       }\n\n       // If power of both polynomial expressions is same then\n       // add their coefficients\n       else \n       {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient + poly2->coefficient;\n           poly1 = poly1->next;\n           poly2 = poly2->next;\n       }\n\n       poly->next = new Node;\n       poly = poly->next;\n       poly->next = NULL;\n   }\n   while (poly1->next || poly2->next) \n   {\n       if (poly1->next) {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient;\n           poly1 = poly1->next;\n       }\n       if (poly2->next) \n       {\n           poly->power = poly2->power;\n           poly->coefficient = poly2->coefficient;\n           poly2 = poly2->next;\n       }\n       poly->next = new Node;\n       poly = poly->next;\n       poly->next = NULL;\n   }\n} Time Complexity: O(m + n), where m and n are the respective numbers of nodes in the first and second lists.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. How will you find the length of a linked list which contains a cycle?",
        "answer": "The algorithm to determine the length of the list: At a time, pointer A advances one node while pointer B advances two nodes.\nStarting from the head, they move until B reaches null (no loop) or A and B refer to the same node.\nNow, if A simply advances, A will run into B again. The length of the loop, let's call it x, may be calculated from this.\nBegin again from the head, but this time have a pointer C which has moved x nodes, followed by a pointer D behind it. Both will move one node further at a time.\nWhen they meet, the length of the linked list with a loop is equal to the number of nodes traversed by D plus x. At a time, pointer A advances one node while pointer B advances two nodes. Starting from the head, they move until B reaches null (no loop) or A and B refer to the same node. Now, if A simply advances, A will run into B again. The length of the loop, let's call it x, may be calculated from this. Begin again from the head, but this time have a pointer C which has moved x nodes, followed by a pointer D behind it. Both will move one node further at a time. When they meet, the length of the linked list with a loop is equal to the number of nodes traversed by D plus x. int calcLen( Node* head )\n{\n  struct Node *A = head, *B = head;\n\n   while ( A && B && B->next )\n   {\n       A = A->next;\n       B = B->next->next;\n\n       /* If slow_p and fast_p meet at\n       some point then there is a loop */\n       if (A == B)\n       {\n          int x = 1;\n          struct Node *t = A;\n          while (t->next != A)\n          {\n              x++;\n              t = t->next;\n          }\n       }\n   }\n  \n   struct Node *C = head, *D = head;\n   int y = 0;\n   for ( int i = 0; i < x; i++ )\n   {\n      C = C->next;\n   }\n   while( C != D )\n   {\n      y++;\n      C = C->next;\n      D = D->next;\n   }\n \n   return x+y;\n} int calcLen( Node* head )\n{\n  struct Node *A = head, *B = head;\n\n   while ( A && B && B->next )\n   {\n       A = A->next;\n       B = B->next->next;\n\n       /* If slow_p and fast_p meet at\n       some point then there is a loop */\n       if (A == B)\n       {\n          int x = 1;\n          struct Node *t = A;\n          while (t->next != A)\n          {\n              x++;\n              t = t->next;\n          }\n       }\n   }\n  \n   struct Node *C = head, *D = head;\n   int y = 0;\n   for ( int i = 0; i < x; i++ )\n   {\n      C = C->next;\n   }\n   while( C != D )\n   {\n      y++;\n      C = C->next;\n      D = D->next;\n   }\n \n   return x+y;\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com"
    }
]