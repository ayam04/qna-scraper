[
    {
        "question": "1. What is the difference between C and C++?",
        "answer": "The main difference between C and C++ are provided in the table below: C C++\nC is a procedure-oriented programming language. C++ is an object-oriented programming language.\nC does not support data hiding. Data is hidden by encapsulation to ensure that data structures and operators are used as intended.\nC is a subset of C++ C++ is a superset of C.\nFunction and operator overloading are not supported in C Function and operator overloading is supported in C++\nNamespace features are not present in C Namespace is used by C++, which avoids name collisions.\nFunctions can not be defined inside structures. Functions can be defined inside structures.\ncalloc() and malloc() functions are used for memory allocation and free() function is used for memory deallocation. new operator is used for memory allocation and deletes operator is used for memory deallocation. C C++\nC is a procedure-oriented programming language. C++ is an object-oriented programming language.\nC does not support data hiding. Data is hidden by encapsulation to ensure that data structures and operators are used as intended.\nC is a subset of C++ C++ is a superset of C.\nFunction and operator overloading are not supported in C Function and operator overloading is supported in C++\nNamespace features are not present in C Namespace is used by C++, which avoids name collisions.\nFunctions can not be defined inside structures. Functions can be defined inside structures.\ncalloc() and malloc() functions are used for memory allocation and free() function is used for memory deallocation. new operator is used for memory allocation and deletes operator is used for memory deallocation. C C++ C C++ C C++ C is a procedure-oriented programming language. C++ is an object-oriented programming language.\nC does not support data hiding. Data is hidden by encapsulation to ensure that data structures and operators are used as intended.\nC is a subset of C++ C++ is a superset of C.\nFunction and operator overloading are not supported in C Function and operator overloading is supported in C++\nNamespace features are not present in C Namespace is used by C++, which avoids name collisions.\nFunctions can not be defined inside structures. Functions can be defined inside structures.\ncalloc() and malloc() functions are used for memory allocation and free() function is used for memory deallocation. new operator is used for memory allocation and deletes operator is used for memory deallocation. C is a procedure-oriented programming language. C++ is an object-oriented programming language. C is a procedure-oriented programming language. C++ is an object-oriented programming language. C does not support data hiding. Data is hidden by encapsulation to ensure that data structures and operators are used as intended. C does not support data hiding. Data is hidden by encapsulation to ensure that data structures and operators are used as intended. C is a subset of C++ C++ is a superset of C. C is a subset of C++ C++ is a superset of C. Function and operator overloading are not supported in C Function and operator overloading is supported in C++ Function and operator overloading are not supported in C Function and operator overloading is supported in C++ Namespace features are not present in C Namespace is used by C++, which avoids name collisions. Namespace features are not present in C Namespace is used by C++, which avoids name collisions. Functions can not be defined inside structures. Functions can be defined inside structures. Functions can not be defined inside structures. Functions can be defined inside structures. calloc() and malloc() functions are used for memory allocation and free() function is used for memory deallocation. new operator is used for memory allocation and deletes operator is used for memory deallocation. calloc() and malloc() functions are used for memory allocation and free() function is used for memory deallocation. calloc() and malloc() new operator is used for memory allocation and deletes operator is used for memory deallocation.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Explain inheritance",
        "answer": "Inheritance is the process of creating new classes, called derived classes, from existing classes. These existing classes are called base classes. The derived classes inherit all the capabilities of the base class but can add new features and refinements of their own. Example- Example- Inheritance in C++  Inheritance in C++ Class Bus, Class Car, and Class Truck inherit the properties of Class Vehicle. The most important thing about inheritance is that it permits code reusability.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What are the static members and static member functions?",
        "answer": "When a variable in a class is declared static, space for it is allocated for the lifetime of the program. No matter how many objects of that class have been created, there is only one copy of the static member. So same static member can be accessed by all the objects of that class. A static member function can be called even if no objects of the class exist and the static function are accessed using only the class name and the scope resolution operator ::",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What are destructors in C++?",
        "answer": "A constructor is automatically called when an object is first created. Similarly when an object is destroyed a function called destructor automatically gets called. A destructor has the same name as the constructor (which is the same as the class name) but is preceded by a tilde. Example: Example: class A{\n private:\n  int val;\n public:\n  A(int x){           \n   val=x;\n  }\n  A(){                \n  }\n  ~A(){                  //destructor\n  }\n}\nint main(){\n A a(3);     \n return 0;\n} class A{\n private:\n  int val;\n public:\n  A(int x){           \n   val=x;\n  }\n  A(){                \n  }\n  ~A(){                  //destructor\n  }\n}\nint main(){\n A a(3);     \n return 0;\n} class A{ class A private int public int //destructor int main() int main () A a(3) a (3) 3 return 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. What is an abstract class and when do you use it?",
        "answer": "A class is called an abstract class whose objects can never be created. Such a class exists as a parent for the derived classes. We can make a class abstract by placing a pure virtual function in the class.",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What do you mean by call by value and call by reference?",
        "answer": "In call by value method, we pass a copy of the parameter is passed to the functions. For these copied values a new memory is assigned and changes made to these values do not reflect the variable in the main function. In call by reference method, we pass the address of the variable and the address is used to access the actual argument used in the function call. So changes made in the parameter alter the passing argument.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. Is deconstructor overloading possible? If yes then explain and if no then why?",
        "answer": "No destructor overloading is not possible. Destructors take no arguments, so there\u2019s only one way to destroy an object. That\u2019s the reason destructor overloading is not possible.",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What do you mean by abstraction in C++?",
        "answer": "Abstraction is the process of showing the essential details to the user and hiding the details which we don\u2019t want to show to the user or hiding the details which are irrelevant to a particular user.",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What is a reference in C++?",
        "answer": "A reference is like a pointer. It is another name of an already existing variable. Once a reference name is initialized with a variable, that variable can be accessed by the variable name or reference name both. For example- int x=10;\nint &ref=x;           //reference variable int x=10;\nint &ref=x;           //reference variable int 10 int //reference variable If we change the value of ref it will be reflected in x. Once a reference variable is initialized it cannot refer to any other variable. We can declare an array of pointers but an array of references is not possible.",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Define inline function",
        "answer": "If a function is inline, the compiler places a copy of the code of that function at each point where the function is called at compile time. One of the important advantages of using an inline function is that it eliminates the function calling overhead of a traditional function.",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. What do you know about friend class and friend function?",
        "answer": "A friend class can access private, protected, and public members of other classes in which it is declared as friends. Like friend class, friend function can also access private, protected, and public members. But, Friend functions are not member functions. For example - class A{\n private:\n  int data_a;\n public:\n  A(int x){\n   data_a=x;\n  }\n  friend int fun(A, B);\n}\nclass B{\n private:\n  int data_b;\n public:\n  A(int x){\n   data_b=x;\n  }\n  friend int fun(A, B);\n}\nint fun(A a, B b){\n return a.data_a+b.data_b;\n}\nint main(){\n A a(10);\n B b(20);\n cout<<fun(a,b)<<endl;\n return 0;\n} class A{\n private:\n  int data_a;\n public:\n  A(int x){\n   data_a=x;\n  }\n  friend int fun(A, B);\n}\nclass B{\n private:\n  int data_b;\n public:\n  A(int x){\n   data_b=x;\n  }\n  friend int fun(A, B);\n}\nint fun(A a, B b){\n return a.data_a+b.data_b;\n}\nint main(){\n A a(10);\n B b(20);\n cout<<fun(a,b)<<endl;\n return 0;\n} class A{ class A private int public int friend int fun(A, B) friend int fun (A, B) class B{ class B private int public int friend int fun(A, B) friend int fun (A, B) int fun(A a, B b) int fun (A a, B b) return int main() int main () A a(10) a (10) 10 B b(20) b (20) 20 cout endl return 0 Here we can access the private data of class A and class B.",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. What are the different data types present in C++?",
        "answer": "The 4 data types in C++ are given below: Primitive Datatype(basic datatype). Example- char, short, int, float, long, double, bool, etc.\nDerived datatype. Example- array, pointer, etc.\nEnumeration. Example- enum\nUser-defined data types. Example- structure, class, etc. Primitive Datatype(basic datatype). Example- char, short, int, float, long, double, bool, etc. Derived datatype. Example- array, pointer, etc. Enumeration. Example- enum User-defined data types. Example- structure, class, etc.",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What are class and object in C++?",
        "answer": "A class is a user-defined data type that has data members and member functions. Data members are the data variables and member functions are the functions that are used to perform operations on these variables. An object is an instance of a class. Since a class is a user-defined data type so an object can also be called a variable of that data type. A class is defined as- class A{\nprivate:\n int data;\npublic:\n void fun(){\n\n }\n}; class A{\nprivate:\n int data;\npublic:\n void fun(){\n\n }\n}; class A{ class A private int public void fun() void fun () Class and Object in C++  Class and Object in C++ For example, the following is a class car that can have properties like name, color, etc. and they can have methods like speed().",
        "reference": "interviewbit.com"
    },
    {
        "question": "14. What is the difference between struct and class?",
        "answer": "In C++ a structure is the same as a class except for a few differences like security. The difference between struct and class are given below: Structure Class\nMembers of the structure are public by default. Members of the class are private by default.\nWhen deriving a struct from a class/struct, default access specifiers for base class/struct are public. When deriving a class, default access specifiers are private. Structure Class\nMembers of the structure are public by default. Members of the class are private by default.\nWhen deriving a struct from a class/struct, default access specifiers for base class/struct are public. When deriving a class, default access specifiers are private. Structure Class Structure Class Structure Class Members of the structure are public by default. Members of the class are private by default.\nWhen deriving a struct from a class/struct, default access specifiers for base class/struct are public. When deriving a class, default access specifiers are private. Members of the structure are public by default. Members of the class are private by default. Members of the structure are public by default. Members of the class are private by default. When deriving a struct from a class/struct, default access specifiers for base class/struct are public. When deriving a class, default access specifiers are private. When deriving a struct from a class/struct, default access specifiers for base class/struct are public. When deriving a class, default access specifiers are private.",
        "reference": "interviewbit.com"
    },
    {
        "question": "15. What is operator overloading?",
        "answer": "Operator Overloading is a very essential element to perform the operations on user-defined data types. By operator overloading we can modify the default meaning to the operators like +, -, *, /, <=, etc. For example - For example - The following code is for adding two complex number using operator overloading- class complex{\nprivate:\n float r, i;\npublic:\n complex(float r, float i){\n  this->r=r;\n  this->i=i;\n }\n complex(){}\n void displaydata(){\n  cout<<\u201dreal part = \u201c<<r<<endl;\n  cout<<\u201dimaginary part = \u201c<<i<<endl;\n }\n complex operator+(complex c){\n  return complex(r+c.r, i+c.i);\n }\n};\nint main(){\ncomplex a(2,3);\ncomplex b(3,4);\ncomplex c=a+b;\nc.displaydata();\nreturn 0;\n} class complex{\nprivate:\n float r, i;\npublic:\n complex(float r, float i){\n  this->r=r;\n  this->i=i;\n }\n complex(){}\n void displaydata(){\n  cout<<\u201dreal part = \u201c<<r<<endl;\n  cout<<\u201dimaginary part = \u201c<<i<<endl;\n }\n complex operator+(complex c){\n  return complex(r+c.r, i+c.i);\n }\n};\nint main(){\ncomplex a(2,3);\ncomplex b(3,4);\ncomplex c=a+b;\nc.displaydata();\nreturn 0;\n} class complex{ class complex private float public complex float float this this complex void displaydata() void displaydata () cout endl cout imaginary endl complex operator complex return complex int main() int main () complex a(2,3) complex a (2,3) 2 3 complex b(3,4) complex b (3,4) 3 4 complex return 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "16. What is polymorphism in C++?",
        "answer": "Polymorphism in simple means having many forms. Its behavior is different in different situations. And this occurs when we have multiple classes that are related to each other by inheritance. For example, think of a base class called a car that has a method called car brand(). Derived classes of cars could be Mercedes, BMW, Audi - And they also have their own implementation of a cars The two types of polymorphism in c++ are: Compile Time Polymorphism\nRuntime Polymorphism Compile Time Polymorphism Runtime Polymorphism Polymorphism in C++  Polymorphism in C++ Here is a Free C++ course with certification that can help clear your basics of C++ programming. Free C++ course Free C++ course",
        "reference": "interviewbit.com"
    },
    {
        "question": "17. Explain constructor in C++",
        "answer": "The constructor is a member function that is executed automatically whenever an object is created. Constructors have the same name as the class of which they are members so that compiler knows that the member function is a constructor. And no return type is used for constructors. Example: Example: class A{\n private:\n  int val;\n public:\n  A(int x){             //one argument constructor\n   val=x;\n  }\n  A(){                    //zero argument constructor\n  }\n}\nint main(){\n A a(3);     \n\n return 0;\n} class A{\n private:\n  int val;\n public:\n  A(int x){             //one argument constructor\n   val=x;\n  }\n  A(){                    //zero argument constructor\n  }\n}\nint main(){\n A a(3);     \n\n return 0;\n} class A{ class A private int public int //one argument constructor //zero argument constructor int main() int main () A a(3) a (3) 3 return 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "18. Tell me about virtual function",
        "answer": "Virtual function is a member function in the base class that you redefine in a derived class. A virtual function is declared using the virtual keyword. When the function is made virtual, C++ determines which function is to be invoked at the runtime based on the type of the object pointed by the base class pointer. Virtual function",
        "reference": "interviewbit.com"
    },
    {
        "question": "19. Compare compile time polymorphism and Runtime polymorphism",
        "answer": "The main difference between compile-time and runtime polymorphism is provided below: Compile-time polymorphism Run time polymorphism\nIn this method, we would come to know at compile time which method will be called. And the call is resolved by the compiler. In this method, we come to know at run time which method will be called. The call is not resolved by the compiler.\nIt provides fast execution because it is known at the compile time. It provides slow execution compared to compile-time polymorphism because it is known at the run time.\nIt is achieved by function overloading and operator overloading. It can be achieved by virtual functions and pointers.\nExample -\nint add(int a, int b){\n      return a+b;\n}\nint add(int a, int b, int c){\n      return a+b+c;\n}\n\nint main(){\n    cout<<add(2,3)<<endl;\n    cout<<add(2,3,4)<<endl;\n\n\n     return 0;\n}\n  Example -\nclass A{\n     public:\n          virtual void fun(){\n               cout<<\"base \";\n          }\n};\nclass B: public A{\n     public:\n          void fun(){\n               cout<<\"derived \";\n          }\n};\nint main(){\n     A *a=new B;\n     a->fun();\n\n     return 0;\n} Compile-time polymorphism Run time polymorphism\nIn this method, we would come to know at compile time which method will be called. And the call is resolved by the compiler. In this method, we come to know at run time which method will be called. The call is not resolved by the compiler.\nIt provides fast execution because it is known at the compile time. It provides slow execution compared to compile-time polymorphism because it is known at the run time.\nIt is achieved by function overloading and operator overloading. It can be achieved by virtual functions and pointers.\nExample -\nint add(int a, int b){\n      return a+b;\n}\nint add(int a, int b, int c){\n      return a+b+c;\n}\n\nint main(){\n    cout<<add(2,3)<<endl;\n    cout<<add(2,3,4)<<endl;\n\n\n     return 0;\n}\n  Example -\nclass A{\n     public:\n          virtual void fun(){\n               cout<<\"base \";\n          }\n};\nclass B: public A{\n     public:\n          void fun(){\n               cout<<\"derived \";\n          }\n};\nint main(){\n     A *a=new B;\n     a->fun();\n\n     return 0;\n} Compile-time polymorphism Run time polymorphism Compile-time polymorphism Run time polymorphism Compile-time polymorphism Run time polymorphism In this method, we would come to know at compile time which method will be called. And the call is resolved by the compiler. In this method, we come to know at run time which method will be called. The call is not resolved by the compiler.\nIt provides fast execution because it is known at the compile time. It provides slow execution compared to compile-time polymorphism because it is known at the run time.\nIt is achieved by function overloading and operator overloading. It can be achieved by virtual functions and pointers.\nExample -\nint add(int a, int b){\n      return a+b;\n}\nint add(int a, int b, int c){\n      return a+b+c;\n}\n\nint main(){\n    cout<<add(2,3)<<endl;\n    cout<<add(2,3,4)<<endl;\n\n\n     return 0;\n}\n  Example -\nclass A{\n     public:\n          virtual void fun(){\n               cout<<\"base \";\n          }\n};\nclass B: public A{\n     public:\n          void fun(){\n               cout<<\"derived \";\n          }\n};\nint main(){\n     A *a=new B;\n     a->fun();\n\n     return 0;\n} In this method, we would come to know at compile time which method will be called. And the call is resolved by the compiler. In this method, we come to know at run time which method will be called. The call is not resolved by the compiler. In this method, we would come to know at compile time which method will be called. And the call is resolved by the compiler. In this method, we come to know at run time which method will be called. The call is not resolved by the compiler. It provides fast execution because it is known at the compile time. It provides slow execution compared to compile-time polymorphism because it is known at the run time. It provides fast execution because it is known at the compile time. It provides slow execution compared to compile-time polymorphism because it is known at the run time. It is achieved by function overloading and operator overloading. It can be achieved by virtual functions and pointers. It is achieved by function overloading and operator overloading. It can be achieved by virtual functions and pointers. Example -\nint add(int a, int b){\n      return a+b;\n}\nint add(int a, int b, int c){\n      return a+b+c;\n}\n\nint main(){\n    cout<<add(2,3)<<endl;\n    cout<<add(2,3,4)<<endl;\n\n\n     return 0;\n}\n  Example -\nclass A{\n     public:\n          virtual void fun(){\n               cout<<\"base \";\n          }\n};\nclass B: public A{\n     public:\n          void fun(){\n               cout<<\"derived \";\n          }\n};\nint main(){\n     A *a=new B;\n     a->fun();\n\n     return 0;\n} Example -\nint add(int a, int b){\n      return a+b;\n}\nint add(int a, int b, int c){\n      return a+b+c;\n}\n\nint main(){\n    cout<<add(2,3)<<endl;\n    cout<<add(2,3,4)<<endl;\n\n\n     return 0;\n} Example - int add(int a, int b){\n      return a+b;\n}\nint add(int a, int b, int c){\n      return a+b+c;\n}\n\nint main(){\n    cout<<add(2,3)<<endl;\n    cout<<add(2,3,4)<<endl;\n\n\n     return 0;\n} int add(int a, int b){\n      return a+b;\n}\nint add(int a, int b, int c){\n      return a+b+c;\n}\n\nint main(){\n    cout<<add(2,3)<<endl;\n    cout<<add(2,3,4)<<endl;\n\n\n     return 0;\n} int add(int a, int b) int add (int a, int b) int int return int add(int a, int b, int c) int add (int a, int b, int c) int int int return int main() int main () add 2 3 add 2 3 4 return 0  Example -\nclass A{\n     public:\n          virtual void fun(){\n               cout<<\"base \";\n          }\n};\nclass B: public A{\n     public:\n          void fun(){\n               cout<<\"derived \";\n          }\n};\nint main(){\n     A *a=new B;\n     a->fun();\n\n     return 0;\n} Example - class A{\n     public:\n          virtual void fun(){\n               cout<<\"base \";\n          }\n};\nclass B: public A{\n     public:\n          void fun(){\n               cout<<\"derived \";\n          }\n};\nint main(){\n     A *a=new B;\n     a->fun();\n\n     return 0;\n} class A{\n     public:\n          virtual void fun(){\n               cout<<\"base \";\n          }\n};\nclass B: public A{\n     public:\n          void fun(){\n               cout<<\"derived \";\n          }\n};\nint main(){\n     A *a=new B;\n     a->fun();\n\n     return 0;\n} class A{ class A public virtual void fun() virtual void fun () \"base \" class B: class B public public void fun() void fun () \"derived \" int main() int main () new fun return 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "20. What are the C++ access specifiers?",
        "answer": "In C++ there are the following access specifiers: Public: All data members and member functions are accessible outside the class. Public: Protected: All data members and member functions are accessible inside the class and to the derived class. Protected: Private: All data members and member functions are not accessible outside the class. Private:",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. What is a copy constructor?",
        "answer": "A copy constructor is a member function that initializes an object using another object of the same class. Example- Example- class A{\nint x,y;\nA(int x, int y){\n this->x=x;\n this->y=y;\n}\n\n};\nint main(){\nA a1(2,3);\nA a2=a1;     //default copy constructor is called\nreturn 0;\n} class A{\nint x,y;\nA(int x, int y){\n this->x=x;\n this->y=y;\n}\n\n};\nint main(){\nA a1(2,3);\nA a2=a1;     //default copy constructor is called\nreturn 0;\n} class A{ class A int int int this this int main() int main () A a1(2,3) a1 (2,3) 2 3 //default copy constructor is called return 0 We can define our copy constructor. If we don\u2019t define a copy constructor then the default copy constructor is called.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. What is the difference between shallow copy and deep copy?",
        "answer": "The difference between shallow copy and a deep copy is given below: Shallow Copy Deep Copy\nShallow copy stores the references of objects to the original memory address. Deep copy makes a new and separate copy of an entire object with its unique memory address.\nShallow copy is faster. Deep copy is comparatively slower.\nShallow copy reflects changes made to the new/copied object in the original object. Deep copy doesn\u2019t reflect changes made to the new/copied object in the original object Shallow Copy Deep Copy\nShallow copy stores the references of objects to the original memory address. Deep copy makes a new and separate copy of an entire object with its unique memory address.\nShallow copy is faster. Deep copy is comparatively slower.\nShallow copy reflects changes made to the new/copied object in the original object. Deep copy doesn\u2019t reflect changes made to the new/copied object in the original object Shallow Copy Deep Copy Shallow Copy Deep Copy Shallow Copy Deep Copy Shallow copy stores the references of objects to the original memory address. Deep copy makes a new and separate copy of an entire object with its unique memory address.\nShallow copy is faster. Deep copy is comparatively slower.\nShallow copy reflects changes made to the new/copied object in the original object. Deep copy doesn\u2019t reflect changes made to the new/copied object in the original object Shallow copy stores the references of objects to the original memory address. Deep copy makes a new and separate copy of an entire object with its unique memory address. Shallow copy stores the references of objects to the original memory address. Deep copy makes a new and separate copy of an entire object with its unique memory address. Shallow copy is faster. Deep copy is comparatively slower. Shallow copy is faster. Deep copy is comparatively slower. Shallow copy reflects changes made to the new/copied object in the original object. Deep copy doesn\u2019t reflect changes made to the new/copied object in the original object Shallow copy reflects changes made to the new/copied object in the original object. Deep copy doesn\u2019t reflect changes made to the new/copied object in the original object",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What is the difference between virtual functions and pure virtual functions?",
        "answer": "A virtual function is a member function in the base class that you redefine in a derived class. It is declared using the virtual keyword. Example- Example- class base{\npublic:\n virtual void fun(){\n\n }\n}; class base{\npublic:\n virtual void fun(){\n\n }\n}; class base{ class base public virtual void fun() virtual void fun () A pure virtual function is a function that has no implementation and is declared by assigning 0. It has no body. Example- Example- class base{\npublic:\n virtual void fun()=0;\n}; class base{\npublic:\n virtual void fun()=0;\n}; class base{ class base public virtual void fun() virtual void fun () 0 Here, = sign has got nothing to do with the assignment, and value 0 is not assigned to anything. It is used to simply tell the compiler that a function will be pure and it will not have anybody.",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. If class D is derived from a base class B. When creating an object of type D in what order would the constructors of these classes get called?",
        "answer": "The derived class has two parts, a base part, and a derived part.  When C++ constructs derived objects, it does so in phases. First, the most-base class(at the top of the inheritance tree) is constructed. Then each child class is constructed in order until the most-child class is constructed last. \nSo the first Constructor of class B will be called and then the constructor of class D will be called.  During the destruction exactly reverse order is followed. That is destructor starts at the most-derived class and works its way down to base class.\nSo the first destructor of class D will be called and then the destructor of class B will be called. ",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Can we call a virtual function from a constructor?",
        "answer": "Yes, we can call a virtual function from a constructor. But the behavior is a little different in this case. When a virtual function is called, the virtual call is resolved at runtime. It is always the member function of the current class that gets called. That is the virtual machine doesn\u2019t work within the constructor. For example- For example- class base{\n private:\n  int value;\n public:\n  base(int x){\n   value=x;\n  }\n  virtual void fun(){\n   \n  }\n}\n\nclass derived{\n private:\n  int a;\n public:\n  derived(int x, int y):base(x){\n   base *b;\n   b=this;\n   b->fun();      //calls derived::fun()\n  }\n  void fun(){\n   cout<<\u201dfun inside derived class\u201d<<endl;\n  }\n} class base{\n private:\n  int value;\n public:\n  base(int x){\n   value=x;\n  }\n  virtual void fun(){\n   \n  }\n}\n\nclass derived{\n private:\n  int a;\n public:\n  derived(int x, int y):base(x){\n   base *b;\n   b=this;\n   b->fun();      //calls derived::fun()\n  }\n  void fun(){\n   cout<<\u201dfun inside derived class\u201d<<endl;\n  }\n} class base{ class base private int public int virtual void fun() virtual void fun () class derived{ class derived private int public int int this //calls derived::fun() void fun() void fun () cout class\u201d< class endl",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What are void pointers?",
        "answer": "A void pointer is a pointer which is having no datatype associated with it. It can hold addresses of any type. For example- void *ptr; \nchar *str;\np=str;                // no error \nstr=p;                // error because of type mismatch void *ptr; \nchar *str;\np=str;                // no error \nstr=p;                // error because of type mismatch void char // no error // error because of type mismatch We can assign a pointer of any type to a void pointer but the reverse is not true unless you typecast it as str=(char*) ptr; str=(char*) ptr; char",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What is this pointer in C++?",
        "answer": "The member functions of every object have a pointer named this, which points to the object itself. The value of this is set to the address of the object for which it is called. It can be used to access the data in the object it points to. Example Example class A{\n private:\n  int value;\n public:\n  void setvalue(int x){\n   this->value=x; \n  }\n};\n\nint main(){\n A a;\n a.setvalue(5);\n return 0;\n} class A{\n private:\n  int value;\n public:\n  void setvalue(int x){\n   this->value=x; \n  }\n};\n\nint main(){\n A a;\n a.setvalue(5);\n return 0;\n} class A{ class A private int public void setvalue(int x) void setvalue (int x) int this int main() int main () 5 return 0",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. How do you allocate and deallocate memory in C++?",
        "answer": "The new operator is used for memory allocation and deletes operator is used for memory deallocation in C++. For example- For example- int value=new int;    //allocates memory for storing 1 integer\ndelete value;            // deallocates memory taken by value\n\nint *arr=new int[10];     //allocates memory for storing 10 int\ndelete []arr;               // deallocates memory occupied by arr int value=new int;    //allocates memory for storing 1 integer\ndelete value;            // deallocates memory taken by value\n\nint *arr=new int[10];     //allocates memory for storing 10 int\ndelete []arr;               // deallocates memory occupied by arr int new int //allocates memory for storing 1 integer delete // deallocates memory taken by value int new int 10 //allocates memory for storing 10 int delete // deallocates memory occupied by arr Additional Resources Additional Resources Practice Coding Practice Coding C++ MCQ C++ MCQ C++ Tutorials C++ Tutorials C Interview Questions C Interview Questions Difference Between C and C++ Difference Between C and C++ Difference Between C++ and Java Difference Between C++ and Java Online C++ Compiler Online C++ Compiler Features of C++ Features of C++",
        "reference": "interviewbit.com"
    }
]