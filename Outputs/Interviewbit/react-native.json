[
    {
        "question": "1. How Different is React-native from ReactJS ?",
        "answer": "Usage Scope\nReactJs - React is a  JavaScript library for building Responsive User Interfaces for Building Web Application.\nReact Native - It is a framework for creating mobile applications with a native feel.\nSyntax\nBoth React and React Native uses JSX (JavaScript XML)  syntax but React uses html tags like <div> <h1> <p> etc while React Native uses <view> <text> etc.\n Animation And Gestures\nReact uses CSS animations on a major scale to achieve animations for a web page while  The recommended way to animate a component is to use the Animated API provided by React-Native.\nRouting Mechanism\nReact uses a react-router for routing and does not have any inbuilt routing capabilities but React Native has a built-in Navigator library for navigating mobile applications. Usage Scope\nReactJs - React is a  JavaScript library for building Responsive User Interfaces for Building Web Application.\nReact Native - It is a framework for creating mobile applications with a native feel. Usage Scope  React  Syntax\nBoth React and React Native uses JSX (JavaScript XML)  syntax but React uses html tags like <div> <h1> <p> etc while React Native uses <view> <text> etc. Syntax  Animation And Gestures\nReact uses CSS animations on a major scale to achieve animations for a web page while  The recommended way to animate a component is to use the Animated API provided by React-Native. Animation And Gestures  Routing Mechanism\nReact uses a react-router for routing and does not have any inbuilt routing capabilities but React Native has a built-in Navigator library for navigating mobile applications. Routing Mechanism    REACT JS REACT NATIVE\nIt is used for developing web applications. It is used for developing mobile applications.\nIt uses React-router for navigating web pages. It has a built-in navigator library for navigating mobile applications.\nIt uses HTML tags. It does not use HTML tags.\nIt provides high security. It provides low security in comparison to ReactJS.\nIn this, the virtual DOM renders the browser code. In this, Native uses its API to render code for mobile applications. REACT JS REACT NATIVE\nIt is used for developing web applications. It is used for developing mobile applications.\nIt uses React-router for navigating web pages. It has a built-in navigator library for navigating mobile applications.\nIt uses HTML tags. It does not use HTML tags.\nIt provides high security. It provides low security in comparison to ReactJS.\nIn this, the virtual DOM renders the browser code. In this, Native uses its API to render code for mobile applications. REACT JS REACT NATIVE REACT JS REACT NATIVE REACT JS REACT NATIVE It is used for developing web applications. It is used for developing mobile applications.\nIt uses React-router for navigating web pages. It has a built-in navigator library for navigating mobile applications.\nIt uses HTML tags. It does not use HTML tags.\nIt provides high security. It provides low security in comparison to ReactJS.\nIn this, the virtual DOM renders the browser code. In this, Native uses its API to render code for mobile applications. It is used for developing web applications. It is used for developing mobile applications. It is used for developing web applications. It is used for developing mobile applications. It uses React-router for navigating web pages. It has a built-in navigator library for navigating mobile applications. It uses React-router for navigating web pages. It has a built-in navigator library for navigating mobile applications. It uses HTML tags. It does not use HTML tags. It uses HTML tags. It does not use HTML tags. It provides high security. It provides low security in comparison to ReactJS. It provides high security. It provides low security in comparison to ReactJS. In this, the virtual DOM renders the browser code. In this, Native uses its API to render code for mobile applications. In this, the virtual DOM renders the browser code. In this, Native uses its API to render code for mobile applications.",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. List down Key Points to integrate React Native in an existing Android mobile application",
        "answer": "Primary points to note to integrating React Native components into your Android application are to: Set up React Native dependencies and directory structure.\nDevelop your React Native components in JavaScript.\nAdd a ReactRootView to your Android app. This view will serve as the container for your React Native component.\nStart the React Native server and run your native application.\nLastly, we need to Verify that the React Native aspect of your application works as expected. Set up React Native dependencies and directory structure. Develop your React Native components in JavaScript. Add a ReactRootView to your Android app. This view will serve as the container for your React Native component. Start the React Native server and run your native application. Lastly, we need to Verify that the React Native aspect of your application works as expected.",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. Describing Networking in React Native and how to make AJAX network calls in React Native?",
        "answer": "React Native provides the Fetch API for networking needs. \nTo fetch content from an arbitrary URL, we can pass the URL to fetch:  fetch('https://mywebsite.com/endpoint/', {\n method: 'POST',\n headers: {\n   Accept: 'application/json',\n   'Content-Type': 'application/json'\n },\n body: JSON.stringify({\n   firstParam: 'yourValue',\n   secondParam: 'yourOtherValue'\n })\n}); fetch('https://mywebsite.com/endpoint/', {\n method: 'POST',\n headers: {\n   Accept: 'application/json',\n   'Content-Type': 'application/json'\n },\n body: JSON.stringify({\n   firstParam: 'yourValue',\n   secondParam: 'yourOtherValue'\n })\n}); Networking is an inherently asynchronous operation. Fetch methods will return a Promise that makes it straightforward to write code that works in an asynchronous manner: const getMoviesFromApi = () => {\n return fetch('https://reactnative.dev/movies.json')\n   .then((response) => response.json())\n   .then((json) => {\n     return json.movies;\n   })\n   .catch((error) => {\n     console.error(error);\n   });\n}; const getMoviesFromApi = () => {\n return fetch('https://reactnative.dev/movies.json')\n   .then((response) => response.json())\n   .then((json) => {\n     return json.movies;\n   })\n   .catch((error) => {\n     console.error(error);\n   });\n}; The XMLHttpRequest API is built in to React Native  Since frisbee and Axios use XMLHttpRequest we can even use these libraries. var request = new XMLHttpRequest();\nrequest.onreadystatechange = (e) => {\n if (request.readyState !== 4) {\n   return;\n }\n\n if (request.status === 200) {\n   console.log('success', request.responseText);\n } else {\n   console.warn('error');\n }\n};\n\nrequest.open('GET', 'https://mywebsite.com/endpoint/');\nrequest.send(); var request = new XMLHttpRequest();\nrequest.onreadystatechange = (e) => {\n if (request.readyState !== 4) {\n   return;\n }\n\n if (request.status === 200) {\n   console.log('success', request.responseText);\n } else {\n   console.warn('error');\n }\n};\n\nrequest.open('GET', 'https://mywebsite.com/endpoint/');\nrequest.send();",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. What is Props Drilling and how can we avoid it ?",
        "answer": "Props Drilling (Threading) is a concept that refers to the process you pass the data from the parent component to the exact child Component BUT in between, other components owning the props just to pass it down the chain.   Steps to avoid it Steps to avoid it 1. React Context API.\n2. Composition\n3. Render props\n4. HOC\n5. Redux or MobX    ",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. How to debug React Native Applications and Name the Tools used for it ?",
        "answer": "In the React Native world, debugging may be done in different ways and with different tools, since React Native is composed of different environments (iOS and Android), which means there\u2019s an assortment of problems and a variety of tools needed for debugging. The Developer Menu:\n\nReload: reloads the app\nDebug JS Remotely: opens a channel to a JavaScript debugger\nEnable Live Reload: makes the app reload automatically on clicking Save\nEnable Hot Reloading: watches for changes accrued in a changed file\nToggle Inspector: toggles an inspector interface, which allows us to inspect any UI element on the screen and its properties, and presents an interface that has other tabs like networking, which shows us the HTTP calls, and a tab for performance. The Developer Menu:\n\nReload: reloads the app\nDebug JS Remotely: opens a channel to a JavaScript debugger\nEnable Live Reload: makes the app reload automatically on clicking Save\nEnable Hot Reloading: watches for changes accrued in a changed file\nToggle Inspector: toggles an inspector interface, which allows us to inspect any UI element on the screen and its properties, and presents an interface that has other tabs like networking, which shows us the HTTP calls, and a tab for performance. The Developer Menu:   Reload:  Debug JS Remotely:  Enable Live Reload:  Enable Hot Reloading:  Toggle Inspector:   Chrome\u2019s DevTools:\n\nChrome is possibly the first tool to think of for debugging React Native. It\u2019s common to use Chrome\u2019s DevTools to debug web apps, but we can also use them to debug React Native since it\u2019s powered by JavaScript.To use Chrome\u2019s DevTools with React Native, first make sure to connect to the same Wi-Fi, then press command + R if you\u2019re using macOS, or Ctrl + M on Windows/Linux. In the developer menu, choose Debug Js Remotely. This will open the default JS debugger.\n  React Developer Tools\nFor Debugging React Native using React\u2019s Developer Tools, you need to use the desktop app. In can installed it globally or locally in your project by just running the following command:\nyarn add react-devtools\nOr npm:\nnpm install react-devtools --save\n\nReact\u2019s Developer Tools may be the best tool for debugging React Native for these two reasons:\nIt allows for debugging React components.\nThere is also a possibility to debug styles in React Native. There is also a new version that comes with this feature that also works with the inspector in the developer menu. Previously, it was a problem to write styles and have to wait for the app to reload to see the changes. Now we can debug and implement style properties and see the effect of the change instantly without reloading the app.\n  React Native Debugger\nWhile using Redux in your React Native app, React Native Debugger is probably the right debugger for you. This is a standalone desktop app that works on macOS, Windows, and Linux. It even integrates both Redux\u2019s DevTools and React\u2019s Developer Tools in one app so you don\u2019t have to work with two separate apps for debugging. Chrome\u2019s DevTools:\n\nChrome is possibly the first tool to think of for debugging React Native. It\u2019s common to use Chrome\u2019s DevTools to debug web apps, but we can also use them to debug React Native since it\u2019s powered by JavaScript.To use Chrome\u2019s DevTools with React Native, first make sure to connect to the same Wi-Fi, then press command + R if you\u2019re using macOS, or Ctrl + M on Windows/Linux. In the developer menu, choose Debug Js Remotely. This will open the default JS debugger. Chrome\u2019s DevTools:    React Developer Tools\nFor Debugging React Native using React\u2019s Developer Tools, you need to use the desktop app. In can installed it globally or locally in your project by just running the following command:\nyarn add react-devtools\nOr npm:\nnpm install react-devtools --save\n\nReact\u2019s Developer Tools may be the best tool for debugging React Native for these two reasons:\nIt allows for debugging React components.\nThere is also a possibility to debug styles in React Native. There is also a new version that comes with this feature that also works with the inspector in the developer menu. Previously, it was a problem to write styles and have to wait for the app to reload to see the changes. Now we can debug and implement style properties and see the effect of the change instantly without reloading the app. React Developer Tools   yarn add react-devtools   npm install react-devtools --save      React Native Debugger\nWhile using Redux in your React Native app, React Native Debugger is probably the right debugger for you. This is a standalone desktop app that works on macOS, Windows, and Linux. It even integrates both Redux\u2019s DevTools and React\u2019s Developer Tools in one app so you don\u2019t have to work with two separate apps for debugging. React Native Debugger   React Native CLI You can use the React Native CLI to do some debugging as well. It can also be used for showing the logs of the app. Hitting react-native log-android will show you the logs of db logcat on Android, and to view the logs in iOS you can run react-native log-ios, and with console.log you can dispatch logs to the terminal: console.log(\"some error\ud83d\uded1\") console.log(\"some error\ud83d\uded1\")",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. Describe Timers in React Native Application ?",
        "answer": "Timers are an important and integral part of any application and React Native implements the browser timers.\n\nTimers   Timers Timers  setTimeout, clearTimeout setTimeout, clearTimeout setTimeout, clearTimeout There may be business requirements to execute a certain piece of code after waiting for some time duration or after a delay setTimeout can be used in such cases, clearTimeout is simply used to clear the timer that is started. setTimeout(() => {\nyourFunction();\n}, 3000); setTimeout(() => {\nyourFunction();\n}, 3000); setInterval, clearInterval setInterval, clearInterval setInterval, clearInterval setInterval is a method that calls a function or runs some code after specific intervals of time, as specified through the second parameter. setInterval(() => {\nconsole.log('Interval triggered');\n}, 1000); setInterval(() => {\nconsole.log('Interval triggered');\n}, 1000); A function or block of code that is bound to an interval executes until it is stopped. To stop an interval, we can use the clearInterval() method. setImmediate, clearImmediate setImmediate, clearImmediate setImmediate, clearImmediate Calling the function or execution as soon as possible. var immediateID = setImmediate(function);\n// The below code displays the alert dialog immediately.\nvar immediateId = setImmediate(\n    () => {    alert('Immediate Alert');\n} var immediateID = setImmediate(function);\n// The below code displays the alert dialog immediately.\nvar immediateId = setImmediate(\n    () => {    alert('Immediate Alert');\n} clearImmediate  is used for Canceling the immediate actions that were set by setImmediate(). requestAnimationFrame, cancelAnimationFrame requestAnimationFrame, cancelAnimationFrame requestAnimationFrame, cancelAnimationFrame It is the standard way to perform animations. Calling a function to update an animation before the next animation frame. var requestID = requestAnimationFrame(function);\n// The following code performs the animation.\nvar requestId = requestAnimationFrame(\n    () => { // animate something}\n) var requestID = requestAnimationFrame(function);\n// The following code performs the animation.\nvar requestId = requestAnimationFrame(\n    () => { // animate something}\n) cancelAnimationFrame is used for Canceling the function that was set by requestAnimationFrame().",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What is Redux in React Native and give important components of Redux used in React Native app ?",
        "answer": "Redux is a predictable state container for JavaScript apps. It helps write applications that run in different environments. This means the entire data flow of the app is handled within a single container while persisting previous state. Actions: are payloads of information that send data from your application to your store. They are the only source of information for the store. This means if any state change is necessary the change required will be dispatched through the actions.\n\nReducers: \u201cActions describe the fact that something happened, but don\u2019t specify how the application\u2019s state changes in response. This is the job of reducers.\u201d when an action is dispatched for state change its the reducers duty to make the necessary changes to the state and return the new state of the application.\n\nStore: a store can be created with help of reducers which holds the entire state of the application. The recommended way is to use a single store for the entire application rather than having multiple stores which will violate the use of redux which only has a single store.\n\nComponents: this is where the UI of the application is kept. Actions:   Reducers:   Store:   Components:  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What is State and how is it used in React Native?",
        "answer": "It is used to control the components. The variable data can be stored in the state. It is mutable means a state can change the value at any time. import React, {Component} from 'react';    \nimport { Text, View } from 'react-native';    \nexport default class App extends Component {    \n state = { \nmyState: 'State of Text Component'\n              }\nupdateState = () => this.setState({myState: 'The state is updated'})\nrender() {\nreturn (\n<View>    \n<Text onPress={this.updateState}> {this.state.myState} </Text>    \n</View> \n); } } import React, {Component} from 'react';    \nimport { Text, View } from 'react-native';    \nexport default class App extends Component {    \n state = { \nmyState: 'State of Text Component'\n              }\nupdateState = () => this.setState({myState: 'The state is updated'})\nrender() {\nreturn (\n<View>    \n<Text onPress={this.updateState}> {this.state.myState} </Text>    \n</View> \n); } } Here we create a Text component with state data. The content of the Text component will be updated whenever we click on it. The state is updated by event onPress .",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. How is user Input Handled in React Native ?",
        "answer": "TextInput is a Core Component that allows the user to enter text. It has an onChangeText prop that takes a function to be called every time the text changes, and an onSubmitEditing prop that takes a function to be called when the text is submitted. import React, { useState } from 'react';\nimport { Text, TextInput, View } from 'react-native';\n\nconst PizzaTranslator = () => {\n const [text, setText] = useState('');\n return (\n   <View style={{padding: 10}}>\n     <TextInput\n       style={{height: 40}}\n       placeholder=\"Type here to translate!\"\n       onChangeText={text => setText(text)}\n       defaultValue={text}\n     />\n     <Text style={{padding: 10, fontSize: 42}}>\n       {text.split(' ').map((word) => word && '\ud83c\udf55').join(' ')}\n     </Text>\n   </View>\n );\n}\n\nexport default PizzaTranslator; import React, { useState } from 'react';\nimport { Text, TextInput, View } from 'react-native';\n\nconst PizzaTranslator = () => {\n const [text, setText] = useState('');\n return (\n   <View style={{padding: 10}}>\n     <TextInput\n       style={{height: 40}}\n       placeholder=\"Type here to translate!\"\n       onChangeText={text => setText(text)}\n       defaultValue={text}\n     />\n     <Text style={{padding: 10, fontSize: 42}}>\n       {text.split(' ').map((word) => word && '\ud83c\udf55').join(' ')}\n     </Text>\n   </View>\n );\n}\n\nexport default PizzaTranslator;",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. Are default props available in React Native and if yes for what are they used and how are they used ?",
        "answer": "Yes, default props available in React Native as they are for React,  If for an instance we do not pass props value, the component will use the default props value. import React, {Component} from 'react'; import {View, Text} from 'react-native';\nclass DefaultPropComponent extends Component {\n   render() {\n       return ( \n           <View>\n             <Text> \n              {this.props.name} \n            </Text> \n          </View>\n       )\n   }\n}\nDemo.defaultProps = {\n   name: 'BOB'\n}\n\nexport default DefaultPropComponent; import {View, Text} from 'react-native';\nclass DefaultPropComponent extends Component {\n   render() {\n       return ( \n           <View>\n             <Text> \n              {this.props.name} \n            </Text> \n          </View>\n       )\n   }\n}\nDemo.defaultProps = {\n   name: 'BOB'\n}\n\nexport default DefaultPropComponent;",
        "reference": "interviewbit.com"
    },
    {
        "question": "11. What are threads in General ? and explain Different Threads in ReactNative with Use of Each ?",
        "answer": "  The single sequential flow of control within a program can be controlled by a thread.\n\nReact Native right now uses 3 threads:   React Native right now uses 3 threads: MAIN/UI  Thread \u2014 This is the main application thread on which your Android/iOS app is running. The UI of the application can be changed by the Main thread and it has access to it .\n  Shadow Thread \u2014 layout created using React library in React Native can be calculated by this and it is a background thread.\n  JavaScript Thread \u2014 The main Javascript code is executed by this thread. MAIN/UI  Thread \u2014 This is the main application thread on which your Android/iOS app is running. The UI of the application can be changed by the Main thread and it has access to it . MAIN/UI  Thread  Shadow Thread \u2014 layout created using React library in React Native can be calculated by this and it is a background thread. Shadow Thread  JavaScript Thread \u2014 The main Javascript code is executed by this thread. JavaScript Thread",
        "reference": "interviewbit.com"
    },
    {
        "question": "12. Describe advantages of using React Native?",
        "answer": "There are multiple advantage of using React Native like, Large Community\nReact Native is an Open Source Framework, it is completely community driven so any challenges can be resolved by getting online help from other developers.\n  Reusability\nCode can be written once and can be used for both IOS and ANDROID, which helps in maintaining and as well debugging large complex applications as no separate teams are needed for supporting both the platforms, this also reduces the cost to a major extent.\n  Live and Hot Reloading\nLive reloading reloads or refreshes the entire app when a file changes. For example, if you were four links deep into your navigation and saved a change, live reloading would restart the app and load the app back to the initial route.\nHot reloading only refreshes the files that were changed without losing the state of the app. For example, if you were four links deep into your navigation and saved a change to some styling, the state would not change, but the new styles would appear on the page without having to navigate back to the page you are on because you would still be on the same page.\n  Additional Third-Party Plugins\nIf the existing modules do not meet the business requirement in React Native we can also use Third Party plugins which may help to speed up the development process. Large Community\nReact Native is an Open Source Framework, it is completely community driven so any challenges can be resolved by getting online help from other developers. Large Community   Reusability\nCode can be written once and can be used for both IOS and ANDROID, which helps in maintaining and as well debugging large complex applications as no separate teams are needed for supporting both the platforms, this also reduces the cost to a major extent. Reusability   Live and Hot Reloading\nLive reloading reloads or refreshes the entire app when a file changes. For example, if you were four links deep into your navigation and saved a change, live reloading would restart the app and load the app back to the initial route.\nHot reloading only refreshes the files that were changed without losing the state of the app. For example, if you were four links deep into your navigation and saved a change to some styling, the state would not change, but the new styles would appear on the page without having to navigate back to the page you are on because you would still be on the same page. Live and Hot Reloading    Additional Third-Party Plugins\nIf the existing modules do not meet the business requirement in React Native we can also use Third Party plugins which may help to speed up the development process. Additional Third-Party Plugins ",
        "reference": "interviewbit.com"
    },
    {
        "question": "13. What is Flexbox and describe any elaborate on its most used properties?",
        "answer": "It is a layout model that allows elements to align and distribute space within a container. With Flexbox when Using flexible widths and heights, all the inside the main container can be aligned to fill a space or distribute space between elements, which makes it a great tool to use for responsive design systems. Property  Values Description\nflexDirection \u2018column\u2019,'row' Used to specify if elements will be aligned vertically or horizontally \njustifyContent \u2018center\u2019,'flex-start','flex-end','space-around','space-between' Used to determine how should elements be distributed inside the container \nalignItems \u2018center\u2019,'flex-start','flex-end','stretched' Used to determine how should elements be distributed inside the container along the secondary axis (opposite of flexDirection) Property  Values Description\nflexDirection \u2018column\u2019,'row' Used to specify if elements will be aligned vertically or horizontally \njustifyContent \u2018center\u2019,'flex-start','flex-end','space-around','space-between' Used to determine how should elements be distributed inside the container \nalignItems \u2018center\u2019,'flex-start','flex-end','stretched' Used to determine how should elements be distributed inside the container along the secondary axis (opposite of flexDirection) Property  Values Description Property  Values Description Property  Values Description flexDirection \u2018column\u2019,'row' Used to specify if elements will be aligned vertically or horizontally \njustifyContent \u2018center\u2019,'flex-start','flex-end','space-around','space-between' Used to determine how should elements be distributed inside the container \nalignItems \u2018center\u2019,'flex-start','flex-end','stretched' Used to determine how should elements be distributed inside the container along the secondary axis (opposite of flexDirection) flexDirection \u2018column\u2019,'row' Used to specify if elements will be aligned vertically or horizontally flexDirection \u2018column\u2019,'row' Used to specify if elements will be aligned vertically or horizontally justifyContent \u2018center\u2019,'flex-start','flex-end','space-around','space-between' Used to determine how should elements be distributed inside the container justifyContent \u2018center\u2019,'flex-start','flex-end','space-around','space-between' Used to determine how should elements be distributed inside the container alignItems \u2018center\u2019,'flex-start','flex-end','stretched' Used to determine how should elements be distributed inside the container along the secondary axis (opposite of flexDirection) alignItems \u2018center\u2019,'flex-start','flex-end','stretched' Used to determine how should elements be distributed inside the container along the secondary axis (opposite of flexDirection)",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. Name core Components in React Native and the analogy of those components when compared with the web .",
        "answer": "The core components used in React Native are <View> , <Text> , <Image> , <ScrollView> , <TextInput>\n\nAnd analogy when compared Web can be explained by below diagram:   REACT NATIVE UI COMPONENT ANDROID VIEW IOS VIEW WEB ANALOG DESCRIPTION\n<View> <ViewGroup> <UIView> A non-scrolling <div> A container that supports layout with flexbox style, some touch handling, and accessibility controls.\n<Text> <TextView> <UITextView> <p> Displays, styles, and nests strings of text and even handles touch events.\n<Image> <ImageView> <UIImageView> <img> Displays different types of images\n<ScrollView> <ScrollView> <UIScrollView> <div> A generic scrolling container that can contain multiple components and views.\n<TextInput> <EditText> <UITextField> <input type=\"text\"> Allows the user to enter text REACT NATIVE UI COMPONENT ANDROID VIEW IOS VIEW WEB ANALOG DESCRIPTION\n<View> <ViewGroup> <UIView> A non-scrolling <div> A container that supports layout with flexbox style, some touch handling, and accessibility controls.\n<Text> <TextView> <UITextView> <p> Displays, styles, and nests strings of text and even handles touch events.\n<Image> <ImageView> <UIImageView> <img> Displays different types of images\n<ScrollView> <ScrollView> <UIScrollView> <div> A generic scrolling container that can contain multiple components and views.\n<TextInput> <EditText> <UITextField> <input type=\"text\"> Allows the user to enter text REACT NATIVE UI COMPONENT ANDROID VIEW IOS VIEW WEB ANALOG DESCRIPTION REACT NATIVE UI COMPONENT ANDROID VIEW IOS VIEW WEB ANALOG DESCRIPTION REACT NATIVE UI COMPONENT ANDROID VIEW IOS VIEW WEB ANALOG DESCRIPTION <View> <ViewGroup> <UIView> A non-scrolling <div> A container that supports layout with flexbox style, some touch handling, and accessibility controls.\n<Text> <TextView> <UITextView> <p> Displays, styles, and nests strings of text and even handles touch events.\n<Image> <ImageView> <UIImageView> <img> Displays different types of images\n<ScrollView> <ScrollView> <UIScrollView> <div> A generic scrolling container that can contain multiple components and views.\n<TextInput> <EditText> <UITextField> <input type=\"text\"> Allows the user to enter text <View> <ViewGroup> <UIView> A non-scrolling <div> A container that supports layout with flexbox style, some touch handling, and accessibility controls. <View> <View> <ViewGroup> <ViewGroup> <UIView> <UIView> A non-scrolling <div> <div> A container that supports layout with flexbox style, some touch handling, and accessibility controls. <Text> <TextView> <UITextView> <p> Displays, styles, and nests strings of text and even handles touch events. <Text> <Text> <TextView> <TextView> <UITextView> <UITextView> <p> <p> Displays, styles, and nests strings of text and even handles touch events. <Image> <ImageView> <UIImageView> <img> Displays different types of images <Image> <Image> <ImageView> <ImageView> <UIImageView> <UIImageView> <img> <img> Displays different types of images <ScrollView> <ScrollView> <UIScrollView> <div> A generic scrolling container that can contain multiple components and views. <ScrollView> <ScrollView> <ScrollView> <ScrollView> <UIScrollView> <UIScrollView> <div> <div> A generic scrolling container that can contain multiple components and views. <TextInput> <EditText> <UITextField> <input type=\"text\"> Allows the user to enter text <TextInput> <TextInput> <EditText> <EditText> <UITextField> <UITextField> <input type=\"text\"> <input type=\"text\"> Allows the user to enter text",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Explain Async Storage in React Native and also define when to use it and when to not?",
        "answer": "Async Storage is the React Native equivalent of Local Storage from the web.\nAsync Storage is a community-maintained module for React Native that provides an asynchronous, unencrypted, key-value store. Async Storage is not shared between apps: every app has its own sandbox environment and has no access to data from other apps. Async Storage is the React Native equivalent of Local Storage from the web. Async Storage is a community-maintained module for React Native that provides an asynchronous, unencrypted, key-value store. Async Storage is not shared between apps: every app has its own sandbox environment and has no access to data from other apps. DO USE ASYNC STORAGE WHEN.. DON'T USE ASYNC STORAGE FOR..\nPersisting non-sensitive data across app runs Token storage\nPersisting Redux state Secrets\nPersisting GraphQL state  \nStoring global app-wide variables DO USE ASYNC STORAGE WHEN.. DON'T USE ASYNC STORAGE FOR..\nPersisting non-sensitive data across app runs Token storage\nPersisting Redux state Secrets\nPersisting GraphQL state  \nStoring global app-wide variables DO USE ASYNC STORAGE WHEN.. DON'T USE ASYNC STORAGE FOR.. DO USE ASYNC STORAGE WHEN.. DON'T USE ASYNC STORAGE FOR.. DO USE ASYNC STORAGE WHEN.. DON'T USE ASYNC STORAGE FOR.. Persisting non-sensitive data across app runs Token storage\nPersisting Redux state Secrets\nPersisting GraphQL state  \nStoring global app-wide variables Persisting non-sensitive data across app runs Token storage Persisting non-sensitive data across app runs Token storage Persisting Redux state Secrets Persisting Redux state Secrets Persisting GraphQL state Persisting GraphQL state  Storing global app-wide variables Storing global app-wide variables ",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What are the Different Ways to style React Native Application ?",
        "answer": "React Native give us two powerful ways by default to style our application : 1 ) Style props 1 ) Style props You can add styling to your component using style props. You simply add style props to your element and it accepts an object of properties. import React, {Component} from 'react';\nimport {Platform, StyleSheet, Text, View} from 'react-native';\nexport default class App extends Component<Props> {\nrender() {\nreturn (\n<View style={{flex:1,justifyContent:\"center\",backgroundColor:\"#fff\", alignItems:\"center\"}}>\n<View style={{width:200,height:150,backgroundColor:\"red\",padding:10}}>\n<Text style={{fontSize:20, color:\"#666\"}}>Styled with style props</Text>\n</View>\n</View>\n);\n}\n} import React, {Component} from 'react';\nimport {Platform, StyleSheet, Text, View} from 'react-native';\nexport default class App extends Component<Props> {\nrender() {\nreturn (\n<View style={{flex:1,justifyContent:\"center\",backgroundColor:\"#fff\", alignItems:\"center\"}}>\n<View style={{width:200,height:150,backgroundColor:\"red\",padding:10}}>\n<Text style={{fontSize:20, color:\"#666\"}}>Styled with style props</Text>\n</View>\n</View>\n);\n}\n}   2 )  Using StyleSheet 2 )  Using StyleSheet For an extremely  large codebase or you want to set many properties to your elements, writing our styling rules directly inside style props will make our code more complex that\u2019s why React Native give us another way that let us write a concise code using the StyleSheet method: import { StyleSheet} from 'react-native';\nconst styles = StyleSheet.create({\ncontainer: {\nflex:1,\njustifyContent:\"center\",\nbackgroundColor:\"#fff\",\nalignItems:\"stretch\"\n},\ntitle: {\nfontSize:20,\ncolor:\"#fff\"\n},\nitem1: {\nbackgroundColor:\"orange\",\nflex:1\n},\nitem2: {\nbackgroundColor:\"purple\",\nflex:1\n},\nitem3: {\nbackgroundColor:\"yellow\",\nflex:1\n},\n\n}); import { StyleSheet} from 'react-native';\nconst styles = StyleSheet.create({\ncontainer: {\nflex:1,\njustifyContent:\"center\",\nbackgroundColor:\"#fff\",\nalignItems:\"stretch\"\n},\ntitle: {\nfontSize:20,\ncolor:\"#fff\"\n},\nitem1: {\nbackgroundColor:\"orange\",\nflex:1\n},\nitem2: {\nbackgroundColor:\"purple\",\nflex:1\n},\nitem3: {\nbackgroundColor:\"yellow\",\nflex:1\n},\n\n}); We then  pass the styles object to our component via the style props: <View style={styles.container}>\n<View style={styles.item1}>\n<Text style={{fontSize:20, color:\"#fff\"}}>Item number 1</Text>\n</View>\n<View style={styles.item2}>\n<Text style={{fontSize:20, color:\"#fff\"}}>Item number 1</Text>\n</View>\n<View style={styles.item3}>\n<Text style={{fontSize:20, color:\"#fff\"}}>Item number 1</Text>\n</View>\n<View style={styles.item4}>\n<Text style={{fontSize:20, color:\"#fff\"}}>Item number 1</Text>\n</View>\n</View> <View style={styles.container}>\n<View style={styles.item1}>\n<Text style={{fontSize:20, color:\"#fff\"}}>Item number 1</Text>\n</View>\n<View style={styles.item2}>\n<Text style={{fontSize:20, color:\"#fff\"}}>Item number 1</Text>\n</View>\n<View style={styles.item3}>\n<Text style={{fontSize:20, color:\"#fff\"}}>Item number 1</Text>\n</View>\n<View style={styles.item4}>\n<Text style={{fontSize:20, color:\"#fff\"}}>Item number 1</Text>\n</View>\n</View> 3 ) styled-components in React Native 3 ) styled-components in React Native We can also use styled-components with React native so you can write your styles in React Native as you write normal CSS. It is very easy to include it in your project and it doesn\u2019t need any linking just run this following command inside the root directory of your app to install it: yarn add styled-components import React, {Component} from 'react';\nimport { StyleSheet,Text, View} from 'react-native';\nimport styled from 'styled-components'\nconst Container=styled.View`\n   flex:1;\n   padding:50px 0;\n   justify-content:center;\n   background-color:#f4f4f4;\n   align-items:center\n`\nconst Title=styled.Text`\nfont-size:20px;\ntext-align:center;\ncolor:red;\n`\nconst Item=styled.View`\nflex:1;\nborder:1px solid #ccc;\nmargin:2px 0;\nborder-radius:10px;\nbox-shadow:0 0 10px #ccc;\nbackground-color:#fff;\nwidth:80%;\npadding:10px;\n\n`\n\nexport default class App extends Component {\n render() {\n   return (\n     <Container>\n            <Item >\n            <Title >Item number 1</Title>\n            </Item>\n            <Item >\n            <Title >Item number 2</Title>\n            </Item>\n            <Item >\n            <Title >Item number 3</Title>\n            </Item>\n            <Item >\n            <Title >Item number  4</Title>\n            </Item>\n     </Container>\n   );\n } import React, {Component} from 'react';\nimport { StyleSheet,Text, View} from 'react-native';\nimport styled from 'styled-components'\nconst Container=styled.View`\n   flex:1;\n   padding:50px 0;\n   justify-content:center;\n   background-color:#f4f4f4;\n   align-items:center\n`\nconst Title=styled.Text`\nfont-size:20px;\ntext-align:center;\ncolor:red;\n`\nconst Item=styled.View`\nflex:1;\nborder:1px solid #ccc;\nmargin:2px 0;\nborder-radius:10px;\nbox-shadow:0 0 10px #ccc;\nbackground-color:#fff;\nwidth:80%;\npadding:10px;\n\n`\n\nexport default class App extends Component {\n render() {\n   return (\n     <Container>\n            <Item >\n            <Title >Item number 1</Title>\n            </Item>\n            <Item >\n            <Title >Item number 2</Title>\n            </Item>\n            <Item >\n            <Title >Item number 3</Title>\n            </Item>\n            <Item >\n            <Title >Item number  4</Title>\n            </Item>\n     </Container>\n   );\n }",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. How To Use Routing with React Navigation in React Native ?",
        "answer": "One of the popular libraries for routing and navigation in a React Native application is React Navigation. This library helps solve the problem of navigating between multiple screens and sharing data between them. import * as React from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\n\nconst Stack = createStackNavigator();\n\nconst MyStack = () => {\n return (\n   <NavigationContainer>\n     <Stack.Navigator>\n       <Stack.Screen\n         name=\"Home\"\n         component={HomeScreen}\n         options={{ title: 'Welcome' }}\n       />\n       <Stack.Screen name=\"Profile\" component={ProfileScreen} />\n     </Stack.Navigator>\n   </NavigationContainer>\n );\n}; import * as React from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\n\nconst Stack = createStackNavigator();\n\nconst MyStack = () => {\n return (\n   <NavigationContainer>\n     <Stack.Navigator>\n       <Stack.Screen\n         name=\"Home\"\n         component={HomeScreen}\n         options={{ title: 'Welcome' }}\n       />\n       <Stack.Screen name=\"Profile\" component={ProfileScreen} />\n     </Stack.Navigator>\n   </NavigationContainer>\n );\n};",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Explain FlatList components, what are its key features along with a code sample ?",
        "answer": "The FlatList component displays similarly structured data in a scrollable list. It works well for large lists of data where the number of list items might change over time. Key Feature: Key Feature: The FlatList shows only those rendered elements which are currently displaying on the screen, not all the elements of the list at once. import React, { Component } from 'react';  \nimport { AppRegistry, FlatList,  \n   StyleSheet, Text, View,Alert } from 'react-native';  \n\nexport default class FlatListBasics extends Component {  \n \n   renderSeparator = () => {  \n       return (  \n           <View  \n               style={{  \n                   height: 1,  \n                   width: \"100%\",  \n                   backgroundColor: \"#000\",  \n               }}  \n           />  \n       );  \n   };  \n   //handling onPress action  \n   getListViewItem = (item) => {  \n       Alert.alert(item.key);  \n   }  \n \n   render() {  \n       return (  \n           <View style={styles.container}>  \n               <FlatList  \n                   data={[  \n                       {key: 'Android'},{key: 'iOS'}, {key: 'Java'},{key: 'Swift'},  \n                       {key: 'Php'},{key: 'Hadoop'},{key: 'Sap'},  \n                   ]}  \n                   renderItem={({item}) =>  \n                       <Text style={styles.item}  \n                             onPress={this.getListViewItem.bind(this, item)}>{item.key}</Text>}  \n                   ItemSeparatorComponent={this.renderSeparator}  \n               />  \n           </View>  \n       );  \n   }  \n}  \nAppRegistry.registerComponent('AwesomeProject', () => FlatListBasics); import React, { Component } from 'react';  \nimport { AppRegistry, FlatList,  \n   StyleSheet, Text, View,Alert } from 'react-native';  \n\nexport default class FlatListBasics extends Component {  \n \n   renderSeparator = () => {  \n       return (  \n           <View  \n               style={{  \n                   height: 1,  \n                   width: \"100%\",  \n                   backgroundColor: \"#000\",  \n               }}  \n           />  \n       );  \n   };  \n   //handling onPress action  \n   getListViewItem = (item) => {  \n       Alert.alert(item.key);  \n   }  \n \n   render() {  \n       return (  \n           <View style={styles.container}>  \n               <FlatList  \n                   data={[  \n                       {key: 'Android'},{key: 'iOS'}, {key: 'Java'},{key: 'Swift'},  \n                       {key: 'Php'},{key: 'Hadoop'},{key: 'Sap'},  \n                   ]}  \n                   renderItem={({item}) =>  \n                       <Text style={styles.item}  \n                             onPress={this.getListViewItem.bind(this, item)}>{item.key}</Text>}  \n                   ItemSeparatorComponent={this.renderSeparator}  \n               />  \n           </View>  \n       );  \n   }  \n}  \nAppRegistry.registerComponent('AwesomeProject', () => FlatListBasics);",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. What are Touchable components in react Native and which one to use when ?",
        "answer": "Tapping gestures can be captured by Touchable components and can display feedback when a gesture is recognized. Depending on what kind of feedback you want to provide we choose Touchable Components. Generally, we use TouchableHighlight anywhere you would use a button or link on the web. The background of the view will be darkened when the user presses down on the button. We can use TouchableNativeFeedback on Android to display ink surface reaction ripples that respond to the user's touch. TouchableOpacity can be used to provide feedback by reducing the opacity of the button, allowing the background to be seen through while the user is pressing down. If we need to handle a tap gesture but you don't want any feedback to be displayed, use TouchableWithoutFeedback. import React, { Component } from 'react';\nimport { Platform, StyleSheet, Text, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback, View } from 'react-native';\nexport default class Touchables extends Component {\n_onPressButton() {\n   alert('You tapped the button!')  }\n _onLongPressButton() {\n   alert('You long-pressed the button!')\n }\nrender() {\nreturn (\n<View style={styles.container}>\n<TouchableHighlight onPress={this._onPressButton} underlayColor=\"white\">\n<View style={styles.button}>\n<Text style={styles.buttonText}>TouchableHighlight</Text>\n</View>\n</TouchableHighlight>\n);}\n} import React, { Component } from 'react';\nimport { Platform, StyleSheet, Text, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback, View } from 'react-native';\nexport default class Touchables extends Component {\n_onPressButton() {\n   alert('You tapped the button!')  }\n _onLongPressButton() {\n   alert('You long-pressed the button!')\n }\nrender() {\nreturn (\n<View style={styles.container}>\n<TouchableHighlight onPress={this._onPressButton} underlayColor=\"white\">\n<View style={styles.button}>\n<Text style={styles.buttonText}>TouchableHighlight</Text>\n</View>\n</TouchableHighlight>\n);}\n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. How can you write different code for IOS and Android in the same code base ? Is there any module available for this ?",
        "answer": "The platform module detects the platform in which the app is running. import { Platform, Stylesheet } from 'react-native';\nconst styles = Stylesheet.create({\nheight: Platform.OS === 'IOS' ? 200 : 400\n}) import { Platform, Stylesheet } from 'react-native';\nconst styles = Stylesheet.create({\nheight: Platform.OS === 'IOS' ? 200 : 400\n}) Additionally Platform.select method available that takes an object containing Platform.OS as keys and returns the value for the platform you are currently on. import { Platform, StyleSheet } from 'react-native';\nconst styles = StyleSheet.create({\n container: {\nflex: 1,\n   ...Platform.select({\n     ios: {\n       backgroundColor: 'red',\n     },\n     android: {\n       backgroundColor: 'green',\n     },\n     default: {\n       // other platforms, web for example\n       backgroundColor: 'blue',\n     },    }),\n},\n}); import { Platform, StyleSheet } from 'react-native';\nconst styles = StyleSheet.create({\n container: {\nflex: 1,\n   ...Platform.select({\n     ios: {\n       backgroundColor: 'red',\n     },\n     android: {\n       backgroundColor: 'green',\n     },\n     default: {\n       // other platforms, web for example\n       backgroundColor: 'blue',\n     },    }),\n},\n});",
        "reference": "interviewbit.com"
    },
    {
        "question": "8. What is ListView and describe its use in React Native ?",
        "answer": "React Native ListView is a view component that contains the list of items and displays it in a vertically scrollable list. export default class MyListComponent extends Component {  \nconstructor() {  \nsuper();  \nconst ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});  \nthis.state = {  \ndataSource: ds.cloneWithRows(['Android','iOS', 'Java','Php', 'Hadoop', 'Sap', 'Python','Ajax', 'C++']), \n};\n}  \nrender() {  \nreturn ( \n<ListView \ndataSource={this.state.dataSource}  \nrenderRow={  \n(rowData) =>  \n<Text style={{fontSize: 30}}>{rowData}</Text>} />  \n); }  \n} export default class MyListComponent extends Component {  \nconstructor() {  \nsuper();  \nconst ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});  \nthis.state = {  \ndataSource: ds.cloneWithRows(['Android','iOS', 'Java','Php', 'Hadoop', 'Sap', 'Python','Ajax', 'C++']), \n};\n}  \nrender() {  \nreturn ( \n<ListView \ndataSource={this.state.dataSource}  \nrenderRow={  \n(rowData) =>  \n<Text style={{fontSize: 30}}>{rowData}</Text>} />  \n); }  \n}",
        "reference": "interviewbit.com"
    },
    {
        "question": "9. What is a bridge and why is it used in React Native ? Explain for both android and IOS ?",
        "answer": "Bridge in ReactNative is a layer or simply a connection that is responsible for gluing \ntogether Native and JavaScript environments.  Consider Below diagram: Consider Below diagram:   The layer which is closest to the device on which the application runs is the Native Layer.\n  The bridge is basically a transport layer which acts as a connection between Javascript and Native modules, it does the work of transporting asynchronous serialized batched response messages from JavaScript to Native modules.\n\nNow for an example, there is some state change that happens, because of which React Native will batch Update UI and send it to the Bridge. The bridge will pass this Serialized batched response to the Native layer, which will process all commands that it can distinguish from a serialized batched response and will update the User Interface accordingly.\n\nIOS Platform: The layer which is closest to the device on which the application runs is the Native Layer.  The bridge is basically a transport layer which acts as a connection between Javascript and Native modules, it does the work of transporting asynchronous serialized batched response messages from JavaScript to Native modules.\n\nNow for an example, there is some state change that happens, because of which React Native will batch Update UI and send it to the Bridge. The bridge will pass this Serialized batched response to the Native layer, which will process all commands that it can distinguish from a serialized batched response and will update the User Interface accordingly.\n\nIOS Platform:     IOS Platform: IOS Platform:    Android Platform:  Android Platform: Android Platform:       ",
        "reference": "interviewbit.com"
    },
    {
        "question": "10. How is the entire React Native code processed to show the final output on a mobile screen",
        "answer": "At the first start of the app, the main thread starts execution and starts loading JS bundles.\nWhen JavaScript code has been loaded successfully, the main thread sends it to another JS thread because when JS does some heavy calculations stuff the thread for a while, the UI thread will not suffer at all times.\nWhen React starts rendering, Reconciler starts \u201cdiffing\u201d, and when it generates a new virtual DOM(layout) it sends changes to another thread(Shadow thread).\nShadow thread calculates layout and then sends layout parameters/objects to the main(UI) thread. ( Here you may wonder why we call it \u201cshadow\u201d? It\u2019s because it generates shadow nodes )\nSince only the main thread is able to render something on the screen, the shadow thread should send the generated layout to the main thread, and only then UI renders. At the first start of the app, the main thread starts execution and starts loading JS bundles. When JavaScript code has been loaded successfully, the main thread sends it to another JS thread because when JS does some heavy calculations stuff the thread for a while, the UI thread will not suffer at all times. When React starts rendering, Reconciler starts \u201cdiffing\u201d, and when it generates a new virtual DOM(layout) it sends changes to another thread(Shadow thread). Shadow thread calculates layout and then sends layout parameters/objects to the main(UI) thread. ( Here you may wonder why we call it \u201cshadow\u201d? It\u2019s because it generates shadow nodes ) Since only the main thread is able to render something on the screen, the shadow thread should send the generated layout to the main thread, and only then UI renders.",
        "reference": "interviewbit.com"
    },
    {
        "question": "1. How to make your React Native app feel smooth on animations ?",
        "answer": "The primary reason and an important one why well-built native apps feel so smooth are by avoiding expensive operations during interactions and animations. React Native has a  limitation that there is only a single JS execution thread, but you can use InteractionManager to make sure long-running work is scheduled to start after any interactions/animations have completed. Applications can schedule tasks to run after interactions with the following: InteractionManager.runAfterInteractions(() => {\n // ...long-running synchronous task...\n}); InteractionManager.runAfterInteractions(() => {\n // ...long-running synchronous task...\n});",
        "reference": "interviewbit.com"
    },
    {
        "question": "2. Explain setNativeProps. Does it create Performance issues and how is it used ?",
        "answer": "It is sometimes necessary to make changes directly to a component without using state/props to trigger a re-render of the entire subtree. When using React in the browser, for example, you sometimes need to directly modify a DOM node, and the same is true for views in mobile apps. setNativeProps is the React Native equivalent to setting properties directly on a DOM node.\nUse setNativeProps when frequent re-rendering creates a performance bottleneck.\n\nDirect manipulation will not be a tool that you reach for frequently; you will typically only be using it for creating continuous animations to avoid the overhead of rendering the component hierarchy and reconciling many views. setNativeProps is imperative and stores state in the native layer (DOM, UIView, etc.) and not within your React components, which makes your code more difficult to reason about. Before you use it, try to solve your problem with setState and shouldComponentUpdate.   ",
        "reference": "interviewbit.com"
    },
    {
        "question": "3. What is Network Security and SSL Pinning?",
        "answer": "Understanding of SSL: Understanding of SSL: SSL (Secure Sockets Layer) and its successor, TLS (Transport Layer Security), are protocols for establishing authenticated and encrypted links between networked computers.\nSSL/TLS works by binding the identities of entities such as websites and companies to cryptographic key pairs via digital documents known as X.509 certificates. Each key pair consists of a private key and a public key. The private key is kept secure, and the public key can be widely distributed via a certificate.\n\nUnderstanding of pinning \nPinning is an optional mechanism that can be used to improve the security of a service or site that relies on SSL Certificates. Pinning allows specifying a cryptographic identity that should be accepted by users visiting site/app\n         \nWhy do we need SSL pinning?    Understanding of pinning    Why do we need SSL pinning? One of the inherent risks to the SSL ecosystem is mis-issuance. This is when an unauthorized certificate is issued for a domain/host you control. This can happen with both public and private PKIs (Public Key Infrastructure) How is SSL pinning used in Mobile applications?\nWhen mobile applications communicate with the server, they typically use SSL to protect the transmitted data against tampering. By default SSL implementations used, apps trust any server with a certificate trusted by the Operating systems trust store, This store is a list of certificate authorities that are shipped with the operating system.  How is SSL pinning used in Mobile applications?    With SSL pinning, however, the application is configured to reject all but one or few predefined certificates, whenever the application connects to a server, it compares the server certificate with the pinned certificate(s) , if and only if they match the server is trusted and SSL connection is established.  ",
        "reference": "interviewbit.com"
    },
    {
        "question": "4. Is there any out of the box way storing sensitive data in React ? If yes which and if not how can this be achieved ?",
        "answer": "React Native does not come bundled with any way of storing sensitive data. However, there are pre-existing solutions for Android and iOS platforms. iOS - Keychain Services\nKeychain Services allows you to securely store small chunks of sensitive info for the user. This is an ideal place to store certificates, tokens, passwords, and any other sensitive information that doesn\u2019t belong in Async Storage.\n\nAndroid - Secure Shared Preferences#\nShared Preferences is the Android equivalent for a persistent key-value data store. Data in Shared Preferences is not encrypted by default, but Encrypted Shared Preferences wraps the Shared Preferences class for Android, and automatically encrypts keys and values.\n\nAndroid - Keystore\nThe Android Keystore system lets you store cryptographic keys in a container to make it more difficult to extract from the device. In order to use iOS Keychain services or Android Secure Shared Preferences, you can either write a bridge yourself or use a library that wraps them for you and provides a unified API at your own risk. Some libraries to consider: iOS - Keychain Services    Android - Secure Shared Preferences#    Android - Keystore  Expo-secure-store\nReact-native-keychain\nreact-native-sensitive-info - secure for iOS, but uses Android Shared Preferences for Android (which is not secure by default). There is however a branch that uses Android Keystore. Expo-secure-store React-native-keychain react-native-sensitive-info - secure for iOS, but uses Android Shared Preferences for Android (which is not secure by default). There is however a branch that uses Android Keystore.",
        "reference": "interviewbit.com"
    },
    {
        "question": "5. Describe Memory leak Issue in React Native , how can it be detected and resolved ?",
        "answer": "In JavaScript memory is managed automatically by Garbage Collector (GC). In short, Garbage Collector is a background process that periodically traverses the graph of allocated objects and their references. If it happens to encounter a part of the graph that is not being referenced directly or indirectly from root objects (e.g., variables on the stack or a global object like window or navigator) that whole part can be deallocated from the memory.\n\nIn React Native world each JS module scope is attached to a root object. Many modules, including React Native core ones, declare variables that are kept in the main scope (e.g., when you define an object outside of a class or function in your JS module). Such variables may retain other objects and hence prevent them from being garbage collected.\n\nSome Causes of Memory Leak:     Some Causes of Memory Leak: Unreleased timers/listeners added in componentDidMount\nClosure scope leaks Unreleased timers/listeners added in componentDidMount Closure scope leaks Detecting memory leaks for IOS:\n\nIn Xcode,\n\nGo to XCode \u2192 Product \u2192 Profile (\u2318 + i)\n\nAfter that shows you all templates choose leaks.\n\nDetecting memory leaks for Android :\n\nRun React Native app normally (react-native run-android)\nRun Android Studio\n\nOn the menu,\nclick Tools \u2192 Android \u2192 Enable ADB Integration\nClick Tools \u2192 Android \u2192 Android Device Monitor\nWhen Android Device Monitor shows up, click Monitor \u2192 Preferences\n\nThere is also one more way in Android\nPerf Monitor (Performance Monitor) is a good choice to use for android leak monitoring. Detecting memory leaks for IOS:         Detecting memory leaks for Android :            Import PerfMonitor from 'react-native/Libraries/Performance/RCTRenderingPerf';\nPerfMonitor.toggle();\nPerfMonitor.start();\nsetTimeout(() => {\n PerfMonitor.stop();\n}, 20000);\n}, 5000); Import PerfMonitor from 'react-native/Libraries/Performance/RCTRenderingPerf';\nPerfMonitor.toggle();\nPerfMonitor.start();\nsetTimeout(() => {\n PerfMonitor.stop();\n}, 20000);\n}, 5000);",
        "reference": "interviewbit.com"
    },
    {
        "question": "6. List down some of the steps to optimize the application.",
        "answer": "Use Proguard to minimize the application size.(It does this by stripping parts of the React Native Java bytecode (and its dependencies) that your app is not using)\nCreate reduced-sized APK files for specific CPU architectures. When you do that, your app users will automatically get the relevant APK file for their specific phone\u2019s architecture. This eliminates the need to keep JSCore binaries that support multiple architectures and consequently reduces the app size.\nCompress images and other graphic elements. Another option to reduce image size is using file types like APNG in place of PNG files.\nDon\u2019t store raw JSON data,  eIther we need to Compress it or convert it into static object IDs.\nOptimize native libraries.\nOptimize the number of state operations and remember to use pure and memoized components when needed\nUse Global State wisely for example worst-case scenario is when state change of single control like TextInput or CheckBox propagates render of the whole application. Use libraries like Redux or Overmind.js to handle your state management in a more optimized way.\nUse key attribute on list items, it helps React Native to pick which list to update when rendering a long list of data \nUse VirtualizedList, FlatList, and SectionList for large data sets.\nClear all the active timers which may lead to heavy memory leakage issues. Use Proguard to minimize the application size.(It does this by stripping parts of the React Native Java bytecode (and its dependencies) that your app is not using) Create reduced-sized APK files for specific CPU architectures. When you do that, your app users will automatically get the relevant APK file for their specific phone\u2019s architecture. This eliminates the need to keep JSCore binaries that support multiple architectures and consequently reduces the app size. Compress images and other graphic elements. Another option to reduce image size is using file types like APNG in place of PNG files. Don\u2019t store raw JSON data,  eIther we need to Compress it or convert it into static object IDs. Optimize native libraries. Optimize the number of state operations and remember to use pure and memoized components when needed Use Global State wisely for example worst-case scenario is when state change of single control like TextInput or CheckBox propagates render of the whole application. Use libraries like Redux or Overmind.js to handle your state management in a more optimized way. Use key attribute on list items, it helps React Native to pick which list to update when rendering a long list of data Use VirtualizedList, FlatList, and SectionList for large data sets. Clear all the active timers which may lead to heavy memory leakage issues.",
        "reference": "interviewbit.com"
    },
    {
        "question": "7. What\u2019s the real cause behind performance issues in React Native ?",
        "answer": "The real cause behind React Native performance issues is that each thread (i.e Native and JS thread) is blazingly fast. The performance bottleneck in React Native app occurs when you\u2019re passing the components from one thread to another unnecessarily or more than required. A major thumb rule to avoid any kind of performance-related issue in React Native is to keep the passes over the bridge to a minimum. Native thread built for running Java/ Kotlin, Swift/ Objective C\nJavascript thread is the primary thread that runs everything from javascript-based animations to other UI components\nThe bridge as the name suggests acts as an  intermediate communication point for the native and JS thread Native thread built for running Java/ Kotlin, Swift/ Objective C Javascript thread is the primary thread that runs everything from javascript-based animations to other UI components The bridge as the name suggests acts as an  intermediate communication point for the native and JS thread",
        "reference": "interviewbit.com"
    }
]