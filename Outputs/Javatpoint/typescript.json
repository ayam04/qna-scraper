[
    {
        "question": "1) What is Typescript?",
        "answer": "TypeScript is a free and open-source programming language developed and maintained by Microsoft. It is a strongly typed superset of JavaScript that compiles to plain JavaScript. It is a language for application-scale JavaScript development. TypeScript is quite easy to learn and use for developers familiar with C#, Java and all strong typed languages.\nTypeScript can be executed on Any browser, Any Host, and Any Operating System. TypeScript is not directly run on the browser. It needs a compiler to compile and generate in JavaScript file. TypeScript is the ES6 version of JavaScript with some additional features.",
        "reference": "javatpoint.com"
    },
    {
        "question": "2) How is TypeScript different from JavaScript?",
        "answer": "TypeScript is different from JavaScript in the following manner:\nSN JavaScript TypeScript\n1 It was developed by Netscape in 1995. It was developed by Anders Hejlsberg in 2012.\n2 JavaScript source file is in \".js\" extension. TypeScript source file is in \".ts\" extension.\n3 JavaScript doesn't support ES6. TypeScript supports ES6.\n4 It doesn't support strongly typed or static typing. It supports strongly typed or static typing feature.\n5 It is just a scripting language. It supports object-oriented programming concept like classes, interfaces, inheritance, generics, etc.\n6 JavaScript has no optional parameter feature. TypeScript has optional parameter feature.\n7 It is interpreted language that's why it highlighted the errors at runtime. It compiles the code and highlighted errors during the development time.\n8 JavaScript doesn't support modules. TypeScript gives support for modules.\n9 In this, number, string are the objects. In this, number, string are the interface.\n10 JavaScript doesn't support generics. TypeScript supports generics.\nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "3) Why do we need TypeScript?",
        "answer": "We need TypeScript:\nADVERTISEMENT\nTypeScript is fast, simple, and most importantly, easy to learn.\nTypeScript supports object-oriented programming features such as classes, interfaces, inheritance, generics, etc.\nTypeScript provides the error-checking feature at compilation time. It will compile the code, and if any error found, then it highlighted the errors before the script is run.\nTypeScript supports all JavaScript libraries because it is the superset of JavaScript.\nTypeScript support reusability by using the inheritance.\nTypeScript make app development quick and easy as possible, and the tooling support of TypeScript gives us autocompletion, type checking, and source documentation.\nTypeScript supports the latest JavaScript features including ECMAScript 2015.\nTypeScript gives all the benefits of ES6 plus more productivity.\nTypeScript supports Static typing, Strongly type, Modules, Optional Parameters, etc.",
        "reference": "javatpoint.com"
    },
    {
        "question": "4) List some features of Typescript?",
        "answer": "To know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "5) List some benefits of using Typescript?",
        "answer": "TypeScript has the following benefits.\nIt provides the benefits of optional static typing. Here, Typescript provides types that can be added to variables, functions, properties, etc.\nTypescript has the ability to compile down to a version of JavaScript that runs on all browsers.\nTypeScript always highlights errors at compilation time during the time of development whereas JavaScript points out errors at the runtime.\nTypeScript supports strongly typed or static typing whereas this is not in JavaScript.\nIt helps in code structuring.\nIt uses class-based object-oriented programming.\nIt provides excellent tooling supports with IntelliSense which provides active hints as the code is added.\nIt has a namespace concept by defining a module.",
        "reference": "javatpoint.com"
    },
    {
        "question": "6) What are the disadvantages of TypeScript?",
        "answer": "TypeScript has the following disadvantages:\nTypeScript takes a long time to compile the code.\nTypeScript does not support abstract classes.\nIf we run the TypeScript application in the browser, a compilation step is required to transform TypeScript into JavaScript.\nWeb developers are using JavaScript from decades and TypeScript doesn?t bring anything new.\nTo use any third party library, the definition file is must. And not all the third party library have definition file available.\nQuality of type definition files is a concern as for how can you be sure the definitions are correct?",
        "reference": "javatpoint.com"
    },
    {
        "question": "7) What are the different components of TypeScript?",
        "answer": "The TypeScript has mainly three components. These are-\n\nLanguage\nThe language comprises elements like new syntax, keywords, type annotations, and allows us to write TypeScript.\nCompiler\nThe TypeScript compiler is open source, cross-platform, and is written in TypeScript. It transforms the code written in TypeScript equivalent to its JavaScript code. It performs the parsing, type checking of our TypeScript code to JavaScript code. It can also help in concatenating different files to the single output file and in generating source maps.\nLanguage Service\nThe language service provides information which helps editors and other tools to give better assistance features such as automated refactoring and IntelliSense.\nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "8) Who developed Typescript and what is the current stable version of Typescript?",
        "answer": "The typescript was developed by Anders Hejlsberg, who is also one of the core members of the development team of C# language. The typescript was first released in the month of October 1st, 2012 and was labeled version 0.8. It is developed and maintained by Microsoft under the Apache 2 license. It was designed for the development of a large application.\nThe current stable version of TypeScript is 3.2 which was released on September 30, 2018. Typescript compiles to simple JavaScript code which runs on any browser that supports ECMAScript 2015 framework. It offers support for the latest and evolving JavaScript features.",
        "reference": "javatpoint.com"
    },
    {
        "question": "OR how can we get TypeScript and install it?",
        "answer": "TypeScript can be installed and managed with the help of node via npm (the Node.js package manager). To install TypeScript, first ensure that the npm is installed correctly, then run the following command which installs TypeScript globally on the system.\n$ npm install -g typescript  \nIt installs a command line code \"tsc\" which will further be used to compile our Typescript code. Make sure that we check the version of Typescript installed on the system.\nFollowing steps are involved for installing TypeScript:\nDownload and run the .msi installer for the node.\nEnter the command \"node -v\" to check if the installation was successful.\nType the following command in the terminal window to install Typescript: $ npm install -g typescript\n\nTo know installation process click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "The built-in data types are also known as primitive data types in Typescript. These are given below.\n\nNumber type: It is used to represent number type values. All the numbers in TypeScript are stored as floating point values.\nSyntax: let identifier: number = value;\nString type: It represents a sequence of characters stored as Unicode UTF-16 code. We include string literals in our scripts by enclosing them in single or double quotation marks.\nSyntax: let identifier: string = \" \";\n\nBoolean type: It is used to represent a logical value. When we use the Boolean type, we get output only in true or false. A Boolean value is a truth value that specifies whether the condition is true or not.\nSyntax: let identifier: bool = Boolean value;\nNull type: Null represents a variable whose value is undefined. It is not possible to directly reference the null type value itself. Null type is not useful because we can only assign a null value to it.\nSyntax: let num: number = null;\nUndefined type: It is the type of undefined literal. The Undefined type denotes all uninitialized variables. It is not useful because we can only assign an undefined value to it. This type of built-in type is the sub-type of all the types.\nSyntax: let num: number = undefined;\nVoid type: A void is the return type of the functions that do not return any type of value. It is used where no datatype is available.\nSyntax: let unusable: void = undefined;\nTo know TypeScript datatypes in detail click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "11) What are the variables in Typescript? How to create a variable in Typescript?",
        "answer": "A variable is the storage location, which is used to store value/information to be referenced and used by programs. It acts as a container for value in a program. It can be declared using the var keyword. It should be declared before the use. While declaring a variable in Typescript, certain rules should be followed-\nThe variable name must be an alphabet or numeric digits.\nThe variable name cannot start with digits.\nThe variable name cannot contain spaces and special character, except the underscore(_) and the dollar($) sign.\nWe can declare a variable in one of the four ways:\nDeclare type and value in a single statement. Syntax: var [identifier] : [type-annotation] = value;\nDeclare type without value. Syntax: var [identifier] : [type-annotation];\nDeclare its value without type. Syntax: var [identifier] = value;\nDeclare without value and type. Syntax: var [identifier];\nTo know more in detail click here.https://www.javatpoint.com/typescript-variables",
        "reference": "javatpoint.com"
    },
    {
        "question": "12) How to compile a Typescript file?",
        "answer": "Here is the command which is followed while compiling a Typescript file into JavaScript.\n$ tsc <TypeScript File Name>  \nFor example, to compile \"Helloworld.ts.\"\n$ tsc helloworld.ts  \nThe result would be helloworld.js.",
        "reference": "javatpoint.com"
    },
    {
        "question": "js file? If yes, then how?",
        "answer": "Yes, it is possible. For this, we need to add --outFILE [OutputJSFileName] compiling option.\n$ tsc --outFile comman.js file1.ts file2.ts file3.ts  \nThe above command will compile all three \".ts\"file and result will be stored into single \"comman.js\" file. In the case, when we don't provide an output file name as like in below command.\n$ tsc --outFile file1.ts file2.ts file3.ts  \nThen, the file2.ts and file3.ts will be compiled, and the output will be placed in file1.ts. So now our file1.ts contains JavaScript code.",
        "reference": "javatpoint.com"
    },
    {
        "question": "ts file?",
        "answer": "Yes, it is possible to compile \".ts\" automatically with real-time changes in the .ts file. This can be achieved by using --watch compiler option\ntsc --watch file1.ts  \nThe above command first compiles file1.ts in file1.js and watch for the file changes. If there is any change detected, it will compile the file again. Here, we need to ensure that command prompt must not be closed on running with --watch option.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "An Interface is a structure which acts as a contract in our application. It defines the syntax for classes to follow, it means a class that implements an interface is bound to implement all its members. It cannot be instantiated but can be referenced by the class object that implements it. The TypeScript compiler uses interface for type-checking (also known as \"duck typing\" or \"structural subtyping\") whether the object has a specific structure or not.\nSyntax:\ninterface interface_name {    \n          // variables' declaration    \n          // methods' declaration    \n}    \nThe interface just declares the methods and fields. It cannot be used to build anything. Interfaces need not be converted to JavaScript for execution. They have zero runtime JavaScript impact. Thus, their only purpose is to help in the development stage.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "We know, TypeScript is a type of Object-Oriented JavaScript language and supports OOPs programming features like classes, interfaces, etc. Like Java, classes are the fundamental entities which are used to create reusable components. It is a group of objects which have common properties. A class is a template or blueprint for creating objects. It is a logical entity. The \"class\" keyword is used to declare a class in Typescript.\nExample:\nclass Student {    \n    studCode: number;    \n    studName: string;    \n    constructor(code: number, name: string) {    \n            this.studName = name;    \n            this.studCode = code;    \n    }    \n    getGrade() : string {    \n        return \"A+\" ;    \n    }    \n}    \nFeatures of a class are-\nInheritance\nEncapsulation\nPolymorphism\nAbstraction",
        "reference": "javatpoint.com"
    },
    {
        "question": "17) Is Native Javascript supports modules?",
        "answer": "No. Currently, modules are not supported by Native JavaScript. To create and work with modules in Javascript we require an external like CommonJS.",
        "reference": "javatpoint.com"
    },
    {
        "question": "18) Which object oriented terms are supported by TypeScript?",
        "answer": "TypeScript supports following object oriented terms.\nModules\nClasses\nInterfaces\nInheritance\nData Types\nMember functions",
        "reference": "javatpoint.com"
    },
    {
        "question": "19) How to Call Base Class Constructor from Child Class in TypeScript?",
        "answer": "super() function is used to called parent or base class constructor from Child Class.",
        "reference": "javatpoint.com"
    },
    {
        "question": "20) How do you implement inheritance in TypeScript?",
        "answer": "Inheritance is a mechanism that acquires the properties and behaviors of a class from another class. It is an important aspect of OOPs languages and has the ability which creates new classes from an existing class. The class whose members are inherited is called the base class, and the class that inherits those members is called the derived class.\nAn Inheritance can be implemented by using the extend keyword. We can understand it by the following example.\nclass Shape {     \n   Area:number     \n   constructor(area:number) {     \n      this.Area = area    \n   }     \n}     \nclass Circle extends Shape {     \n   display():void {     \n      console.log(\"Area of the circle: \"+this.Area)     \n   }     \n}    \nvar obj = new Circle(320);     \nobj.display()  //Output: Area of the circle: 320  \nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "21) What are the Modules in Typescript?",
        "answer": "A module is a powerful way to create a group of related variables, functions, classes, and interfaces, etc. It can be executed within their own scope, not in the global scope. In other words, the variables, functions, classes, and interfaces declared in a module cannot be accessible outside the module directly.\nCreating a Module\nA module can be created by using the export keyword and can be used in other modules by using the import keyword.\nmodule module_name{  \n    class xyz{  \n        export sum(x, y){  \n            return x+y;  \n         }  \n    }  \n}  \nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "22) What is the difference between the internal module and the external module?",
        "answer": "The difference between internal and external module is given below:\nSN Internal Module External Module\n1 Internal modules were used to logically group the classes, interfaces, functions, variables into a single unit and can be exported in another module. External modules are useful in hiding the internal statements of the module definitions and show only the methods and parameters associated with the declared variable.\n2 Internal modules were in the earlier version of Typescript. But they are still supported by using namespace in the latest version of TypeScript. External modules are simply known as a module in the latest version of TypeScript.\n3 Internal modules are local or exported members of other modules (including the global module and external modules). External modules are separately loaded bodies of code referenced using external module names.\n4 Internal modules are declared using ModuleDeclarations that specify their name and body. An external module is written as a separate source file that contains at least one import or export declaration.\n5 Example:\nmodule Sum {   \n   export function add(a, b) {    \n      console.log(\"Sum: \" +(a+b));   \n   }   \n} \nExample:\nexport class Addition{  \n    constructor(private x?: number, private y?: number){  \n    }  \n    Sum(){  \n        console.log(\"SUM: \" +(this.x + this.y));  \n    }  \n}\nTo know more in detail click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "23) What is namespace in Typescript? How to declare a namespace in Typescript?",
        "answer": "A namespace is a way that is used for logical grouping of functionalities. Namespaces are used to maintain the legacy code of typescript internally. It encapsulates the features and objects that share certain relationships. A namespace is also known as internal modules. A namespace can also include interfaces, classes, functions, and variables to support a group of related functionalities.\nNote: A namespace can be defined in multiple files and allow to keep each file as they were all defined in one place. It makes code easier to maintain.\nSynatax for creating namespace\nnamespace <namespace_name> {    \n           export interface I1 { }    \n           export class c1{ }    \n}    \nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "24) Explain Decorators in Typescript?",
        "answer": "A Decorator is a special kind of declaration that can be applied to classes, methods, accessor, property, or parameter. Decorators are simply functions that are prefixed @expression symbol, where expression must evaluate to a function that will be called at runtime with information about the decorated declaration.\nTypeScript Decorators serves the purpose of adding both annotations and metadata to the existing code in a declarative way. Decorators are an experimental feature proposed for ES7. It is already in use by some of the JavaScript frameworks including Angular 2. The Decorators may change in future releases.\nTo enable experimental support for decorators, we must enable the experimentalDecorators compiler option either on the command line or in our tsconfig.json:\n\nCommand Line\n$tsc --target ES5 --experimentalDecorators    \ntsconfig.json\n{    \n    \"compilerOptions\": {    \n        \"target\": \"ES5\",    \n        \"experimentalDecorators\": true    \n    }    \n}    \nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "25) What are Mixins?",
        "answer": "In Javascript, Mixins are a way of building up classes from reusable components is to build them by combining simpler partial classes called mixins.\nThe idea is simple, instead of a class A extending class B to get its functionality, function B takes class A and returns a new class with this added functionality. Function B is a mixin.",
        "reference": "javatpoint.com"
    },
    {
        "question": "26) What is default visibility for properties/methods in TypeScript classes?",
        "answer": "Public is the default visibility for properties/methods in TypeScript classes.",
        "reference": "javatpoint.com"
    },
    {
        "question": "27) How does TypeScript support optional parameters in function as in JavaScript every parameter is optional for a function?",
        "answer": "Unlike JavaScript, the TypeScript compiler will throw an error if we try to invoke a function without providing the exact number and types of parameters as declared in its function signature. To overcome this problem, we can use optional parameters by using question mark sign ('?'). It means that the parameters which may or may not receive a value can be appended with a '?' to mark them optional.\nfunction Demo(arg1: number, arg2? :number) {              \n}So, arg1 is always required, and arg2 is an optional parameter.   \nSo, arg1 is always required, and arg2 is an optional parameter.\nNote: Optional parameters must follow the required parameters. If we want to make arg1 optional, instead of arg2, then we need to change the order and arg1 must be put after arg2.\nfunction Demo(arg2: number, arg1? :number) {  \n}  \nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "28) Does TypeScript supports function overloading as JavaScript doesn't support function overloading?",
        "answer": "Yes, TypeScript support function overloading. But the implementation is odd. When we perform function overloading in TypeScript, then we can implement only one functions with multiple signatures.\n//Function with string type parameter    \nfunction add(a:string, b:string): string;    \n  //Function with number type parameter    \nfunction add(a:number, b:number): number;    \n  //Function Definition    \nfunction add(a: any, b:any): any {    \n    return a + b;    \n}    \nIn the above example, the first two lines are the function overload declaration. It has two overloads. The first signature has a parameter of type string whereas the second signature has a parameter of type number. The third function contains the actual implementation and has a parameter of type any. Any data type can take any type of data. The implementation then checks for the type of the supplied parameter and execute a different piece of code based on supplier parameter type.",
        "reference": "javatpoint.com"
    },
    {
        "question": "29) Is it possible to debug any TypeScript file?",
        "answer": "Yes, it is possible. To debug any TypeScript file, we need .js source map file. So compile the .ts file with the --sourcemap flag to generate a source map file.\n$ tsc -sourcemap file1.ts  \nThis will create file1.js and file1.js.map. And last line of file1.js would be reference of source map file.\n//# sourceMappingURL=file1.js.map",
        "reference": "javatpoint.com"
    },
    {
        "question": "30) What is TypeScript Definition Manager and why do we need it?",
        "answer": "TypeScript Definition Manager (TSD) is a package manager used to search and install TypeScript definition files directly from the community-driven DefinitelyTyped repository.\nSuppose, we want to use some jQuery code in our .ts file.\n$(document).ready(function() { //Your jQuery code });",
        "reference": "javatpoint.com"
    },
    {
        "question": "31) What is TypeScript Declare Keyword?",
        "answer": "We know that all JavaScript libraries/frameworks don't have TypeScript declaration files, but we want to use them in our TypeScript file without any compilation errors. To do this, we use the declare keyword. The declare keyword is used for ambient declarations and methods where we want to define a variable that may exist elsewhere.\nFor example, suppose we have a library called myLibrary that doesn't have a TypeScript declaration file and have a namespace called myLibrary in the global namespace. If we want to use that library in our TypeScript code, we can use the following code:\ndeclare var myLibrary;  \nTypeScript runtime will assign the myLibrary variable as any type. Here is a problem that we won't get Intellisense in design time but we will be able to use the library in our code.",
        "reference": "javatpoint.com"
    },
    {
        "question": "ts file?",
        "answer": "We can generate TypeScript definition file from any .ts file by using tsc compiler. It will be generating a TypeScript definition which makes our TypeScript file reusable.\ntsc --declaration file1.ts",
        "reference": "javatpoint.com"
    },
    {
        "question": "json file?",
        "answer": "The tsconfig.json file is a file which is in JSON format. In the tsconfig.json file, we can specify various options to tell the compiler how to compile the current project. The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. Below is a sample tsconfig.json file.\n{  \n   \"compilerOptions\": {  \n      \"declaration\": true,      \n      \"emitDecoratorMetadata\": false,      \n      \"experimentalDecorators\": false,      \n      \"module\": \"none\",      \n      \"moduleResolution\": \"node\"  \n      \"removeComments\": true,  \n      \"sourceMap\": true  \n   },  \n   \"files\": [  \n      \"main.ts\",  \n      \"othermodule.ts\"  \n    ]  \n}  \nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "34) Explain generics in TypeScript?",
        "answer": "TypeScript Generics is a tool which provides a way to create reusable components. It is able to create components that can work with a variety of data types rather than a single data type. Generics provides type safety without compromising the performance, or productivity. Generics allow us to create generic classes, generic functions, generic methods, and generic interfaces.\nIn generics, a type parameter is written between the open (<) and close (>) brackets which makes it strongly typed collections. Generics use a special kind of type variable <T> that denotes types. The generics collections contain only similar types of objects.\nfunction identity<T>(arg: T): T {      \n    return arg;      \n}      \nlet output1 = identity<string>(\"myString\");      \nlet output2 = identity<number>( 100 );    \nconsole.log(output1);    \nconsole.log(output2);     \nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "35) Does TypeScript support all object-oriented principles?",
        "answer": "Yes, TypeScript support all object-oriented principles. There are four main principles to object-oriented programming:\nEncapsulation,\nInheritance,\nAbstraction, and\nPolymorphism.",
        "reference": "javatpoint.com"
    },
    {
        "question": "36) How to check null and undefined in TypeScript?",
        "answer": "By using a juggling-check, we can check both null and undefined:\nif (x == null) {  \n}  \nIf we use a strict-check, it will always true for values set to null and won't evaluate as true for undefined variables.\nExample\nvar a: number;  \nvar b: number = null;  \nfunction check(x, name) {  \n    if (x == null) {  \n        console.log(name + ' == null');  \n    }  \n    if (x === null) {  \n        console.log(name + ' === null');  \n    }  \n    if (typeof x === 'undefined') {  \n        console.log(name + ' is undefined');  \n    }  \n}  \ncheck(a, 'a');  \ncheck(b, 'b');  \nOutput\n\"a == null\"  \n\"a is undefined\"  \n\"b == null\"  \n\"b === null\"",
        "reference": "javatpoint.com"
    },
    {
        "question": "37) Could we use TypeScript on the backend? If yes, how?",
        "answer": "Yes, we can use TypeScript on the backend. We can understand it with the following example. Here, we choose Node.js and have some additional type safety and the other abstraction that the language brings.\nInstall Typescript compiler\nnpm i -g typescript  \nThe TypeScript compiler takes options in the tsconfig.json file. This file determines where to put built files.\n{  \n  \"compilerOptions\": {  \n    \"target\": \"es5\",  \n    \"module\": \"commonjs\",  \n    \"declaration\": true,  \n    \"outDir\": \"build\"  \n  }  \n}  \nCompile ts files\ntsc  \nRun\nnode build/index.js",
        "reference": "javatpoint.com"
    },
    {
        "question": "38) What is the difference between \"interface vs type\" statements?",
        "answer": "interface X {  \n    a: number  \n    b: string  \n}  \ntype X = {  \n    a: number  \n    b: string  \n};  \nSN interface type\n1 An interface declaration always introduces a named object type. A type alias declaration can introduce a name for any kind of type, including primitive, union, and intersection types.\n2 An interface can be named in an extends or implements clause. Type alias for an object type literal cannot be named in an extends or implements clause.\n3 Interfaces create a new name that is used everywhere. Type aliases don't create a new name.\n4 An interface can have multiple merged declarations. Type alias for an object type literal cannot have multiple merged declarations.",
        "reference": "javatpoint.com"
    },
    {
        "question": "39) What are Ambients in TypeScripts and when to use them?",
        "answer": "Ambient declarations tell the compiler about the actual source code exist elsewhere. If these source codes do not exist at runtime and we try to use them, then it will break without warning.\nAmbient declarations files are like docs file. If the source changes, the docs need to be kept updated also. If the ambient declaration file is not updated, then we will get compiler errors.\nThe Ambient declarations allow us to safely and easily use existing popular JavaScript libraries like jquery, angularjs, nodejs, etc.",
        "reference": "javatpoint.com"
    },
    {
        "question": "40) What is a TypeScript Map file?",
        "answer": "TypeScript Map file is a source map file which holds information about our original files.\n.map files are source map files that let tools map between the emitted JavaScript code and the TypeScript source files that created it.\nMany debuggers can consume these files so we can debug the TypeScript file instead of the JavaScript file.",
        "reference": "javatpoint.com"
    },
    {
        "question": "41) What is Type assertions in TypeScript?",
        "answer": "Type assertion works like a typecasting in other languages, but it doesn't perform type checking or restructuring of data just like other languages can do like C# and Java. The typecasting comes with runtime support whereas type assertion has no impact on runtime. However, type assertions are used purely by the compiler and provide hints to the compiler on how we want our code to be analyzed.\nExample\nlet empCode: any = 111;     \nlet employeeCode = <number> code;     \nconsole.log(typeof(employeeCode)); //Output: number  \nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "42) What is \"as\" syntax in TypeScript?",
        "answer": "The as is the additional syntax for Type assertion in TypeScript. The reason for introducing the as-syntax is that the original syntax (<type>) conflicted with JSX.\nExample\nlet empCode: any = 111;     \nlet employeeCode = code as number;   \nWhen using TypeScript with JSX, only as-style assertions are allowed.",
        "reference": "javatpoint.com"
    },
    {
        "question": "43) What is JSX? Can we use JSX in TypeScript?",
        "answer": "JSX is NOTHING BUT Javascript with a different extension. Facebook came up with this new extension so that they can distinguish from the XML-like implementation of HTML in JavaScript.\nJSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript. JSX came to popularity with the React framework. TypeScript supports embedding, type checking, and compiling JSX directly into JavaScript.\nTo use JSX, we must do two things.\nName the files with a .tsx extension\nEnable the jsx option",
        "reference": "javatpoint.com"
    },
    {
        "question": "44) What is Rest parameters?",
        "answer": "The rest parameter is used to pass zero or more values to a function. It is declared by prefixing the three dot characters ('...')before the parameter. It allows the functions to have a variable number of arguments without using the arguments object. It is very useful where we have an undetermined number of parameters.\nRules to follow in rest parameter:\nOnly one rest parameter is allowed in a function.\nIt must be an array type.\nIt must be a last parameter in the parameter list.\nfunction sum(a: number, ...b: number[]): number {    \n let result = a;    \n for (var i = 0; i < b.length; i++) {    \n result += b[i];    \n }    \n console.log(result);    \n}    \nlet result1 = sum(3, 5);    \nlet result2 = sum(3, 5, 7, 9);   \nTo know more click here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "45) Explain Enum in TypeScript?",
        "answer": "Enums or enumerations are a TypeScipt data type that allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. It is a collection of related values that can be numeric or string values.\nExample\nenum Gender {  \n  Male,  \n  Female  \n  Other  \n}  \nconsole.log(Gender.Female); // Output: 1  \n//We can also access an enum value by it's number value.  \nconsole.log(Gender[1]); // Output: Female",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Non-Relative Relative\nA non-relative import can be resolved relative to baseUrl, or through path mapping. In other words, we use non-relative paths when importing any of our external dependencies.\nExample:\nimport * as $ from \"jquery\";\nimport { Component } from \"@angular/core\";\nRelative imports can be used for our own modules that are guaranteed to maintain their relative location at runtime. A relative import is starts with /, ./ or ../.\nExample:\nimport Entry from \"./components/Entry\";\nimport {DefaultHeaders} from \"../constants/http\";",
        "reference": "javatpoint.com"
    },
    {
        "question": "47) What is an anonymous function?",
        "answer": "An anonymous function is a function that was declared without any named identifier. These functions are dynamically declared at runtime. Anonymous functions can accept inputs and return outputs, just as standard functions do. An anonymous function is usually not accessible after its initial creation.\nExample\nlet myAdd = function(x: number, y: number): number {   \nreturn x + y;   \n};  \nconsole.log(myAdd())",
        "reference": "javatpoint.com"
    },
    {
        "question": "48) What is Declaration Merging?",
        "answer": "Declaration merging is the process followed by the compiler to merge two or more separate declarations. The declaration declared with the same name into a single definition. This merged definition has the features of both of the original declarations.\nThe simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.\nExample\ninterface Cloner {  \n    clone(animal: Animal): Animal;  \n}  \ninterface Cloner {  \n    clone(animal: Sheep): Sheep;  \n}  \ninterface Cloner {  \n    clone(animal: Dog): Dog;  \n    clone(animal: Cat): Cat;  \n}  \nThe three interfaces will merge to create a single declaration as so:\ninterface Cloner {  \n    clone(animal: Dog): Dog;  \n    clone(animal: Cat): Cat;  \n    clone(animal: Sheep): Sheep;  \n    clone(animal: Animal): Animal;  \n}  \nNote: Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or variables.",
        "reference": "javatpoint.com"
    },
    {
        "question": "49) What are method overriding in TypeScript?",
        "answer": "If subclass (child class) has the same method as declared in the parent class, it is known as method overriding. In other words, redefined the base class methods in the derived class or child class.\nRules for Method Overriding\nThe method must have the same name as in the parent class\nThe method must have the same parameter as in the parent class.\nThere must be an IS-A relationship (inheritance).\nExample\nclass NewPrinter extends Printer {  \n    doPrint(): any {  \n        super.doPrint();  \n        console.log(\"Called Child class.\");  \n    }  \n    doInkJetPrint(): any {  \n        console.log(\"Called doInkJetPrint().\");  \n    }  \n}  \nlet printer: new () => NewPrinter;  \nprinter.doPrint();  \nprinter.doInkJetPrint();",
        "reference": "javatpoint.com"
    },
    {
        "question": "50) What is Lambda/Arrow function?",
        "answer": "ES6 version of TypeScript provides shorthand syntax for defining the anonymous function, i.e., for function expressions. These arrow functions are also called Lambda functions. A lambda function is a function without a name. Arrow function omits the function keyword.\nExample\nlet sum = (a: number, b: number): number => {    \n            return a + b;    \n}    \nconsole.log(sum(20, 30)); //returns 50    \nIn the above, the ?=>? is a lambda operator and (a + b) is the body of the function and (a: number, b: number) are inline parameters.\nTo know more click here.",
        "reference": "javatpoint.com"
    }
]