[
    {
        "question": "",
        "answer": "Solution:\nAt least one such element will exist in an array, called the \"Peak element\". We can use many approaches, like iterating the whole array, finding the largest element in the array, etc., to find the element. Here, we'll use the best approach. Remember that we are just asked to write a function. Hence, we can take the array and its size as the two parameters and write the function:\nWay to think:\nWe need an efficient code. It takes O(n) time if we iterate the whole array. But we don't need all the peak elements; we need one. We have to keep searching for the element eliminating parts of the array.\nWe used the Binary search algorithm to eliminate the parts of the array we don't have to traverse. Even though the array isn't sorted, we'll have to find one locally large element.\nCode:\nint Peak(int arr[], int l, int h, int n)  \n{  \n    int i, mid;  \n    mid = l + (h - l)/2;  \n    if((mid == 0) || arr[mid - 1] <= arr[mid] && arr[mid + 1] <= arr[mid])  \n    {  \n        return mid;  \n    }  \n    if(arr[mid - 1] > arr[mid])  \n    {  \n        h = mid - 1;  \n        Peak(arr, l, h, n);  \n    }  \n    if(arr[mid + 1] > arr[mid])  \n    {  \n        l = mid + 1;  \n        Peak(arr, l, h, n);  \n    }  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Solution:\nADVERTISEMENT\nWe can declare two variables, l = 0, h = (n - 1). We can keep swapping the values in the array at l and h by incrementing l and decrementing h till both l and h reach the middle element or till both overtake each other.\nFunction:\nvoid reverse(int l, int h, int arr[])  \n{  \n    if(l >= h)  \n    {  \n        return;  \n    }  \n    int temp;  \n    temp = arr[l];  \n    arr[l] = arr[h];  \n    arr[h] = temp;  \n    reverse(l + 1, h - 1, arr);  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Solution:\nWe're asked to traverse the array only once. We need to use two pointers/ variables to traverse the array. We have two options here:\nUsing two variables pointing from the beginning of the array\nUsing one variable pointing from the beginning and the other from the end.\nVariables from both ends of the array:\nWay to think:\nWe use two variables l and h storing the indexes of the array's first and last elements, respectively. We want to set 0's followed by 1's in the array. The elements traversed by l from the beginning should be 0's, and the elements from the end visited by h should be 1s. We need to swap the elements if l finds a 1 or h finds a 0.\nint* segregation(int arr[], int n)  \n{  \n    int temp, l = 0;  \n    int h = n - 1;  \n    while(l < h)  \n    {  \n        if(arr[l] == 0)  \n        {  \n            l++;  \n        }  \n        else if(arr[h] == 1)  \n        {  \n            h--;  \n        }  \n        else  \n        {  \n            temp = arr[l];  \n            arr[l] = arr[h];  \n            arr[h] = temp;  \n        }  \n    }  \n    return arr;  \n}  \nBoth variables from the beginning of the array:\nWay to think:\nWe want to arrange 0's followed by 1's in the array. We'll use two variables, both traversing from the beginning of the array. One variable is used to visit the elements and check the values, and the other is dedicated to staying at an index. The logic here is that whenever the visiting variable finds a 0, we should swap the elements at two variables.\nint* segregation(int arr[], int n)  \n{  \n    int i, j, temp;  \n    j = 0;  \n    for(i = 0; i < n; i++)  \n    {  \n        if(arr[i] == 0)  \n        {  \n            if(i != j)  \n            {  \n                temp = arr[i];  \n                arr[i] = arr[j];  \n                arr[j] = temp;  \n                j++;  \n            }  \n        }  \n    }  \n    return arr;  \n}  \nObserve that in both methods, we traversed the whole array only once.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Solution:\n\nWe can solve this problem like the above problem. We're given an integer array with positive and negative integers arranged randomly. We're supposed to arrange the array in the order of positive integers followed by negative or negative integers followed by positive integers.\nIn the above problem, we wrote code to arrange an array with 0's followed by 1's. Here, we need to use the same algorithm to arrange an array with negative elements followed by positive elements.\nVariables from both ends of the array:\nint* arrangement(int arr[], int n)  \n{  \n    int temp, l = 0;  \n    int h = n - 1;  \n    while(l < h)  \n    {  \n        if(arr[l] < 0)  \n        {  \n            l++;  \n        }  \n        else if(arr[h] > 0)  \n        {  \n            h--;  \n        }  \n        else  \n        {  \n            temp = arr[l];  \n            arr[l] = arr[h];  \n            arr[h] = temp;  \n        }  \n    }  \n    return arr;  \n}  \nBoth variables from the beginning of the array:\nint* arrangement(int arr[], int n)  \n{  \n    int i, j, temp;  \n    j = 0;  \n    for(i = 0; i < n; i++)  \n    {  \n        if(arr[i] < 0)  \n        {  \n            if(i != j)  \n            {  \n                temp = arr[i];  \n                arr[i] = arr[j];  \n                arr[j] = temp;  \n                j++;  \n            }  \n        }  \n    }  \n    return arr;  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Solution:\nWe're given an integer array and an integer k. We need to find the maximum sum possible in the array when elements in k consecutive indexes are added. Using nested loops, we can use the brute-force approach to check all the k-sized possible sub-arrays in the array. It could be more efficient. Another notable technique we can use is the \"Sliding window technique\".\n\nSliding Window technique:\nWe take the value of k from the user, and the concept here is that we create a window of size k, and we'll keep sliding it by a unit index.\nFor example:\n\nSuppose we need the maximum sum of 2 consecutive indexes, create a 2-sized window, and keep sliding (traversing) it throughout the array. We'll find the sum of elements of each window and return the maximum sum:\n\nCode:\nint maxsum(int a[], int k, int n)  \n{  \n    if(n < k)  \n    {  \n        return -1;  \n    }  \n    int i, sum, maxm = 0;  \n    for(i = 0; i < k; i++)  \n    {  \n        maxm = maxm + a[i];  \n    }  \n    sum = maxm;  \n    for(i = k; i < n; i++)  \n    {  \n        sum += a[i] - a[i - k]; /*subtract the last element of the previous window and add the first element of the current window*/  \n        if(sum > maxm)  \n        {  \n            maxm = sum;  \n        }  \n    }  \n    return maxm;  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Solution:\nWe're given an array of only positive numbers and the required sum. We need to find a sub-array with elements adding to the given sum. There can be more than one such sub-array. We can use nested loops and check the sum of all possible sub-arrays, but it could be more efficient. Hence, we can use the above \"Sliding window technique.\"\nWay to think:\nIt is given that all the elements in the array are positive. So, if there is a sub-array with a sum greater than the given sum, that's it. We need to leave the elements as they are. Hence, we can use this condition if the array also has negative elements; we cannot use the sliding window technique in all cases as the sum keeps changing.\nKeep adding elements to the window/ sub-array until the sum of elements is less than the given sum.\nIf the sum exceeds the given sum, remove elements from the start of the window.\nTraversal:\nFor example:\n\nCode:\nvoid subarray(int a[], int sum, int n)  \n{  \n    int cursum = a[0], start = 0, i;  \n    for(i = 1; i <= n; i++)  \n    {  \n        while(cursum > sum && start < i - 1)  \n        {  \n            cursum -= a[start];  \n            start++;  \n        }  \n        if (cursum == sum)  \n        {  \n            printf(\"Sub-array from %d to %d index\", start, i - 1);  \n            exit(0);  \n        }  \n        cursum = cursum + a[i];  \n    }  \n    printf(\"No sub-array found\");  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Solution:\nWe're given a sorted array and an integer. Our task is to find the number of occurrences of the integer in the array. It is a simple problem. We can solve it using any search algorithm we want.\nWay to think:\nWe can solve the problem using the linear search or binary search. It is an optimization of traditional binary sort for better efficiency. But, we need to use an improved binary search algorithm to solve the problem in O(Log n) time.\nAlgorithm:\nFind the index of the first occurrence of the integer using Binary sort\nFind the index of the last occurrence of the integer using Binary sort\nReturn count = last index - first index + 1\nCode:\nThree functions:\nFirstoc: To find the first occurring index of the integer in the array\nLastoc: To find the last occurring index of the integer in the remaining array.\nCount: To count the number of occurrences of the integer from firstoc to lastoc.\nint firstoc(int arr[], int l, int h, int k, int n)  \n{  \n    if(h >= l)  \n    {  \n        int mid = l + (h - l)/2;  \n        if((mid == 0 || k > arr[mid - 1]) && arr[mid] == k)  \n        {  \n            return mid;  \n        }  \n        else if(k > arr[mid])  \n        {  \n            return firstoc(arr, (mid + 1), h, k, n);  \n        }  \n        else  \n        {  \n            return firstoc(arr, l, (mid - 1), k, n);  \n        }  \n    }  \n    return -1;  \n}  \nint lastoc(int arr[], int l, int h, int k, int n)  \n{  \n    if(h >= l)  \n    {  \n        int mid = l + (h - l)/2;  \n        if((mid == n - 1 || k < arr[mid + 1]) && arr[mid] == k)  \n        {  \n            return mid;  \n        }  \n        else if(k < arr[mid])  \n        {  \n            return lastoc(arr, l, mid - 1, k, n);  \n        }  \n        else  \n        {  \n                          return lastoc(arr, mid + 1, h, k, n);  \n        }  \n    }  \n    return -1;  \n}  \n  int count(int arr[], int k, int n)  \n{  \n    int first, last;  \n    first = firstoc(arr, 0, n - 1, k, n);  \n    if(first == -1)  \n    {  \n        return 0;  \n    }  \n    last = lastoc(arr, first, n - 1, k, n);  \n    return last - first + 1;  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Solution:\nThe whole logic lies in the relation between LCM and GCD of two numbers. Suppose a and b are the two numbers:\na * b = LCM (a, b) * GCD (a, b)\nLCM (a, b) = a * b / GCD (a, b)\nint gcd(int num1, int num2)  \n{  \n    if(num1 == 0)  \n    {  \n        return num2;  \n    }  \n    return gcd(num2 % num1, num1);  \n}  \nint lcm(int a, int b)  \n{  \n    return (a / gcd(a, b))*b;  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Solution:\nTo find the sum of all the number's digits and reverse them, we need to separate them from the number. We can access the digits of a number using division and modulus with multiples of 10:\nCode:\nint rev(int num)  \n{  \n    int i, rem = 0, sum = 0, rev = 0;  \n    while(num > 0)  \n    {  \n        rem = num % 10;  \n        sum = sum + rem;  \n        rev = rev * 10 + rem;  \n        num = num / 10;  \n    }  \n    printf(\"Sum of digits of the number: %d\", sum);  \n    return rev;  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Solution:\nLogic to check if a given year is a leap year or not:\nA multiple of 400 or\nMultiple of 4 and not a multiple of 100\nCode:\nvoid leap(int year)  \n{  \n    if((year % 4 == 0) && (year % 100 != 0))  \n    {  \n        printf(\"%d is a leap year\");      \n    }  \n    else if(year % 400 == 0)  \n    {  \n        printf(\"%d is a leap year\", year);  \n    }  \n    else  \n    {  \n        printf(\"%d is a non-leap year\");  \n    }  \n  }",
        "reference": "javatpoint.com"
    }
]