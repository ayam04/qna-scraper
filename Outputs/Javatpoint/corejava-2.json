[
    {
        "question": "101) What is the difference between compile-time polymorphism and runtime polymorphism?",
        "answer": "There are the following differences between compile-time polymorphism and runtime polymorphism.\nSN compile-time polymorphism Runtime polymorphism\n1 In compile-time polymorphism, call to a method is resolved at compile-time. In runtime polymorphism, call to an overridden method is resolved at runtime.\n2 It is also known as static binding, early binding, or overloading. It is also known as dynamic binding, late binding, overriding, or dynamic method dispatch.\n3 Overloading is a way to achieve compile-time polymorphism in which, we can define multiple methods or constructors with different signatures.\nOverriding is a way to achieve runtime polymorphism in which, we can redefine some particular method or variable in the derived class. By using overriding, we can give some specific implementation to the base class properties in the derived class.\n4 It provides fast execution because the type of an object is determined at compile-time. It provides slower execution as compare to compile-time because the type of an object is determined at run-time.\n5 Compile-time polymorphism provides less flexibility because all the things are resolved at compile-time. Run-time polymorphism provides more flexibility because all the things are resolved at runtime.",
        "reference": "javatpoint.com"
    },
    {
        "question": "102) What is Runtime Polymorphism?",
        "answer": "Runtime polymorphism or dynamic method dispatch is a process in which a call to an overridden method is resolved at runtime rather than at compile-time. In this process, an overridden method is called through the reference variable of a superclass. The determination of the method to be called is based on the object being referred to by the reference variable.\nclass Bike{  \n  void run(){System.out.println(\"running\");}  \n}  \nclass Splendor extends Bike{  \n  void run(){System.out.println(\"running safely with 60km\");}  \n  public static void main(String args[]){  \n    Bike b = new Splendor();//upcasting  \n    b.run();  \n  }  \n}  \nTest it Now\nOutput:\n\nrunning safely with 60km.\nIn this process, an overridden method is called through the reference variable of a superclass. The determination of the method to be called is based on the object being referred to by the reference variable.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "103) Can you achieve Runtime Polymorphism by data members?",
        "answer": "No, because method overriding is used to achieve runtime polymorphism and data members cannot be overridden. We can override the member functions but not the data members. Consider the example given below.\nclass Bike{  \n int speedlimit=90;  \n}  \nclass Honda3 extends Bike{  \n int speedlimit=150;  \n public static void main(String args[]){  \n  Bike obj=new Honda3();  \n  System.out.println(obj.speedlimit);//90  \n   }  \nTest it Now\nOutput:\n\n90\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "104) What is the difference between static binding and dynamic binding?",
        "answer": "In case of the static binding, the type of the object is determined at compile-time whereas, in the dynamic binding, the type of the object is determined at runtime.\nStatic Binding\nclass Dog{  \n private void eat(){System.out.println(\"dog is eating...\");}  \n   public static void main(String args[]){  \n  Dog d1=new Dog();  \n  d1.eat();  \n }  \n}  \nDynamic Binding\n\nclass Animal{  \n void eat(){System.out.println(\"animal is eating...\");}  \n}  \n  class Dog extends Animal{  \n void eat(){System.out.println(\"dog is eating...\");}  \n   public static void main(String args[]){  \n  Animal a=new Dog();  \n  a.eat();  \n }  \n}  \nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "105) What is the output of the following Java program?",
        "answer": "class BaseTest   \n{  \n  void print()  \n  {  \n    System.out.println(\"BaseTest:print() called\");  \n  }  \n}  \npublic class Test extends BaseTest   \n{  \n  void print()   \n  {  \n    System.out.println(\"Test:print() called\");  \n  }  \n  public static void main (String args[])  \n  {  \n    BaseTest b = new Test();  \n    b.print();  \n  }  \n}  \nOutput\n  Test:print() called\nExplanation\nIt is an example of Dynamic method dispatch. The type of reference variable b is determined at runtime. At compile-time, it is checked whether that method is present in the Base class. In this case, it is overridden in the child class, therefore, at runtime the derived class method is called.",
        "reference": "javatpoint.com"
    },
    {
        "question": "106) What is Java instanceOf operator?",
        "answer": "The instanceof in Java is also known as type comparison operator because it compares the instance with type. It returns either true or false. If we apply the instanceof operator with any variable that has a null value, it returns false. Consider the following example.\nclass Simple1{  \n public static void main(String args[]){  \n Simple1 s=new Simple1();  \n System.out.println(s instanceof Simple1);//true  \n }  \n}  \nTest it Now\nOutput\ntrue",
        "reference": "javatpoint.com"
    },
    {
        "question": "107) What is the abstraction?",
        "answer": "Abstraction is a process of hiding the implementation details and showing only functionality to the user. It displays just the essential things to the user and hides the internal information, for example, sending SMS where you type the text and send the message. You don't know the internal processing about the message delivery. Abstraction enables you to focus on what the object does instead of how it does it. Abstraction lets you focus on what the object does instead of how it does it.\nIn Java, there are two ways to achieve the abstraction.\nADVERTISEMENT\nAbstract Class\nInterface\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "108) What is the difference between abstraction and encapsulation?",
        "answer": "Abstraction hides the implementation details whereas encapsulation wraps code and data into a single unit.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "109) What is the abstract class?",
        "answer": "A class that is declared as abstract is known as an abstract class. It needs to be extended and its method implemented. It cannot be instantiated. It can have abstract methods, non-abstract methods, constructors, and static methods. It can also have the final methods which will force the subclass not to change the body of the method. Consider the following example.\nabstract class Bike{  \n  abstract void run();  \n}  \nclass Honda4 extends Bike{  \nvoid run(){System.out.println(\"running safely\");}  \npublic static void main(String args[]){  \n Bike obj = new Honda4();  \n obj.run();  \n}  \n}  \nTest it Now\nOutput\nrunning safely\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "110) Can there be an abstract method without an abstract class?",
        "answer": "No, if there is an abstract method in a class, that class must be abstract.",
        "reference": "javatpoint.com"
    },
    {
        "question": "111) Is the following program written correctly? If yes then what will be the output of the program?",
        "answer": "abstract class Calculate  \n{  \n    abstract int multiply(int a, int b);  \n}  \n   public class Main  \n{  \n    public static void main(String[] args)  \n    {  \n        int result = new Calculate()  \n        {      \n            @Override  \n            int multiply(int a, int b)  \n            {  \n                return a*b;  \n            }  \n        }.multiply(12,32);  \n        System.out.println(\"result = \"+result);  \n    }  \n}  \nYes, the program is written correctly. The Main class provides the definition of abstract method multiply declared in abstract class Calculation. The output of the program will be:\n\nOutput\n384",
        "reference": "javatpoint.com"
    },
    {
        "question": "112) Can you use abstract and final both with a method?",
        "answer": "No, because we need to override the abstract method to provide its implementation, whereas we can't override the final method.",
        "reference": "javatpoint.com"
    },
    {
        "question": "113) Is it possible to instantiate the abstract class?",
        "answer": "No, the abstract class can never be instantiated even if it contains a constructor and all of its methods are implemented.",
        "reference": "javatpoint.com"
    },
    {
        "question": "114) What is the interface?",
        "answer": "The interface is a blueprint for a class that has static constants and abstract methods. It can be used to achieve full abstraction and multiple inheritance. It is a mechanism to achieve abstraction. There can be only abstract methods in the Java interface, not method body. It is used to achieve abstraction and multiple inheritance in Java. In other words, you can say that interfaces can have abstract methods and variables. Java Interface also represents the IS-A relationship. It cannot be instantiated just like the abstract class. However, we need to implement it to define its methods. Since Java 8, we can have the default, static, and private methods in an interface.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "115) Can you declare an interface method static?",
        "answer": "No, because methods of an interface are abstract by default, and we can not use static and abstract together.",
        "reference": "javatpoint.com"
    },
    {
        "question": "116) Can the Interface be final?",
        "answer": "No, because an interface needs to be implemented by the other class and if it is final, it can't be implemented by any class.",
        "reference": "javatpoint.com"
    },
    {
        "question": "117) What is a marker interface?",
        "answer": "A Marker interface can be defined as the interface which has no data member and member functions. For example, Serializable, Cloneable are marker interfaces. The marker interface can be declared as follows.\npublic interface Serializable{    \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "118) What are the differences between abstract class and interface?",
        "answer": "Abstract class Interface\nAn abstract class can have a method body (non-abstract methods). The interface has only abstract methods.\nAn abstract class can have instance variables. An interface cannot have instance variables.\nAn abstract class can have the constructor. The interface cannot have the constructor.\nAn abstract class can have static methods. The interface cannot have static methods.\nYou can extend one abstract class. You can implement multiple interfaces.\nThe abstract class can provide the implementation of the interface. The Interface can't provide the implementation of the abstract class.\nThe abstract keyword is used to declare an abstract class. The interface keyword is used to declare an interface.\nAn abstract class can extend another Java class and implement multiple Java interfaces. An interface can extend another Java interface only.\nAn abstract class can be extended using keyword extends An interface class can be implemented using keyword implements\nA Java abstract class can have class members like private, protected, etc. Members of a Java interface are public by default.\nExample:\npublic abstract class Shape{\npublic abstract void draw();\n} Example:\npublic interface Drawable{\nvoid draw();\n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "119) Can we define private and protected modifiers for the members in interfaces?",
        "answer": "No, they are implicitly public.",
        "reference": "javatpoint.com"
    },
    {
        "question": "120) When can an object reference be cast to an interface reference?",
        "answer": "An object reference can be cast to an interface reference when the object implements the referenced interface.",
        "reference": "javatpoint.com"
    },
    {
        "question": "121) How to make a read-only class in Java?",
        "answer": "A class can be made read-only by making all of the fields private. The read-only class will have only getter methods which return the private property of the class to the main method. We cannot modify this property because there is no setter method available in the class. Consider the following example.\n  //A Java class which has only getter methods.    \npublic class Student{    \n//private data member    \nprivate String college=\"AKG\";    \n//getter method for college    \npublic String getCollege(){    \nreturn college;    \n}    \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "122) How to make a write-only class in Java?",
        "answer": "A class can be made write-only by making all of the fields private. The write-only class will have only setter methods which set the value passed from the main method to the private fields. We cannot read the properties of the class because there is no getter method in this class. Consider the following example.\n  //A Java class which has only setter methods.    \npublic class Student{    \n//private data member    \nprivate String college;    \n//getter method for college    \npublic void setCollege(String college){    \nthis.college=college;    \n}    \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "123) What are the advantages of Encapsulation in Java?",
        "answer": "There are the following advantages of Encapsulation in Java?\nBy providing only the setter or getter method, you can make the class read-only or write-only. In other words, you can skip the getter or setter methods.\nIt provides you the control over the data. Suppose you want to set the value of id which should be greater than 100 only, you can write the logic inside the setter method. You can write the logic not to store the negative numbers in the setter methods.\nIt is a way to achieve data hiding in Java because other class will not be able to access the data through the private data members.\nThe encapsulate class is easy to test. So, it is better for unit testing.\nThe standard IDE's are providing the facility to generate the getters and setters. So, it is easy and fast to create an encapsulated class in Java.",
        "reference": "javatpoint.com"
    },
    {
        "question": "124) What is the package?",
        "answer": "A package is a group of similar type of classes, interfaces, and sub-packages. It provides access protection and removes naming collision. The packages in Java can be categorized into two forms, inbuilt package, and user-defined package. There are many built-in packages such as Java, lang, awt, javax, swing, net, io, util, sql, etc. Consider the following example to create a package in Java.\n//save as Simple.java  \npackage mypack;  \npublic class Simple{  \n public static void main(String args[]){  \n    System.out.println(\"Welcome to package\");  \n   }  \n}  \n\n\n\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "125) What are the advantages of defining packages in Java?",
        "answer": "By defining packages, we can avoid the name conflicts between the same class names defined in different packages. Packages also enable the developer to organize the similar classes more effectively. For example, one can clearly understand that the classes present in java.io package are used to perform io related operations.",
        "reference": "javatpoint.com"
    },
    {
        "question": "126) How to create packages in Java?",
        "answer": "If you are using the programming IDEs like Eclipse, NetBeans, MyEclipse, etc. click on file->new->project and eclipse will ask you to enter the name of the package. It will create the project package containing various directories such as src, etc. If you are using an editor like notepad for java programming, use the following steps to create the package.\nDefine a package package_name. Create the class with the name class_name and save this file with your_class_name.java.\n\nNow compile the file by running the following command on the terminal.\njavac -d . your_class_name.java  \nThe above command creates the package with the name package_name in the present working directory.\nNow, run the class file by using the absolute class file name, like following.\njava package_name.class_name",
        "reference": "javatpoint.com"
    },
    {
        "question": "127) How can we access some class in another class in Java?",
        "answer": "There are two ways to access a class in another class.\nBy using the fully qualified name: To access a class in a different package, either we must use the fully qualified name of that class, or we must import the package containing that class.\nBy using the relative path, We can use the path of the class that is related to the package that contains our class. It can be the same or subpackage.",
        "reference": "javatpoint.com"
    },
    {
        "question": "lang package any time? Why?",
        "answer": "No. It is by default loaded internally by the JVM.",
        "reference": "javatpoint.com"
    },
    {
        "question": "129) Can I import same package/class twice? Will the JVM load the package twice at runtime?",
        "answer": "One can import the same package or the same class multiple times. Neither compiler nor JVM complains about it. However, the JVM will internally load the class only once no matter how many times you import the same class.",
        "reference": "javatpoint.com"
    },
    {
        "question": "130) What is the static import?",
        "answer": "By static import, we can access the static members of a class directly, and there is no to qualify it with the class name.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "131) How many types of exception can occur in a Java program?",
        "answer": "There are mainly two types of exceptions: checked and unchecked. Here, an error is considered as the unchecked exception. According to Oracle, there are three types of exceptions:\nChecked Exception: Checked exceptions are the one which are checked at compile-time. For example, SQLException, ClassNotFoundException, etc.\n\nUnchecked Exception: Unchecked exceptions are the one which are handled at runtime because they can not be checked at compile-time. For example, ArithmaticException, NullPointerException, ArrayIndexOutOfBoundsException, etc.\n\nError: Error cause the program to exit since they are not recoverable. For Example, OutOfMemoryError, AssertionError, etc.",
        "reference": "javatpoint.com"
    },
    {
        "question": "132) What is Exception Handling?",
        "answer": "Exception Handling is a mechanism that is used to handle runtime errors. It is used primarily to handle checked exceptions. Exception handling maintains the normal flow of the program. There are mainly two types of exceptions: checked and unchecked. Here, the error is considered as the unchecked exception.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "133) Explain the hierarchy of Java Exception classes?",
        "answer": "The java.lang.Throwable class is the root class of Java Exception hierarchy which is inherited by two subclasses: Exception and Error. A hierarchy of Java Exception classes are given below:",
        "reference": "javatpoint.com"
    },
    {
        "question": "134) What is the difference between Checked Exception and Unchecked Exception?",
        "answer": "1) Checked Exception\nThe classes that extend Throwable class except RuntimeException and Error are known as checked exceptions, e.g., IOException, SQLException, etc. Checked exceptions are checked at compile-time.\n2) Unchecked Exception\nThe classes that extend RuntimeException are known as unchecked exceptions, e.g., ArithmeticException, NullPointerException, etc. Unchecked exceptions are not checked at compile-time.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "1) Checked Exception",
        "answer": "The classes that extend Throwable class except RuntimeException and Error are known as checked exceptions, e.g., IOException, SQLException, etc. Checked exceptions are checked at compile-time.\n2) Unchecked Exception\nThe classes that extend RuntimeException are known as unchecked exceptions, e.g., ArithmeticException, NullPointerException, etc. Unchecked exceptions are not checked at compile-time.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "2) Unchecked Exception",
        "answer": "The classes that extend RuntimeException are known as unchecked exceptions, e.g., ArithmeticException, NullPointerException, etc. Unchecked exceptions are not checked at compile-time.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "135) What is the base class for Error and Exception?",
        "answer": "The Throwable class is the base class for Error and Exception.",
        "reference": "javatpoint.com"
    },
    {
        "question": "136) Is it necessary that each try block must be followed by a catch block?",
        "answer": "It is not necessary that each try block must be followed by a catch block. It should be followed by either a catch block OR a finally block. So whatever exceptions are likely to be thrown should be declared in the throws clause of the method. Consider the following example.\npublic class Main{  \n     public static void main(String []args){  \n        try{  \n            int a = 1;   \n            System.out.println(a/0);  \n        }  \n        finally  \n        {  \n            System.out.println(\"rest of the code...\");  \n        }  \n     }  \n}  \n      \nOutput:\nException in thread main java.lang.ArithmeticException:/ by zero\nrest of the code...",
        "reference": "javatpoint.com"
    },
    {
        "question": "137) What is the output of the following Java program?",
        "answer": "public class ExceptionHandlingExample {  \npublic static void main(String args[])  \n{  \n    try  \n    {  \n        int a = 1/0;  \n        System.out.println(\"a = \"+a);  \n    }  \n    catch(Exception e){System.out.println(e);}  \n    catch(ArithmeticException ex){System.out.println(ex);}    \n}  \n}  \nOutput\nExceptionHandlingExample.java:10: error: exception ArithmeticException has already been caught\n catch(ArithmeticException ex){System.out.println(ex);} \n ^\n1 error\nExplanation\nArithmaticException is the subclass of Exception. Therefore, it can not be used after Exception. Since Exception is the base class for all the exceptions, therefore, it must be used at last to handle the exception. No class can be used after this.",
        "reference": "javatpoint.com"
    },
    {
        "question": "138) What is finally block?",
        "answer": "The \"finally\" block is used to execute the important code of the program. It is executed whether an exception is handled or not. In other words, we can say that finally block is the block which is always executed. Finally block follows try or catch block. If you don't handle the exception, before terminating the program, JVM runs finally block, (if any). The finally block is mainly used to place the cleanup code such as closing a file or closing a connection. Here, we must know that for each try block there can be zero or more catch blocks, but only one finally block. The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort).\n\n\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "139) Can finally block be used without a catch?",
        "answer": "Yes, According to the definition of finally block, it must be followed by a try or catch block, therefore, we can use try block instead of catch. More details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "140) Is there any case when finally will not be executed?",
        "answer": "Finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort).More details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "141) What is the difference between throw and throws?",
        "answer": "throw keyword throws keyword\n1) The throw keyword is used to throw an exception explicitly. The throws keyword is used to declare an exception.\n2) The checked exceptions cannot be propagated with throw only. The checked exception can be propagated with throws\n3) The throw keyword is followed by an instance. The throws keyword is followed by class.\n4) The throw keyword is used within the method. The throws keyword is used with the method signature.\n5) You cannot throw multiple exceptions. You can declare multiple exceptions, e.g., public void method()throws IOException, SQLException.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "142) What is the output of the following Java program?",
        "answer": "public class Main{  \n     public static void main(String []args){  \n        try  \n        {  \n            throw 90;   \n        }  \n        catch(int e){  \n            System.out.println(\"Caught the exception \"+e);  \n        }  \n                  }  \n}  \nOutput\nMain.java:6: error: incompatible types: int cannot be converted to Throwable\n            throw 90; \n            ^\nMain.java:8: error: unexpected type\n        catch(int e){\n              ^\n  required: class\n  found:    int\n2 errors\nExplanation\nIn Java, the throwable objects can only be thrown. If we try to throw an integer object, The compiler will show an error since we can not throw basic data type from a block of code.",
        "reference": "javatpoint.com"
    },
    {
        "question": "143) What is the output of the following Java program?",
        "answer": "class Calculation extends Exception  \n{  \n    public Calculation()   \n    {  \n        System.out.println(\"Calculation class is instantiated\");  \n    }  \n    public void add(int a, int b)  \n    {  \n        System.out.println(\"The sum is \"+(a+b));  \n    }  \n}  \npublic class Main{  \n     public static void main(String []args){  \n        try  \n        {  \n            throw new Calculation();   \n        }  \n        catch(Calculation c){  \n            c.add(10,20);  \n        }  \n    }  \n}   \nOutput\nCalculation class is instantiated\nThe sum is 30\nExplanation\nThe object of Calculation is thrown from the try block which is caught in the catch block. The add() of Calculation class is called with the integer values 10 and 20 by using the object of this class. Therefore there sum 30 is printed. The object of the Main class can only be thrown in the case when the type of the object is throwable. To do so, we need to extend the throwable class.",
        "reference": "javatpoint.com"
    },
    {
        "question": "144) Can an exception be rethrown?",
        "answer": "Yes.",
        "reference": "javatpoint.com"
    },
    {
        "question": "145) Can subclass overriding method declare an exception if parent class method doesn't throw an exception?",
        "answer": "Yes but only unchecked exception not checked.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "146) What is exception propagation?",
        "answer": "An exception is first thrown from the top of the stack and if it is not caught, it drops down the call stack to the previous method, If not caught there, the exception again drops down to the previous method, and so on until they are caught or until they reach the very bottom of the call stack. This procedure is called exception propagation. By default, checked exceptions are not propagated.\nclass TestExceptionPropagation1{  \n  void m(){  \n    int data=50/0;  \n  }  \n  void n(){  \n    m();  \n  }  \n  void p(){  \n   try{  \n    n();  \n   }catch(Exception e){System.out.println(\"exception handled\");}  \n  }  \n  public static void main(String args[]){  \n   TestExceptionPropagation1 obj=new TestExceptionPropagation1();  \n   obj.p();  \n   System.out.println(\"normal flow...\");  \n  }  \n}  \nTest it Now\nOutput:\nexception handled\nnormal flow...\n\n\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "147) What is the output of the following Java program?",
        "answer": "public class Main   \n{  \n    void a()  \n    {  \n        try{  \n        System.out.println(\"a(): Main called\");  \n        b();  \n        }catch(Exception e)  \n        {  \n            System.out.println(\"Exception is caught\");  \n        }  \n    }  \n    void b() throws Exception  \n    {  \n     try{  \n         System.out.println(\"b(): Main called\");  \n         c();  \n     }catch(Exception e){  \n         throw new Exception();  \n     }  \n     finally   \n     {  \n         System.out.println(\"finally block is called\");  \n     }  \n    }  \n    void c() throws Exception   \n    {  \n        throw new Exception();  \n    }  \n      public static void main (String args[])  \n    {  \n        Main m = new Main();  \n        m.a();  \n    }  \n}  \nOutput\na(): Main called\nb(): Main called\nfinally block is called\nException is caught\nExplanation\nIn the main method, a() of Main is called which prints a message and call b(). The method b() prints some message and then call c(). The method c() throws an exception which is handled by the catch block of method b. However, It propagates this exception by using throw Exception() to be handled by the method a(). As we know, finally block is always executed therefore the finally block in the method b() is executed first and prints a message. At last, the exception is handled by the catch block of the method a().",
        "reference": "javatpoint.com"
    },
    {
        "question": "148) What is the output of the following Java program?",
        "answer": "public class Calculation   \n{  \n    int a;   \n    public Calculation(int a)  \n    {  \n        this.a = a;  \n    }  \n    public int add()  \n    {  \n        a = a+10;   \n        try   \n        {  \n            a = a+10;   \n            try   \n            {  \n                a = a*10;   \n                throw new Exception();   \n            }catch(Exception e){  \n                a = a - 10;  \n            }  \n        }catch(Exception e)  \n        {  \n            a = a - 10;   \n        }  \n        return a;  \n    }  \n          public static void main (String args[])  \n    {  \n        Calculation c = new Calculation(10);  \n        int result = c.add();  \n        System.out.println(\"result = \"+result);  \n    }  \n}  \nOutput\nresult = 290\nExplanation\nThe instance variable a of class Calculation is initialized to 10 using the class constructor which is called while instantiating the class. The add method is called which returns an integer value result. In add() method, a is incremented by 10 to be 20. Then, in the first try block, 10 is again incremented by 10 to be 30. In the second try block, a is multiplied by 10 to be 300. The second try block throws the exception which is caught by the catch block associated with this try block. The catch block again alters the value of a by decrementing it by 10 to make it 290. Thus the add() method returns 290 which is assigned to result. However, the catch block associated with the outermost try block will never be executed since there is no exception which can be handled by this catch block.",
        "reference": "javatpoint.com"
    },
    {
        "question": "149) What is String Pool?",
        "answer": "String pool is the space reserved in the heap memory that can be used to store the strings. The main advantage of using the String pool is whenever we create a string literal; the JVM checks the \"string constant pool\" first. If the string already exists in the pool, a reference to the pooled instance is returned. If the string doesn't exist in the pool, a new string instance is created and placed in the pool. Therefore, it saves the memory by avoiding the duplicacy.",
        "reference": "javatpoint.com"
    },
    {
        "question": "150) What is the meaning of immutable regarding String?",
        "answer": "The simple meaning of immutable is unmodifiable or unchangeable. In Java, String is immutable, i.e., once string object has been created, its value can't be changed. Consider the following example for better understanding.\nclass Testimmutablestring{  \n public static void main(String args[]){  \n   String s=\"Sachin\";  \n   s.concat(\" Tendulkar\");//concat() method appends the string at the end  \n   System.out.println(s);//will print Sachin because strings are immutable objects  \n }  \n}  \nTest it Now\nOutput:\nSachin\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "151) Why are the objects immutable in java?",
        "answer": "Because Java uses the concept of the string literal. Suppose there are five reference variables, all refer to one object \"sachin\". If one reference variable changes the value of the object, it will be affected by all the reference variables. That is why string objects are immutable in java.\n\n\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "152) How many ways can we create the string object?",
        "answer": "1) String Literal\nJava String literal is created by using double quotes. For Example:\nString s=\"welcome\";  \nEach time you create a string literal, the JVM checks the \"string constant pool\" first. If the string already exists in the pool, a reference to the pooled instance is returned. If the string doesn't exist in the pool, a new string instance is created and placed in the pool. String objects are stored in a special memory area known as the string constant pool For example:\nString s1=\"Welcome\";  \nString s2=\"Welcome\";//It doesn't create a new instance  \n2) By new keyword\nString s=new String(\"Welcome\");//creates two objects and one reference variable  \nIn such case, JVM will create a new string object in normal (non-pool) heap memory, and the literal \"Welcome\" will be placed in the constant string pool. The variable s will refer to the object in a heap (non-pool).",
        "reference": "javatpoint.com"
    },
    {
        "question": "1) String Literal",
        "answer": "Java String literal is created by using double quotes. For Example:\nString s=\"welcome\";  \nEach time you create a string literal, the JVM checks the \"string constant pool\" first. If the string already exists in the pool, a reference to the pooled instance is returned. If the string doesn't exist in the pool, a new string instance is created and placed in the pool. String objects are stored in a special memory area known as the string constant pool For example:\nString s1=\"Welcome\";  \nString s2=\"Welcome\";//It doesn't create a new instance  \n2) By new keyword\nString s=new String(\"Welcome\");//creates two objects and one reference variable  \nIn such case, JVM will create a new string object in normal (non-pool) heap memory, and the literal \"Welcome\" will be placed in the constant string pool. The variable s will refer to the object in a heap (non-pool).",
        "reference": "javatpoint.com"
    },
    {
        "question": "2) By new keyword",
        "answer": "String s=new String(\"Welcome\");//creates two objects and one reference variable  \nIn such case, JVM will create a new string object in normal (non-pool) heap memory, and the literal \"Welcome\" will be placed in the constant string pool. The variable s will refer to the object in a heap (non-pool).",
        "reference": "javatpoint.com"
    },
    {
        "question": "153) How many objects will be created in the following code?",
        "answer": "String s1=\"Welcome\";  \nString s2=\"Welcome\";  \nString s3=\"Welcome\";  \nOnly one object will be created using the above code because strings in Java are immutable.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "154) Why java uses the concept of the string literal?",
        "answer": "To make Java more memory efficient (because no new objects are created if it exists already in the string constant pool).\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "155) How many objects will be created in the following code?",
        "answer": "String s = new String(\"Welcome\");  \nTwo objects, one in string constant pool and other in non-pool(heap).\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "156) What is the output of the following Java program?",
        "answer": "public class Test   \n    public static void main (String args[])  \n  {  \n      String a = new String(\"Sharma is a good player\");  \n      String b = \"Sharma is a good player\";  \n      if(a == b)  \n      {  \n          System.out.println(\"a == b\");  \n      }  \n      if(a.equals(b))  \n      {  \n          System.out.println(\"a equals b\");  \n      }  \n  }  \nOutput\n  a equals b\nExplanation\nThe operator == also check whether the references of the two string objects are equal or not. Although both of the strings contain the same content, their references are not equal because both are created by different ways(Constructor and String literal) therefore, a == b is unequal. On the other hand, the equal() method always check for the content. Since their content is equal hence, a equals b is printed.",
        "reference": "javatpoint.com"
    },
    {
        "question": "157) What is the output of the following Java program?",
        "answer": "public class Test   \n{  \n    public static void main (String args[])  \n    {  \n        String s1 = \"Sharma is a good player\";  \n        String s2 = new String(\"Sharma is a good player\");  \n        s2 = s2.intern();  \n        System.out.println(s1 ==s2);  \n    }  \n}  \nOutput\ntrue\nExplanation\nThe intern method returns the String object reference from the string pool. In this case, s1 is created by using string literal whereas, s2 is created by using the String pool. However, s2 is changed to the reference of s1, and the operator == returns true.",
        "reference": "javatpoint.com"
    },
    {
        "question": "158) What are the differences between String and StringBuffer?",
        "answer": "The differences between the String and StringBuffer is given in the table below.\nNo. String StringBuffer\n1) The String class is immutable. The StringBuffer class is mutable.\n2) The String is slow and consumes more memory when you concat too many strings because every time it creates a new instance. The StringBuffer is fast and consumes less memory when you cancat strings.\n3) The String class overrides the equals() method of Object class. So you can compare the contents of two strings by equals() method. The StringBuffer class doesn't override the equals() method of Object class.",
        "reference": "javatpoint.com"
    },
    {
        "question": "159) What are the differences between StringBuffer and StringBuilder?",
        "answer": "The differences between the StringBuffer and StringBuilder is given below.\nNo. StringBuffer StringBuilder\n1) StringBuffer is synchronized, i.e., thread safe. It means two threads can't call the methods of StringBuffer simultaneously. StringBuilder is non-synchronized,i.e., not thread safe. It means two threads can call the methods of StringBuilder simultaneously.\n2) StringBuffer is less efficient than StringBuilder. StringBuilder is more efficient than StringBuffer.",
        "reference": "javatpoint.com"
    },
    {
        "question": "160) How can we create an immutable class in Java?",
        "answer": "We can create an immutable class by defining a final class having all of its members as final. Consider the following example.\npublic final class Employee{  \nfinal String pancardNumber;  \n  public Employee(String pancardNumber){  \nthis.pancardNumber=pancardNumber;  \n}  \n  public String getPancardNumber(){  \nreturn pancardNumber;  \n}  \n  }  \nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "161) What is the purpose of toString() method in Java?",
        "answer": "The toString() method returns the string representation of an object. If you print any object, java compiler internally invokes the toString() method on the object. So overriding the toString() method, returns the desired output, it can be the state of an object, etc. depending upon your implementation. By overriding the toString() method of the Object class, we can return the values of the object, so we don't need to write much code. Consider the following example.\nclass Student{  \n int rollno;  \n String name;  \n String city;  \n   Student(int rollno, String name, String city){  \n this.rollno=rollno;  \n this.name=name;  \n this.city=city;  \n }  \n    public String toString(){//overriding the toString() method  \n  return rollno+\" \"+name+\" \"+city;  \n }  \n public static void main(String args[]){  \n   Student s1=new Student(101,\"Raj\",\"lucknow\");  \n   Student s2=new Student(102,\"Vijay\",\"ghaziabad\");  \n        System.out.println(s1);//compiler writes here s1.toString()  \n   System.out.println(s2);//compiler writes here s2.toString()  \n }  \n}  \nOutput:\n101 Raj lucknow\n102 Vijay ghaziabad\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "162) Why CharArray() is preferred over String to store the password?",
        "answer": "String stays in the string pool until the garbage is collected. If we store the password into a string, it stays in the memory for a longer period, and anyone having the memory-dump can extract the password as clear text. On the other hand, Using CharArray allows us to set it to blank whenever we are done with the password. It avoids the security threat with the string by enabling us to control the memory.",
        "reference": "javatpoint.com"
    },
    {
        "question": "163) Write a Java program to count the number of words present in a string?",
        "answer": "Program:\n  public class Test   \n{  \n    public static void main (String args[])  \n    {  \n        String s = \"Sharma is a good player and he is so punctual\";  \n        String words[] = s.split(\" \");  \n        System.out.println(\"The Number of words present in the string are : \"+words.length);  \n    }  \n}  \nOutput\nThe Number of words present in the string are : 10",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "There are the following classes and interfaces present in java.util.regex package.\nMatchResult Interface\nMatcher class\nPattern class\nPatternSyntaxException class",
        "reference": "javatpoint.com"
    },
    {
        "question": "165) How the metacharacters are different from the ordinary characters?",
        "answer": "Metacharacters have the special meaning to the regular expression engine. The metacharacters are ^, $, ., *, +, etc. The regular expression engine does not consider them as the regular characters. To enable the regular expression engine treating the metacharacters as ordinary characters, we need to escape the metacharacters with the backslash.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "The regular expression for the above criteria will be: ^[a-zA-Z][a-zA-Z0-9]{8,19} where ^ represents the start of the regex, [a-zA-Z] represents that the first character must be an alphabet, [a-zA-Z0-9] represents the alphanumeric character, {8,19} represents that the length of the password must be in between 8 and 20.",
        "reference": "javatpoint.com"
    },
    {
        "question": "167) What is the output of the following Java program?",
        "answer": "import java.util.regex.*;  \nclass RegexExample2{  \npublic static void main(String args[]){  \nSystem.out.println(Pattern.matches(\".s\", \"as\")); //line 4  \nSystem.out.println(Pattern.matches(\".s\", \"mk\")); //line 5   \nSystem.out.println(Pattern.matches(\".s\", \"mst\")); //line 6  \nSystem.out.println(Pattern.matches(\".s\", \"amms\")); //line 7  \nSystem.out.println(Pattern.matches(\"..s\", \"mas\")); //line 8  \n}}  \nOutput\ntrue\nfalse \nfalse\nfalse \ntrue\nExplanation\nline 4 prints true since the second character of string is s, line 5 prints false since the second character is not s, line 6 prints false since there are more than 3 characters in the string, line 7 prints false since there are more than 2 characters in the string, and it contains more than 2 characters as well, line 8 prints true since the third character of the string is s.",
        "reference": "javatpoint.com"
    },
    {
        "question": "168) What are the advantages of Java inner classes?",
        "answer": "There are two types of advantages of Java inner classes.\nNested classes represent a special type of relationship that is it can access all the members (data members and methods) of the outer class including private.\nNested classes are used to develop a more readable and maintainable code because it logically groups classes and interfaces in one place only.\nCode Optimization: It requires less code to write.",
        "reference": "javatpoint.com"
    },
    {
        "question": "169) What is a nested class?",
        "answer": "The nested class can be defined as the class which is defined inside another class or interface. We use the nested class to logically group classes and interfaces in one place so that it can be more readable and maintainable. A nested class can access all the data members of the outer class including private data members and methods. The syntax of the nested class is defined below.\nclass Java_Outer_class{    \n //code    \n class Java_Nested_class{    \n  //code    \n }    \n}    \n      \nThere are two types of nested classes, static nested class, and non-static nested class. The non-static nested class can also be called as inner-class\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "170) What are the disadvantages of using inner classes?",
        "answer": "There are the following main disadvantages of using inner classes.\nInner classes increase the total number of classes used by the developer and therefore increases the workload of JVM since it has to perform some routine operations for those extra classes which result in slower performance.\nIDEs provide less support to the inner classes as compare to the top level classes and therefore it annoys the developers while working with inner classes.",
        "reference": "javatpoint.com"
    },
    {
        "question": "171) What are the types of inner classes (non-static nested class) used in Java?",
        "answer": "There are mainly three types of inner classes used in Java.\nType Description\nMember Inner Class A class created within class and outside method.\nAnonymous Inner Class A class created for implementing an interface or extending class. Its name is decided by the java compiler.\nLocal Inner Class A class created within the method.",
        "reference": "javatpoint.com"
    },
    {
        "question": "172) Is there any difference between nested classes and inner classes?",
        "answer": "Yes, inner classes are non-static nested classes. In other words, we can say that inner classes are the part of nested classes.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "173) Can we access the non-final local variable, inside the local inner class?",
        "answer": "No, the local variable must be constant if you want to access it in the local inner class.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "174) How many class files are created on compiling the OuterClass in the following program?",
        "answer": "public class Person {  \nString name, age, address;  \nclass Employee{  \n  float salary=10000;  \n}  \nclass BusinessMen{  \n  final String gstin=\"\u00a34433drt3$\";   \n}  \npublic static void main (String args[])  \n{  \n  Person p = new Person();  \n}  \n}  \n3 class-files will be created named as Person.class, Person$BusinessMen.class, and Person$Employee.class.",
        "reference": "javatpoint.com"
    },
    {
        "question": "175) What are anonymous inner classes?",
        "answer": "Anonymous inner classes are the classes that are automatically declared and instantiated within an expression. We cannot apply different access modifiers to them. Anonymous class cannot be static, and cannot define any static fields, method, or class. In other words, we can say that it a class without the name and can have only one object that is created by its definition. Consider the following example.\nabstract class Person{  \n  abstract void eat();  \n}  \nclass TestAnonymousInner{  \n public static void main(String args[]){  \n  Person p=new Person(){  \n  void eat(){System.out.println(\"nice fruits\");}  \n  };  \n  p.eat();  \n }  \n}  \nTest it Now\nOutput:\nnice fruits\nConsider the following example for the working of the anonymous class using interface.\ninterface Eatable{  \n void eat();  \n}  \nclass TestAnnonymousInner1{  \n public static void main(String args[]){  \n Eatable e=new Eatable(){  \n  public void eat(){System.out.println(\"nice fruits\");}  \n };  \n e.eat();  \n }  \n}  \nTest it Now\nOutput:\nnice fruits",
        "reference": "javatpoint.com"
    },
    {
        "question": "176) What is the nested interface?",
        "answer": "An Interface that is declared inside the interface or class is known as the nested interface. It is static by default. The nested interfaces are used to group related interfaces so that they can be easy to maintain. The external interface or class must refer to the nested interface. It can't be accessed directly. The nested interface must be public if it is declared inside the interface but it can have any access modifier if declared within the class. The syntax of the nested interface is given as follows.\ninterface interface_name{    \n ...    \n interface nested_interface_name{    \n  ...    \n }    \n}     \n      \nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "177) Can a class have an interface?",
        "answer": "Yes, an interface can be defined within the class. It is called a nested interface.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "178) Can an Interface have a class?",
        "answer": "Yes, they are static implicitly.\nMore details.\nGarbage Collection Interview Questions",
        "reference": "javatpoint.com"
    },
    {
        "question": "179) What is Garbage Collection?",
        "answer": "Garbage collection is a process of reclaiming the unused runtime objects. It is performed for memory management. In other words, we can say that It is the process of removing unused objects from the memory to free up space and make this space available for Java Virtual Machine. Due to garbage collection java gives 0 as output to a variable whose value is not set, i.e., the variable has been defined but not initialized. For this purpose, we were using free() function in the C language and delete() in C++. In Java, it is performed automatically. So, java provides better memory management.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "180) What is gc()?",
        "answer": "The gc() method is used to invoke the garbage collector for cleanup processing. This method is found in System and Runtime classes. This function explicitly makes the Java Virtual Machine free up the space occupied by the unused objects so that it can be utilized or reused. Consider the following example for the better understanding of how the gc() method invoke the garbage collector.\npublic class TestGarbage1{  \n public void finalize(){System.out.println(\"object is garbage collected\");}  \n public static void main(String args[]){  \n  TestGarbage1 s1=new TestGarbage1();  \n  TestGarbage1 s2=new TestGarbage1();  \n  s1=null;  \n  s2=null;  \n  System.gc();  \n }  \n}  \nTest it Now\n       object is garbage collected\n       object is garbage collected",
        "reference": "javatpoint.com"
    },
    {
        "question": "181) How is garbage collection controlled?",
        "answer": "Garbage collection is managed by JVM. It is performed when there is not enough space in the memory and memory is running low. We can externally call the System.gc() for the garbage collection. However, it depends upon the JVM whether to perform it or not.",
        "reference": "javatpoint.com"
    },
    {
        "question": "182) How can an object be unreferenced?",
        "answer": "There are many ways:\nBy nulling the reference\nBy assigning a reference to another\nBy anonymous object etc.\n\n1) By nulling a reference:\nEmployee e=new Employee();  \ne=null;  \n2) By assigning a reference to another:\nEmployee e1=new Employee();  \nEmployee e2=new Employee();  \ne1=e2;//now the first object referred by e1 is available for garbage collection  \n3) By anonymous object:\nnew Employee();",
        "reference": "javatpoint.com"
    },
    {
        "question": "1) By nulling a reference:",
        "answer": "Employee e=new Employee();  \ne=null;  \n2) By assigning a reference to another:\nEmployee e1=new Employee();  \nEmployee e2=new Employee();  \ne1=e2;//now the first object referred by e1 is available for garbage collection  \n3) By anonymous object:\nnew Employee();",
        "reference": "javatpoint.com"
    },
    {
        "question": "2) By assigning a reference to another:",
        "answer": "Employee e1=new Employee();  \nEmployee e2=new Employee();  \ne1=e2;//now the first object referred by e1 is available for garbage collection  \n3) By anonymous object:\nnew Employee();",
        "reference": "javatpoint.com"
    },
    {
        "question": "3) By anonymous object:",
        "answer": "new Employee();",
        "reference": "javatpoint.com"
    },
    {
        "question": "183) What is the purpose of the finalize() method?",
        "answer": "The finalize() method is invoked just before the object is garbage collected. It is used to perform cleanup processing. The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created an object without new, you can use the finalize method to perform cleanup processing (destroying remaining objects). The cleanup processing is the process to free up all the resources, network which was previously used and no longer needed. It is essential to remember that it is not a reserved keyword, finalize method is present in the object class hence it is available in every class as object class is the superclass of every class in java. Here, we must note that neither finalization nor garbage collection is guaranteed. Consider the following example.\npublic class FinalizeTest {  \n    int j=12;  \n    void add()  \n    {  \n        j=j+12;  \n        System.out.println(\"J=\"+j);  \n    }  \n    public void finalize()  \n    {  \n        System.out.println(\"Object is garbage collected\");  \n    }  \n    public static void main(String[] args) {  \n        new FinalizeTest().add();  \n        System.gc();  \n        new FinalizeTest().add();  \n    }  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "184) Can an unreferenced object be referenced again?",
        "answer": "Yes,",
        "reference": "javatpoint.com"
    },
    {
        "question": "185) What kind of thread is the Garbage collector thread?",
        "answer": "Daemon thread.",
        "reference": "javatpoint.com"
    },
    {
        "question": "186) What is the difference between final, finally and finalize?",
        "answer": "No. final finally finalize\n1) Final is used to apply restrictions on class, method, and variable. The final class can't be inherited, final method can't be overridden, and final variable value can't be changed. Finally is used to place important code, it will be executed whether an exception is handled or not. Finalize is used to perform clean up processing just before an object is garbage collected.\n2) Final is a keyword. Finally is a block. Finalize is a method.",
        "reference": "javatpoint.com"
    },
    {
        "question": "187) What is the purpose of the Runtime class?",
        "answer": "Java Runtime class is used to interact with a java runtime environment. Java Runtime class provides methods to execute a process, invoke GC, get total and free memory, etc. There is only one instance of java.lang.Runtime class is available for one java application. The Runtime.getRuntime() method returns the singleton instance of Runtime class.",
        "reference": "javatpoint.com"
    },
    {
        "question": "188) How will you invoke any external process in Java?",
        "answer": "By Runtime.getRuntime().exec(?) method. Consider the following example.\npublic class Runtime1{  \n public static void main(String args[])throws Exception{  \n  Runtime.getRuntime().exec(\"notepad\");//will open a new notepad  \n }  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "OutputStream Hierarchy\n\nInputStream Hierarchy",
        "reference": "javatpoint.com"
    },
    {
        "question": "190) What do you understand by an IO stream?",
        "answer": "The stream is a sequence of data that flows from source to destination. It is composed of bytes. In Java, three streams are created for us automatically.\nSystem.out: standard output stream\nSystem.in: standard input stream\nSystem.err: standard error stream",
        "reference": "javatpoint.com"
    },
    {
        "question": "191) What is the difference between the Reader/Writer class hierarchy and the InputStream/OutputStream class hierarchy?",
        "answer": "The Reader/Writer class hierarchy is character-oriented, and the InputStream/OutputStream class hierarchy is byte-oriented. The ByteStream classes are used to perform input-output of 8-bit bytes whereas the CharacterStream classes are used to perform the input/output for the 16-bit Unicode system. There are many classes in the ByteStream class hierarchy, but the most frequently used classes are FileInputStream and FileOutputStream. The most frequently used classes CharacterStream class hierarchy is FileReader and FileWriter.",
        "reference": "javatpoint.com"
    },
    {
        "question": "192) What are the super most classes for all the streams?",
        "answer": "All the stream classes can be divided into two types of classes that are ByteStream classes and CharacterStream Classes. The ByteStream classes are further divided into InputStream classes and OutputStream classes. CharacterStream classes are also divided into Reader classes and Writer classes. The SuperMost classes for all the InputStream classes is java.io.InputStream and for all the output stream classes is java.io.OutPutStream. Similarly, for all the reader classes, the super-most class is java.io.Reader, and for all the writer classes, it is java.io.Writer.",
        "reference": "javatpoint.com"
    },
    {
        "question": "193) What are the FileInputStream and FileOutputStream?",
        "answer": "Java FileOutputStream is an output stream used for writing data to a file. If you have some primitive values to write into a file, use FileOutputStream class. You can write byte-oriented as well as character-oriented data through the FileOutputStream class. However, for character-oriented data, it is preferred to use FileWriter than FileOutputStream. Consider the following example of writing a byte into a file.\nimport java.io.FileOutputStream;    \npublic class FileOutputStreamExample {    \n    public static void main(String args[]){      \n           try{      \n             FileOutputStream fout=new FileOutputStream(\"D:\\\\testout.txt\");      \n             fout.write(65);      \n             fout.close();      \n             System.out.println(\"success...\");      \n            }catch(Exception e){System.out.println(e);}      \n      }      \n}    \nJava FileInputStream class obtains input bytes from a file. It is used for reading byte-oriented data (streams of raw bytes) such as image data, audio, video, etc. You can also read character-stream data. However, for reading streams of characters, it is recommended to use FileReader class. Consider the following example for reading bytes from a file.\nimport java.io.FileInputStream;    \npublic class DataStreamExample {    \n     public static void main(String args[]){      \n          try{      \n            FileInputStream fin=new FileInputStream(\"D:\\\\testout.txt\");      \n            int i=fin.read();    \n            System.out.print((char)i);      \n                fin.close();      \n          }catch(Exception e){System.out.println(e);}      \n         }      \n        }",
        "reference": "javatpoint.com"
    },
    {
        "question": "194) What is the purpose of using BufferedInputStream and BufferedOutputStream classes?",
        "answer": "Java BufferedOutputStream class is used for buffering an output stream. It internally uses a buffer to store data. It adds more efficiency than to write data directly into a stream. So, it makes the performance fast. Whereas, Java BufferedInputStream class is used to read information from the stream. It internally uses the buffer mechanism to make the performance fast.",
        "reference": "javatpoint.com"
    },
    {
        "question": "195) How to set the Permissions to a file in Java?",
        "answer": "In Java, FilePermission class is used to alter the permissions set on a file. Java FilePermission class contains the permission related to a directory or file. All the permissions are related to the path. The path can be of two types:\nD:\\\\IO\\\\-: It indicates that the permission is associated with all subdirectories and files recursively.\nD:\\\\IO\\\\*: It indicates that the permission is associated with all directory and files within this directory excluding subdirectories.\nLet's see the simple example in which permission of a directory path is granted with read permission and a file of this directory is granted for write permission.\npackage com.javatpoint;  \nimport java.io.*;  \nimport java.security.PermissionCollection;  \npublic class FilePermissionExample{  \n     public static void main(String[] args) throws IOException {  \n      String srg = \"D:\\\\IO Package\\\\java.txt\";  \n      FilePermission file1 = new FilePermission(\"D:\\\\IO Package\\\\-\", \"read\");  \n      PermissionCollection permission = file1.newPermissionCollection();  \n      permission.add(file1);  \n           FilePermission file2 = new FilePermission(srg, \"write\");  \n           permission.add(file2);  \n         if(permission.implies(new FilePermission(srg, \"read,write\"))) {  \n           System.out.println(\"Read, Write permission is granted for the path \"+srg );  \n             }else {  \n            System.out.println(\"No Read, Write permission is granted for the path \"+srg);            }  \n     }   \n}  \nOutput\nRead, Write permission is granted for the path D:\\IO Package\\java.txt",
        "reference": "javatpoint.com"
    },
    {
        "question": "196) What are FilterStreams?",
        "answer": "FilterStream classes are used to add additional functionalities to the other stream classes. FilterStream classes act like an interface which read the data from a stream, filters it, and pass the filtered data to the caller. The FilterStream classes provide extra functionalities like adding line numbers to the destination file, etc.",
        "reference": "javatpoint.com"
    },
    {
        "question": "197) What is an I/O filter?",
        "answer": "An I/O filter is an object that reads from one stream and writes to another, usually altering the data in some way as it is passed from one stream to another. Many Filter classes that allow a user to make a chain using multiple input streams. It generates a combined effect on several filters.",
        "reference": "javatpoint.com"
    },
    {
        "question": "198) In Java, How many ways you can take input from the console?",
        "answer": "In Java, there are three ways by using which, we can take input from the console.\nUsing BufferedReader class: we can take input from the console by wrapping System.in into an InputStreamReader and passing it into the BufferedReader. It provides an efficient reading as the input gets buffered. Consider the following example.\nimport java.io.BufferedReader;   \nimport java.io.IOException;   \nimport java.io.InputStreamReader;   \npublic class Person   \n{   \n    public static void main(String[] args) throws IOException    \n    {   \n      System.out.println(\"Enter the name of the person\");  \n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));   \n        String name = reader.readLine();   \n        System.out.println(name);           \n    }   \n}   \nUsing Scanner class: The Java Scanner class breaks the input into tokens using a delimiter that is whitespace by default. It provides many methods to read and parse various primitive values. Java Scanner class is widely used to parse text for string and primitive types using a regular expression. Java Scanner class extends Object class and implements Iterator and Closeable interfaces. Consider the following example.\nimport java.util.*;    \npublic class ScannerClassExample2 {      \n      public static void main(String args[]){                         \n          String str = \"Hello/This is JavaTpoint/My name is Abhishek.\";    \n          //Create scanner with the specified String Object    \n          Scanner scanner = new Scanner(str);    \n          System.out.println(\"Boolean Result: \"+scanner.hasNextBoolean());              \n          //Change the delimiter of this scanner    \n          scanner.useDelimiter(\"/\");    \n          //Printing the tokenized Strings    \n          System.out.println(\"---Tokenizes String---\");     \n        while(scanner.hasNext()){    \n            System.out.println(scanner.next());    \n        }    \n          //Display the new delimiter    \n          System.out.println(\"Delimiter used: \" +scanner.delimiter());              \n          scanner.close();    \n          }      \n}    \n     Using Console class: The Java Console class is used to get input from the console. It provides methods to read texts and passwords. If you read the password using the Console class, it will not be displayed to the user. The java.io.Console class is attached to the system console internally. The Console class is introduced since 1.5. Consider the following example.\nimport java.io.Console;    \nclass ReadStringTest{      \npublic static void main(String args[]){      \nConsole c=System.console();      \nSystem.out.println(\"Enter your name: \");      \nString n=c.readLine();      \nSystem.out.println(\"Welcome \"+n);      \n}      \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "199) What is serialization?",
        "answer": "Serialization in Java is a mechanism of writing the state of an object into a byte stream. It is used primarily in Hibernate, RMI, JPA, EJB and JMS technologies. It is mainly used to travel object's state on the network (which is known as marshaling). Serializable interface is used to perform serialization. It is helpful when you require to save the state of a program to storage such as the file. At a later point of time, the content of this file can be restored using deserialization. It is also required to implement RMI(Remote Method Invocation). With the help of RMI, it is possible to invoke the method of a Java object on one machine to another machine.\n\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "200) How can you make a class serializable in Java?",
        "answer": "A class can become serializable by implementing the Serializable interface.",
        "reference": "javatpoint.com"
    },
    {
        "question": "201) How can you avoid serialization in child class if the base class is implementing the Serializable interface?",
        "answer": "It is very tricky to prevent serialization of child class if the base class is intended to implement the Serializable interface. However, we cannot do it directly, but the serialization can be avoided by implementing the writeObject() or readObject() methods in the subclass and throw NotSerializableException from these methods. Consider the following example.\nimport java.io.FileInputStream;   \nimport java.io.FileOutputStream;   \nimport java.io.IOException;   \nimport java.io.NotSerializableException;   \nimport java.io.ObjectInputStream;   \nimport java.io.ObjectOutputStream;   \nimport java.io.Serializable;   \nclass Person implements Serializable   \n{   \n    String name = \" \";  \n    public Person(String name)    \n    {   \n        this.name = name;   \n    }         \n}   \nclass Employee extends Person  \n{   \n    float salary;  \n    public Employee(String name, float salary)    \n    {   \n        super(name);   \n        this.salary = salary;   \n    }   \n    private void writeObject(ObjectOutputStream out) throws IOException   \n    {   \n        throw new NotSerializableException();   \n    }   \n    private void readObject(ObjectInputStream in) throws IOException   \n    {   \n        throw new NotSerializableException();   \n    }   \n        }   \npublic class Test   \n{   \n    public static void main(String[] args)    \n            throws Exception    \n    {   \n        Employee emp = new Employee(\"Sharma\", 10000);   \n                    System.out.println(\"name = \" + emp.name);   \n        System.out.println(\"salary = \" + emp.salary);   \n                    FileOutputStream fos = new FileOutputStream(\"abc.ser\");   \n        ObjectOutputStream oos = new ObjectOutputStream(fos);   \n                        oos.writeObject(emp);   \n                        oos.close();   \n        fos.close();   \n                        System.out.println(\"Object has been serialized\");   \n                    FileInputStream f = new FileInputStream(\"ab.txt\");   \n        ObjectInputStream o = new ObjectInputStream(f);   \n                        Employee emp1 = (Employee)o.readObject();   \n                        o.close();   \n        f.close();   \n                        System.out.println(\"Object has been deserialized\");   \n                    System.out.println(\"name = \" + emp1.name);   \n        System.out.println(\"salary = \" + emp1.salary);   \n    }   \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "202) Can a Serialized object be transferred via network?",
        "answer": "Yes, we can transfer a serialized object via network because the serialized object is stored in the memory in the form of bytes and can be transmitted over the network. We can also write the serialized object to the disk or the database.",
        "reference": "javatpoint.com"
    },
    {
        "question": "203) What is Deserialization?",
        "answer": "Deserialization is the process of reconstructing the object from the serialized state. It is the reverse operation of serialization. An ObjectInputStream deserializes objects and primitive data written using an ObjectOutputStream.\nimport java.io.*;  \nclass Depersist{  \n public static void main(String args[])throws Exception{  \n      ObjectInputStream in=new ObjectInputStream(new FileInputStream(\"f.txt\"));  \n  Student s=(Student)in.readObject();  \n  System.out.println(s.id+\" \"+s.name);  \n    in.close();  \n }  \n}  \n211 ravi",
        "reference": "javatpoint.com"
    },
    {
        "question": "204) What is the transient keyword?",
        "answer": "If you define any data member as transient, it will not be serialized. By determining transient keyword, the value of variable need not persist when it is restored. More details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "205) What is Externalizable?",
        "answer": "The Externalizable interface is used to write the state of an object into a byte stream in a compressed format. It is not a marker interface.",
        "reference": "javatpoint.com"
    },
    {
        "question": "206) What is the difference between Serializable and Externalizable interface?",
        "answer": "No. Serializable Externalizable\n1) The Serializable interface does not have any method, i.e., it is a marker interface. The Externalizable interface contains is not a marker interface, It contains two methods, i.e., writeExternal() and readExternal().\n2) It is used to \"mark\" Java classes so that objects of these classes may get the certain capability. The Externalizable interface provides control of the serialization logic to the programmer.\n3) It is easy to implement but has the higher performance cost. It is used to perform the serialization and often result in better performance.\n4) No class constructor is called in serialization. We must call a public default constructor while using this interface.",
        "reference": "javatpoint.com"
    },
    {
        "question": "207) Give a brief description of Java socket programming?",
        "answer": "Java Socket programming is used for communication between the applications running on different JRE. Java Socket programming can be connection-oriented or connectionless. Socket and ServerSocket classes are used for connection-oriented socket programming and DatagramSocket, and DatagramPacket classes are used for connectionless socket programming. The client in socket programming must know two information:\nIP address of the server\nport number",
        "reference": "javatpoint.com"
    },
    {
        "question": "208) What is Socket?",
        "answer": "A socket is simply an endpoint for communications between the machines. It provides the connection mechanism to connect the two computers using TCP. The Socket class can be used to create a socket.",
        "reference": "javatpoint.com"
    },
    {
        "question": "209) What are the steps that are followed when two computers connect through TCP?",
        "answer": "There are the following steps that are performed when two computers connect through TCP.\nThe ServerSocket object is instantiated by the server which denotes the port number to which, the connection will be made.\nAfter instantiating the ServerSocket object, the server invokes accept() method of ServerSocket class which makes server wait until the client attempts to connect to the server on the given port.\nMeanwhile, the server is waiting, a socket is created by the client by instantiating Socket class. The socket class constructor accepts the server port number and server name.\nThe Socket class constructor attempts to connect with the server on the specified name. If the connection is established, the client will have a socket object that can communicate with the server.\nThe accept() method invoked by the server returns a reference to the new socket on the server that is connected with the server.",
        "reference": "javatpoint.com"
    },
    {
        "question": "210) Write a program in Java to establish a connection between client and server?",
        "answer": "Consider the following program where the connection between the client and server is established.\nFile: MyServer.java\nimport java.io.*;  \nimport java.net.*;  \npublic class MyServer {  \npublic static void main(String[] args){  \ntry{  \nServerSocket ss=new ServerSocket(6666);  \nSocket s=ss.accept();//establishes connection   \nDataInputStream dis=new DataInputStream(s.getInputStream());  \nString  str=(String)dis.readUTF();  \nSystem.out.println(\"message= \"+str);  \nss.close();  \n}catch(Exception e){System.out.println(e);}  \n}  \n}  \nFile: MyClient.java\nimport java.io.*;  \nimport java.net.*;  \npublic class MyClient {  \npublic static void main(String[] args) {  \ntry{    \nSocket s=new Socket(\"localhost\",6666);  \nDataOutputStream dout=new DataOutputStream(s.getOutputStream());  \ndout.writeUTF(\"Hello Server\");  \ndout.flush();  \ndout.close();  \ns.close();  \n}catch(Exception e){System.out.println(e);}  \n}  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "com?",
        "answer": "By InetAddress.getByName(\"192.18.97.39\").getHostName() where 192.18.97.39 is the IP address. Consider the following example.\nimport java.io.*;    \nimport java.net.*;    \npublic class InetDemo{    \npublic static void main(String[] args){    \ntry{    \nInetAddress ip=InetAddress.getByName(\"195.201.10.8\");    \n  System.out.println(\"Host Name: \"+ip.getHostName());    \n}catch(Exception e){System.out.println(e);}    \n}    \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "212) What is the reflection?",
        "answer": "Reflection is the process of examining or modifying the runtime behavior of a class at runtime. The java.lang.Class class provides various methods that can be used to get metadata, examine and change the runtime behavior of a class. The java.lang and java.lang.reflect packages provide classes for java reflection. It is used in:\nIDE (Integrated Development Environment), e.g., Eclipse, MyEclipse, NetBeans.\nDebugger\nTest Tools, etc.",
        "reference": "javatpoint.com"
    },
    {
        "question": "Class class?",
        "answer": "The java.lang.Class class performs mainly two tasks:\nProvides methods to get the metadata of a class at runtime.\nProvides methods to examine and change the runtime behavior of a class.",
        "reference": "javatpoint.com"
    },
    {
        "question": "214) What are the ways to instantiate the Class class?",
        "answer": "There are three ways to instantiate the Class class.\nforName() method of Class class: The forName() method is used to load the class dynamically. It returns the instance of Class class. It should be used if you know the fully qualified name of the class. This cannot be used for primitive types.\n\ngetClass() method of Object class: It returns the instance of Class class. It should be used if you know the type. Moreover, it can be used with primitives.\n\nthe .class syntax: If a type is available, but there is no instance then it is possible to obtain a Class by appending \".class\" to the name of the type. It can be used for primitive data type also.",
        "reference": "javatpoint.com"
    },
    {
        "question": "215) What is the output of the following Java program?",
        "answer": "class Simple{    \n public Simple()  \n {  \n   System.out.println(\"Constructor of Simple class is invoked\");  \n }  \n void message(){System.out.println(\"Hello Java\");}    \n}    \n    class Test1{    \n public static void main(String args[]){    \n  try{    \n  Class c=Class.forName(\"Simple\");    \n  Simple s=(Simple)c.newInstance();    \n  s.message();    \n  }catch(Exception e){System.out.println(e);}    \n }    \n}    \nOutput\nConstructor of Simple class is invoked\nHello Java\nExplanation\nThe newInstance() method of the Class class is used to invoke the constructor at runtime. In this program, the instance of the Simple class is created.",
        "reference": "javatpoint.com"
    },
    {
        "question": "216) What is the purpose of using javap?",
        "answer": "The javap command disassembles a class file. The javap command displays information about the fields, constructors and methods present in a class file.\nSyntax\njavap fully_class_name",
        "reference": "javatpoint.com"
    },
    {
        "question": "217) Can you access the private method from outside the class?",
        "answer": "Yes, by changing the runtime behavior of a class if the class is not secured.\nMore details.",
        "reference": "javatpoint.com"
    },
    {
        "question": "218)What are wrapper classes?",
        "answer": "Wrapper classes are classes that allow primitive types to be accessed as objects. In other words, we can say that wrapper classes are built-in java classes which allow the conversion of objects to primitives and primitives to objects. The process of converting primitives to objects is called autoboxing, and the process of converting objects to primitives is called unboxing. There are eight wrapper classes present in java.lang package is given below.\nPrimitive Type Wrapper class\nboolean Boolean\nchar Character\nbyte Byte\nshort Short\nint Integer\nlong Long\nfloat Float\ndouble Double",
        "reference": "javatpoint.com"
    },
    {
        "question": "219)What are autoboxing and unboxing? When does it occur?",
        "answer": "The autoboxing is the process of converting primitive data type to the corresponding wrapper class object, eg., int to Integer. The unboxing is the process of converting wrapper class object to primitive data type. For eg., integer to int. Unboxing and autoboxing occur automatically in Java. However, we can externally convert one into another by using the methods like valueOf() or xxxValue().\nIt can occur whenever a wrapper class object is expected, and primitive data type is provided or vice versa.\nAdding primitive types into Collection like ArrayList in Java.\nCreating an instance of parameterized classes ,e.g., ThreadLocal which expect Type.\nJava automatically converts primitive to object whenever one is required and another is provided in the method calling.\nWhen a primitive type is assigned to an object type.",
        "reference": "javatpoint.com"
    },
    {
        "question": "220) What is the output of the below Java program?",
        "answer": "public class Test1  \n{  \n  public static void main(String[] args) {  \n  Integer i = new Integer(201);  \n  Integer j = new Integer(201);  \n  if(i == j)  \n  {  \n    System.out.println(\"hello\");  \n  }  \n  else   \n  {  \n    System.out.println(\"bye\");  \n  }  \n  }  \n}  \nOutput\nbye\nExplanation\nThe Integer class caches integer values from -127 to 127. Therefore, the Integer objects can only be created in the range -128 to 127. The operator == will not work for the value greater than 127; thus bye is printed.",
        "reference": "javatpoint.com"
    },
    {
        "question": "221) What is object cloning?",
        "answer": "The object cloning is a way to create an exact copy of an object. The clone() method of the Object class is used to clone an object. The java.lang.Cloneable interface must be implemented by the class whose object clone we want to create. If we don't implement Cloneable interface, clone() method generates CloneNotSupportedException. The clone() method is defined in the Object class. The syntax of the clone() method is as follows:\nprotected Object clone() throws CloneNotSupportedException",
        "reference": "javatpoint.com"
    },
    {
        "question": "222) What are the advantages and disadvantages of object cloning?",
        "answer": "Advantage of Object Cloning\nYou don't need to write lengthy and repetitive codes. Just use an abstract class with a 4- or 5-line long clone() method.\nIt is the easiest and most efficient way of copying objects, especially if we are applying it to an already developed or an old project. Just define a parent class, implement Cloneable in it, provide the definition of the clone() method and the task will be done.\nClone() is the fastest way to copy the array.\nDisadvantage of Object Cloning\nTo use the Object.clone() method, we have to change many syntaxes to our code, like implementing a Cloneable interface, defining the clone() method and handling CloneNotSupportedException, and finally, calling Object.clone(), etc.\nWe have to implement the Cloneable interface while it does not have any methods in it. We have to use it to tell the JVM that we can perform a clone() on our object.\nObject.clone() is protected, so we have to provide our own clone() and indirectly call Object.clone() from it.\nObject.clone() does not invoke any constructor, so we do not have any control over object construction.\nIf you want to write a clone method in a child class, then all of its superclasses should define the clone() method in them or inherit it from another parent class. Otherwise, the super.clone() chain will fail.\nObject.clone() supports only shallow copying, but we will need to override it if we need deep cloning.",
        "reference": "javatpoint.com"
    },
    {
        "question": "223) What is a native method?",
        "answer": "A native method is a method that is implemented in a language other than Java. Natives methods are sometimes also referred to as foreign methods.",
        "reference": "javatpoint.com"
    },
    {
        "question": "224) What is the purpose of the strictfp keyword?",
        "answer": "Java strictfp keyword ensures that you will get the same result on every platform if you perform operations in the floating-point variable. The precision may differ from platform to platform that is why java programming language has provided the strictfp keyword so that you get the same result on every platform. So, now you have better control over the floating-point arithmetic.",
        "reference": "javatpoint.com"
    },
    {
        "question": "225) What is the purpose of the System class?",
        "answer": "The purpose of the System class is to provide access to system resources such as standard input and output. It cannot be instantiated. Facilities provided by System class are given below.\nStandard input\nError output streams\nStandard output\nutility method to copy the portion of an array\nutilities to load files and libraries\nThere are the three fields of Java System class, i.e., static printstream err, static inputstream in, and standard output stream.",
        "reference": "javatpoint.com"
    },
    {
        "question": "226) What comes to mind when someone mentions a shallow copy in Java?",
        "answer": "Object cloning.",
        "reference": "javatpoint.com"
    },
    {
        "question": "227) What is a singleton class?",
        "answer": "Singleton class is the class which can not be instantiated more than once. To make a class singleton, we either make its constructor private or use the static getInstance method. Consider the following example.\nclass Singleton{  \n    private static Singleton single_instance = null;  \n    int i;  \n     private Singleton ()  \n     {  \n         i=90;  \n     }  \n     public static Singleton getInstance()  \n     {  \n         if(single_instance == null)  \n         {  \n             single_instance = new Singleton();  \n         }  \n         return single_instance;  \n     }  \n}  \npublic class Main   \n{  \n    public static void main (String args[])  \n    {  \n        Singleton first = Singleton.getInstance();  \n        System.out.println(\"First instance integer value:\"+first.i);  \n        first.i=first.i+90;  \n        Singleton second = Singleton.getInstance();  \n        System.out.println(\"Second instance integer value:\"+second.i);  \n    }  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Program\nclass A{  \npublic static void main(String args[]){  \n  for(int i=0;i<args.length;i++)  \nSystem.out.println(args[i]);  \n  }  \n}  \ncompile by > javac A.java  \nrun by > java A sonoo jaiswal 1 3 abc  \nOutput\nsonoo\njaiswal\n1\n3\nabc",
        "reference": "javatpoint.com"
    },
    {
        "question": "229) Which containers use a border layout as their default layout?",
        "answer": "The Window, Frame and Dialog classes use a border layout as their default layout.",
        "reference": "javatpoint.com"
    },
    {
        "question": "230) Which containers use a FlowLayout as their default layout?",
        "answer": "The Panel and Applet classes use the FlowLayout as their default layout.",
        "reference": "javatpoint.com"
    },
    {
        "question": "231) What are peerless components?",
        "answer": "The lightweight component of Swing is called peerless components. Spring has its libraries, so it does not use resources from the Operating System, and hence it has lightweight components.",
        "reference": "javatpoint.com"
    },
    {
        "question": "232) is there is any difference between a Scrollbar and a ScrollPane?",
        "answer": "The Scrollbar is a Component whereas the ScrollPane is a Container. A ScrollPane handles its events and performs its scrolling.",
        "reference": "javatpoint.com"
    },
    {
        "question": "233) What is a lightweight component?",
        "answer": "Lightweight components are the one which does not go with the native call to obtain the graphical units. They share their parent component graphical units to render them. For example, Swing components, and JavaFX Components.",
        "reference": "javatpoint.com"
    },
    {
        "question": "234) What is a heavyweight component?",
        "answer": "The portable elements provided by the operating system are called heavyweight components. AWT is limited to the graphical classes provided by the operating system and therefore, It implements only the minimal subset of screen elements supported by all platforms. The Operating system dependent UI discovery tools are called heavyweight components.",
        "reference": "javatpoint.com"
    },
    {
        "question": "235) What is an applet?",
        "answer": "An applet is a small java program that runs inside the browser and generates dynamic content. It is embedded in the webpage and runs on the client side. It is secured and takes less response time. It can be executed by browsers running under many platforms, including Linux, Windows, Mac Os, etc. However, the plugins are required at the client browser to execute the applet. The following image shows the architecture of Applet.\n\nWhen an applet is created, the following methods are invoked in order.\ninit()\nstart()\npaint()\nWhen an applet is destroyed, the following functions are invoked in order.\nstop()\ndestroy()",
        "reference": "javatpoint.com"
    },
    {
        "question": "236) Can you write a Java class that could be used both as an applet as well as an application?",
        "answer": "Yes. Add a main() method to the applet.",
        "reference": "javatpoint.com"
    },
    {
        "question": "237) What is Locale?",
        "answer": "A Locale object represents a specific geographical, political, or cultural region. This object can be used to get the locale-specific information such as country name, language, variant, etc.\nimport java.util.*;  \npublic class LocaleExample {  \npublic static void main(String[] args) {  \nLocale locale=Locale.getDefault();  \n//Locale locale=new Locale(\"fr\",\"fr\");//for the specific locale  \n  System.out.println(locale.getDisplayCountry());  \nSystem.out.println(locale.getDisplayLanguage());  \nSystem.out.println(locale.getDisplayName());  \nSystem.out.println(locale.getISO3Country());  \nSystem.out.println(locale.getISO3Language());  \nSystem.out.println(locale.getLanguage());  \nSystem.out.println(locale.getCountry());  \n      }  \n}  \nOutput:\nUnited States\nEnglish\nEnglish (United States)\nUSA\neng\nen\nUS",
        "reference": "javatpoint.com"
    },
    {
        "question": "238)How will you load a specific locale?",
        "answer": "By ResourceBundle.getBundle(?) method.",
        "reference": "javatpoint.com"
    },
    {
        "question": "239) What is a JavaBean?",
        "answer": "JavaBean is a reusable software component written in the Java programming language, designed to be manipulated visually by a software development environment, like JBuilder or VisualAge for Java. t. A JavaBean encapsulates many objects into one object so that we can access this object from multiple places. Moreover, it provides the easy maintenance. Consider the following example to create a JavaBean class.\n//Employee.java  \npackage mypack;  \npublic class Employee implements java.io.Serializable{  \nprivate int id;  \nprivate String name;  \npublic Employee(){}  \npublic void setId(int id){this.id=id;}  \npublic int getId(){return id;}  \npublic void setName(String name){this.name=name;}  \npublic String getName(){return name;}  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "240) What is the purpose of using the Java bean?",
        "answer": "According to Java white paper, it is a reusable software component. A bean encapsulates many objects into one object so that we can access this object from multiple places. Moreover, it provides the easy maintenance.",
        "reference": "javatpoint.com"
    },
    {
        "question": "241) What do you understand by the bean persistent property?",
        "answer": "The persistence property of Java bean comes into the act when the properties, fields, and state information are saved to or retrieve from the storage.",
        "reference": "javatpoint.com"
    },
    {
        "question": "242) What is RMI?",
        "answer": "The RMI (Remote Method Invocation) is an API that provides a mechanism to create the distributed application in java. The RMI allows an object to invoke methods on an object running in another JVM. The RMI provides remote communication between the applications using two objects stub and skeleton.",
        "reference": "javatpoint.com"
    },
    {
        "question": "243) What is the purpose of stub and skeleton?",
        "answer": "Stub\nThe stub is an object, acts as a gateway for the client side. All the outgoing requests are routed through it. It resides at the client side and represents the remote object. When the caller invokes the method on the stub object, it does the following tasks:\nIt initiates a connection with remote Virtual Machine (JVM).\nIt writes and transmits (marshals) the parameters to the remote Virtual Machine (JVM).\nIt waits for the result.\nIt reads (unmarshals) the return value or exception.\nIt finally, returns the value to the caller.\n\nSkeleton\nThe skeleton is an object, acts as a gateway for the server side object. All the incoming requests are routed through it. When the skeleton receives the incoming request, it does the following tasks:\nIt reads the parameter for the remote method.\nIt invokes the method on the actual remote object.\nIt writes and transmits (marshals) the result to the caller.",
        "reference": "javatpoint.com"
    },
    {
        "question": "244) What are the steps involved to write RMI based programs?",
        "answer": "There are 6 steps which are performed to write RMI based programs.\nCreate the remote interface.\nProvide the implementation of the remote interface.\nCompile the implementation class and create the stub and skeleton objects using the rmic tool.\nStart the registry service by the rmiregistry tool.\nCreate and start the remote application.\nCreate and start the client application.",
        "reference": "javatpoint.com"
    },
    {
        "question": "245) What is the use of HTTP-tunneling in RMI?",
        "answer": "HTTP tunneling can be defined as the method which doesn't need any setup to work within the firewall environment. It handles the HTTP connections through the proxy servers. However, it does not allow outbound TCP connections.",
        "reference": "javatpoint.com"
    },
    {
        "question": "246) What is JRMP?",
        "answer": "JRMP (Java Remote Method Protocol) can be defined as the Java-specific, stream-based protocol which looks up and refers to the remote objects. It requires both client and server to use Java objects. It is wire level protocol which runs under RMI and over TCP/IP.",
        "reference": "javatpoint.com"
    },
    {
        "question": "247) Can RMI and CORBA based applications interact?",
        "answer": "Yes, they can. RMI is available with IIOP as the transport protocol instead of JRMP.",
        "reference": "javatpoint.com"
    },
    {
        "question": "248) How to perform Bubble Sort in Java?",
        "answer": "Consider the following program to perform Bubble sort in Java.\npublic class BubbleSort {  \n  public static void main(String[] args) {  \n  int[] a = {10, 9, 7, 101, 23, 44, 12, 78, 34, 23};  \n  for(int i=0;i<10;i++)  \n  {  \n    for (int j=0;j<10;j++)  \n    {  \n      if(a[i]<a[j])  \n      {  \n        int temp = a[i];  \n        a[i]=a[j];  \n        a[j] = temp;   \n      }  \n    }  \n  }  \n  System.out.println(\"Printing Sorted List ...\");  \n  for(int i=0;i<10;i++)  \n  {  \n    System.out.println(a[i]);  \n  }  \n}  \n}  \nOutput:\nPrinting Sorted List . . . \n7\n9\n10\n12\n23\n34\n34\n44\n78 \n101",
        "reference": "javatpoint.com"
    },
    {
        "question": "249) How to perform Binary Search in Java?",
        "answer": "Consider the following program to perform the binary search in Java.\nimport java.util.*;  \npublic class BinarySearch {  \npublic static void main(String[] args) {  \n  int[] arr = {16, 19, 20, 23, 45, 56, 78, 90, 96, 100};  \n  int item, location = -1;  \n  System.out.println(\"Enter the item which you want to search\");  \n  Scanner sc = new Scanner(System.in);  \n  item = sc.nextInt();  \n  location = binarySearch(arr,0,9,item);  \n  if(location != -1)  \n  System.out.println(\"the location of the item is \"+location);  \n  else   \n    System.out.println(\"Item not found\");  \n  }  \npublic static int binarySearch(int[] a, int beg, int end, int item)  \n{  \n  int mid;  \n  if(end >= beg)   \n  {   \n    mid = (beg + end)/2;  \n    if(a[mid] == item)  \n    {  \n      return mid+1;  \n    }  \n    else if(a[mid] < item)   \n    {  \n      return binarySearch(a,mid+1,end,item);  \n    }  \n    else   \n    {  \n      return binarySearch(a,beg,mid-1,item);  \n    }  \n  }  \n  return -1;   \n}  \n}  \nOutput:\nEnter the item which you want to search \n45 \nthe location of the item is 5",
        "reference": "javatpoint.com"
    },
    {
        "question": "250) How to perform Selection Sort in Java?",
        "answer": "Consider the following program to perform selection sort in Java.\npublic class SelectionSort {  \npublic static void main(String[] args) {  \n  int[] a = {10, 9, 7, 101, 23, 44, 12, 78, 34, 23};  \n  int i,j,k,pos,temp;  \n  for(i=0;i<10;i++)  \n  {  \n    pos = smallest(a,10,i);  \n    temp = a[i];  \n    a[i]=a[pos];  \n    a[pos] = temp;  \n  }  \n  System.out.println(\"\\nprinting sorted elements...\\n\");  \n  for(i=0;i<10;i++)  \n  {  \n    System.out.println(a[i]);  \n  }  \n}  \npublic static int smallest(int a[], int n, int i)  \n{  \n  int small,pos,j;  \n  small = a[i];  \n  pos = i;  \n  for(j=i+1;j<10;j++)  \n  {  \n    if(a[j]<small)  \n    {  \n      small = a[j];  \n      pos=j;  \n    }  \n  }  \n  return pos;  \n}  \n}  \nOutput:\nprinting sorted elements...\n7\n9\n10\n12\n23\n23\n34\n44\n78\n101",
        "reference": "javatpoint.com"
    },
    {
        "question": "251) How to perform Linear Search in Java?",
        "answer": "Consider the following program to perform Linear search in Java.\nimport java.util.Scanner;  \n  public class Leniear_Search {  \npublic static void main(String[] args) {  \n  int[] arr = {10, 23, 15, 8, 4, 3, 25, 30, 34, 2, 19};  \n  int item,flag=0;   \n  Scanner sc = new Scanner(System.in);  \n  System.out.println(\"Enter Item ?\");  \n  item = sc.nextInt();  \n  for(int i = 0; i<10; i++)  \n  {  \n    if(arr[i]==item)  \n    {  \n      flag = i+1;  \n      break;  \n    }  \n    else   \n      flag = 0;   \n  }  \n  if(flag != 0)  \n  {  \n    System.out.println(\"Item found at location\" + flag);  \n  }  \n  else   \n    System.out.println(\"Item not found\");  \n    }  \n}  \nOutput:\nEnter Item ?\n23\nItem found at location 2\nEnter Item ?\n22\nItem not found",
        "reference": "javatpoint.com"
    },
    {
        "question": "252) How to perform merge sort in Java?",
        "answer": "Consider the following program to perform merge sort in Java.\npublic class MyMergeSort  \n{  \nvoid merge(int arr[], int beg, int mid, int end)  \n{  \n  int l = mid - beg + 1;  \nint r = end - mid;  \n  intLeftArray[] = new int [l];  \nintRightArray[] = new int [r];  \n  for (int i=0; i<l; ++i)  \nLeftArray[i] = arr[beg + i];  \n  for (int j=0; j<r; ++j)  \nRightArray[j] = arr[mid + 1+ j];  \n    int i = 0, j = 0;  \nint k = beg;  \nwhile (i<l&&j<r)  \n{  \nif (LeftArray[i] <= RightArray[j])  \n{  \narr[k] = LeftArray[i];  \ni++;  \n}  \nelse  \n{  \narr[k] = RightArray[j];  \nj++;  \n}  \nk++;  \n}  \nwhile (i<l)  \n{  \narr[k] = LeftArray[i];  \ni++;  \nk++;  \n}  \n  while (j<r)  \n{  \narr[k] = RightArray[j];  \nj++;  \nk++;  \n}  \n}  \n  void sort(int arr[], int beg, int end)  \n{  \nif (beg<end)  \n{  \nint mid = (beg+end)/2;  \nsort(arr, beg, mid);  \nsort(arr , mid+1, end);  \nmerge(arr, beg, mid, end);  \n}  \n}  \npublic static void main(String args[])  \n{  \nintarr[] = {90,23,101,45,65,23,67,89,34,23};  \nMyMergeSort ob = new MyMergeSort();  \nob.sort(arr, 0, arr.length-1);  \n  System.out.println(\"\\nSorted array\");  \nfor(int i =0; i<arr.length;i++)  \n{  \n  System.out.println(arr[i]+\"\");  \n}  \n}  \n}  \nOutput:\nSorted array \n23\n23\n23\n34\n45\n65\n67\n89\n90\n101",
        "reference": "javatpoint.com"
    },
    {
        "question": "253) How to perform quicksort in Java?",
        "answer": "Consider the following program to perform quicksort in Java.\npublic class QuickSort {  \npublic static void main(String[] args) {  \n    int i;  \n    int[] arr={90,23,101,45,65,23,67,89,34,23};  \n    quickSort(arr, 0, 9);  \n    System.out.println(\"\\n The sorted array is: \\n\");  \n    for(i=0;i<10;i++)  \n    System.out.println(arr[i]);  \n  }  \n  public static int partition(int a[], int beg, int end)  \n  {  \n          int left, right, temp, loc, flag;   \n    loc = left = beg;  \n    right = end;  \n    flag = 0;  \n    while(flag != 1)  \n    {  \n      while((a[loc] <= a[right]) && (loc!=right))  \n      right--;  \n      if(loc==right)  \n      flag =1;  \n      elseif(a[loc]>a[right])  \n      {  \n        temp = a[loc];  \n        a[loc] = a[right];  \n        a[right] = temp;  \n        loc = right;  \n      }  \n      if(flag!=1)  \n      {  \n        while((a[loc] >= a[left]) && (loc!=left))  \n        left++;  \n        if(loc==left)  \n        flag =1;  \n        elseif(a[loc] <a[left])  \n        {  \n          temp = a[loc];  \n          a[loc] = a[left];  \n          a[left] = temp;  \n          loc = left;  \n        }  \n      }  \n    }  \n    returnloc;  \n  }  \n  static void quickSort(int a[], int beg, int end)  \n  {  \n          int loc;  \n    if(beg<end)  \n    {  \n      loc = partition(a, beg, end);  \n      quickSort(a, beg, loc-1);  \n      quickSort(a, loc+1, end);  \n    }  \n  }  \n}  \nOutput:\nThe sorted array is: \n23\n23\n23\n34\n45\n65\n67\n89\n90\n101",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Consider the following program to create a doubly linked list containing n nodes.\n  public class CountList {  \n          //Represent a node of the doubly linked list  \n      class Node{  \n        int data;  \n        Node previous;  \n        Node next;  \n                  public Node(int data) {  \n            this.data = data;  \n        }  \n    }  \n          //Represent the head and tail of the doubly linked list  \n    Node head, tail = null;  \n          //addNode() will add a node to the list  \n    public void addNode(int data) {  \n        //Create a new node  \n        Node newNode = new Node(data);  \n                  //If list is empty  \n        if(head == null) {  \n            //Both head and tail will point to newNode  \n            head = tail = newNode;  \n            //head's previous will point to null  \n            head.previous = null;  \n            //tail's next will point to null, as it is the last node of the list  \n            tail.next = null;  \n        }  \n        else {  \n            //newNode will be added after tail such that tail's next will point to newNode  \n            tail.next = newNode;  \n            //newNode's previous will point to tail  \n            newNode.previous = tail;  \n            //newNode will become new tail  \n            tail = newNode;  \n            //As it is last node, tail's next will point to null  \n            tail.next = null;  \n        }  \n    }  \n          //countNodes() will count the nodes present in the list  \n    public int countNodes() {  \n        int counter = 0;  \n        //Node current will point to head  \n        Node current = head;  \n                  while(current != null) {  \n            //Increment the counter by 1 for each node  \n            counter++;  \n            current = current.next;  \n        }  \n        return counter;  \n    }  \n          //display() will print out the elements of the list  \n    public void display() {  \n        //Node current will point to head  \n        Node current = head;  \n        if(head == null) {  \n            System.out.println(\"List is empty\");  \n            return;  \n        }  \n        System.out.println(\"Nodes of doubly linked list: \");  \n        while(current != null) {  \n            //Prints each node by incrementing the pointer.  \n              System.out.print(current.data + \" \");  \n            current = current.next;  \n        }  \n    }  \n          public static void main(String[] args) {  \n                  CountList dList = new CountList();  \n        //Add nodes to the list  \n        dList.addNode(1);  \n        dList.addNode(2);  \n        dList.addNode(3);  \n        dList.addNode(4);  \n        dList.addNode(5);  \n                  //Displays the nodes present in the list  \n        dList.display();  \n                  //Counts the nodes present in the given list  \n        System.out.println(\"\\nCount of nodes present in the list: \" + dList.countNodes());  \n    }  \n}  \nOutput:\nNodes of doubly linked list: \n1 2 3 4 5 \nCount of nodes present in the list: 5",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Consider the following program.\npublic class MinMax {  \n    //Represents the node of list.  \n    public class Node{  \n        int data;  \n        Node next;  \n        public Node(int data) {  \n            this.data = data;  \n        }  \n    }  \n          //Declaring head and tail pointer as null.  \n    public Node head = null;  \n    public Node tail = null;  \n          //This function will add the new node at the end of the list.  \n    public void add(int data){  \n        //Create new node  \n        Node newNode = new Node(data);  \n        //Checks if the list is empty.  \n        if(head == null) {  \n             //If list is empty, both head and tail would point to new node.  \n            head = newNode;  \n            tail = newNode;  \n            newNode.next = head;  \n        }  \n        else {  \n            //tail will point to new node.  \n            tail.next = newNode;  \n            //New node will become new tail.  \n            tail = newNode;  \n            //Since, it is circular linked list tail will points to head.  \n            tail.next = head;  \n        }  \n    }  \n          //Finds out the minimum value node in the list  \n    public void minNode() {  \n        Node current = head;  \n        //Initializing min to initial node data  \n        int min = head.data;  \n        if(head == null) {  \n            System.out.println(\"List is empty\");  \n        }  \n        else {  \n             do{  \n                 //If current node's data is smaller than min  \n                 //Then replace value of min with current node's data  \n                 if(min > current.data) {  \n                     min = current.data;  \n                 }  \n                 current= current.next;  \n            }while(current != head);  \n                      System.out.println(\"Minimum value node in the list: \"+ min);  \n        }  \n    }  \n              //Finds out the maximum value node in the list  \n    public void maxNode() {  \n        Node current = head;  \n        //Initializing max to initial node data  \n        int max = head.data;  \n        if(head == null) {  \n            System.out.println(\"List is empty\");  \n        }  \n        else {  \n             do{  \n                 //If current node's data is greater than max  \n                 //Then replace value of max with current node's data  \n                 if(max < current.data) {  \n                     max = current.data;  \n                 }  \n                 current= current.next;  \n                }while(current != head);  \n                           System.out.println(\"Maximum value node in the list: \"+ max);  \n        }  \n    }  \n                      public static void main(String[] args) {  \n        MinMax cl = new MinMax();  \n        //Adds data to the list  \n        cl.add(5);  \n        cl.add(20);  \n        cl.add(10);  \n        cl.add(1);  \n        //Prints the minimum value node in the list  \n        cl.minNode();  \n        //Prints the maximum value node in the list  \n        cl.maxNode();  \n    }  \n}  \nOutput:\nMinimum value node in the list: 1\nMaximum value node in the list: 20",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Consider the following program.\nimport java.util.LinkedList;  \nimport java.util.Queue;  \n   public class DiffOddEven {  \n          //Represent a node of binary tree  \n    public static class Node{  \n        int data;  \n        Node left;  \n        Node right;  \n                  public Node(int data){  \n            //Assign data to the new node, set left and right children to null  \n            this.data = data;  \n            this.left = null;  \n            this.right = null;  \n            }  \n        }  \n          //Represent the root of binary tree  \n    public Node root;  \n        public DiffOddEven(){  \n        root = null;  \n    }  \n       //difference() will calculate the difference between sum of odd and even levels of binary tree  \n    public int difference() {  \n          int oddLevel = 0, evenLevel = 0, diffOddEven = 0;  \n                      //Variable nodesInLevel keep tracks of number of nodes in each level  \n          int nodesInLevel = 0;  \n                      //Variable currentLevel keep track of level in binary tree  \n          int currentLevel = 0;  \n                      //Queue will be used to keep track of nodes of tree level-wise  \n          Queue<Node> queue = new LinkedList<Node>();  \n                      //Check if root is null  \n          if(root == null) {  \n              System.out.println(\"Tree is empty\");  \n              return 0;  \n          }  \n          else {  \n              //Add root node to queue as it represents the first level  \n              queue.add(root);  \n              currentLevel++;  \n                              while(queue.size() != 0) {  \n                                      //Variable nodesInLevel will hold the size of queue i.e. number of elements in queue  \n                  nodesInLevel = queue.size();  \n                                      while(nodesInLevel > 0) {  \n                      Node current = queue.remove();  \n                                            //Checks if currentLevel is even or not.  \n                      if(currentLevel % 2 == 0)  \n                          //If level is even, add nodes's to variable evenLevel  \n                          evenLevel += current.data;  \n                      else  \n                          //If level is odd, add nodes's to variable oddLevel  \n                          oddLevel += current.data;  \n                                              //Adds left child to queue  \n                      if(current.left != null)  \n                          queue.add(current.left);  \n                      //Adds right child to queue  \n                      if(current.right != null)   \n                          queue.add(current.right);  \n                     nodesInLevel--;  \n                  }  \n                  currentLevel++;  \n              }  \n              //Calculates difference between oddLevel and evenLevel  \n              diffOddEven = Math.abs(oddLevel - evenLevel);  \n          }  \n          return diffOddEven;  \n      }  \n        public static void main (String[] args) {  \n                  DiffOddEven bt = new DiffOddEven();  \n        //Add nodes to the binary tree  \n        bt.root = new Node(1);  \n        bt.root.left = new Node(2);  \n        bt.root.right = new Node(3);  \n        bt.root.left.left = new Node(4);  \n        bt.root.right.left = new Node(5);  \n        bt.root.right.right = new Node(6);  \n              //Display the difference between sum of odd level and even level nodes  \n        System.out.println(\"Difference between sum of odd level and even level nodes: \" + bt.difference());  \n}  \n}  \nOutput:\nDifference between sum of odd level and even level nodes: 11",
        "reference": "javatpoint.com"
    }
]