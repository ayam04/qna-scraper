[
    {
        "question": "",
        "answer": "Method overloading in Java allows us to define multiple methods in the same class with the same name but different parameter lists. The parameters can differ in terms of number, order, or type. Method overloading is a form of compile-time polymorphism.\nExample:\npublic class Calculator {  \n    public int add(int a, int b) {  \n        return a + b;  \n    }  \n    public double add(double a, double b) {  \n        return a + b;  \n    }  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "2) How does Java distinguish between overloaded methods?",
        "answer": "Java distinguishes between overloaded methods based on the number, order, and types of the parameters. During compilation, the Java compiler resolves the correct method to call based on the arguments provided.",
        "reference": "javatpoint.com"
    },
    {
        "question": "3) Can method overloading be based solely on the return type of the method? Why or why not?",
        "answer": "No, method overloading cannot be based solely on the return type. Java uses the method's name and parameter list to determine which method to call. Return type alone is not sufficient to differentiate between overloaded methods.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Compile-time polymorphism, also known as static polymorphism, is a mechanism where the appropriate method to be called is determined at compile-time based on the method's signature. Method overloading is an example of compile-time polymorphism, where the decision about which method to call is made by the compiler based on the method's parameters and their types.",
        "reference": "javatpoint.com"
    },
    {
        "question": "5) Can we overload static methods in Java? Why or why not?",
        "answer": "Yes, we can overload static methods in Java. Like instance methods, static methods can also be overloaded. Java determines which overloaded static method to call based on the method's parameter list.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Inheritance and method overloading work together seamlessly. If a subclass defines a method with the same name and parameter list as a method in its superclass, it's not considered method overloading; it's method overriding. Method overloading applies when methods in the same class have different parameter lists.\nExample:\nclass Parent {  \n    void print(int x) {  \n        System.out.println(\"Parent: \" + x);  \n    }  \n}  \nclass Child extends Parent {  \n    void print(double y) {  \n        System.out.println(\"Child: \" + y);  \n    }  \n}",
        "reference": "javatpoint.com"
    },
    {
        "question": "7) What happens if we define two overloaded methods with the same parameter types and the same method name, but different return types?",
        "answer": "It would result in a compilation error. Overloaded methods must have different parameter lists. The return type alone is not sufficient to distinguish between overloaded methods.",
        "reference": "javatpoint.com"
    },
    {
        "question": "Can methods with different parameter types be overloaded?",
        "answer": "Method parameters play a crucial role in method overloading. Methods with different parameter types (or number of parameters) can indeed be overloaded, as long as there's a difference in the parameters that allows the compiler to distinguish between them.\nADVERTISEMENT",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "No, we cannot overload methods based solely on the exception thrown by the method. Overloading is determined by the method's name and parameter list, not the exceptions it throws.",
        "reference": "javatpoint.com"
    },
    {
        "question": "10) How does method overloading contribute to code readability and maintenance in Java?",
        "answer": "Method overloading enhances code readability by allowing developers to use the same method name for related functionalities. It can make the code more intuitive and easier to understand. It also contributes to code maintenance, as changes to a single method name can affect multiple overloaded methods, reducing the need for separate, distinct method names.",
        "reference": "javatpoint.com"
    }
]