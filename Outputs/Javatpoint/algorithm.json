[
    {
        "question": "1) What is an algorithm? What is the need for an algorithm?",
        "answer": "An algorithm is a well-defined computational procedure that takes some values or the set of values, as an input and produces a set of values or some values, as an output.\nNeed for Algorithm\nADVERTISEMENT\nThe algorithm provides the basic idea of the problem and an approach to solve it. Some reasons to use an algorithm are as follows.\nADVERTISEMENT\nThe algorithm improves the efficiency of an existing technique.\nTo compare the performance of the algorithm with respect to other techniques.\nThe algorithm gives a strong description of requirements and goal of the problems to the designer.\nThe algorithm provides a reasonable understanding of the flow of the program.\nThe algorithm measures the performance of the methods in different cases (Best cases, worst cases, average cases).\nThe algorithm identifies the resources (input/output, memory) cycles required by the algorithm.\nWith the help of an algorithm, we can measure and analyze the complexity time and space of the problems.\nThe algorithm also reduces the cost of design.",
        "reference": "javatpoint.com"
    },
    {
        "question": "2) What is the Complexity of Algorithm?",
        "answer": "The complexity of the algorithm is a way to classify how efficient an algorithm is compared to alternative ones. Its focus is on how execution time increases with the data set to be processed. The computational complexity of the algorithm is important in computing.\nIt is very suitable to classify algorithm based on the relative amount of time or relative amount of space they required and specify the growth of time/ space requirement as a function of input size.\nTime complexity\nTime complexity is a Running time of a program as a function of the size of the input.\nSpace complexity\nSpace complexity analyzes the algorithms, based on how much space an algorithm needs to complete its task. Space complexity analysis was critical in the early days of computing (when storage space on the computer was limited).\nNowadays, the problem of space rarely occurs because space on the computer is broadly enough.\nWe achieve the following types of analysis for complexity\nWorst-case: f(n)\nIt is defined by the maximum number of steps taken on any instance of size n.\nBest-case: f(n)\nIt is defined by the minimum number of steps taken on any instance of size n.\nAverage-case: f(n)\nIt is defined by the average number of steps taken on any instance of size n.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Algorithm to reverse a string.\nStep1: start\nStep2: Take two variable i and j\n\nStep3: do length (string)-1, to set J at last position\nStep4: do string [0], to set i on the first character.\nStep5: string [i] is interchanged with string[j]\nStep6: Increment i by 1\nStep7: Increment j by 1\nStep8: if i>j then go to step3\n\nStep9: Stop",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Algorithm to insert a node in a sorted linked list.\nCase1:\nCheck if the linked list is empty then set the node as head and return it.\nNew_node-> Next= head;  \nHead=New_node  \nCase2:\nInsert the new node in middle\nWhile( P!= insert position)  \n{  \nP= p-> Next;  \n}  \nStore_next=p->Next;  \nP->Next= New_node;  \nNew_Node->Next = Store_next;  \nCase3:\nInsert a node at the end\nWhile (P->next!= null)  \n{  \nP= P->Next;  \n}  \nP->Next = New_Node;  \nNew_Node->Next = null;",
        "reference": "javatpoint.com"
    },
    {
        "question": "5) What are the Asymptotic Notations?",
        "answer": "Asymptotic analysis is used to measure the efficiency of an algorithm that doesn't depend on machine-specific constants and prevents the algorithm from comparing the time taking algorithm. Asymptotic notation is a mathematical tool that is used to represent the time complexity of algorithms for asymptotic analysis.\nThe three most used asymptotic notation is as follows.\n\u03b8 Notation\n\u03b8 Notation defines the exact asymptotic behavior. To define a behavior, it bounds functions from above and below. A convenient way to get Theta notation of an expression is to drop low order terms and ignore leading constants.\n\nBig O Notation\nThe Big O notation bounds a function from above, it defines an upper bound of an algorithm. Let's consider the case of insertion sort; it takes linear time in the best case and quadratic time in the worst case. The time complexity of insertion sort is O(n2). It is useful when we only have upper bound on time complexity of an algorithm.\n\n\u03a9 Notation\nJust like Big O notation provides an asymptotic upper bound, the \u03a9 Notation provides an asymptotic lower bound on a function. It is useful when we have lower bound on time complexity of an algorithm.",
        "reference": "javatpoint.com"
    },
    {
        "question": "6) Explain the Bubble sort algorithm?",
        "answer": "Bubble sort is the simplest sorting algorithm among all sorting algorithm. It repeatedly works by swapping the adjacent elements if they are in the wrong order.\ne.g.\n(72538) we have this array for sorting.\nPass1:\n(72538) -> (27538) swap 7 and 2.\n(27538) -> (25738) swap 7 and 5.\n(25738) -> (25378) swap 7 and 3.\n(25378) -> (25378) algorithm does not swap 7 and 8 because 7<8.\nPass2:\n(25378) -> (25378) algorithm does not swap 2 and 5 because 2<5.\n(25378) -> (23578) swap 3 and 5.\n(23578) -> (23578) algorithm does not swap 5 and 7 because 5<7.\n(23578) -> (23578) algorithm does not swap 7 and 8 because 7<8.\nHere, the sorted element is (23578).",
        "reference": "javatpoint.com"
    },
    {
        "question": "7) How to swap two integers without swapping the temporary variable in Java?",
        "answer": "It's a very commonly asked trick question. There are many ways to solve this problem.\nBut the necessary condition is we have to solve it without swapping the temporary variable.\nIf we think about integer overflow and consider its solution, then it creates an excellent impression in the eye of interviewers.\nSuppose we have two integers I and j, the value of i=7 and j=8 then how will you swap them without using a third variable. This is a journal problem.\nWe need to do this using Java programming constructs. We can swap numbers by performing some mathematical operations like addition, subtraction, multiplication, and division. But maybe it will create the problem of integer overflow.\nUsing addition and subtraction\na= a + b;  \nb=a - b; // this will act like (a+b)-b, now b is equal to a.  \na=a - b; // (a+b)-a, now, a is equal to b.  \nIt is a nice trick. But in this trick, the integer will overflow if the addition is more than the maximum value of int primitive as defined by Integer.MAX_VALUE and if subtraction is less than minimum value i.e., Integer.MIN_VALUE.\nUsing XOR trick\nAnother solution to swap two integers without using a third variable (temp variable) is widely recognized as the best solution, as it will also work in a language which doesn't handle integer overflow like Java example C, C++. Java supports several bitwise operators. One of them is XOR (denoted by ^).\nx=x^y;  \ny=x^y;  \nx=x^y;",
        "reference": "javatpoint.com"
    },
    {
        "question": "8) What is a Hash Table? How can we use this structure to find all anagrams in a dictionary?",
        "answer": "A Hash table is a data structure for storing values to keys of arbitrary type. The Hash table consists of an index into an array by using a Hash function. Indexes are used to store the elements. We assign each possible element to a bucket by using a hash function. Multiple keys can be assigned to the same bucket, so all the key and value pairs are stored in lists within their respective buckets. Right hashing function has a great impact on performance.\nTo find all anagrams in a dictionary, we have to group all words that contain the same set of letters in them. So, if we map words to strings representing their sorted letters, then we could group words into lists by using their sorted letters as a key.\nFUNCTION find_anagrams(words)  \n    word_groups = HashTable<String, List>  \n    FOR word IN words  \n        word_groups.get_or_default(sort(word), []).push(word)  \n    END FOR  \n    anagrams = List  \n    FOR key, value IN word_groups  \n        anagrams.push(value)  \n    END FOR  \n    RETURN anagrams  \nThe hash table contains lists mapped to strings. For each word, we add it to the list at the suitable key, or create a new list and add it to it.",
        "reference": "javatpoint.com"
    },
    {
        "question": "9) What is Divide and Conquer algorithms?",
        "answer": "Divide and Conquer is not an algorithm; it's a pattern for the algorithm. It is designed in a way as to take dispute on a huge input, break the input into minor pieces, and decide the problem for each of the small pieces. Now merge all of the piecewise solutions into a global solution. This strategy is called divide and conquer.\nDivide and conquer uses the following steps to make a dispute on an algorithm.\nDivide: In this section, the algorithm divides the original problem into a set of subproblems.\nConquer: In this section, the algorithm solves every subproblem individually.\nCombine: In this section, the algorithm puts together the solutions of the subproblems to get the solution to the whole problem.\n10) Explain the BFS algorithm?\nBFS (Breadth First Search) is a graph traversal algorithm. It starts traversing the graph from the root node and explores all the neighboring nodes. It selects the nearest node and visits all the unexplored nodes. The algorithm follows the same procedure for each of the closest nodes until it reaches the goal state.\nAlgorithm\nStep1: Set status=1 (ready state)\n\nStep2: Queue the starting node A and set its status=2, i.e. (waiting state)\nStep3: Repeat steps 4 and 5 until the queue is empty.\nStep4: Dequeue a node N and process it and set its status=3, i.e. (processed state)\nStep5: Queue all the neighbors of N that are in the ready state (status=1) and set their status =2 (waiting state)\n[Stop Loop]\nStep6: Exit",
        "reference": "javatpoint.com"
    },
    {
        "question": "10) Explain the BFS algorithm?",
        "answer": "BFS (Breadth First Search) is a graph traversal algorithm. It starts traversing the graph from the root node and explores all the neighboring nodes. It selects the nearest node and visits all the unexplored nodes. The algorithm follows the same procedure for each of the closest nodes until it reaches the goal state.\nAlgorithm\nStep1: Set status=1 (ready state)\n\nStep2: Queue the starting node A and set its status=2, i.e. (waiting state)\nStep3: Repeat steps 4 and 5 until the queue is empty.\nStep4: Dequeue a node N and process it and set its status=3, i.e. (processed state)\nStep5: Queue all the neighbors of N that are in the ready state (status=1) and set their status =2 (waiting state)\n[Stop Loop]\nStep6: Exit",
        "reference": "javatpoint.com"
    },
    {
        "question": "11) What is Dijkstra's shortest path algorithm?",
        "answer": "Dijkstra's algorithm is an algorithm for finding the shortest path from a starting node to the target node in a weighted graph. The algorithm makes a tree of shortest paths from the starting vertex and source vertex to all other nodes in the graph.\nSuppose you want to go from home to office in the shortest possible way. You know some roads are heavily congested and challenging to use this, means these edges have a large weight. In Dijkstra's algorithm, the shortest path tree found by the algorithm will try to avoid edges with larger weights.",
        "reference": "javatpoint.com"
    },
    {
        "question": "12) Give some examples of Divide and Conquer algorithm?",
        "answer": "Some problems that use Divide and conquer algorithm to find their solution are listed below.\nMerge Sort\nQuick Sort\nBinary Search\nStrassen's Matrix Multiplication\nClosest pair (points)",
        "reference": "javatpoint.com"
    },
    {
        "question": "13) What are Greedy algorithms? Give some example of it?",
        "answer": "A greedy algorithm is an algorithmic strategy which is made for the best optimal choice at each sub stage with the goal of this, eventually leading to a globally optimum solution. This means that the algorithm chooses the best solution at the moment without regard for consequences.\nIn other words, an algorithm that always takes the best immediate, or local, solution while finding an answer.\nGreedy algorithms find the overall, ideal solution for some idealistic problems, but may discover less-than-ideal solutions for some instances of other problems.\nBelow is a list of algorithms that finds their solution with the use of the Greedy algorithm.\nTravelling Salesman Problem\nPrim's Minimal Spanning Tree Algorithm\nKruskal's Minimal Spanning Tree Algorithm\nDijkstra's Minimal Spanning Tree Algorithm\nGraph - Map Coloring\nGraph - Vertex Cover\nKnapsack Problem\nJob Scheduling Problem",
        "reference": "javatpoint.com"
    },
    {
        "question": "14) What is a linear search?",
        "answer": "Linear search is used on a group of items. It relies on the technique of traversing a list from start to end by visiting properties of all the elements that are found on the way.\nFor example, suppose an array of with some integer elements. You should find and print the position of all the elements with their value. Here, the linear search acts in a flow like matching each element from the beginning of the list to the end of the list with the integer, and if the condition is `True then printing the position of the element.'\nImplementing Linear Search\nBelow steps are required to implement the linear search.\nStep1: Traverse the array using for loop.\nStep2: In every iteration, compare the target value with the current value of the array\nStep3: If the values match, return the current index of the array\nStep4: If the values do not match, shift on to the next array element.\nStep5: If no match is found, return -1",
        "reference": "javatpoint.com"
    },
    {
        "question": "15) What is a Binary Search Tree?",
        "answer": "The binary search tree is a special type of data structure which has the following properties.\nNodes which are less than root will be in the left subtree.\nNodes which are greater than root (i.e., contains more value) will be right subtree.\nA binary search tree should not have duplicate nodes.\nBoth sides subtree (i.e., left and right) also should be a binary search tree.",
        "reference": "javatpoint.com"
    },
    {
        "question": "16) Write an algorithm to insert a node in the Binary search tree?",
        "answer": "Insert node operation is a smooth operation. You need to compare it with the root node and traverse left (if smaller) or right (if greater) according to the value of the node to be inserted.\nAlgorithm:\nMake the root node as the current node\nIf the node to be inserted < root\nIf it has left child, then traverse left\nIf it does not have left child, insert node here\nIf the node to be inserted > root\nIf it has the right child, traverse right\nIf it does not have the right child, insert node here.",
        "reference": "javatpoint.com"
    },
    {
        "question": "17) How to count leaf nodes of the binary tree?",
        "answer": "Algorithm-\nSteps for counting the number of leaf nodes are:\nIf the node is null (contains null values) then return 0.\nIf encountered leaf node. Left is null and node Right is null then return 1.\nRecursively calculate the number of leaf nodes using\nNo. of leaf nodes= no of leaf nodes in left subtree + number of leaf nodes in the right subtree.",
        "reference": "javatpoint.com"
    },
    {
        "question": "18) How to find all possible words in a board of characters (Boggle game)?",
        "answer": "In the given dictionary, a process to do a lookup in the dictionary and an M x N board where every cell has a single character. Identify all possible words that can be formed by order of adjacent characters. Consider that we can move to any of the available 8 adjacent characters, but a word should not have multiple instances of the same cell.\nExample:\ndictionary[] = {\"Java\", \"Point\",\"Quiz\"};  \nArray[][]    = {{'J', 'T', 'P',},  \n        {'U', 'A', 'A'},  \n        {'Q', 'S', 'V'}};  \nisWord(str): returns true if str is present in dictionary   \n    else false.  \nOutput:\nFollowing words of the dictionary are present\nJAVA",
        "reference": "javatpoint.com"
    },
    {
        "question": "19) Write an algorithm to insert a node in a link list?",
        "answer": "Algorithm\nCheck If the Linked list does not have any value then make the node as head and return it\nCheck if the value of the node to be inserted is less than the value of the head node, then insert the node at the start and make it head.\nIn a loop, find the appropriate node after which the input node is to be inserted. To find the just node start from the head, keep forwarding until you reach a node whose value is greater than the input node. The node just before is the appropriate node.\nInsert the node after the proper node found in step 3.",
        "reference": "javatpoint.com"
    },
    {
        "question": "20) How to delete a node in a given link list? Write an algorithm and a program?",
        "answer": "Write a function to delete a given node from a Singly Linked List. The function must follow the following constraints:\nThe function must accept a pointer to the start node as the first argument and node to be deleted as the second argument, i.e., a pointer to head node is not global.\nThe function should not return a pointer to the head node.\nThe function should not accept pointer to pointer to head node.\nWe may assume that the Linked List never becomes empty.\nSuppose the function name is delNode(). In a direct implementation, the function needs to adjust the head pointer when the node to be deleted the first node.\nC program for deleting a node in Linked List\nWe will handle the case when the first node to be deleted then we copy the data of the next node to head and delete the next node. In other cases when a deleted node is not the head node can be handled generally by finding the previous node.\n#include <stdio.h>   \n#include <stdlib.h>   \nstruct Node   \n{     \n    int data;   \n    struct Node *next;   \n};   \n  void delNode(struct Node *head, struct Node *n)   \n{   \n    if(head == n)   \n    {     \n        if(head->next == NULL)   \n        {   \n            printf(\"list can't be made empty because there is only one node. \");   \n            return;   \n        }   \n        head->data = head->next->data;   \n        n = head->next;   \n        head->next = head->next->next;   \n        free(n);   \n        return;   \n    }   \n        struct Node *prev = head;   \n    while(prev->next != NULL && prev->next != n)   \n        prev = prev->next;   \n    if(prev->next == NULL)   \n    {   \n        printf(\"\\n This node is not present in  List\");   \n        return;   \n    }   \n    prev->next = prev->next->next;   \n    free(n);   \n    return;   \n}   \nvoid push(struct Node **head_ref, int new_data)   \n{   \n    struct Node *new_node =   \n        (struct Node *)malloc(sizeof(struct Node));   \n    new_node->data = new_data;   \n    new_node->next = *head_ref;   \n    *head_ref = new_node;   \n}   \nvoid printList(struct Node *head)   \n{   \n    while(head!=NULL)   \n    {   \n        printf(\"%d \",head->data);   \n        head=head->next;   \n    }   \n    printf(\"\\n\");   \n}   \nint main()   \n{   \n    struct Node *head = NULL;   \n    push(&head,3);   \n    push(&head,2);   \n    push(&head,6);   \n    push(&head,5);   \n    push(&head,11);   \n    push(&head,10);   \n    push(&head,15);   \n    push(&head,12);   \n    printf(\"Available Link list: \");   \n    printList(head);   \n    printf(\"\\nDelete node %d: \", head->next->next->data);   \n    delNode(head, head->next->next);   \n      printf(\"\\nUpdated  Linked List: \");   \n    printList(head);   \n      /* Let us delete the the first node */  \n    printf(\"\\nDelete first node \");   \n    delNode(head, head);   \n       printf(\"\\nUpdated Linked List: \");   \n    printList(head);   \n      getchar();   \n    return 0;   \n}  \nOutput:\nAvailable Link List: 12 15 10 11 5 6 2 3 \nDelete node 10:\nUpdated Linked List: 12 15 11 5 6 2 3\nDelete first node\nUpdated Linked list: 15 11 5 6 2 3",
        "reference": "javatpoint.com"
    },
    {
        "question": "21) Write a c program to merge a link list into another at an alternate position?",
        "answer": "We have two linked lists, insert nodes of the second list into the first list at substitute positions of the first list.\nExample\nif first list is 1->2->3 and second is 12->10->2->4->6, the first list should become 1->12->2->10->17->3->2->4->6 and second list should become empty. The nodes of the second list should only be inserted when there are positions available.\nUse of extra space is not allowed i.e., insertion must be done in a place. Predictable time complexity is O(n) where n is number of nodes in first list.\n#include <stdio.h>   \n#include <stdlib.h>   \nstruct Node   \n{   \n    int data;   \n    struct Node *next;   \n};   \nvoid push(struct Node ** head_ref, int new_data)   \n{   \n    struct Node* new_node =   \n        (struct Node*) malloc(sizeof(struct Node));   \n    new_node->data = new_data;   \n    new_node->next = (*head_ref);   \n    (*head_ref) = new_node;   \n}   \nvoid printList(struct Node *head)   \n{   \n    struct Node *temp = head;   \n    while (temp != NULL)   \n    {   \n        printf(\"%d \", temp->data);   \n        temp = temp->next;   \n    }   \n    printf(\"\\n\");   \n}    \nvoid merge(struct Node *p, struct Node **q)   \n{   \n    struct Node *p_curr = p, *q_curr = *q;   \n    struct Node *p_next, *q_next;   \n    while (p_curr != NULL && q_curr != NULL)   \n    {  \n        p_next = p_curr->next;   \n        q_next = q_curr->next;   \n        q_curr->next = p_next;  \n        p_curr->next = q_curr;   \n        p_curr = p_next;   \n        q_curr = q_next;   \n    }   \n      *q = q_curr;  \n}   \nint main()   \n{   \n    struct Node *p = NULL, *q = NULL;   \n    push(&p, 3);   \n    push(&p, 2);   \n    push(&p, 1);   \n    printf(\"I Linked List:\\n\");   \n    printList(p);   \n      push(&q, 8);   \n    push(&q, 7);   \n    push(&q, 6);   \n    push(&q, 5);   \n    push(&q, 4);   \n    printf(\"II Linked List:\\n\");   \n    printList(q);   \n      merge(p, &q);   \n      printf(\"Updated I  Linked List:\\n\");   \n    printList(p);   \n      printf(\"Updated II Linked List:\\n\");   \n    printList(q);   \n            getchar();   \n    return 0;   \n}  \nOutput:\nI Linked List:        \n1 2 3\nII Linked List:      \n4 5 6 7 8                \nUpdated I Linked List:         \n1 4 2 5 3 6           \nUpdated II Linked List:          \n7 8",
        "reference": "javatpoint.com"
    },
    {
        "question": "22) Explain how the encryption algorithm works?",
        "answer": "Encryption is the technique of converting plaintext into a secret code format it is also called as \"Ciphertext.\" To convert the text, the algorithm uses a string of bits called as \"keys\" for calculations. The larger the key, the higher the number of potential patterns for Encryption. Most of the algorithm use codes fixed blocks of input that have a length of about 64 to 128 bits, while some uses stream method for encryption.",
        "reference": "javatpoint.com"
    },
    {
        "question": "23) What Are The Criteria Of Algorithm Analysis?",
        "answer": "An algorithm is generally analyzed by two factors.\nTime complexity\nSpace complexity\nTime complexity deals with the quantification of the amount of time taken by a set of code or algorithm to process or run as a function of the amount of input. In other words, the time complexity is efficiency or how long a program function takes to process a given input.\nSpace complexity is the amount of memory used by the algorithm to execute and produce the result.",
        "reference": "javatpoint.com"
    },
    {
        "question": "24) What are the differences between stack and Queue?",
        "answer": "Stack and Queue both are non-primitive data structure used for storing data elements and are based on some real-world equivalent.\nLet's have a look at key differences based on the following parameters.\nWorking principle\nThe significant difference between stack and queue is that stack uses LIFO (Last in First Out) method to access and add data elements whereas Queue uses FIFO (First in first out) method to obtain data member.\nStructure\nIn Stack, the same end is used to store and delete elements, but in Queue, one end is used for insertion, i.e., rear end and another end is used for deletion of elements.\nNumber of pointers used\nStack uses one pointer whereas Queue uses two pointers (in the simple case).\nOperations performed\nStack operates as Push and pop while Queue operates as Enqueue and dequeuer.\nVariants\nStack does not have variants while Queue has variants like a circular queue, Priority queue, doubly ended Queue.\nImplementation\nThe stack is simpler while Queue is comparatively complex.",
        "reference": "javatpoint.com"
    },
    {
        "question": "25) What is the difference between the Singly Linked List and Doubly Linked List data structure?",
        "answer": "This is a traditional interview question on the data structure. The major difference between the singly linked list and the doubly linked list is the ability to traverse.\nYou cannot traverse back in a singly linked list because in it a node only points towards the next node and there is no pointer to the previous node.\nOn the other hand, the doubly linked list allows you to navigate in both directions in any linked list because it maintains two pointers towards the next and previous node.",
        "reference": "javatpoint.com"
    }
]