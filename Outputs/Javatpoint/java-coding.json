[
    {
        "question": "",
        "answer": "In a Fibonacci series, the value of any term is the sum of the values of the last two terms.\nFor example, if we want to compute the 3rd term of the series, then it is the sum of the 1st and the 2nd term. Note that the first two terms of the Fibonacci series are defined as 0 and 1. Thus, the 3rd term will be 0 + 1 = 1. The 4th term will be the sum of the 3rd and the 2nd terms, 1 + 1 = 2. The 5th term will be the sum of the 4th and the 3rd term, which is 2 + 1 = 3.\nThus the Fibonacci series looks like the following.\nADVERTISEMENT\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \u2026 (considering 1 - indexing)\nTherefore, in general, the nth term of the series can be written as\nF(n) = F(n - 1) + F(n - 2)\nNow, we can write the program for computing the nth term of the Fibonacci series as follows. Note that the value of n will be provided by the user.\nFileName: FibonacciSeries.java\nimport java.util.Scanner;  \npublic class FibonacciSeries   \n{  \n  // main method  \npublic static void main(String argvs[])   \n{  \nScanner scnr = new Scanner(System.in);  \nint N = scnr.nextInt();  \n  int first = 0; // first fibonacci number  \nint second = 1; // second fibonacci number  \n  // handling the corner cases when the N is 0 or negative. Note that we are treating this   \n// series with 1-indexing.   \nif(N <= 0)   \n{  \nSystem.out.println(\"N can never be zero or negative\");  \nreturn;  \n}  \n  // if the user input is either 1 or 2  \nif(N == 1)   \n{  \nSystem.out.println(first);  \n}  \nelse if(N == 2)   \n{  \nSystem.out.println(second);  \n}  \nelse   \n{  \n// loop for the Nth fibonacci numbers  \nint curr = 0;  \nfor(int j = 3; j <= N; j++)   \n{  \ncurr = first + second;  \nfirst = second;  \nsecond = curr;  \n}  \n  System.out.println(\"The \" + N + \"th Fibonacci number is: \" + curr);  \n}  \n    }  \n}  \nInput:\nADVERTISEMENT\n6  \nOutput:\nThe 6th Fibonacci number is: 5\nComplexity Analysis: The program takes O(n) time to compute the value of the Nth term of the Fibonacci series. The space complexity of the program is O(1), as no extra space is being used.\nCorner Cases: The corner of this problem is handling the negative values of N, which we have done in the if-condition. In a lot of cases, it is seen that candidates miss the handling of negative values of n.\nFollow-up: One can also solve this problem with the help of dynamic programming. It will consume O(n) time and O(n) space. Readers are advised to try it themselves.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "If we take a number 5647, we find that the number consists of 4 digits that are 5, 6, 4, and 7. When can find the total number of digits present in a number by consistently dividing the given number by 10 using a loop, till it becomes zero. In the loop, we keep incrementing a counter in each iteration.\nObserve the implementation in the following code.\nFileName: CountDigits.java\nimport java.util.Scanner;  \npublic class CountDigits   \n{  \n// method for counting the number of digits in number n  \npublic static int cntDig(int n)  \n{  \n// The number 0 has the 1 dig.  \nif(n == 0)  \n{  \n    return 1;  \n}  \n  if(n < 0)  \n{  \n    n = -n;  \n}  \nint cnt = 0;  \nwhile(n != 0)  \n{  \n    n = n / 10;  \n    cnt = cnt + 1;  \n}  \n  return cnt;  \n  }  \n// main method  \npublic static void main(String argvs[])   \n{  \nScanner scnr = new Scanner(System.in);  \nint N = scnr.nextInt();  \n  System.out.println(\"The total digits in number \" + N + \" are: \" + cntDig(N));  \n}  \n    }  \nInput:\n0  \nOutput:\nThe total digits in number 0 are: 1\nInput:\n-980  \nOutput:\nThe total digits in number -980 are: 3\nInput:\n1983  \n\nOutput:\nThe total digits in number 1983 are: 4\nComplexity Analysis: The time complexity of the program is O(log10(n)), where n is the input number. The space complexity of the program is O(1) because the program is not using any extra space.\nCorner Cases: Observe the loop mentioned in the above program. Its terminating condition is when n != 0. So, what will happen if the input number is 0? For the number 0, separate handling is required to give answer 1. Also, we have to take care of the numbers that are negative.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "The question is a modified form of the previous question. So, tweaking the above code will do the job for us, and the same is evident by looking at the following code.\nFileName: CountDigitsD.java\nimport java.util.Scanner;  \n  public class CountDigitsD   \n{  \n// method for counting the number of digits in number n  \npublic static int cntDig(int n, int d)  \n{  \n// if d and n both are single digit number  \n// and d and n both are having value 0.  \nif(n == 0 && d == 0)  \n{  \n    return 1;  \n}  \n  if(n < 0)  \n{  \n    n = -n;  \n}  \nint cnt = 0;  \nwhile(n != 0)  \n{  \n    int dig = n % 10;  \n    if(dig == d)  \n    {  \n        cnt = cnt + 1;  \n    }  \n    n = n / 10;  \n      }  \n  return cnt;  \n  }  \n// main method  \npublic static void main(String argvs[])   \n{  \nScanner scnr = new Scanner(System.in);  \nint N = scnr.nextInt();  \nint D = scnr.nextInt();  \n  System.out.println(\"The total count of digit \" + D + \" occurring in the number \" + N + \" is: \" + cntDig(N,D));  \n}  \n    }  \nInput:\n121  \n1  \n\nOutput:\nThe total count of digit 1 occurring in the number 121 is: 2\nInput:\n-9931929  \n9  \nOutput:\nThe total count of digit 9 occurring in the number -9931929 is: 4\nInput:\n0  \n0  \nOutput:\nThe total count of digit 0 occurring in the number 0 is: 1\nComplexity Analysis: The time complexity of the program is O(log10(n)), where n is the input number. The space complexity of the program is O(1), because the program is not using any extra space.\nCorner Cases: We have to take care of cases when N and D both are 0. Also, we have to deal with situations when the user inputs a negative number.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "In a recursion, one needs to look for the relation between the larger problem and the smaller problem. In this problem, there is a relationship between the larger and the smaller problem. See the following mathematical relation.\nan = a x an - 1\nIn the programming world, we can write the above as:\n(a to the power n) = a x (a to the power n - 1)\nFor example, 3 to the power 4 = 81. It can be computed as 3 x (3 to the power 3) = 3 x 27 = 81.\n\nFor every recurrence relation, there is a base case. In our case, the base case is when the power is 0, and we know that any number to the power 0 is 1. Now we are in a position to write the following code.\nFileName: PowerN.java\nimport java.util.Scanner;  \npublic class PowerN   \n{  \n      // a method that recursively finds the power y ^ n  \npublic static double findPower(double y, int n)   \n{  \n    // the base case is handled here  \n    if(n == 0)   \n    {   \n        return 1.0;  \n    }  \n          // recursively computing the power  \n    double pwr = findPower(y, n - 1);   \n      return y * pwr;   \n}  \n  public static double powr(double Y, int N)   \n{  \n    // handling the negative case  \n    if(N < 0)   \n    {  \n        return 1.0 / findPower(Y,-N);  \n    }  \n          return findPower(Y, N);  \n}  \n      // main method  \npublic static void main(String argvs[])   \n{  \n// the code for getting the input   \n// from user  \nScanner scnr = new Scanner(System.in);  \ndouble y = scnr.nextDouble();  \nint N = scnr.nextInt();  \n  System.out.println(\"The value of \" + y + \" ^ \" + N + \" is: \" + powr(y, N));  \n}  \n}  \nInput:\n2.2  \n2  \nOutput:\nThe value of 2.2 ^ 2 is: 4.840000000000001\nInput:\n3.33  \n-4  \nOutput:\nThe value of 3.33 ^ -4 is: 0.008132481162283954\nInput:\n0.0  \n1  \nOutput:\nThe value of 0.0 ^ 1 is: 0.0\nComplexity Analysis: The time complexity of the program is O(n), where n is the input number serving the power of number y. The space complexity of the program is O(1) because the program is not using any extra space.\nCorner Cases: We have to take care of cases when power is negative.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "It is a well-known fact that strings are immutable in Java. Therefore, it is required to create a new string. For toggling, we can use ASCII value, 'a' can be converted to 'A' by 'A' = 'a' - 32.\nCode For Toggling the Cases.\nFileName: ToggleString.java\nimport java.util.Scanner;  \n  public class ToggleString   \n{  \n// main method  \npublic static void main(String argvs[])   \n{  \n    // taking input from the user  \n    Scanner scnnr = new Scanner(System.in);  \n    String strng = scnnr.nextLine();  \n    StringBuilder result = new StringBuilder(\"\");  \n      for(int i = 0; i < strng.length(); i++)   \n    {  \n        char chr = strng.charAt(i); //current character  \n                  // make the capital letter, small letter  \n        if(chr >='A' && chr <= 'Z')   \n        {  \n            result.append((char)(chr + 32));  \n        }   \n        // make the small letter, the capital letter  \n        else if(chr >='a' && chr <= 'z')  \n        {  \n            result.append((char)(chr - 32));  \n        }   \n        // taking care of the cases when the character  \n        // is not the letter  \n        else   \n        {   \n            result.append(chr);  \n        }  \n    }  \n      String answer = result.toString();  \n          // displaying the answer on the console  \n    System.out.println(\"After toggling, the string \" + strng + \" becomes: \" + answer);  \n}  \n}  \nInput:\njaVaTpoiNt  \nOutput:\nAfter toggling, the string jaVaTpoiNt becomes: JAvAtPOInT\nInput:\nJ78trY  \nOutput:\nAfter toggling, the string J78trY becomes: j78TRy\nComplexity Analysis: The time complexity of the program is O(num). The space complexity of the program is also O(num) because the program is using extra for creating a new string, and num is the total number of characters present in the input string.\nCorner Cases: We have to take care of cases when the characters of the input string do not contain small capital letters. For example, consider the string \"ut8Pmn\". In this string, characters 'u', 't', 'P', 'm', 'n' gets toggled to 'U', 'T', 'p', 'M', and 'N'. However, character 8 can never be toggled as there is nothing called small 8 and capital 8. Therefore, this case requires special handling.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "We can create an integer array of the size 256 as there are 256 characters present in the input string. Now, we count the frequency of occurrence of every character present in the input string and update the integer array accordingly. Now iterate over the integer array to check which element has the value 1. The character corresponding to that element index is printed on the console. Note that the 0th index of the array maps to 'a', the 1st index maps to 'b', and so on.\nFileName: UniqueChar.java\nimport java.util.Scanner;  \npublic class UniqueChar   \n{  \npublic static String findUniqueChar(String inputStr)  \n{  \n    // integer array for storing the frequency of characters  \n    int arr[] = new int[256];   \n          for(int j = 0; j < inputStr.length(); j++)  \n    {  \n        // count frequency of characters of the input string  \n        char ch = inputStr.charAt(j);  \n        arr[ch - 'a'] = arr[ch - 'a'] + 1;  \n    }  \n          String str = \"\";  \n    for(int i = 0; i < 256; i++)  \n    {  \n        if(arr[i] == 1)  \n        {  \n        // creating the string that only contains the unique characters  \n        str = str + ((char)(i + 'a'));  \n        }  \n    }  \n          // returning the resultant string  \n    return str;  \n}  \n          // main method  \npublic static void main(String argvs[])   \n{  \n    // Your code goes here  \n    Scanner scn = new Scanner(System.in);  \n    String str = scn.nextLine();  \n          String s = findUniqueChar(str);  \n    if(s.length() == 0)  \n    {  \n        System.out.println(\"There is no unique characters present in the string: '\" + str + \"'\");      \n    }  \n    else  \n    {  \n       System.out.println(\"The unique characters present in the string: '\" + str + \"' are: \");   \n       for(int i = 0; i < s.length(); i++)  \n       {  \n           System.out.print(s.charAt(i) + \" \");  \n       }  \n    }  \n        }  \n}  \nInput:\npppdaf  \nOutput:\nThe unique characters present in the string: 'pppdaf' are: \na d f\nInput:\njjgtrygtry  \nOutput:\nThere is no unqiue characters present in the string: 'jjgtrygtry'\nComplexity Analysis: The time complexity of the program is O(num), where num is the total number of characters present in the input string. The space complexity of the program is constant, even though we are using an integer array. Note that the size of the input array is constant.\nCorner Cases: We have to take care of cases when a null string is passed, or when a string is passed that has all the duplicate characters. We have to handle that case separately.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "In order to check that strings are immutable in Java, we have to use the == operator. It is because the == compares the references or the addresses of the objects. If, after making a change in the string and comparing it with the unchanged one and we get a true value, then it means strings are not immutable; otherwise, they are immutable. True value means the changed string has the same address as compared to the previous one. The following program shows the immutability of strings.\nFileName: ImmutableStrings.java\npublic class ImmutableStrings   \n{  \n  // main method  \npublic static void main(String argvs[])   \n{  \nString str1 = \"dadi\";  \n// assigning the reference of string str1 to string str2   \nString str2 = str1;   \nstr1 = str1 + \"Gulzar\";  \n  if(str1 == str2)  \n{  \nSystem.out.println(\"Strings are not immutable.\");  \n}  \nelse  \n{  \n// if the control reaches here, then it means == operator   \n// has returned a false value.  \nSystem.out.println(\"Strings are immutable.\");      \n}  \n        }  \n}  \nOutput:\nStrings are immutable.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "FileName: ReverseArrUsingRec.java\nimport java.util.*;  \npublic class ReverseArrUsingRec   \n{  \npublic static void revArr(int arr[], int size, int i)  \n{  \n// handling the base case  \nif(i >= size)  \n{  \n    return;  \n}  \n  // recursively printing the input array  \n// in the reverse order  \nrevArr(arr, size, i + 1);  \nSystem.out.print(arr[i] + \" \");  \n  }  \n  // main method  \npublic static void main(String argvs[])   \n{  \nScanner scn = new Scanner(System.in);  \n  int n = scn.nextInt();  \n  int intArr[] = new int[n];  \n  // user to enter the elements  \nfor(int i = 0; i < n; i++)   \n{  \n    intArr[i] = scn.nextInt();  \n}  \n  System.out.println(\"The input array is:\");  \n  // loop for displaying the input array  \nfor(int it = 0; it < intArr.length; it++)   \n{  \n    System.out.print(intArr[it] + \" \");  \n}  \nSystem.out.println(\" \\n\");  \n  System.out.println(\"The reversed array is:\");  \n  revArr(intArr, intArr.length, 0);  \n  }  \n}  \nInput:\n4  \n8  \n5  \n90  \n23  \nOutput:\n\nThe input array is:\n8 5 90 23  \n\nThe reversed array is:\n23 90 5 8\nInput:\n6  \n45  \n12  \n21  \n78  \n60  \n66  \nOutput:\nThe input array is:\n45 12 21 78 60 66  \n\nThe reversed array is:\n66 60 78 21 12 45\nComplexity Analysis: The time complexity of the program is O(num), where num is the total number of elements present in the input array. The space complexity of the program is constant, which is O(1).",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "FileName: FindEle.java\nimport java.util.*;  \npublic class FindEle   \n{  \n  public static int[] findIndexOfReqEle(int inputArr[], int tar)  \n{  \n// size of the input array.  \nint size = inputArr.length;  \n  // array for storing the first and the last index  \nint ansArr[] = new int[2];  \nansArr[0] = -1;  \nansArr[1] = -1;  \n  // flag for checking whether the target element   \n// exists or not  \nboolean isEleFound = false;  \n  // loop for searching the required element  \nfor(int k = 0; k < size; k++)   \n{  \nif(inputArr[k] == tar)   \n{  \nif(!isEleFound)   \n{  \n    // k + 1 because of the one indexing  \n    ansArr[0] = k + 1;  \n    ansArr[1] = k + 1;  \n          // required element found for the first time   \n    isEleFound = true;   \n}   \n  else   \n{  \n    // required element is present in the array at least twice.  \n    ansArr[1] = k + 1;  \n}  \n}  \n}  \n  return ansArr;  \n}  \n  // main method  \npublic static void main(String argvs[])   \n{  \nSystem.out.println(\"Enter size of the input array\");  \nScanner scnr = new Scanner(System.in);  \nint num = scnr.nextInt();  \nint[] intArr = new int[num];  \n  System.out.println(\"Enter elements of the input array\");  \n  // input the array  \nfor(int k = 0; k < num; k++)   \n{  \n    intArr[k] = scnr.nextInt();  \n}  \n  System.out.println(\"Enter target element to be searched.\");  \nint targetEle = scnr.nextInt();  \n  int ansArr[] = findIndexOfReqEle(intArr, targetEle);  \n      if(ansArr[0] == -1)   \n{  \n    System.out.println(\"In the input array, the element \" + targetEle + \" does not exist.\");  \n}   \n  else   \n{  \n    System.out.println(\"For the target element: \" + targetEle + \", First Index = \" + ansArr[0] + \" Last Index = \" + ansArr[1]);  \n}  \n}  \n}  \nInput:\nEnter size of the input array  \n7  \nEnter elements of the input array  \n45  \n12  \n21  \n78  \n60  \n66  \n60  \nEnter target element to be searched.  \n60  \nOutput:\nFor the target element: 60, First Index = 5 Last Index = 7\nInput:\nEnter size of the input array  \n4  \nEnter elements of the input array  \n34  \n12  \n21  \n20  \nEnter target element to be searched.  \n12  \nOutput:\nFor the target element: 12, First Index = 2 Last Index = 2\nInput:\nEnter size of the input array  \n5  \nEnter elements of the input array  \n34  \n55  \n21  \n2  \n80  \nEnter target element to be searched.  \n27  \nOutput:\nIn the input array, the element 27 does not exist.\nComplexity Analysis: The time complexity of the program is O(num), where num is the total number of elements present in the input array. The space complexity of the program is constant, which is O(1).\nCorner Case: We have to take care of the case where the target element is not present in the array. It is because the index of the element becomes irrelevant if the element is absent.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "By observing the image, it is evident that for columns that are even, the traversal is top to down, and when the columns are odd, the traversal is bottom to top direction.\nFileName: WaveOrder.java\nimport java.io.*;  \nimport java.util.*;  \n  public class WaveOrder  \n{  \n  // main method  \npublic static void main(String argvs[]) throws Exception   \n{  \n  Scanner scnr = new Scanner(System.in);  \n  System.out.println(\"Enter row: \");  \nint r = scnr.nextInt();  \n  System.out.println(\"Enter column: \");  \nint c = scnr.nextInt();  \n  int[][] matrx = new int[r][c];  \n  System.out.println(\"Enter the elements of the matrix: \");  \n// input the matrix  \nfor(int i=0; i < r; i++)   \n{  \nfor(int j=0; j < c; j++)   \n{  \n    matrx[i][j] = scnr.nextInt();  \n}  \n}   \n  System.out.println(\"\\n\");  \nSystem.out.println(\"The wave order traversal of the input matrix is: \");  \n  // loop for traversing the input array in the wave order  \nfor(int j = 0; j < matrx[0].length; j++)   \n{  \n// for top to down direction for the even columns  \nif(j % 2 == 0)   \n{  \n    for(int i = 0; i < matrx.length; i++)   \n    {  \n        System.out.print(matrx[i][j] + \" \");  \n    }  \n}   \n  // for down to to direction for the odd columns  \nelse   \n{  \n    for(int i = matrx.length - 1; i >= 0; i--)   \n    {  \n        System.out.print(matrx[i][j] + \" \");  \n    }  \n}  \nSystem.out.println();  \n}   \n}  \n  }  \nInput:\nEnter row:   \n3  \nEnter column:   \n3  \nEnter the elements of the matrix:   \n4 3 1  \n9 0 7  \n5 6 2  \nOutput:\nThe wave order traversal of the input matrix is: \n4 9 5\n6 0 3 \n1 7 2\nInput:\nEnter row:   \n4  \nEnter column:   \n4  \nEnter the elements of the matrix:   \n41 13 21 30  \n49 20 27 12  \n51 16 62 36  \n76 32 29 63  \nOutput:\nThe wave order traversal of the input matrix is: \n41 49 51 76 \n32 16 20 13 \n21 27 62 29 \n63 36 12 30\nComplexity Analysis: The time complexity of the program is O(r x c), where r is the row size and c is the column size. The space complexity of the program is constant, which is O(1).",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Observe the following example.\nFileName: TestClass.java\nimport java.util.*;  \n  class Developer   \n{  \n  private int devAge;  \nprivate String devName;  \n  // parameterless constructor   \n// of the class  \nDeveloper()   \n{  \n  }  \n  // parameterized constructor of the class  \nDeveloper(int devAge, String devName)   \n{  \n    this.devAge = devAge;  \n    this.devName = devName;  \n}  \n  // for setting the age  \nvoid setAge(int devAge)   \n{  \n    this.devAge = devAge;  \n}  \n  // for setting name  \nvoid setName(String devName)   \n{  \n    this.devName = devName;  \n}  \n  // for retriving age  \nint getAge()   \n{  \n    return devAge;  \n}  \n  // for retriving name  \nString getName()   \n{  \n    return devName;  \n}  \n    public void writeCode()   \n{  \n    System.out.println(this.devName + \" writes codes.\");  \n}  \n  public void drinksTea()   \n{  \n    System.out.println(this.devName + \" drinks tea and then convert the quadratic complexity codes to linear.\");  \n}  \n}  \n  public class TestClass  \n{  \n// main method  \npublic static void main(String argvs[])   \n{  \n    // creating an object of the class Developer  \n    Developer d1 = new Developer(32, \"Shiva\");  \n          // invoking the methods writeCode(), and drinksTea()  \n    d1.writeCode();  \n    d1.drinksTea();  \n}  \n}  \nOutput:\nShiva writes code.\nShiva drinks tea and then convert the quadratic complexity codes to linear.\nExplanation: Some things you should keep in mind: The properties must usually be set private, and we should have getter and setter methods to access and modify them. This is good OOPS practice. Also, always create a default constructor, as when we create a parameterized constructor, Java removes its own default constructor, and object creation without passing the parameters to the constructor would not be possible.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "FileName: CountVowelConst.java\nimport java.util.*;  \n  // the main class  \npublic class CountVowelConst  \n{  \n      // the following method checks whether the   \n// character chr is a vowel or a consonant  \npublic static boolean isVowelChar(char chr)   \n{  \n    // an array that contains only vowels  \n    char charArr[] = new char[5];  \n    charArr[0] = 'a';  \n    charArr[1] = 'e';  \n    charArr[2] = 'i';  \n    charArr[3] = 'o';  \n    charArr[4] = 'u';  \n          for(int g = 0; g < 5; g++)  \n    {  \n        if(chr == charArr[g])  \n        {  \n            return true;  \n        }  \n    }  \n          // if the control reaches here then it means  \n    // the character is not vowel  \n    return false;  \n}  \n  // main method  \npublic static void main(String argvs[])   \n{  \n      Scanner scnr = new Scanner(System.in);  \n    String strng = scnr.nextLine();  \n      int vCount = 0;  \n    int cCount = 0;  \n      for(int i = 0; i < strng.length(); i++)   \n    {  \n        char chr = strng.charAt(i);  \n        if(isVowelChar(chr) == true)   \n        {  \n            vCount = vCount + 1;  \n        }  \n                  // for consonent it is necessary for the character to be an alphabet  \n        else if(chr >='a' && chr <='z' && (isVowelChar(chr) == false))   \n        {  \n            cCount = cCount + 1;  \n        }  \n    }  \n      System.out.println(\"Count of vowels in the String : '\" + strng + \"' is: \" + vCount);  \n    System.out.println(\"Count of consonants in the String : '\" + strng + \"' is: \" + cCount);  \n    System.out.println(\"Count of other characters in the String : '\" + strng + \"' is: \" + (int)(strng.length() - vCount - cCount));  \n}  \n}  \nInput:\nabcd44iut  \nOutput:\nCount of vowels in the String : 'abcd44iut' is: 3\nCount of consonants in the String : 'abcd44iut' is: 4\nCount of other characters in the String : 'abcd44iut' is: 2\nInput:\naoiue  \nOutput:\nCount of vowels in the String : 'aoiue' is: 5\nCount of consonants in the String : 'aoiue' is: 0\nCount of other characters in the String : 'aoiue' is: 0\nInput:\naoiue  \nOutput:\nCount of vowels in the String : 'aoiue' is: 5\nCount of consonants in the String : 'aoiue' is: 0\nCount of other characters in the String : 'aoiue' is: 0\nInput:\n@51#$%290(){}  \nOutput:\nCount of vowels in the String : '@51#$%290(){}' is: 0\nCount of consonants in the String : '@51#$%290(){}' is: 0\nCount of other characters in the String : '@51#$%290(){}' is: 13\nCorner Cases: One might miss the case that what will happen if the string contains some numbers or special characters like '0', '5', '#', '@', etc. These characters are neither vowels nor consonants. For characters like these, separate handling is required. Generally, candidates find the vowels count and then subtract it from the size of the string to find consonants, which will give the wrong result if the string contains some characters that are not alphabetical.\nComplexity Analysis: The time complexity of the program is O(n), where n is the total number of characters present in the input string. The space complexity of the program is O(1) as the program uses the array of size 5, which will not change if we change the input string.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "The following program demonstrates inheritance with the help of extends keyword. The following program shows a SmartPhone class that extends the Mobile class and has the features like playing and stopping music player, making a call, taking photos, etc.\nFileName: TestInheritance.java\nclass Mobile   \n{  \n  private int num;  \n  // class constructor  \nMobile()   \n{  \n  }  \n  void setNumber(int num)   \n{  \n    this.num = num;  \n}  \n  int getNumber()   \n{  \n    return num;  \n}  \n  public void doCall()   \n{  \n    System.out.println(\"Calling the dialled number.\");  \n}  \n  public void receiveMessage() {  \n    System.out.println(\"The Message is received.\");  \n}  \n  }  \n  // child class SmrtPhone inheriting the parent class Mobile  \nclass SmrtPhone extends Mobile   \n{  \n  int cameraMegaPX;  \n  public void clickPhoto()   \n{  \n    System.out.println(\"A photo is clicked.\");  \n}  \n  public void playMsic()   \n{  \n    System.out.println(\"Music is getting Played.\");  \n}  \n  public void pauseMusic()   \n{  \n    System.out.println(\"Music player Paused.\");         \n}  \n  public void stpMusic()   \n{  \n    System.out.println(\"Music player Stopped.\");  \n}  \n}  \n  public class TestInheritance   \n{  \n// main method  \npublic static void main(String argvs[])   \n{  \n    SmrtPhone sp = new SmrtPhone();  \n    sp.setNumber(94863472);  \n    System.out.println(\"Phone number is: \" + sp.getNumber());  \n    sp.doCall();  \n    sp.playMsic();  \n    sp.pauseMusic();  \n    sp.stpMusic();  \n    sp.clickPhoto();  \n}  \n}  \nOutput:\nCount of vowels in the String : '@51#$%290(){}' is: 0\nPhone number is: 94863472\nCalling the dialled number.\nMusic is getting Played.\nMusic player Paused.\nMusic player Stopped.\nA photo is clicked.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "The divide by zero exception occurs when we try to divide a number by 0 in Java. The illustration of the same is mentioned in the following program.\nFileName: DivideByZeroException\nimport java.util.*;  \npublic class DivideByZeroException   \n{  \n// main method  \npublic static void main(String argvs[])   \n{  \nScanner scnr = new Scanner(System.in);  \nint num = scnr.nextInt();  \nSystem.out.println(\"The number \" + num + \" is divided by zero.\");  \n  try   \n{  \n    System.out.println(num / 0);  \n}   \ncatch(Exception ex)   \n{  \n    System.out.println(ex);  \n}  \n  System.out.println(\"Program is completed.\");  \n}  \n}  \nInput:\n3  \nOutput:\nThe number 3 is divided by zero.\njava.lang.ArithmeticException: / by zero\nProgram is completed.\nNote: In the above program, the try-catch block is used for handling the divide-by-zero exception. Therefore, the program is executed completely. Otherwise, the program would have stopped at the point of exception, and the print statement (Program is completed) would not have been executed.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "FileName: MainThreadDemo.java\npublic class MainThreadDemo   \n{  \n// main method  \npublic static void main(String[] argvs)   \n{  \n// fetching the current thread  \nThread th = Thread.currentThread();  \n  // setting the name  \nth.setName(\"The Main Thread\");  \nth.setPriority(7);  \nSystem.out.println(th);  \nSystem.out.println(th.getName());  \nSystem.out.println(th.getPriority());  \n  }  \n}  \nOutput:\nThread[The Main Thread,7,main]\nThe Main Thread\n7",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "The approach is to traverse the whole string and remove all those characters that are not alphanumeric. Also, remove the white space. Convert all the alphabetical letters to either small or capital letters. After that, with the help of a loop, check whether the updated string is the palindrome or not.\nFileName: CheckPalindrome.java\nimport java.util.*;  \n  public class CheckPalindrome   \n{  \n  // a method that checks whether the string stng is a palindrome or not  \npublic static boolean isStrngPalindrome(String stng)   \n{  \n  // for traversing the string  \n// from beginning and end  \nint l = 0;  \nint h = stng.length() - 1;  \n  while(l < h)   \n{  \n    char c1 = stng.charAt(l);  \n    char c2 = stng.charAt(h);  \n          if(c1 != c2)   \n    {  \n        return false;  \n    }  \n          l = l + 1;  \n    h = h - 1;  \n}  \n  return true;  \n}  \n    // the following method checks whether the sentence is a palindrome  \n// or not  \npublic static boolean isSntncePalindrome(String sntnce)   \n{  \nString reslt = \"\";  \n  for(int g = 0; g < sntnce.length(); g++)   \n{  \n   // retrieving character at the index g  \n   char chr = sntnce.charAt(g);  \n        // only considering alphanumeric characters and ignoring the other ones   \n   if((chr >='a' && chr <= 'z') || (chr >= 'A' && chr <= 'Z') || (chr >= '0' && chr <= '9'))   \n   {  \n        if(chr >='A' && chr <= 'Z')   \n        {  \n            reslt = reslt + (char)(chr + 32);  \n        }  \n        else reslt = reslt + chr;  \n   }   \n        else   \n   {  \n       // If the control reaches here  \n       // then it means the character is not alphanumeric   \n       // and therefore, we should ignore it.  \n       continue;  \n   }  \n}  \n  if(isStrngPalindrome(reslt))   \n{  \n   return true;  \n}  \n  return false;  \n}  \n  // main method  \npublic static void main(String argvs[])   \n{  \n  // taking user input  \nScanner scnr = new Scanner(System.in);  \nString sentnce = scnr.nextLine();  \n  if(isSntncePalindrome(sentnce))   \n{  \n    System.out.println(\"The string '\" + sentnce + \"' is a palindrome.\");  \n}  \nelse   \n{  \n    System.out.println(\"The string '\" + sentnce + \"' is not a palindrome.\");  \n}  \n}  \n}  \nInput:\na&*  B BA b  \nOutput:\nThe string 'a&*  B BA b' is not a palindrome.\nInput:\na&*  B BA bB a  \nOutput:\nThe string 'a&*  B BA bB a' is a palindrome.\nCorner case: It is important to note that we have to convert all the alphabets to either small or capital letters. Also, we need to take care of the case when the user inputs a string that consists of only white spaces. In our case, a string containing only white spaces should be a palindrome.\nComplexity Analysis: The time complexity of the program is O(n), where n is the total number of characters present in the string. The space complexity of the program is constant, i.e., O(1).",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Rules for the binary addition are mentioned below.\n0 + 0 = 0\n0 + 1 = 1\n1 + 0 = 1\n1 + 1 = 0 & c = 1\nIt is evident by looking at the fourth rule that whenever the result exceeds 1, the answer of addition becomes zero, and carry is 1. shows that whenever the result exceeds 1, the answer of addition becomes 0 and carry becomes 1. Using these four rules, we will do the addition starting from the rightmost index and will move towards the first or the leftmost index. The illustration of it is mentioned in the following program.\nFileName: AddBinaryStrings.java\nimport java.util.*;  \npublic class AddBinaryStrings   \n{  \n  // adding the binary strings  \npublic static String addStrings(String s1, String s2)   \n{  \nString resultantStr = \"\";  \n  if(s1.equals(\"0\") && s2.equals(\"0\"))   \n{  \n    return \"0\";  \n}  \n  // size of the input strings  \nint p = s1.length() - 1;  \nint q = s2.length() - 1;  \n  int cary = 0;  \n  // loop that does the binary addition   \n// by addiing digits from right to left  \nwhile(p >= 0 || q >= 0 || cary > 0)   \n{  \n          int dig1 = (p >= 0) ? (s1.charAt(p) - '0') : 0;  \n    int dig2 = (q >= 0) ? (s2.charAt(q) - '0') : 0;  \n          int digit = 0;  \n    if(dig1 + dig2 + cary >= 2)   \n    {  \n        digit = (dig1 + dig2 + cary) % 2;  \n                  // handling carry  \n        cary = (dig1 + dig2 + cary) / 2;  \n    }   \n    else   \n    {  \n        digit = dig1 + dig2 + cary;  \n        cary = 0;  \n    }  \n          p = p - 1;  \n    q = q - 1;  \n    resultantStr  = digit + resultantStr;  \n}  \n  // returning the final string  \nreturn resultantStr;  \n}  \n  // main method  \npublic static void main(String argvs[])   \n{  \n// taking input from the user  \nScanner scnr = new Scanner(System.in);  \nString s1 = scnr.nextLine();  \nString s2 = scnr.nextLine();  \n  System.out.println(\"The addition of binary strings is: \" + addStrings(s1, s2));    \n}  \n}  \nInput:\n11001  \n100  \nOutput:\nThe addition of binary strings is: 11101\nInput:\n11001  \n111  \nOutput:\nThe addition of binary strings is: 100000\nInput:\n111111  \n111  \nOutput:\nThe addition of binary strings is: 1000110\nCorner case: It is important to note that the user can enter strings of any length. It is not mentioned in the question that input strings will be of the same length. Therefore, the length of the first string can be either less or more or equal to the length of the second string. Also, one should note that the final answer may or may not contain an extra bit. For example, 100 + 1 = 101 but, 111 + 111 = 1000. 1000 contains one more bit as compared to the input stings.\nComplexity Analysis: The time complexity of the program is O(max(m, n)), where m is the total number of characters present in the first input string, and n is the total number of characters present in the second input string. The space complexity of the program is constant, i.e., O(1).",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "We will be using HashMap to store the number of times the characters occur in the first string. Note that character will be the key, and the number of times it occurs is its value. After that, we will traverse the second string and start reducing the frequency of occurrence of characters stored in the HashMap. If the frequency is already zero or the character is absent in the HashMap, we can say that the strings are not anagrams; else, they are anagrams.\nFileName: StringAnagrams.java\nimport java.util.*;  \npublic class StringAnagrams   \n{  \n  // the following method checks whether string a1 and a2 are anagrams  \n// or not. If yes, a true value is returned. Otherwise, a false value is returned  \npublic static boolean isStringsAnagram(String a1, String a2)   \n{  \n// size is not the same. Hence, a false value is returned  \nif(a1.length() != a2.length())  \n{  \nreturn false;  \n}  \n  // hashmap for storing the frequency of occurrence of characters  \n// present in the string s1  \nHashMap<Character, Integer> hashMap = new HashMap<Character, Integer>();  \n  for(int g = 0; g < a1.length(); g++)   \n{  \nint ordrFreq = hashMap.getOrDefault(a1.charAt(g), 0);  \nhashMap.put(a1.charAt(g), ordrFreq + 1);  \n}  \n  for(int g = 0; g < a2.length(); g++)   \n{  \nif(!hashMap.containsKey(a2.charAt(g)) || hashMap.get(a2.charAt(g)) == 0)   \n{  \n    return false;  \n}   \nelse   \n{  \n    int ordrFreq = hashMap.get(a2.charAt(g));  \n    hashMap.put(a2.charAt(g), ordrFreq - 1);  \n}  \n}  \n  return true;  \n}  \n  // main method  \npublic static void main(String argvs[])   \n{  \n// taking user input  \nScanner scnr = new Scanner(System.in);  \nString a1 = scnr.nextLine();  \nString a2 = scnr.nextLine();  \n  if(isStringsAnagram(a1, a2))   \n{  \nSystem.out.println(\"Strings '\" + a1 + \"' & '\" + a2 + \"' are anagrams.\");  \n}  \nelse   \n{  \nSystem.out.println(\"Strings '\" + a1 + \"' & '\" + a2 + \"' are not anagrams.\");  \n}  \n}  \n}  \nInput:\njavatpoint  \nttaaniojvp  \nOutput:\nStrings 'javatpoint' & 'ttaaniojvp' are anagrams.\nInput:\nindia  \nddiaaa  \nOutput:\nStrings 'india' & 'ddiaaa' are not anagrams.\nCorner Cases: It is necessary to check whether the strings are of the same length or not. If not, we can say that the given strings are not anagrams.\nComplexity Analysis: The time complexity of the program is O(m + n), where m and n are the sizes of the two strings. The space complexity of the program is O(1).",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "It is given in the problem that the array is sorted. So, the best approach is to apply the binary search. The following code is an illustration of it.\nFileName: SortedArrayIndex.java\npublic class SortedArrayIndex  \n{  \n  public static int findIndex(int[] numsArr, int tar)   \n{  \nint l = 0;  \nint h = numsArr.length - 1;  \n  // loop that applies the binary search  \nwhile(l <= h)   \n{  \nint middle = l + (h - l) / 2;  \n  // if the element is found  \n// we can return its index  \nif(numsArr[middle] == tar)   \n{  \n    return middle;  \n}   \n  // if the target element is larger than  \n// the numsArr[middle] element, consider the right part of the array  \n// from the index middle  \nelse if(numsArr[middle] < tar)   \n{  \n    l = middle + 1;  \n}   \n  // if the target element is less than  \n// the numsArr[middle] element, consider the left part of the array  \n// from the index middle  \nelse   \n{  \n    h = middle - 1;  \n}  \n}  \n  return l; // ceiling index is considered  \n}  \n    // main method  \npublic static void main(String argvs[])   \n{  \n// input array  \nint[] inputArr = {2, 6, 9, 13, 24, 35, 78, 90, 99};  \nint size = inputArr.length;  \n  System.out.println(\"For the input array: \");  \nfor(int j = 0; j < size; j++)   \n{  \nSystem.out.print(inputArr[j] + \" \");  \n}  \n  int tar = 7;  \nint ans = findIndex(inputArr, tar);  \nSystem.out.println();  \n  System.out.println(\"The index of the target element \" + tar + \" is: \" + ans);  \n  System.out.println(\" \\n \");  \n  // input array  \nint[] inputArr1 = {-3, 5, 24, 40, 51, 80, 89, 97};  \nsize = inputArr1.length;  \n  System.out.println(\"For the input array: \");  \nfor(int j = 0; j < size; j++)   \n{  \nSystem.out.print(inputArr1[j] + \" \");  \n}  \n  tar = 51;  \nans = findIndex(inputArr1, tar);  \nSystem.out.println();  \n  System.out.println(\"The index of the target element \" + tar + \" is: \" + ans);  \n  }  \n}  \nOutput:\nFor the input array: \n2 6 9 13 24 35 78 90 99 \nThe index of the target element 7 is: 2\n \n \nFor the input array: \n-3 5 24 40 51 80 89 97 \nThe index of the target element 51 is: 4\nComplexity Analysis: The time complexity of the program is O(log2(nums)), where nums is the total number of elements present in the input array. The space complexity of the program is O(1), as the program is not using any extra space.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "The main objective is to generate the wave graph. It can be achieved by generating the peaks in the input array or looking at valley generation in the input array. So, we will try to make peaks in the array. We want the first element as the peak element, so the first element remains untouched, and we begin from the second index, leave it as it is and start from the index = 2.\n\nHere, since we want to generate a peak, we need to have the next and previous elements greater than the second element. In the similar fashion, we will have the fourth element smaller than the third and the fifth element.\nThus, we need to take a jump of 2 indices every time until we reach the end of the given array.\n\nFileName: WaveSort.java\npublic class WaveSort   \n{  \n  // swapping elements at the indices a1 and a2  \npublic static void swapEle(int[] inputArr, int a1, int a2)   \n{  \nint t = inputArr[a1];  \ninputArr[a1] = inputArr[a2];  \ninputArr[a2] = t;  \n}  \npublic static void waveSorting(int[] inputArr)   \n{  \n// loop for doing the wave sort without sorting the input array  \n// taking element at i1 as the peak element and elements that are  \n// adjacent to i1 element will not be the peak element.  \nfor(int i1 = 0; i1 < inputArr.length; i1 = i1 + 2)   \n{  \nif(i1 > 0 && inputArr[i1 - 1] > inputArr[i1])   \n{  \n    swapEle(inputArr, i1 - 1, i1);  \n}  \n  if(i1 < inputArr.length - 1 && inputArr[i1 + 1] > inputArr[i1])   \n{  \n    swapEle(inputArr, i1, i1 + 1);  \n}  \n}  \n}  \n  // main method  \npublic static void main(String argvs[])   \n{  \n// input array - 1  \nint[] inputArr = {19, 18, 16, 13, 14, 17, 12};  \n  int size = inputArr.length;  \n  System.out.println(\"The input array is: \");  \n  for(int i1 = 0; i1 < size; i1++)   \n{  \nSystem.out.print(inputArr[i1] + \" \");  \n}  \n  System.out.println( \"\\n \");  \nwaveSorting(inputArr);  \n  System.out.println(\"After the wave sort\");  \n  for(int i1 = 0; i1 < inputArr.length; i1++)   \n{  \nSystem.out.print(inputArr[i1] + \" \");  \n}  \n  System.out.println( \"\\n \");  \n  // input array - 2  \nint[] inputArr1 = {-45, 45, -50, -60, 0, 34, 9, 12};  \n  size = inputArr1.length;  \n  System.out.println(\"The input array is: \");  \n  for(int i1 = 0; i1 < size; i1++)   \n{  \nSystem.out.print(inputArr1[i1] + \" \");  \n}  \n  System.out.println( \"\\n \");  \nwaveSorting(inputArr1);  \n  System.out.println(\"After the wave sort\");  \n  for(int i1 = 0; i1 < inputArr1.length; i1++)   \n{  \nSystem.out.print(inputArr1[i1] + \" \");  \n}  \n}  \n}  \nOutput:\nThe input array is: \n19 18 16 13 14 17 12 \n \nAfter the wave sort\n19 16 18 13 17 12 14 \n \nThe input array is: \n-45 45 -50 -60 0 34 9 12 \n \nAfter the wave sort\n45 -50 -45 -60 34 0 12 9\nComplexity Analysis: The time complexity of the program is O(nums), where nums is the total number of elements present in the input array. The space complexity of the program is O(1), as the program is not using any extra space.\nCorner Case: In the code, the previous and the next element are getting swapped; thus, it is required to take care of the index out-of-bounds condition.\nNote 1: The output shown above is not the only answer. For this problem, there can be other answers too. One has to show any one of them.\nNote 2: Another solution is to sort the array and then swap the adjacent element to get the answer. However, it can lead to O(nums * log(nums)) time complexity, and the solution provided above is more optimized and has O(nums) time complexity. Therefore, the sorting approach is not discussed above, as we have to write the most optimized program.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "In the following program, A class called LowBalanceExcptn is created for the bank. Therefore, when a person creates a bank account, the minimum balance the person should maintain Rs. 7000. Therefore, when the bank balance becomes less than Rs. 7000, the exception is raised. The illustration of the same is mentioned below.\nFileName: BankBlance.java\npublic class BankBlance   \n{  \n// main method  \npublic static void main(String[] argvs)   \n{  \nBankAccount acnt1 = new BankAccount(500);  \nBankAccount acnt2 = new BankAccount();  \nacnt2.setBalance(500);  \n  BankAccount acnt3 = new BankAccount(10000);  \n  System.out.println(\"account - 1 balance = \" + acnt1.getBlnce());  \nSystem.out.println(\"account - 2 balance = \" + acnt2.getBlnce());  \nSystem.out.println(\"account - 3 balance = \" + acnt3.getBlnce());  \n}  \n}  \n  class BankAccount   \n{  \n private int blnce;  \n   // constructor of the class  \nBankAccount()   \n{  \n  blnce = 7000;  \n}  \n  // parameterized constructor of the class  \nBankAccount(int blnce)   \n{  \ntry   \n{  \nif(blnce >= 7000)   \n{  \nthis.blnce = blnce;  \nSystem.out.println(\"The bank account is created and the balance is set to: \"+ blnce);  \n}   \nelse   \n{  \nthis.blnce = 0;  \nSystem.out.println(\"The account can't be created.\");  \nthrow new LowBalanceExcption();  \n}  \n}   \ncatch(LowBalanceExcption e)   \n{  \nSystem.out.println(e);  \n}  \n  }  \n   void setBalance(int balance)   \n{  \n// try catch block for   \n// handling the exception  \ntry   \n{  \nif(blnce >= 7000)   \n{  \nthis.blnce = blnce;  \nSystem.out.println(\"The account has been created and the bank balance has set to: \"+ blnce);  \n}   \nelse   \n{  \nthis.blnce = 0;  \nSystem.out.println(\" The account can't be created.\");  \n  // reaching here means a custom exception has been raised  \n// as the bank balance is less than 7000  \nthrow new LowBalanceExcption();  \n}  \n  }   \ncatch(LowBalanceExcption e)   \n{  \n   System.out.println(e);  \n}  \n}  \n   // get the balance  \nint getBlnce()   \n{  \nreturn blnce;  \n}  \n}  \n  class LowBalanceExcption extends Exception   \n{  \n// message to be printed when the LowBalanceExcption is raised.  \npublic String toString()   \n{  \n  return \"Account has the low balance: The bank balance can never be less than Rs.7000/-\";  \n}  \n}  \nOutput:\nThe account can't be created.\nAccount has the low balance: The bank balance can never be less than Rs.7000/-\nThe account has been created and the bank balance has set to: 7000\nThe bank account is created and the balance is set to: 10000\naccount - 1 balance = 0\naccount - 2 balance = 7000\naccount - 3 balance = 10000",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "In Java, it is not possible to have multiple inheritance. Therefore, we need to take the help of interfaces to make a multiple inheritance scenario. In the following example, a class called DemoClass is created that implements multiple interfaces, and by doing this, multiple inheritance is achieved.\nFileName: TestClass.java\n// first Interface  \ninterface Interface1   \n{  \n  // printMessage is the default method  \ndefault void printMessage()  \n{  \n  // message for the first interface  \nSystem.out.println(\"Default Interface1\");  \n}  \n}  \n  // Second Interface   \ninterface Interface2 {  \n  // printMessage is the default method  \ndefault void printMessage()  \n{  \n  // message for the second interface  \nSystem.out.println(\"Default Interface2\");  \n}  \n}  \n  // Main class that implements Interface2, and Interface1  \npublic class TestClass implements Interface1, Interface2   \n{  \n  // Overriding the default printMessage method  \n@Override  \npublic void printMessage()  \n{  \n  // Using the keyword super to invoke the printMessage()  \n// method of the interface Interface1  \n// In the main method, it should not be used directly;  \nInterface1.super.printMessage();  \n  // Using keyword super to invoke the printMessage()  \n// method of the interface Interface2  \n// In the main method, it should not be used directly;  \nInterface2.super.printMessage();  \n}  \n  // Method for only executing the   \n// method  printMessage() of Interface1  \npublic void showOfInterface1()   \n{  \n  Interface1.super.printMessage();  \n}  \n  // Method for only executing the method  \n// printMessage() of Interface2  \npublic void showOfInterface2()   \n{  \n// In the main method, it should not be used directly.  \nInterface2.super.printMessage();   \n}  \n  // Main method  \npublic static void main(String argvs[])  \n{  \n  // Creating an object of the class TestClass  \nTestClass tc = new TestClass();  \ntc.printMessage();  \nSystem.out.println(\"Now Executing methods showOfInterface1() showOfInterface2()\");  \ntc.showOfInterface1();  \ntc.showOfInterface2();  \n}  \n}  \nOutput:\nDefault Interface1\nDefault Interface2\nNow Executing methods showOfInterface1() showOfInterface2()\nDefault Interface1\nDefault Interface2\nNote: If one removes the default method implementation from the class \"TestClass\", a compilation error is raised. If there exists a diamond through interfaces, then it is not an issue if the middle interfaces is not providing implementation of the topmost interface. If the middle interfaces provide an implementation, then the implementation can be fetched using the keyword super keyword.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Defining a class inside another class is known as nesting of classes. Usually, in Java, the inner class is the static class. Observe the following program.\nFileName: NestedClass.java\npublic class NestedClass  \n{  \n  // main method       \npublic static void main(String argvs[])   \n{  \n// instantiating the outer class  \nOuterClass ob1 = new OuterClass(10, 20);  \n  // instating the second inner class  \nOuterClass.InnerClass2 ob2 = new OuterClass.InnerClass2(40);  \nob2.displayData();  \n  OuterClass.InnerClass3.z1 = 101;  \nSystem.out.println(OuterClass.InnerClass3.z1);  \n  // instating the third inner class  \nOuterClass.InnerClass3 ob3 = new OuterClass.InnerClass3(409);  \nob3.displayData();  \n}  \n   }  \n  class OuterClass   \n{  \n   private int x1;  \n private int y1;  \n       // parameterless constructor  \nOuterClass()   \n{  \nSystem.out.println(\"The default constructor of the Outer class is invoked.\");  \n}  \n  // parameterized constructor  \nOuterClass(int x1, int y1)   \n{  \n this.x1 = x1;  \n this.y1 = y1;  \n System.out.println(\"The parameterized constructor of the Outer class is invoked.\");  \n}  \n  void displayData()   \n{  \n System.out.println(\"X = \" + x1 + \" and Y = \" + y1);  \n}  \n  class InnerClass1   \n{  \n   int z1 = 0;  \n   InnerClass1()   \n {  \n   System.out.println(\"The default constructor invoked of the first inner class.\");  \n }  \n   // parameterized constructor of the   \n // first inner class  \n InnerClass1(int z1)   \n {  \n    this.z1 = z1;  \n }  \n   void displayData()   \n {  \n    System.out.println(\"X = \" + x1 + \" Y = \" + y1 + \" and Z = \" + z1);  \n }  \n}  \n  // the second inner class  \nstatic class InnerClass2   \n{  \n  int z1 = 0;  \n  InnerClass2()   \n{  \nSystem.out.println(\"The default constructor invoked of the second inner class.\");  \n}  \n  // parameterized constructor of the   \n// second inner class  \nInnerClass2(int z1)   \n{  \nthis.z1 = z1;  \nSystem.out.println(\"The parameterized constructor invoked of the second inner class.\");  \n}  \n  void displayData()   \n{  \nSystem.out.println(\"Z = \" + z1);  \n}  \n}  \n      // the third inner class  \nstatic class InnerClass3   \n{  \n  static int z1 = 0;  \n  InnerClass3()   \n{  \nSystem.out.println(\"The default constructor invoked of the third inner class.\");  \n}  \n  // parameterized constructor of the   \n// third inner class  \nInnerClass3(int a1)   \n{  \nz1 = a1;  \nSystem.out.println(\"The parameterized constructor invoked of the third inner class.\");  \n}  \n  void displayData()   \n{  \nSystem.out.println(\"Z = \" + z1);  \n}  \n}  \n}  \nOutput:\nThe parameterized constructor of the Outer class is invoked.\nThe parameterized constructor invoked of the second inner class.\nZ = 40\n101\nThe parameterized constructor invoked of the third inner class.\nZ = 409",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "A diamond problem is a problem of multiple inheritances where one class extends two or more classes. In other words, when a child class has more than one parent class, then an error occurs. The diamond problem using a Java program is discussed below.\nFileName: DiamondProblem.java\nclass P1   \n{  \npublic void display()   \n{  \nSystem.out.println(\"Inside the display method of the class P1.\");  \n}  \n}  \n  class C1 extends P1  \n{  \n@Override  \npublic void display()   \n{  \nSystem.out.println(\"Inside the display method of the class C1.\");  \n}  \n}  \n  class C2 extends P1  \n{  \n@Override  \npublic void display()   \n{  \nSystem.out.println(\"Inside the display method of the class C2.\");  \n}  \n}  \n  // In Java, multiple inheritance is prohibited  \nclass GC1 extends C1,C2  \n{  \n@Override   \npublic void display()   \n{  \nSystem.out.println(\"Inside the display method of the class GC1.\");  \n}  \n}  \n  public class DiamondProblem   \n{  \n  // main method  \npublic static void main(String argvs[])   \n{  \n// creating an object of the class  \n// GC1  \nGC1 obj = new GC1();  \nobj.display(); // display() method of the class GC1 is invoked   \n}  \n}  \nOutput:\n/DiamondProblem.java:28: error: '{' expected\nclass GC1 extends C1,C2\n                    ^\n1 error\nExplanation: The problem with the above code is when we override the display() method in class GC1 which method is overridden, the compiler does not know whether the class C1 display() method is overridden or of the class C2 display() method is overridden.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "The method isAlive() gives information about a thread, whether it is terminated or alive. These terminated and alive are the thread states in Java. Also, the operation join() joins a thread with another, which means that a thread will have to wait for the completion of the thread to which it is joined, even if the thread has accomplished its own work. Together both will terminate.\nFileName: DemoClass.java\nclass DemoThread1 extends Thread   \n{  \n  public DemoThread1(String n)   \n{  \nsuper(n);  \nsetPriority(MAX_PRIORITY);  \n}  \n}  \n  class DemoThread2 extends Thread   \n{  \n  @Override    \npublic void run()   \n{  \nint cnt = 1;  \nwhile (true)   \n{  \nSystem.out.println(cnt);  \ncnt = cnt + 1;  \n// if the value of cnt is more than 6  \n// loop is terminated  \nif(cnt > 6)  \n{  \n   break;  \n}  \ntry   \n{  \n    Thread.sleep(100);  \n}   \n  catch (InterruptedException ex)   \n{  \n    System.out.println(ex);  \n}  \n}  \n}  \n}  \n  // main class  \npublic class DemoClass  \n{  \n// main method  \npublic static void main(String[] argvs)   \n{  \n  // creating thread   \nDemoThread1 th = new DemoThread1(\"first Thread \");  \n  // various print statements  \nSystem.out.println(\"Thread id: \" + th.getId());  \nSystem.out.println(\"Thread name: \" + th.getName());  \nSystem.out.println(\"Thread priority: \" + th.getPriority());  \nth.start();  \nSystem.out.println(\"Thread State: \" + th.getState());  \nSystem.out.println(\"Thread alive: \" + th.isAlive());  \n  // creating thread  \nDemoThread2 th2 = new DemoThread2();  \ntry   \n{  \n Thread.sleep(100);  \n}   \n  catch (Exception ex)   \n{  \n   }  \n  th2.setDaemon(true);  \nth2.start();  \n    try   \n{  \n     th.join();   \n  th2.join();  \n}   \n  catch (Exception ex)   \n{  \n  }  \n}  \n}  \nOutput:\nThread id: 14\nThread name: first Thread \nThread priority: 10\nThread State: RUNNABLE\nThread alive: false\n1\n2\n3\n4\n5\n6",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "We can achieve thread synchronization with the help of the synchronization keyword. The following is an example program.\nFileName: ThreadSynchronization.java\nclass TableClass   \n{  \n// because the keyword synchronized only one   \n// string will enter the method, and the second   \n// string will have to wait for the first thread to  \n// finish its job. After that, the second thread takes  \n// the control.  \npublic synchronized void display(int num)   \n{  \n//   \nfor (int j = 1; j <= 10; j++)   \n{  \nSystem.out.print(num * j + \" \");  \n}  \nSystem.out.println( );  \n}  \n}  \n  class ThreadCl1 extends Thread   \n{  \n TableClass tc;   \n       public ThreadCl1(TableClass tc)   \n{  \n  this.tc = tc;  \n}  \n// inside the run method   \n// display() method is invoked  \npublic void run()   \n{  \n  tc.display(11);  \n}  \n}  \n  class ThreadCl2 extends Thread   \n{  \nTableClass tc;  \npublic ThreadCl2(TableClass tc)   \n{  \nthis.tc = tc;  \n}  \n// inside the run method   \n// display() method is invoked  \npublic void run()   \n{  \ntc.display(12);  \n}  \n}  \n// main class  \npublic class ThreadSynchronization   \n{  \n// main method  \npublic static void main(String argvs[])   \n{  \n// instantiating the class TableClass  \nTableClass tClass = new TableClass();  \n// creating the first thread  \nThreadCl1 thd1 = new ThreadCl1(tClass);  \n  // creating the second thread  \nThreadCl2 thd2 = new ThreadCl2(tClass);  \nthd1.start();  \nthd2.start();  \n}  \n}  \nOutput:\n11 22 33 44 55 66 77 88 99 110 \n12 24 36 48 60 72 84 96 108 120",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "Whenever there is a scenario where two or more than two threads are locked forever, then that scenario is a deadlock scenario. Deadlocks usually occur in a multi-threaded environment. The following program gives demonstration of a deadlock scenario:\nFileName: ThreadSynchronization.java\n// main class  \npublic class ThreadSynchronization   \n{  \n  // main  method  \npublic static void main(String argvs[]) throws InterruptedException   \n{  \n    Object ob1 = new Object();  \n    Object ob2 = new Object();  \n    Object ob3 = new Object();  \n      // creating three threads  \n    Thread th1 = new Thread(new SynThread(ob1, ob2), \"th1\");  \n    Thread th2 = new Thread(new SynThread(ob2, ob3), \"th2\");  \n    Thread th3 = new Thread(new SynThread(ob3, ob1), \"th3\");  \n      // start all the three threads  \n    th1.start();  \n    Thread.sleep(500);  \n    th2.start();  \n    Thread.sleep(500);  \n    th3.start();          \n}  \n  }  \n  class SynThread implements Runnable   \n{  \n  private Object ob1;  \nprivate Object ob2;  \n  public SynThread(Object ob1, Object ob2)   \n{  \n    this.ob1 = ob1;  \n    this.ob2 = ob2;  \n}  \n  @Override  \npublic void run()   \n{  \nString strName = Thread.currentThread().getName();  \n  System.out.println(strName + \" is taking control on the lock \" + ob1);  \n  // lock on the first object  \nsynchronized (ob1)   \n{  \n    System.out.println(strName + \" acquired the lock on \" + ob1);  \n    work();  \n    System.out.println(strName + \" iz taking control on the lock \" + ob2);  \nsynchronized (ob2)   \n{  \n    // because of the deadlock the following print statement will not work  \n    System.out.println(strName + \" acquired the lock on \" + ob2);  \n    work();  \n}  \nSystem.out.println(strName + \" released the lock on \" + ob2); // will not work  \n}  \nSystem.out.println(strName + \" released the lock on \" + ob1); // will not work  \nSystem.out.println(strName + \" finished the execution.\"); // will not work  \n}  \n  private void work()   \n{  \ntry   \n{  \n    Thread.sleep(40000);  \n}   \ncatch (InterruptedException ie)   \n{  \n    ie.printStackTrace();  \n}  \n}  \n  }  \nOutput:\nth1 is taking control on the lock java.lang.Object@256f00b6\nth1 acquired the lock on java.lang.Object@256f00b6\nth2 is taking control on the lock java.lang.Object@5cdddb56\nth2 acquired the lock on java.lang.Object@5cdddb56\nth3 is taking control on the lock java.lang.Object@248f4cc7\nth3 acquired the lock on java.lang.Object@248f4cc7\nExplanation: All of the three threads are able to take a lock on the first object. But, they are also using the resources that is shared and are started in a way that the threads keep on indefinitely waiting in order to acquire the lock on the second object.",
        "reference": "javatpoint.com"
    },
    {
        "question": "",
        "answer": "A sudoku puzzle is a popular Japanese puzzle that is based on the logical positioning of numbers from 1 to 9. The task is to fill the 9 x 9 grid with numbers from 1 to 9 such that all columns, rows and sub-grids (there will be 9 sub-grids of 3 x 3) contain each number from 1 to 9 with zero repeats. The program for solving the sudoku is mentioned below.\nFileName: Sudoku.java\npublic class Sudoku   \n{  \n  // M is the size of the M * M 2D matrix  \nstatic int M = 9;  \n  // Takes a grid that is partially filled in and tries  \n// to assign values to all of the unassigned locations in  \n// a way to fulfil the conditions of the  \n// Sudoku solution, which is zero duplication of numbers   \n// in every row, column, and sub-grid.  \nstatic boolean solveSudokuPuzzle(int sudokuGrid[][], int r, int c)  \n{  \n  // if one has reached the 9th  \n// column and 9th row(consider the matrix zero-indexed)  \n// A true value is returned in order to avoid further  \n// backtracking   \nif (r == M - 1 && c == M)  \n{  \nreturn true;  \n}  \n  // Check if the column value becomes 9,  \n// we move to the next row  \n// and column start from 0  \nif (c == M)   \n{  \nr = r + 1;  \nc = 0;  \n}  \n  // Check whether the current position  \n// of the sudoku grid already  \n// contains a value greater than 0, we loop  \n// for the next column  \nif (sudokuGrid[r][c] != 0)  \n{  \nreturn solveSudokuPuzzle(sudokuGrid, r, c + 1);  \n}  \n  for (int n = 1; n < 10; n++)   \n{  \n  // Check if it is safe to place  \n// the n (1-9) in the  \n// given row ,col ->we move to next column  \nif (isSafe(sudokuGrid, r, c, n))   \n{  \n      // assign the value n in the current  \n    // (r,c) position of the sudoku grid and  \n    // assume that the assigned value of n in the position  \n    // is valid.  \n    sudokuGrid[r][c] = n;  \n      // Checking for the next  \n    // possibility with the next column  \n    if (solveSudokuPuzzle(sudokuGrid, r, c + 1))  \n    {  \n        return true;  \n    }  \n}  \n// removing the assigned n, since whatever was the  \n// assumption turns out to be wrong, and hence look for the next  \n// assumption with diff value of n value  \nsudokuGrid[r][c] = 0;  \n}  \nreturn false;  \n}  \n  // A utility method for printing the grid  \nstatic void print(int sudokuGrid[][])  \n{  \nfor (int j = 0; j < M; j++)   \n{  \nfor (int k = 0; k < M; k++)  \n{  \n    System.out.print(sudokuGrid[j][k] + \" \");  \n}  \nSystem.out.println( );  \n}  \n}  \n  // Checking whether it is valid  \n// to assign the value n to the given   \n// given r, c  \nstatic boolean isSafe(int[][] sudokuGrid, int r, int c, int n)  \n{  \n  // Checking if the same value of n is found  \n// in the similar row , if it is found a  \n// false value is returned  \nfor (int row = 0; row <= 8; row++)  \n{  \nif (sudokuGrid[r][row] == n)  \n{  \n    return false;  \n}  \n}  \n  // Check if we find the same num  \n// in the similar column ,  \n// we return false  \nfor (int col = 0; col <= 8; col++)  \n{  \nif (sudokuGrid[col][c] == n)  \n{  \n    return false;  \n}  \n}  \n  // Checking if the same value of n is  \n// found in the the particular 3 x 3 sub-grid  \n// if found a false value is returned  \nint startR = r - r % 3;  \nint startC = c - c % 3;  \nfor (int j = 0; j < 3; j++)  \n{  \nfor (int k = 0; k < 3; k++)  \n{  \n    if (sudokuGrid[j + startR][k + startC] == n)  \n    {  \n                return false;  \n    }  \n}  \n}  \n  return true;  \n}  \n  // main method  \npublic static void main(String[] args)  \n{  \n// 9 x 9 sudoku grid  \n// 0 means that place is empty and the player will put  \n// numbers only in the empty space, i.e., only at those places  \n// where 0 is mentioned.  \nint sudokuGrid[][] = { { 5, 3, 0, 0, 7, 0, 0, 0, 0 },  \n             { 6, 0, 0, 1, 9, 5, 0, 0, 0 },  \n             { 0, 9, 8, 0, 0, 0, 0, 6, 0 },  \n             { 8, 0, 0, 0, 6, 0, 0, 0, 3 },  \n             { 4, 0, 0, 8, 0, 3, 0, 0, 1 },  \n             { 7, 0, 0, 0, 2, 0, 0, 0, 6 },  \n             { 0, 6, 0, 0, 0, 0, 2, 8, 0 },  \n             { 0, 0, 0, 4, 1, 9, 0, 0, 5 },  \n             { 0, 0, 0, 0, 8, 0, 0, 7, 9 } };  \n  if (solveSudokuPuzzle(sudokuGrid, 0, 0))  \n{  \nprint(sudokuGrid);  \n}  \nelse  \n{  \nSystem.out.println(\"The solution is not found!\");  \n}  \n}  \n}  \nOutput:\n5 3 4 6 7 8 9 1 2 \n6 7 2 1 9 5 3 4 8 \n1 9 8 3 4 2 5 6 7 \n8 5 9 7 6 1 4 2 3 \n4 2 6 8 5 3 7 9 1 \n7 1 3 9 2 4 8 5 6 \n9 6 1 5 3 7 2 8 4 \n2 8 7 4 1 9 6 3 5 \n3 4 5 2 8 6 1 7 9\nTime complexity: In the worst case, it is required to put every number in the empty cell and check whether it is a valid one or not. Thus, there are 9 choices for every cell, making the time complexity O(9^(n x n)).\nAuxiliary Space: O(n x n).",
        "reference": "javatpoint.com"
    }
]