[
    {
        "question": "1. What is React?",
        "answer": "React is a front-end and open-source JavaScript library which is useful in developing user interfaces specifically for applications with a single page. It is helpful in building complex and reusable user interface(UI) components of mobile and web applications as it follows the component-based approach. The important features of React are: It supports server-side rendering.\nIt will make use of the virtual DOM rather than real DOM (Data Object Model) as RealDOM manipulations are expensive.\nIt follows unidirectional data binding or data flow.\nIt uses reusable or composable UI components for developing the view. It supports server-side rendering. It will make use of the virtual DOM rather than real DOM (Data Object Model) as RealDOM manipulations are expensive. It follows unidirectional data binding or data flow. It uses reusable or composable UI components for developing the view.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "2. What are the advantages of using React?",
        "answer": "MVC is generally abbreviated as Model View Controller. Use of Virtual DOM to improve efficiency: React uses virtual DOM to render the view. As the name suggests, virtual DOM is a virtual representation of the real DOM. Each time the data changes in a react app, a new virtual DOM gets created. Creating a virtual DOM is much faster than rendering the UI inside the browser. Therefore, with the use of virtual DOM, the efficiency of the app improves.\nGentle learning curve: React has a gentle learning curve when compared to frameworks like Angular. Anyone with little knowledge of javascript can start building web applications using React.\nSEO friendly: React allows developers to develop engaging user interfaces that can be easily navigated in various search engines. It also allows server-side rendering, which boosts the SEO of an app.\nReusable components: React uses component-based architecture for developing applications. Components are independent and reusable bits of code. These components can be shared across various applications having similar functionality. The re-use of components increases the pace of development.\nHuge ecosystem of libraries to choose from: React provides you with the freedom to choose the tools, libraries, and architecture for developing an application based on your requirement. Use of Virtual DOM to improve efficiency: React uses virtual DOM to render the view. As the name suggests, virtual DOM is a virtual representation of the real DOM. Each time the data changes in a react app, a new virtual DOM gets created. Creating a virtual DOM is much faster than rendering the UI inside the browser. Therefore, with the use of virtual DOM, the efficiency of the app improves. Use of Virtual DOM to improve efficiency: Gentle learning curve: React has a gentle learning curve when compared to frameworks like Angular. Anyone with little knowledge of javascript can start building web applications using React. Gentle learning curve: SEO friendly: React allows developers to develop engaging user interfaces that can be easily navigated in various search engines. It also allows server-side rendering, which boosts the SEO of an app. SEO friendly: Reusable components: React uses component-based architecture for developing applications. Components are independent and reusable bits of code. These components can be shared across various applications having similar functionality. The re-use of components increases the pace of development. Reusable components: Huge ecosystem of libraries to choose from: React provides you with the freedom to choose the tools, libraries, and architecture for developing an application based on your requirement. Huge ecosystem of libraries to choose from:",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "3. What are the limitations of React?",
        "answer": "The few limitations of React are as given below: React is not a full-blown framework as it is only a library.\nThe components of React are numerous and will take time to fully grasp the benefits of all.\nIt might be difficult for beginner programmers to understand React.\nCoding might become complex as it will make use of inline templating and JSX. React is not a full-blown framework as it is only a library. The components of React are numerous and will take time to fully grasp the benefits of all. It might be difficult for beginner programmers to understand React. Coding might become complex as it will make use of inline templating and JSX.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "4. What is useState() in React?",
        "answer": "The useState() is a built-in React Hook that allows you for having state variables in functional components. It should be used when the DOM has something that is dynamically manipulating/controlling. In the below-given example code, The useState(0) will return a tuple where the count is the first parameter that represents the counter’s current state and the second parameter setCounter method will allow us to update the state of the counter. ...\nconst [count, setCounter] = useState(0);\nconst [otherStuffs, setOtherStuffs] = useState(...);\n...\nconst setCount = () => {\n   setCounter(count + 1);\n   setOtherStuffs(...);\n   ...\n}; ...\nconst [count, setCounter] = useState(0);\nconst [otherStuffs, setOtherStuffs] = useState(...);\n...\nconst setCount = () => {\n   setCounter(count + 1);\n   setOtherStuffs(...);\n   ...\n}; We can make use of setCounter() method for updating the state of count anywhere. In this example, we are using setCounter() inside the setCount function where various other things can also be done. The idea with the usage of hooks is that we will be able to keep our code more functional and avoid class-based components if they are not required.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "5. What are keys in React?",
        "answer": "A key is a special string attribute that needs to be included when using lists of elements.   Example of a list using key - const ids = [1,2,3,4,5];\nconst listElements = ids.map((id)=>{\nreturn(\n<li key={id.toString()}>\n  {id}\n</li>\n)\n}) const ids = [1,2,3,4,5];\nconst listElements = ids.map((id)=>{\nreturn(\n<li key={id.toString()}>\n  {id}\n</li>\n)\n}) Importance of keys - Importance of keys - Keys help react identify which elements were added, changed or removed.\nKeys should be given to array elements for providing a unique identity for each element.\nWithout keys, React does not understand the order or uniqueness of each element.\nWith keys, React has an idea of which particular element was deleted, edited, and added.\nKeys are generally used for displaying a list of data coming from an API. Keys help react identify which elements were added, changed or removed. Keys should be given to array elements for providing a unique identity for each element. Without keys, React does not understand the order or uniqueness of each element. With keys, React has an idea of which particular element was deleted, edited, and added. Keys are generally used for displaying a list of data coming from an API. ***Note- Keys used within arrays should be unique among siblings. They need not be globally unique. ***Note- Keys used within arrays should be unique among siblings. They need not be globally unique.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "6. What is JSX?",
        "answer": "JSX stands for JavaScript XML. It allows us to write HTML inside JavaScript and place them in the DOM without using functions like appendChild( ) or createElement( ). As stated in the official docs of React, JSX provides syntactic sugar for React.createElement( ) function. Note- We can create react applications without using JSX as well. Note- We can create react applications without using JSX as well. Let’s understand how JSX works: how JSX works Without using JSX, we would have to create an element by the following process: const text = React.createElement('p', {}, 'This is a text');\nconst container = React.createElement('div','{}',text );\nReactDOM.render(container,rootElement); const text = React.createElement('p', {}, 'This is a text');\nconst container = React.createElement('div','{}',text );\nReactDOM.render(container,rootElement); Using JSX, the above code can be simplified: Using JSX const container = (\n<div>\n  <p>This is a text</p>\n</div>\n);\nReactDOM.render(container,rootElement); const container = (\n<div>\n  <p>This is a text</p>\n</div>\n);\nReactDOM.render(container,rootElement); As one can see in the code above, we are directly using HTML inside JavaScript.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "7. What are the differences between functional and class components?",
        "answer": "Before the introduction of Hooks in React, functional components were called stateless components and were behind class components on a feature basis. After the introduction of Hooks, functional components are equivalent to class components. Although functional components are the new trend, the react team insists on keeping class components in React. Therefore, it is important to know how these components differ. On the following basis let’s compare functional and class components: Declaration Declaration Declaration Functional components are nothing but JavaScript functions and therefore can be declared using an arrow function or the function keyword: function card(props){\n   return(\n      <div className=\"main-container\">\n        <h2>Title of the card</h2>\n      </div>\n    )\n   }\n   const card = (props) =>{\n    return(\n      <div className=\"main-container\">\n        <h2>Title of the card</h2>\n      </div>\n    )\n   } function card(props){\n   return(\n      <div className=\"main-container\">\n        <h2>Title of the card</h2>\n      </div>\n    )\n   }\n   const card = (props) =>{\n    return(\n      <div className=\"main-container\">\n        <h2>Title of the card</h2>\n      </div>\n    )\n   } Class components, on the other hand, are declared using the ES6 class: class Card extends React.Component{\n  constructor(props){\n     super(props);\n   }\n    render(){\n      return(\n        <div className=\"main-container\">\n          <h2>Title of the card</h2>\n        </div>\n      )\n    }\n   } class Card extends React.Component{\n  constructor(props){\n     super(props);\n   }\n    render(){\n      return(\n        <div className=\"main-container\">\n          <h2>Title of the card</h2>\n        </div>\n      )\n    }\n   } Handling props Handling props Handling props Let’s render the following component with props and analyse how functional and class components handle props: <Student Info name=\"Vivek\" rollNumber=\"23\" /> <Student Info name=\"Vivek\" rollNumber=\"23\" /> In functional components, the handling of props is pretty straightforward. Any prop provided as an argument to a functional component can be directly used inside HTML elements: function StudentInfo(props){\n   return(\n     <div className=\"main\">\n       <h2>{props.name}</h2>\n       <h4>{props.rollNumber}</h4>\n     </div>\n   )\n } function StudentInfo(props){\n   return(\n     <div className=\"main\">\n       <h2>{props.name}</h2>\n       <h4>{props.rollNumber}</h4>\n     </div>\n   )\n } In the case of class components, props are handled in a different way: class StudentInfo extends React.Component{\n   constructor(props){\n     super(props);\n    }\n    render(){\n      return(\n        <div className=\"main\">\n          <h2>{this.props.name}</h2>\n          <h4>{this.props.rollNumber}</h4> \n        </div>\n      )\n    }\n   } class StudentInfo extends React.Component{\n   constructor(props){\n     super(props);\n    }\n    render(){\n      return(\n        <div className=\"main\">\n          <h2>{this.props.name}</h2>\n          <h4>{this.props.rollNumber}</h4> \n        </div>\n      )\n    }\n   } As we can see in the code above, this keyword is used in the case of class components. this Handling state Handling state Handling state Functional components use React hooks to handle state. It uses the useState hook to set the state of a variable inside the component: function ClassRoom(props){\n   let [studentsCount,setStudentsCount] = useState(0);\n    const addStudent = () => {\n      setStudentsCount(++studentsCount);\n   }\n    return(\n      <div>\n        <p>Number of students in class room: {studentsCount}</p>\n        <button onClick={addStudent}>Add Student</button>\n      </div>\n    )\n   } function ClassRoom(props){\n   let [studentsCount,setStudentsCount] = useState(0);\n    const addStudent = () => {\n      setStudentsCount(++studentsCount);\n   }\n    return(\n      <div>\n        <p>Number of students in class room: {studentsCount}</p>\n        <button onClick={addStudent}>Add Student</button>\n      </div>\n    )\n   } Since useState hook returns an array of two items, the first item contains the current state, and the second item is a function used to update the state. In the code above, using array destructuring we have set the variable name to studentsCount with a current value of “0” and setStudentsCount is the function that is used to update the state. For reading the state, we can see from the code above, the variable name can be directly used to read the current state of the variable. We cannot use React Hooks inside class components, therefore state handling is done very differently in a class component: Let’s take the same above example and convert it into a class component: class ClassRoom extends React.Component{\n        constructor(props){\n            super(props);\n            this.state = {studentsCount : 0};\n            \n            this.addStudent = this.addStudent.bind(this);\n         }\n            \n            addStudent(){\n            this.setState((prevState)=>{\n               return {studentsCount: prevState.studentsCount++}\n            });\n         }\n            \n            render(){\n             return(\n               <div>\n                 <p>Number of students in class room: {this.state.studentsCount}</p>\n                 <button onClick={this.addStudent}>Add Student</button>\n               </div>\n             )\n           }\n         } class ClassRoom extends React.Component{\n        constructor(props){\n            super(props);\n            this.state = {studentsCount : 0};\n            \n            this.addStudent = this.addStudent.bind(this);\n         }\n            \n            addStudent(){\n            this.setState((prevState)=>{\n               return {studentsCount: prevState.studentsCount++}\n            });\n         }\n            \n            render(){\n             return(\n               <div>\n                 <p>Number of students in class room: {this.state.studentsCount}</p>\n                 <button onClick={this.addStudent}>Add Student</button>\n               </div>\n             )\n           }\n         } In the code above, we see we are using this.state to add the variable studentsCount and setting the value to “0”. this.state For reading the state, we are using this.state.studentsCount. this.state.studentsCount For updating the state, we need to first bind the addStudent function to this. Only then, we will be able to use the setState function which is used to update the state. this setState",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "8. What is the virtual DOM? How does react use the virtual DOM to render the UI?",
        "answer": "As stated by the react team, virtual DOM is a concept where a virtual representation of the real DOM is kept inside the memory and is synced with the real DOM by a library such as ReactDOM.   Why was virtual DOM introduced? Why was virtual DOM introduced? DOM manipulation is an integral part of any web application, but DOM manipulation is quite slow when compared to other operations in JavaScript. The efficiency of the application gets affected when several DOM manipulations are being done. Most JavaScript frameworks update the entire DOM even when a small part of the DOM changes. For example, consider a list that is being rendered inside the DOM. If one of the items in the list changes, the entire list gets rendered again instead of just rendering the item that was changed/updated. This is called inefficient updating. To address the problem of inefficient updating, the react team introduced the concept of virtual DOM. How does it work? How does it work?   For every DOM object, there is a corresponding virtual DOM object(copy), which has the same properties. The main difference between the real DOM object and the virtual DOM object is that any changes in the virtual DOM object will not reflect on the screen directly. Consider a virtual DOM object as a blueprint of the real DOM object. Whenever a JSX element gets rendered, every virtual DOM object gets updated. **Note- One may think updating every virtual DOM object might be inefficient, but that’s not the case. Updating the virtual DOM is much faster than updating the real DOM since we are just updating the blueprint of the real DOM. **Note- One may think updating every virtual DOM object might be inefficient, but that’s not the case. Updating the virtual DOM is much faster than updating the real DOM since we are just updating the blueprint of the real DOM. React uses two virtual DOMs to render the user interface. One of them is used to store the current state of the objects and the other to store the previous state of the objects. Whenever the virtual DOM gets updated, react compares the two virtual DOMs and gets to know about which virtual DOM objects were updated. After knowing which objects were updated, react renders only those objects inside the real DOM instead of rendering the complete real DOM. This way, with the use of virtual DOM, react solves the problem of inefficient updating.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "9. What are the differences between controlled and uncontrolled components?",
        "answer": "Controlled and uncontrolled components are just different approaches to handling input from elements in react. Feature Uncontrolled Controlled Name attrs\nOne-time value retrieval (e.g. on submit) ✔️ ✔️ ✔️\nValidating on submit ✔️ ✔️ ✔️\nField-level Validation ❌ ✔️ ✔️\nConditionally disabling submit button ❌ ✔️ ✔️\nEnforcing input format ❌ ✔️ ✔️\nseveral inputs for one piece of data ❌ ✔️ ✔️\ndynamic inputs ❌ ✔️ 🤔 Feature Uncontrolled Controlled Name attrs\nOne-time value retrieval (e.g. on submit) ✔️ ✔️ ✔️\nValidating on submit ✔️ ✔️ ✔️\nField-level Validation ❌ ✔️ ✔️\nConditionally disabling submit button ❌ ✔️ ✔️\nEnforcing input format ❌ ✔️ ✔️\nseveral inputs for one piece of data ❌ ✔️ ✔️\ndynamic inputs ❌ ✔️ 🤔 Feature Uncontrolled Controlled Name attrs Feature Uncontrolled Controlled Name attrs Feature Uncontrolled Controlled Name attrs One-time value retrieval (e.g. on submit) ✔️ ✔️ ✔️\nValidating on submit ✔️ ✔️ ✔️\nField-level Validation ❌ ✔️ ✔️\nConditionally disabling submit button ❌ ✔️ ✔️\nEnforcing input format ❌ ✔️ ✔️\nseveral inputs for one piece of data ❌ ✔️ ✔️\ndynamic inputs ❌ ✔️ 🤔 One-time value retrieval (e.g. on submit) ✔️ ✔️ ✔️ One-time value retrieval (e.g. on submit) ✔️ ✔️ ✔️ Validating on submit ✔️ ✔️ ✔️ Validating on submit ✔️ ✔️ ✔️ Field-level Validation ❌ ✔️ ✔️ Field-level Validation ❌ ✔️ ✔️ Conditionally disabling submit button ❌ ✔️ ✔️ Conditionally disabling submit button ❌ ✔️ ✔️ Enforcing input format ❌ ✔️ ✔️ Enforcing input format ❌ ✔️ ✔️ several inputs for one piece of data ❌ ✔️ ✔️ several inputs for one piece of data ❌ ✔️ ✔️ dynamic inputs ❌ ✔️ 🤔 dynamic inputs ❌ ✔️ 🤔 Controlled component: In a controlled component, the value of the input element is controlled by React. We store the state of the input element inside the code, and by using event-based callbacks, any changes made to the input element will be reflected in the code as well. Controlled component: In a controlled component, the value of the input element is controlled by React. We store the state of the input element inside the code, and by using event-based callbacks, any changes made to the input element will be reflected in the code as well. Controlled component: When a user enters data inside the input element of a controlled component, onChange function gets triggered and inside the code, we check whether the value entered is valid or invalid. If the value is valid, we change the state and re-render the input element with the new value. Example of a controlled component: function FormValidation(props) {\nlet [inputValue, setInputValue] = useState(\"\");\nlet updateInput = e => {\n  setInputValue(e.target.value);\n};\nreturn (\n  <div>\n    <form>\n      <input type=\"text\" value={inputValue} onChange={updateInput} />\n    </form>\n  </div>\n);\n} function FormValidation(props) {\nlet [inputValue, setInputValue] = useState(\"\");\nlet updateInput = e => {\n  setInputValue(e.target.value);\n};\nreturn (\n  <div>\n    <form>\n      <input type=\"text\" value={inputValue} onChange={updateInput} />\n    </form>\n  </div>\n);\n} As one can see in the code above, the value of the input element is determined by the state of the inputValue variable. Any changes made to the input element is handled by the updateInput function. inputValue updateInput Uncontrolled component: In an uncontrolled component, the value of the input element is handled by the DOM itself. Input elements inside uncontrolled components work just like normal HTML input form elements. Uncontrolled component: In an uncontrolled component, the value of the input element is handled by the DOM itself. Input elements inside uncontrolled components work just like normal HTML input form elements. Uncontrolled component: The state of the input element is handled by the DOM. Whenever the value of the input element is changed, event-based callbacks are not called. Basically, react does not perform any action when there are changes made to the input element. Whenever use enters data inside the input field, the updated data is shown directly. To access the value of the input element, we can use ref. ref Example of an uncontrolled component: function FormValidation(props) {\nlet inputValue = React.createRef();\nlet handleSubmit = e => {\n  alert(`Input value: ${inputValue.current.value}`);\n  e.preventDefault();\n};\nreturn (\n  <div>\n    <form onSubmit={handleSubmit}>\n      <input type=\"text\" ref={inputValue} />\n      <button type=\"submit\">Submit</button>\n    </form>\n  </div>\n);\n} function FormValidation(props) {\nlet inputValue = React.createRef();\nlet handleSubmit = e => {\n  alert(`Input value: ${inputValue.current.value}`);\n  e.preventDefault();\n};\nreturn (\n  <div>\n    <form onSubmit={handleSubmit}>\n      <input type=\"text\" ref={inputValue} />\n      <button type=\"submit\">Submit</button>\n    </form>\n  </div>\n);\n} As one can see in the code above, we are not using onChange function to govern the changes made to the input element. Instead, we are using ref to access the value of the input element. not onChange ref",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "10. What are props in React?",
        "answer": "The props in React are the inputs to a component of React. They can be single-valued or objects having a set of values that will be passed to components of React during creation by using a naming convention that almost looks similar to HTML-tag attributes. We can say that props are the data passed from a parent component into a child component. The main purpose of props is to provide different component functionalities such as: Passing custom data to the React component.\nUsing through this.props.reactProp inside render() method of the component.\nTriggering state changes. Passing custom data to the React component. Using through this.props.reactProp inside render() method of the component. this.props.reactProp Triggering state changes. For example, consider we are creating an element with reactProp property as given below: <Element reactProp = \"1\" />\nThis reactProp name will be considered as a property attached to the native props object of React which already exists on each component created with the help of React library: props.reactProp;. <Element reactProp = \"1\" />  props.reactProp;",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "11. Explain React state and props.",
        "answer": "Props State\nImmutable Owned by its component\nHas better performance Locally scoped\nCan be passed to child components Writeable/Mutable\n  has setState() method to modify properties\n  Changes to state can be asynchronous\n  can only be passed as props Props State\nImmutable Owned by its component\nHas better performance Locally scoped\nCan be passed to child components Writeable/Mutable\n  has setState() method to modify properties\n  Changes to state can be asynchronous\n  can only be passed as props Props State Props State Props State Immutable Owned by its component\nHas better performance Locally scoped\nCan be passed to child components Writeable/Mutable\n  has setState() method to modify properties\n  Changes to state can be asynchronous\n  can only be passed as props Immutable Owned by its component Immutable Owned by its component Has better performance Locally scoped Has better performance Locally scoped Can be passed to child components Writeable/Mutable Can be passed to child components Writeable/Mutable has setState() method to modify properties  has setState() method to modify properties Changes to state can be asynchronous  Changes to state can be asynchronous can only be passed as props  can only be passed as props React State\nEvery component in react has a built-in state object, which contains all the property values that belong to that component.\nIn other words, the state object controls the behaviour of a component. Any change in the property values of the state object leads to the re-rendering of the component. React State\nEvery component in react has a built-in state object, which contains all the property values that belong to that component.\nIn other words, the state object controls the behaviour of a component. Any change in the property values of the state object leads to the re-rendering of the component. React State   Note- State object is not available in functional components but, we can use React Hooks to add state to a functional component. Note- State object is not available in functional components but, we can use React Hooks to add state to a functional component. How to declare a state object? How to declare a state object? Example: Example: class Car extends React.Component{\nconstructor(props){\n  super(props);\n  this.state = {\n    brand: \"BMW\",\n    color: \"black\"\n  }\n}\n} class Car extends React.Component{\nconstructor(props){\n  super(props);\n  this.state = {\n    brand: \"BMW\",\n    color: \"black\"\n  }\n}\n} How to use and update the state object? How to use and update the state object? class Car extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = {\n    brand: \"BMW\",\n    color: \"Black\"\n  };\n}\nchangeColor() {\n  this.setState(prevState => {\n    return { color: \"Red\" };\n  });\n}\nrender() {\n  return (\n    <div>\n      <button onClick={() => this.changeColor()}>Change Color</button>\n      <p>{this.state.color}</p>\n    </div>\n  );\n}\n} class Car extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = {\n    brand: \"BMW\",\n    color: \"Black\"\n  };\n}\nchangeColor() {\n  this.setState(prevState => {\n    return { color: \"Red\" };\n  });\n}\nrender() {\n  return (\n    <div>\n      <button onClick={() => this.changeColor()}>Change Color</button>\n      <p>{this.state.color}</p>\n    </div>\n  );\n}\n} As one can see in the code above, we can use the state by calling this.state.propertyName and we can change the state object property using setState method. this.state.propertyName setState React Props React Props React Props Every React component accepts a single object argument called props (which stands for “properties”).  These props can be passed to a component using HTML attributes and the component accepts these props as an argument. Using props, we can pass data from one component to another. Passing props to a component: Passing props to a component: While rendering a component, we can pass the props as an HTML attribute: <Car brand=\"Mercedes\"/> <Car brand=\"Mercedes\"/> The component receives the props: In Class component: In Class component: class Car extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = {\n    brand: this.props.brand,\n    color: \"Black\"\n  };\n}\n} class Car extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = {\n    brand: this.props.brand,\n    color: \"Black\"\n  };\n}\n} In Functional component: In Functional component: function Car(props) {\nlet [brand, setBrand] = useState(props.brand);\n} function Car(props) {\nlet [brand, setBrand] = useState(props.brand);\n} Note- Props are read-only. They cannot be manipulated or changed inside a component. Note- Props are read-only. They cannot be manipulated or changed inside a component.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "12. Explain about types of side effects in React component.",
        "answer": "There are two types of side effects in React component. They are: Effects without Cleanup: This side effect will be used in useEffect which does not restrict the browser from screen update. It also improves the responsiveness of an application. A few common examples are network requests, Logging, manual DOM mutations, etc.\nEffects with Cleanup: Some of the Hook effects will require the cleanup after updating of DOM is done. For example, if you want to set up an external data source subscription, it requires cleaning up the memory else there might be a problem of memory leak. It is a known fact that React will carry out the cleanup of memory when the unmounting of components happens. But the effects will run for each render() method rather than for any specific method. Thus we can say that, before execution of the effects succeeding time the React will also cleanup effects from the preceding render. Effects without Cleanup: This side effect will be used in useEffect which does not restrict the browser from screen update. It also improves the responsiveness of an application. A few common examples are network requests, Logging, manual DOM mutations, etc. Effects without Cleanup: Effects with Cleanup: Some of the Hook effects will require the cleanup after updating of DOM is done. For example, if you want to set up an external data source subscription, it requires cleaning up the memory else there might be a problem of memory leak. It is a known fact that React will carry out the cleanup of memory when the unmounting of components happens. But the effects will run for each render() method rather than for any specific method. Thus we can say that, before execution of the effects succeeding time the React will also cleanup effects from the preceding render. Effects with Cleanup:",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "13. What is prop drilling in React?",
        "answer": "  Sometimes while developing React applications, there is a need to pass data from a component that is higher in the hierarchy to a component that is deeply nested. To pass data between such components, we pass props from a source component and keep passing the prop to the next component in the hierarchy till we reach the deeply nested component. The disadvantage of using prop drilling is that the components that should otherwise be not aware of the data have access to the data. disadvantage",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "14. What are error boundaries?",
        "answer": "Introduced in version 16 of React, Error boundaries provide a way for us to catch errors that occur in the render phase. What is an error boundary? What is an error boundary? What is an error boundary? Any component which uses one of the following lifecycle methods is considered an error boundary.\nIn what places can an error boundary detect an error?  Render phase\nInside a lifecycle method\nInside the constructor Render phase Inside a lifecycle method Inside the constructor Without using error boundaries: Without using error boundaries: class CounterComponent extends React.Component{\nconstructor(props){\n  super(props);\n  this.state = {\n    counterValue: 0\n  }\n  this.incrementCounter = this.incrementCounter.bind(this);\n}\nincrementCounter(){\n  this.setState(prevState => counterValue = prevState+1);\n}\nrender(){\n  if(this.state.counter === 2){\n    throw new Error('Crashed');\n  }\n  return(\n    <div>\n      <button onClick={this.incrementCounter}>Increment Value</button>\n      <p>Value of counter: {this.state.counterValue}</p>\n    </div>\n  )\n}\n} class CounterComponent extends React.Component{\nconstructor(props){\n  super(props);\n  this.state = {\n    counterValue: 0\n  }\n  this.incrementCounter = this.incrementCounter.bind(this);\n}\nincrementCounter(){\n  this.setState(prevState => counterValue = prevState+1);\n}\nrender(){\n  if(this.state.counter === 2){\n    throw new Error('Crashed');\n  }\n  return(\n    <div>\n      <button onClick={this.incrementCounter}>Increment Value</button>\n      <p>Value of counter: {this.state.counterValue}</p>\n    </div>\n  )\n}\n} In the code above, when the counterValue equals 2, we throw an error inside the render method. When we are not using the error boundary, instead of seeing an error, we see a blank page. Since any error inside the render method leads to unmounting of the component. To display an error that occurs inside the render method, we use error boundaries. With error boundaries: As mentioned above, error boundary is a component using one or both of the following methods: static getDerivedStateFromError and componentDidCatch. With error boundaries: static getDerivedStateFromError and componentDidCatch. Let’s create an error boundary to handle errors in the render phase: class ErrorBoundary extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = { hasError: false };\n}\nstatic getDerivedStateFromError(error) {     \n  return { hasError: true }; \n}\n componentDidCatch(error, errorInfo) {       \n  logErrorToMyService(error, errorInfo); \n}\nrender() {\n  if (this.state.hasError) {     \n    return <h4>Something went wrong</h4>     \n  }\n  return this.props.children;\n}\n} class ErrorBoundary extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = { hasError: false };\n}\nstatic getDerivedStateFromError(error) {     \n  return { hasError: true }; \n}\n componentDidCatch(error, errorInfo) {       \n  logErrorToMyService(error, errorInfo); \n}\nrender() {\n  if (this.state.hasError) {     \n    return <h4>Something went wrong</h4>     \n  }\n  return this.props.children;\n}\n} In the code above, getDerivedStateFromError function renders the fallback UI interface when the render method has an error. getDerivedStateFromError componentDidCatch logs the error information to an error tracking service. componentDidCatch Now with the error boundary, we can render the CounterComponent in the following way: <ErrorBoundary>\n <CounterComponent/>\n</ErrorBoundary> <ErrorBoundary>\n <CounterComponent/>\n</ErrorBoundary>",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "15. What is React Hooks?",
        "answer": "React Hooks are the built-in functions that permit developers for using the state and lifecycle methods within React components. These are newly added features made available in React 16.8 version. Each lifecycle of a component is having 3 phases which include mount, unmount, and update. Along with that, components have properties and states. Hooks will allow using these methods by developers for improving the reuse of code with higher flexibility navigating the component tree. Using Hook, all features of React can be used without writing class components. For example, before React version 16.8, it required a class component for managing the state of a component. But now using the useState hook, we can keep the state in a functional component. For example For example",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "16. Explain React Hooks.",
        "answer": "What are Hooks? Hooks are functions that let us “hook into” React state and lifecycle features from a functional component. What are Hooks? functional component. React Hooks cannot be used in class components. They let us write components without class. cannot Why were Hooks introduced in React? Why were Hooks introduced in React? React hooks were introduced in the 16.8 version of React. Previously, functional components were called stateless components. Only class components were used for state management and lifecycle methods. The need to change a functional component to a class component, whenever state management or lifecycle methods were to be used, led to the development of Hooks. Example of a hook: useState hook: Example of a hook: useState hook: In functional components, the useState hook lets us define a state for a component: function Person(props) {\n// We are declaring a state variable called name.\n// setName is a function to update/change the value of name\nlet [name, setName] = useState('');\n} function Person(props) {\n// We are declaring a state variable called name.\n// setName is a function to update/change the value of name\nlet [name, setName] = useState('');\n} The state variable “name” can be directly used inside the HTML.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "17. What are the rules that must be followed while using React Hooks?",
        "answer": "There are 2 rules which must be followed while you code with Hooks: React Hooks must be called only at the top level. It is not allowed to call them inside the nested functions, loops, or conditions.\nIt is allowed to call the Hooks only from the React Function Components. React Hooks must be called only at the top level. It is not allowed to call them inside the nested functions, loops, or conditions. It is allowed to call the Hooks only from the React Function Components.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "18. What is the use of useEffect React Hooks?",
        "answer": "The useEffect React Hook is used for performing the side effects in functional components. With the help of useEffect, you will inform React that your component requires something to be done after rendering the component or after a state change. The function you have passed(can be referred to as “effect”) will be remembered by React and call afterwards the performance of DOM updates is over. Using this, we can perform various calculations such as data fetching, setting up document title, manipulating DOM directly, etc, that don’t target the output value. The useEffect hook will run by default after the first render and also after each update of the component. React will guarantee that the DOM will be updated by the time when the effect has run by it. The useEffect React Hook will accept 2 arguments: useEffect(callback,[dependencies]); useEffect(callback,[dependencies]); Where the first argument callback represents the function having the logic of side-effect and it will be immediately executed after changes were being pushed to DOM. The second argument dependencies represent an optional array of dependencies. The useEffect() will execute the callback only if there is a change in dependencies in between renderings. Example: Example: import { useEffect } from 'react';\nfunction WelcomeGreetings({ name }) {\n const msg = `Hi, ${name}!`;     // Calculates output\n useEffect(() => {\n   document.title = `Welcome to you ${name}`;    // Side-effect!\n }, [name]);\n return <div>{msg}</div>;         // Calculates output\n} import { useEffect } from 'react';\nfunction WelcomeGreetings({ name }) {\n const msg = `Hi, ${name}!`;     // Calculates output\n useEffect(() => {\n   document.title = `Welcome to you ${name}`;    // Side-effect!\n }, [name]);\n return <div>{msg}</div>;         // Calculates output\n} The above code will update the document title which is considered to be a side-effect as it will not calculate the component output directly. That is why updating of document title has been placed in a callback and provided to useEffect(). Consider you don’t want to execute document title update each time on rendering of WelcomeGreetings component and you want it to be executed only when the name prop changes then you need to supply name as a dependency to useEffect(callback, [name]). useEffect(callback, [name])",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "19. Why do React Hooks make use of refs?",
        "answer": "Earlier, refs were only limited to class components but now it can also be accessible in function components through the useRef Hook in React. The refs are used for: Managing focus, media playback, or text selection.\nIntegrating with DOM libraries by third-party.\nTriggering the imperative animations. Managing focus, media playback, or text selection. Integrating with DOM libraries by third-party. Triggering the imperative animations.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "20. What are Custom Hooks?",
        "answer": "A Custom Hook is a function in Javascript whose name begins with ‘use’ and which calls other hooks. It is a part of React v16.8 hook update and permits you for reusing the stateful logic without any need for component hierarchy restructuring. In almost all of the cases, custom hooks are considered to be sufficient for replacing render props and HoCs (Higher-Order components) and reducing the amount of nesting required. Custom Hooks will allow you for avoiding multiple layers of abstraction or wrapper hell that might come along with Render Props and HoCs. The disadvantage of Custom Hooks is it cannot be used inside of the classes. disadvantage",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "1. How to perform automatic redirect after login?",
        "answer": "The react-router package will provide the component <Redirect> in React Router. Rendering of a <Redirect> component will navigate to a newer location. In the history stack, the current location will be overridden by the new location just like the server-side redirects. <Redirect> <Redirect> import React, { Component } from 'react'\nimport { Redirect } from 'react-router'\nexport default class LoginDemoComponent extends Component {\n render() {\n   if (this.state.isLoggedIn === true) {\n     return <Redirect to=\"/your/redirect/page\" />\n   } else {\n     return <div>{'Please complete login'}</div>\n   }\n }\n} import React, { Component } from 'react'\nimport { Redirect } from 'react-router'\nexport default class LoginDemoComponent extends Component {\n render() {\n   if (this.state.isLoggedIn === true) {\n     return <Redirect to=\"/your/redirect/page\" />\n   } else {\n     return <div>{'Please complete login'}</div>\n   }\n }\n} Conclusion React has got more popularity among the top IT companies like Facebook, PayPal, Instagram, Uber, etc., around the world especially in India. Hooks is becoming a trend in the React community as it removes the state management complexities. This article includes the most frequently asked ReactJS and React Hooks interview questions and answers that will help you in interview preparations. Also, remember that your success during the interview is not all about your technical skills, it will also be based on your state of mind and the good impression that you will make at first. All the best!! Useful References and Resources: \"Beginning React with Hooks \" book by Greg Lim\n“Learn React Hooks” book by Daniel Bugl\nNode.js vs React.js\nReact Native Interview Questions\nAngular Interview Questions and Answers \"Beginning React with Hooks \" book by Greg Lim “Learn React Hooks” book by Daniel Bugl Node.js vs React.js Node.js vs React.js React Native Interview Questions React Native Interview Questions Angular Interview Questions and Answers Angular Interview Questions and Answers",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "2. How to pass data between sibling components using React router?",
        "answer": "Passing data between sibling components of React is possible using React Router with the help of history.push and match.params. history.push match.params In the code given below, we have a Parent component AppDemo.js and have two Child Components HomePage and AboutPage. Everything is kept inside a Router by using React-router Route. It is also having a route for /about/{params} where we will pass the data. AppDemo.js HomePage AboutPage /about/{params} import React, { Component } from ‘react’;\nclass AppDemo extends Component {\nrender() {\n  return (\n    <Router>\n      <div className=\"AppDemo\">\n      <ul>\n        <li>\n          <NavLink to=\"/\"  activeStyle={{ color:'blue' }}>Home</NavLink>\n        </li>\n        <li>\n          <NavLink to=\"/about\"  activeStyle={{ color:'blue' }}>About\n </NavLink>\n        </li>\n </ul>\n             <Route path=\"/about/:aboutId\" component={AboutPage} />\n             <Route path=\"/about\" component={AboutPage} />\n             <Route path=\"/\" component={HomePage} />\n      </div>\n    </Router>\n  );\n}\n}\nexport default AppDemo; import React, { Component } from ‘react’;\nclass AppDemo extends Component {\nrender() {\n  return (\n    <Router>\n      <div className=\"AppDemo\">\n      <ul>\n        <li>\n          <NavLink to=\"/\"  activeStyle={{ color:'blue' }}>Home</NavLink>\n        </li>\n        <li>\n          <NavLink to=\"/about\"  activeStyle={{ color:'blue' }}>About\n </NavLink>\n        </li>\n </ul>\n             <Route path=\"/about/:aboutId\" component={AboutPage} />\n             <Route path=\"/about\" component={AboutPage} />\n             <Route path=\"/\" component={HomePage} />\n      </div>\n    </Router>\n  );\n}\n}\nexport default AppDemo; The HomePage is a functional component with a button. On button click, we are using props.history.push(‘/about/’ + data) to programmatically navigate into /about/data. props.history.push(‘/about/’ + data) /about/data export default function HomePage(props) {\n const handleClick = (data) => {\n  props.history.push('/about/' + data);\n }\nreturn (\n  <div>\n    <button onClick={() => handleClick('DemoButton')}>To About</button>\n  </div>\n)\n} export default function HomePage(props) {\n const handleClick = (data) => {\n  props.history.push('/about/' + data);\n }\nreturn (\n  <div>\n    <button onClick={() => handleClick('DemoButton')}>To About</button>\n  </div>\n)\n} Also, the functional component AboutPage will obtain the data passed by props.match.params.aboutId. props.match.params.aboutId export default function AboutPage(props) {\nif(!props.match.params.aboutId) {\n    return <div>No Data Yet</div>\n}\nreturn (\n  <div>\n    {`Data obtained from HomePage is ${props.match.params.aboutId}`}\n  </div>\n)\n} export default function AboutPage(props) {\nif(!props.match.params.aboutId) {\n    return <div>No Data Yet</div>\n}\nreturn (\n  <div>\n    {`Data obtained from HomePage is ${props.match.params.aboutId}`}\n  </div>\n)\n} After button click in the HomePage the page will look like below:  ",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "3. How to re-render the view when the browser is resized?",
        "answer": "It is possible to listen to the resize event in componentDidMount() and then update the width and height dimensions. It requires the removal of the event listener in the componentWillUnmount() method. componentDidMount() componentWillUnmount() Using the below-given code, we can render the view when the browser is resized. class WindowSizeDimensions extends React.Component {\n constructor(props){\n   super(props);\n   this.updateDimension = this.updateDimension.bind(this);\n }\n  \n componentWillMount() {\n   this.updateDimension()\n }\n componentDidMount() {\n   window.addEventListener('resize', this.updateDimension)\n }\n componentWillUnmount() {\n   window.removeEventListener('resize', this.updateDimension)\n }\n updateDimension() {\n   this.setState({width: window.innerWidth, height: window.innerHeight})\n }\n render() {\n   return <span>{this.state.width} x {this.state.height}</span>\n }\n} class WindowSizeDimensions extends React.Component {\n constructor(props){\n   super(props);\n   this.updateDimension = this.updateDimension.bind(this);\n }\n  \n componentWillMount() {\n   this.updateDimension()\n }\n componentDidMount() {\n   window.addEventListener('resize', this.updateDimension)\n }\n componentWillUnmount() {\n   window.removeEventListener('resize', this.updateDimension)\n }\n updateDimension() {\n   this.setState({width: window.innerWidth, height: window.innerHeight})\n }\n render() {\n   return <span>{this.state.width} x {this.state.height}</span>\n }\n}",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "4. How to create a switching component for displaying different pages?",
        "answer": "A switching component refers to a component that will render one of the multiple components. We should use an object for mapping prop values to components. A below-given example will show you how to display different pages based on page prop using switching component: import HomePage from './HomePage'\nimport AboutPage from './AboutPage'\nimport FacilitiesPage from './FacilitiesPage'\nimport ContactPage from './ContactPage'\nimport HelpPage from './HelpPage'\nconst PAGES = {\n home: HomePage,\n about: AboutPage,\n facilitiess: FacilitiesPage,\n contact: ContactPage\n help: HelpPage\n}\nconst Page = (props) => {\n const Handler = PAGES[props.page] || HelpPage\n return <Handler {...props} />\n}\n// The PAGES object keys can be used in the prop types for catching errors during dev-time.\nPage.propTypes = {\n page: PropTypes.oneOf(Object.keys(PAGES)).isRequired\n} import HomePage from './HomePage'\nimport AboutPage from './AboutPage'\nimport FacilitiesPage from './FacilitiesPage'\nimport ContactPage from './ContactPage'\nimport HelpPage from './HelpPage'\nconst PAGES = {\n home: HomePage,\n about: AboutPage,\n facilitiess: FacilitiesPage,\n contact: ContactPage\n help: HelpPage\n}\nconst Page = (props) => {\n const Handler = PAGES[props.page] || HelpPage\n return <Handler {...props} />\n}\n// The PAGES object keys can be used in the prop types for catching errors during dev-time.\nPage.propTypes = {\n page: PropTypes.oneOf(Object.keys(PAGES)).isRequired\n}",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "5. Explain how to create a simple React Hooks example program.",
        "answer": "I will assume that you are having some coding knowledge about JavaScript and have installed Node on your system for creating a below given React Hook program. An installation of Node comes along with the command-line tools: npm and npx, where npm is useful to install the packages into a project and npx is useful in running commands of Node from the command line. The npx looks in the current project folder for checking whether a command has been installed there. When the command is not available on your computer, the npx will look in the npmjs.com repository, then the latest version of the command script will be loaded and will run without locally installing it. This feature is useful in creating a skeleton React application within a few key presses. Open the Terminal inside the folder of your choice, and run the following command: npx create-react-app react-items-with-hooks npx create-react-app react-items-with-hooks Here, the create-react-app is an app initializer created by Facebook, to help with the easy and quick creation of React application, providing options to customize it while creating the application? The above command will create a new folder named react-items-with-hooks and it will be initialized with a basic React application. Now, you will be able to open the project in your favourite IDE. You can see an src folder inside the project along with the main application component App.js. This file is having a single function App() which will return an element and it will make use of an extended JavaScript syntax(JSX) for defining the component. create-react-app App.js App() JSX will permit you for writing HTML-style template syntax directly into the JavaScript file. This mixture of JavaScript and HTML will be converted by React toolchain into pure JavaScript that will render the HTML element. It is possible to define your own React components by writing a function that will return a JSX element. You can try this by creating a new file src/SearchItem.jsand put the following code into it. src/SearchItem.js import React from 'react';\nexport function SearchItem() {\n return (\n   <div>\n     <div className=\"search-input\">\n       <input type=\"text\" placeholder=\"SearchItem\"/>\n     </div>\n     <h1 className=\"h1\">Search Results</h1>\n     <div className=\"items\">\n       <table>\n         <thead>\n           <tr>\n             <th className=\"itemname-col\">Item Name</th>\n             <th className=\"price-col\">Price</th>\n             <th className=\"quantity-col\">Quantity</th>\n           </tr>\n         </thead>\n         <tbody></tbody>\n       </table>\n     </div>\n   </div>\n );\n} import React from 'react';\nexport function SearchItem() {\n return (\n   <div>\n     <div className=\"search-input\">\n       <input type=\"text\" placeholder=\"SearchItem\"/>\n     </div>\n     <h1 className=\"h1\">Search Results</h1>\n     <div className=\"items\">\n       <table>\n         <thead>\n           <tr>\n             <th className=\"itemname-col\">Item Name</th>\n             <th className=\"price-col\">Price</th>\n             <th className=\"quantity-col\">Quantity</th>\n           </tr>\n         </thead>\n         <tbody></tbody>\n       </table>\n     </div>\n   </div>\n );\n} This is all about how you can create a component. It will only display the empty table and doesn’t do anything. But you will be able to use the Search component in the application. Open the file src/App.js and add the import statement given below to the top of the file. src/App.js import { SearchItem } from './SearchItem'; import { SearchItem } from './SearchItem'; Now, from the logo.svg, import will be removed and then contents of returned value in the function App() will be replaced with the following code: App() <div className=\"App\">\n <header>\n   Items with Hooks\n </header>\n <SearchItem/>\n</div> <div className=\"App\">\n <header>\n   Items with Hooks\n </header>\n <SearchItem/>\n</div> You can notice that the element <SearchItem/> has been used just similar to an HTML element. The JSX syntax will enable for including the components in this approach directly within the JavaScript code. Your application can be tested by running the below-given command in your terminal. npm start npm start This command will compile your application and open your default browser into http://localhost:4000. This command can be kept on running when code development is in progress to make sure that the application is up-to-date, and also this browser page will be reloaded each time you modify and save the code. http://localhost:4000 This application will work finely, but it doesn’t look nice as it doesn’t react to any input from the user. You can make it more interactive by adding a state with React Hooks, adding authentication, etc.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "6. Explain conditional rendering in React.",
        "answer": "Conditional rendering refers to the dynamic output of user interface markups based on a condition state. It works in the same way as JavaScript conditions. Using conditional rendering, it is possible to toggle specific application functions, API data rendering, hide or show elements, decide permission levels, authentication handling, and so on. There are different approaches for implementing conditional rendering in React. Some of them are: Using if-else conditional logic which is suitable for smaller as well as for medium-sized applications\nUsing ternary operators, which takes away some amount of complication from if-else statements\nUsing element variables, which will enable us to write cleaner code. Using if-else conditional logic which is suitable for smaller as well as for medium-sized applications Using ternary operators, which takes away some amount of complication from if-else statements Using element variables, which will enable us to write cleaner code.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "7. Can React Hook replaces Redux?",
        "answer": "The React Hook cannot be considered as a replacement for Redux (It is an open-source, JavaScript library useful in managing the application state) when it comes to the management of the global application state tree in large complex applications, even though the React will provide a useReducer hook that manages state transitions similar to Redux. Redux is very useful at a lower level of component hierarchy to handle the pieces of a state which are dependent on each other, instead of a declaration of multiple useState hooks. In commercial web applications which is larger, the complexity will be high, so using only React Hook may not be sufficient. Few developers will try to tackle the challenge with the help of React Hooks and others will combine React Hooks with the Redux.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "8. What is React Router?",
        "answer": "React Router refers to the standard library used for routing in React. It permits us for building a single-page web application in React with navigation without even refreshing the page when the user navigates. It also allows to change the browser URL and will keep the user interface in sync with the URL. React Router will make use of the component structure for calling the components, using which appropriate information can be shown. Since React is a component-based framework, it’s not necessary to include and use this package. Any other compatible routing library would also work with React. The major components of React Router are given below: BrowserRouter: It is a router implementation that will make use of the HTML5 history API (pushState, popstate, and event replaceState) for keeping your UI to be in sync with the URL. It is the parent component useful in storing all other components.\nRoutes: It is a newer component that has been introduced in the React v6 and an upgrade of the component.\nRoute: It is considered to be a conditionally shown component and some UI will be rendered by this whenever there is a match between its path and the current URL.\nLink: It is useful in creating links to various routes and implementing navigation all over the application. It works similarly to the anchor tag in HTML. BrowserRouter: It is a router implementation that will make use of the HTML5 history API (pushState, popstate, and event replaceState) for keeping your UI to be in sync with the URL. It is the parent component useful in storing all other components. BrowserRouter: Routes: It is a newer component that has been introduced in the React v6 and an upgrade of the component. Routes: Route: It is considered to be a conditionally shown component and some UI will be rendered by this whenever there is a match between its path and the current URL. Route: Link: It is useful in creating links to various routes and implementing navigation all over the application. It works similarly to the anchor tag in HTML. Link:",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "9. Do Hooks cover all the functionalities provided by the classes?",
        "answer": "Our goal is for Hooks to cover all the functionalities for classes at its earliest. There are no Hook equivalents for the following methods that are not introduced in Hooks yet: getSnapshotBeforeUpdate()\ngetDerivedStateFromError()\ncomponentDidCatch() getSnapshotBeforeUpdate() getSnapshotBeforeUpdate() getDerivedStateFromError() getDerivedStateFromError() componentDidCatch() componentDidCatch() Since it is an early time for Hooks, few third-party libraries may not be compatible with Hooks at present, but they will be added soon.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "10. How does the performance of using Hooks will differ in comparison with the classes?",
        "answer": "React Hooks will avoid a lot of overheads such as the instance creation, binding of events, etc., that are present with classes.\nHooks in React will result in smaller component trees since they will be avoiding the nesting that exists in HOCs (Higher Order Components) and will render props which result in less amount of work to be done by React. React Hooks will avoid a lot of overheads such as the instance creation, binding of events, etc., that are present with classes. Hooks in React will result in smaller component trees since they will be avoiding the nesting that exists in HOCs (Higher Order Components) and will render props which result in less amount of work to be done by React.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "11. Differentiate React Hooks vs Classes.",
        "answer": "React Hooks Classes\nIt is used in functional components of React. It is used in class-based components of React.\nIt will not require a declaration of any kind of constructor. It is necessary to declare the constructor inside the class component.\nIt does not require the use of this keyword in state declaration or modification. Keyword this will be used in state declaration (this.state) and in modification (this.setState()).\nIt is easier to use because of the useState functionality. No specific function is available for helping us to access the state and its corresponding setState variable.\nReact Hooks can be helpful in implementing Redux and context API. Because of the long setup of state declarations, class states are generally not preferred. React Hooks Classes\nIt is used in functional components of React. It is used in class-based components of React.\nIt will not require a declaration of any kind of constructor. It is necessary to declare the constructor inside the class component.\nIt does not require the use of this keyword in state declaration or modification. Keyword this will be used in state declaration (this.state) and in modification (this.setState()).\nIt is easier to use because of the useState functionality. No specific function is available for helping us to access the state and its corresponding setState variable.\nReact Hooks can be helpful in implementing Redux and context API. Because of the long setup of state declarations, class states are generally not preferred. React Hooks Classes React Hooks Classes React Hooks Classes It is used in functional components of React. It is used in class-based components of React.\nIt will not require a declaration of any kind of constructor. It is necessary to declare the constructor inside the class component.\nIt does not require the use of this keyword in state declaration or modification. Keyword this will be used in state declaration (this.state) and in modification (this.setState()).\nIt is easier to use because of the useState functionality. No specific function is available for helping us to access the state and its corresponding setState variable.\nReact Hooks can be helpful in implementing Redux and context API. Because of the long setup of state declarations, class states are generally not preferred. It is used in functional components of React. It is used in class-based components of React. It is used in functional components of React. It is used in class-based components of React. It will not require a declaration of any kind of constructor. It is necessary to declare the constructor inside the class component. It will not require a declaration of any kind of constructor. It is necessary to declare the constructor inside the class component. It does not require the use of this keyword in state declaration or modification. Keyword this will be used in state declaration (this.state) and in modification (this.setState()). It does not require the use of this keyword in state declaration or modification. this Keyword this will be used in state declaration (this.state) and in modification (this.setState()). this this.state this.setState() It is easier to use because of the useState functionality. No specific function is available for helping us to access the state and its corresponding setState variable. It is easier to use because of the useState functionality. useState No specific function is available for helping us to access the state and its corresponding setState variable. React Hooks can be helpful in implementing Redux and context API. Because of the long setup of state declarations, class states are generally not preferred. React Hooks can be helpful in implementing Redux and context API. Because of the long setup of state declarations, class states are generally not preferred.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "12. Explain about types of Hooks in React.",
        "answer": "There are two types of Hooks in React. They are: 1. Built-in Hooks: The built-in Hooks are divided into 2 parts as given below: 1. Built-in Hooks: Basic Hooks:\nuseState(): This functional component is used to set and retrieve the state.\nuseEffect(): It enables for performing the side effects in the functional components.\nuseContext(): It is used for creating common data that is to be accessed by the components hierarchy without having to pass the props down to each level.\nAdditional Hooks:\nuseReducer() : It is used when there is a complex state logic that is having several sub-values or when the upcoming state is dependent on the previous state. It will also enable you to optimization of component performance that will trigger deeper updates as it is permitted to pass the dispatch down instead of callbacks.\nuseMemo() : This will be used for recomputing the memoized value when there is a change in one of the dependencies. This optimization will help for avoiding expensive calculations on each render.\nuseCallback() : This is useful while passing callbacks into the optimized child components and depends on the equality of reference for the prevention of unneeded renders.\nuseImperativeHandle():  It will enable modifying the instance that will be passed with the ref object.\nuseDebugValue(): It is used for displaying a label for custom hooks in React DevTools.\nuseRef() : It will permit creating a reference to the DOM element directly within the functional component.\nuseLayoutEffect(): It is used for the reading layout from the DOM and re-rendering synchronously. Basic Hooks:\nuseState(): This functional component is used to set and retrieve the state.\nuseEffect(): It enables for performing the side effects in the functional components.\nuseContext(): It is used for creating common data that is to be accessed by the components hierarchy without having to pass the props down to each level. Basic Hooks: useState(): This functional component is used to set and retrieve the state.\nuseEffect(): It enables for performing the side effects in the functional components.\nuseContext(): It is used for creating common data that is to be accessed by the components hierarchy without having to pass the props down to each level. useState(): This functional component is used to set and retrieve the state. useState() useEffect(): It enables for performing the side effects in the functional components. useEffect() useContext(): It is used for creating common data that is to be accessed by the components hierarchy without having to pass the props down to each level. useContext() Additional Hooks:\nuseReducer() : It is used when there is a complex state logic that is having several sub-values or when the upcoming state is dependent on the previous state. It will also enable you to optimization of component performance that will trigger deeper updates as it is permitted to pass the dispatch down instead of callbacks.\nuseMemo() : This will be used for recomputing the memoized value when there is a change in one of the dependencies. This optimization will help for avoiding expensive calculations on each render.\nuseCallback() : This is useful while passing callbacks into the optimized child components and depends on the equality of reference for the prevention of unneeded renders.\nuseImperativeHandle():  It will enable modifying the instance that will be passed with the ref object.\nuseDebugValue(): It is used for displaying a label for custom hooks in React DevTools.\nuseRef() : It will permit creating a reference to the DOM element directly within the functional component.\nuseLayoutEffect(): It is used for the reading layout from the DOM and re-rendering synchronously. Additional Hooks: useReducer() : It is used when there is a complex state logic that is having several sub-values or when the upcoming state is dependent on the previous state. It will also enable you to optimization of component performance that will trigger deeper updates as it is permitted to pass the dispatch down instead of callbacks.\nuseMemo() : This will be used for recomputing the memoized value when there is a change in one of the dependencies. This optimization will help for avoiding expensive calculations on each render.\nuseCallback() : This is useful while passing callbacks into the optimized child components and depends on the equality of reference for the prevention of unneeded renders.\nuseImperativeHandle():  It will enable modifying the instance that will be passed with the ref object.\nuseDebugValue(): It is used for displaying a label for custom hooks in React DevTools.\nuseRef() : It will permit creating a reference to the DOM element directly within the functional component.\nuseLayoutEffect(): It is used for the reading layout from the DOM and re-rendering synchronously. useReducer() : It is used when there is a complex state logic that is having several sub-values or when the upcoming state is dependent on the previous state. It will also enable you to optimization of component performance that will trigger deeper updates as it is permitted to pass the dispatch down instead of callbacks. useReducer() useMemo() : This will be used for recomputing the memoized value when there is a change in one of the dependencies. This optimization will help for avoiding expensive calculations on each render. useMemo() useCallback() : This is useful while passing callbacks into the optimized child components and depends on the equality of reference for the prevention of unneeded renders. useCallback() useImperativeHandle():  It will enable modifying the instance that will be passed with the ref object. useImperativeHandle() useDebugValue(): It is used for displaying a label for custom hooks in React DevTools. useDebugValue() useRef() : It will permit creating a reference to the DOM element directly within the functional component. useRef() useLayoutEffect(): It is used for the reading layout from the DOM and re-rendering synchronously. useLayoutEffect() 2. Custom Hooks: A custom Hook is basically a function of JavaScript. The Custom Hook working is similar to a regular function. The “use” at the beginning of the Custom Hook Name is required for React to understand that this is a custom Hook and also it will describe that this specific function follows the rules of Hooks. Moreover, developing custom Hooks will enable you for extracting component logic from within reusable functions. 2. Custom Hooks:  ",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "13. Does React Hook work with static typing?",
        "answer": "Static typing refers to the process of code check during the time of compilation for ensuring all variables will be statically typed. React Hooks are functions that are designed to make sure about all attributes must be statically typed. For enforcing stricter static typing within our code, we can make use of the React API with custom Hooks.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "14. What are the lifecycle methods of React?",
        "answer": "React lifecycle hooks will have the methods that will be automatically called at different phases in the component lifecycle and thus it provides good control over what happens at the invoked point. It provides the power to effectively control and manipulate what goes on throughout the component lifecycle. For example, if you are developing the YouTube application, then the application will make use of a network for buffering the videos and it consumes the power of the battery (assume only these two). After playing the video if the user switches to any other application, then you should make sure that the resources like network and battery are being used most efficiently. You can stop or pause the video buffering which in turn stops the battery and network usage when the user switches to another application after video play. So we can say that the developer will be able to produce a quality application with the help of lifecycle methods and it also helps developers to make sure to plan what and how to do it at different points of birth, growth, or death of user interfaces. The various lifecycle methods are: constructor(): This method will be called when the component is initiated before anything has been done. It helps to set up the initial state and initial values.\ngetDerivedStateFromProps(): This method will be called just before element(s) rendering in the DOM. It helps to set up the state object depending on the initial props. The getDerivedStateFromProps() method will have a state as an argument and it returns an object that made changes to the state. This will be the first method to be called on an updating of a component.\nrender(): This method will output or re-render the HTML to the DOM with new changes. The render() method is an essential method and will be called always while the remaining methods are optional and will be called only if they are defined.\ncomponentDidMount(): This method will be called after the rendering of the component. Using this method, you can run statements that need the component to be already kept in the DOM.\nshouldComponentUpdate(): The Boolean value will be returned by this method which will specify whether React should proceed further with the rendering or not. The default value for this method will be True.\ngetSnapshotBeforeUpdate(): This method will provide access for the props as well as for the state before the update. It is possible to check the previously present value before the update, even after the update.\ncomponentDidUpdate(): This method will be called after the component has been updated in the DOM.\ncomponentWillUnmount(): This method will be called when the component removal from the DOM is about to happen. constructor(): This method will be called when the component is initiated before anything has been done. It helps to set up the initial state and initial values. constructor() getDerivedStateFromProps(): This method will be called just before element(s) rendering in the DOM. It helps to set up the state object depending on the initial props. The getDerivedStateFromProps() method will have a state as an argument and it returns an object that made changes to the state. This will be the first method to be called on an updating of a component. getDerivedStateFromProps() render(): This method will output or re-render the HTML to the DOM with new changes. The render() method is an essential method and will be called always while the remaining methods are optional and will be called only if they are defined. render() componentDidMount(): This method will be called after the rendering of the component. Using this method, you can run statements that need the component to be already kept in the DOM. componentDidMount() shouldComponentUpdate(): The Boolean value will be returned by this method which will specify whether React should proceed further with the rendering or not. The default value for this method will be True. shouldComponentUpdate() getSnapshotBeforeUpdate(): This method will provide access for the props as well as for the state before the update. It is possible to check the previously present value before the update, even after the update. getSnapshotBeforeUpdate() componentDidUpdate(): This method will be called after the component has been updated in the DOM. componentDidUpdate() componentWillUnmount(): This method will be called when the component removal from the DOM is about to happen. componentWillUnmount()",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "15. What are the different phases of the component lifecycle?",
        "answer": "There are four different phases in the lifecycle of React component. They are: Initialization: During this phase, React component will prepare by setting up the default props and initial state for the upcoming tough journey.\nMounting: Mounting refers to putting the elements into the browser DOM. Since React uses VirtualDOM, the entire browser DOM which has been currently rendered would not be refreshed. This phase includes the lifecycle methods componentWillMount and componentDidMount.\nUpdating: In this phase, a component will be updated when there is a change in the state or props of a component. This phase will have lifecycle methods like componentWillUpdate, shouldComponentUpdate, render, and componentDidUpdate.\nUnmounting: In this last phase of the component lifecycle, the component will be removed from the DOM or will be unmounted from the browser DOM. This phase will have the lifecycle method named componentWillUnmount. Initialization: During this phase, React component will prepare by setting up the default props and initial state for the upcoming tough journey. Initialization: Mounting: Mounting refers to putting the elements into the browser DOM. Since React uses VirtualDOM, the entire browser DOM which has been currently rendered would not be refreshed. This phase includes the lifecycle methods componentWillMount and componentDidMount. Mounting: componentWillMount componentDidMount Updating: In this phase, a component will be updated when there is a change in the state or props of a component. This phase will have lifecycle methods like componentWillUpdate, shouldComponentUpdate, render, and componentDidUpdate. Updating: componentWillUpdate shouldComponentUpdate render componentDidUpdate Unmounting: In this last phase of the component lifecycle, the component will be removed from the DOM or will be unmounted from the browser DOM. This phase will have the lifecycle method named componentWillUnmount. Unmounting: componentWillUnmount  ",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "16. What are Higher Order Components?",
        "answer": "Simply put, Higher-Order Component(HOC) is a function that takes in a component and returns a new component.   When do we need a Higher Order Component? When do we need a Higher Order Component? While developing React applications, we might develop components that are quite similar to each other with minute differences. In most cases, developing similar components might not be an issue but, while developing larger applications we need to keep our code DRY, therefore, we want an abstraction that allows us to define this logic in a single place and share it across components. HOC allows us to create that abstraction. DRY abstraction Example of a HOC: Example of a HOC: Consider the following components having similar functionality. The following component displays the list of articles: // \"GlobalDataSource\" is some global data source\nclass ArticlesList extends React.Component {\n constructor(props) {\n   super(props);\n   this.handleChange = this.handleChange.bind(this);\n   this.state = {\n     articles: GlobalDataSource.getArticles(),\n   };\n }\n componentDidMount() {\n   // Listens to the changes added\n   GlobalDataSource.addChangeListener(this.handleChange);\n }\n componentWillUnmount() {\n   // Listens to the changes removed\n   GlobalDataSource.removeChangeListener(this.handleChange);\n }\n handleChange() {\n   // States gets Update whenver data source changes\n   this.setState({\n     articles: GlobalDataSource.getArticles(),\n   });\n }\n render() {\n   return (\n     <div>\n       {this.state.articles.map((article) => (\n         <ArticleData article={article} key={article.id} />\n       ))}\n     </div>\n   );\n }\n} // \"GlobalDataSource\" is some global data source\nclass ArticlesList extends React.Component {\n constructor(props) {\n   super(props);\n   this.handleChange = this.handleChange.bind(this);\n   this.state = {\n     articles: GlobalDataSource.getArticles(),\n   };\n }\n componentDidMount() {\n   // Listens to the changes added\n   GlobalDataSource.addChangeListener(this.handleChange);\n }\n componentWillUnmount() {\n   // Listens to the changes removed\n   GlobalDataSource.removeChangeListener(this.handleChange);\n }\n handleChange() {\n   // States gets Update whenver data source changes\n   this.setState({\n     articles: GlobalDataSource.getArticles(),\n   });\n }\n render() {\n   return (\n     <div>\n       {this.state.articles.map((article) => (\n         <ArticleData article={article} key={article.id} />\n       ))}\n     </div>\n   );\n }\n} The following component displays the list of users: // \"GlobalDataSource\" is some global data source\nclass UsersList extends React.Component {\n constructor(props) {\n   super(props);\n   this.handleChange = this.handleChange.bind(this);\n   this.state = {\n     users: GlobalDataSource.getUsers(),\n   };\n }\n componentDidMount() {\n   // Listens to the changes added\n   GlobalDataSource.addChangeListener(this.handleChange);\n }\n componentWillUnmount() {\n   // Listens to the changes removed\n   GlobalDataSource.removeChangeListener(this.handleChange);\n }\n handleChange() {\n   // States gets Update whenver data source changes\n   this.setState({\n     users: GlobalDataSource.getUsers(),\n   });\n }\n render() {\n   return (\n     <div>\n       {this.state.users.map((user) => (\n         <UserData user={user} key={user.id} />\n       ))}\n     </div>\n   );\n }\n} // \"GlobalDataSource\" is some global data source\nclass UsersList extends React.Component {\n constructor(props) {\n   super(props);\n   this.handleChange = this.handleChange.bind(this);\n   this.state = {\n     users: GlobalDataSource.getUsers(),\n   };\n }\n componentDidMount() {\n   // Listens to the changes added\n   GlobalDataSource.addChangeListener(this.handleChange);\n }\n componentWillUnmount() {\n   // Listens to the changes removed\n   GlobalDataSource.removeChangeListener(this.handleChange);\n }\n handleChange() {\n   // States gets Update whenver data source changes\n   this.setState({\n     users: GlobalDataSource.getUsers(),\n   });\n }\n render() {\n   return (\n     <div>\n       {this.state.users.map((user) => (\n         <UserData user={user} key={user.id} />\n       ))}\n     </div>\n   );\n }\n} Notice the above components, both have similar functionality but, they are calling different methods to an API endpoint. Let’s create a Higher Order Component to create an abstraction: // Higher Order Component which takes a component\n// as input and returns another component\n// \"GlobalDataSource\" is some global data source\nfunction HOC(WrappedComponent, selectData) {\n return class extends React.Component {\n   constructor(props) {\n     super(props);\n     this.handleChange = this.handleChange.bind(this);\n     this.state = {\n       data: selectData(GlobalDataSource, props),\n     };\n   }\n   componentDidMount() {\n     // Listens to the changes added\n     GlobalDataSource.addChangeListener(this.handleChange);\n   }\n   componentWillUnmount() {\n     // Listens to the changes removed\n     GlobalDataSource.removeChangeListener(this.handleChange);\n   }\n   handleChange() {\n     this.setState({\n       data: selectData(GlobalDataSource, this.props),\n     });\n   }\n   render() {\n     // Rendering the wrapped component with the latest data data\n     return <WrappedComponent data={this.state.data} {...this.props} />;\n   }\n };\n} // Higher Order Component which takes a component\n// as input and returns another component\n// \"GlobalDataSource\" is some global data source\nfunction HOC(WrappedComponent, selectData) {\n return class extends React.Component {\n   constructor(props) {\n     super(props);\n     this.handleChange = this.handleChange.bind(this);\n     this.state = {\n       data: selectData(GlobalDataSource, props),\n     };\n   }\n   componentDidMount() {\n     // Listens to the changes added\n     GlobalDataSource.addChangeListener(this.handleChange);\n   }\n   componentWillUnmount() {\n     // Listens to the changes removed\n     GlobalDataSource.removeChangeListener(this.handleChange);\n   }\n   handleChange() {\n     this.setState({\n       data: selectData(GlobalDataSource, this.props),\n     });\n   }\n   render() {\n     // Rendering the wrapped component with the latest data data\n     return <WrappedComponent data={this.state.data} {...this.props} />;\n   }\n };\n} We know HOC is a function that takes in a component and returns a component. In the code above, we have created a function called HOC which returns a component and performs functionality that can be shared across both the ArticlesList component and UsersList Component. ArticlesList UsersList The second parameter in the HOC function is the function that calls the method on the API endpoint. We have reduced the duplicated code of the componentDidUpdate and componentDidMount functions. componentDidUpdate componentDidMount Using the concept of Higher-Order Components, we can now render the ArticlesList and UsersList components in the following way: ArticlesList UsersList const ArticlesListWithHOC = HOC(ArticlesList, (GlobalDataSource) => GlobalDataSource.getArticles());\nconst UsersListWithHOC = HOC(UsersList, (GlobalDataSource) => GlobalDataSource.getUsers()); const ArticlesListWithHOC = HOC(ArticlesList, (GlobalDataSource) => GlobalDataSource.getArticles());\nconst UsersListWithHOC = HOC(UsersList, (GlobalDataSource) => GlobalDataSource.getUsers()); Remember, we are not trying to change the functionality of each component, we are trying to share a single functionality across multiple components using HOC.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "17. How to pass data between react components?",
        "answer": "  Parent Component to Child Component (using props) Parent Component to Child Component (using props) With the help of props, we can send data from a parent to a child component. How do we do this? How do we do this? Consider the following Parent Component: import ChildComponent from \"./Child\";\n   function ParentComponent(props) {\n    let [counter, setCounter] = useState(0);\n   \n    let increment = () => setCounter(++counter);\n   \n    return (\n      <div>\n        <button onClick={increment}>Increment Counter</button>\n        <ChildComponent counterValue={counter} />\n      </div>\n    );\n   } import ChildComponent from \"./Child\";\n   function ParentComponent(props) {\n    let [counter, setCounter] = useState(0);\n   \n    let increment = () => setCounter(++counter);\n   \n    return (\n      <div>\n        <button onClick={increment}>Increment Counter</button>\n        <ChildComponent counterValue={counter} />\n      </div>\n    );\n   } As one can see in the code above, we are rendering the child component inside the parent component, by providing a prop called counterValue. The value of the counter is being passed from the parent to the child component. We can use the data passed by the parent component in the following way: function ChildComponent(props) {\nreturn (\n  <div>\n    <p>Value of counter: {props.counterValue}</p>\n  </div>\n);\n} function ChildComponent(props) {\nreturn (\n  <div>\n    <p>Value of counter: {props.counterValue}</p>\n  </div>\n);\n} We use the props.counterValue to display the data passed on by the parent component. props.counterValue Child Component to Parent Component (using callbacks) Child Component to Parent Component (using callbacks) This one is a bit tricky. We follow the steps below: Create a callback in the parent component which takes in the data needed as a parameter.\nPass this callback as a prop to the child component.\nSend data from the child component using the callback. Create a callback in the parent component which takes in the data needed as a parameter. Pass this callback as a prop to the child component. Send data from the child component using the callback. We are considering the same example above but in this case, we are going to pass the updated counterValue from child to parent. Step1 and Step2: Create a callback in the parent component, pass this callback as a prop. Step1 and Step2: function ParentComponent(props) {\nlet [counter, setCounter] = useState(0);\nlet callback = valueFromChild => setCounter(valueFromChild);\nreturn (\n  <div>\n    <p>Value of counter: {counter}</p>\n    <ChildComponent callbackFunc={callback} counterValue={counter} />\n  </div>\n);\n} function ParentComponent(props) {\nlet [counter, setCounter] = useState(0);\nlet callback = valueFromChild => setCounter(valueFromChild);\nreturn (\n  <div>\n    <p>Value of counter: {counter}</p>\n    <ChildComponent callbackFunc={callback} counterValue={counter} />\n  </div>\n);\n} As one can see in the code above, we created a function called callback which takes in the data received from the child component as a parameter. Next, we passed the function callback as a prop to the child component. Step3: Pass data from the child to the parent component. Step3: function ChildComponent(props) {\nlet childCounterValue = props.counterValue;\nreturn (\n  <div>\n    <button onClick={() => props.callbackFunc(++childCounterValue)}>\n      Increment Counter\n    </button>\n  </div>\n);\n} function ChildComponent(props) {\nlet childCounterValue = props.counterValue;\nreturn (\n  <div>\n    <button onClick={() => props.callbackFunc(++childCounterValue)}>\n      Increment Counter\n    </button>\n  </div>\n);\n} In the code above, we have used the props.counterValue and set it to a variable called childCounterValue. Next, on button click, we pass the incremented childCounterValue to the props.callbackFunc. props.callbackFunc This way, we can pass data from the child to the parent component.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "18. Name a few techniques to optimize React app performance.",
        "answer": "There are many ways through which one can optimize the performance of a React app, let’s have a look at some of them: Using useMemo( ) -\nIt is a React hook that is used for caching CPU-Expensive functions.\nSometimes in a React app, a CPU-Expensive function gets called repeatedly due to re-renders of a component, which can lead to slow rendering.\nuseMemo( ) hook can be used to cache such functions. By using useMemo( ), the CPU-Expensive function gets called only when it is needed.\nUsing React.PureComponent -\nIt is a base component class that checks the state and props of a component to know whether the component should be updated.\nInstead of using the simple React.Component, we can use React.PureComponent to reduce the re-renders of a component unnecessarily.\nMaintaining State Colocation -\nThis is a process of moving the state as close to where you need it as possible.\nSometimes in React app, we have a lot of unnecessary states inside the parent component which makes the code less readable and harder to maintain. Not to forget, having many states inside a single component leads to unnecessary re-renders for the component.\nIt is better to shift states which are less valuable to the parent component, to a separate component.\nLazy Loading -\n It is a technique used to reduce the load time of a React app. Lazy loading helps reduce the risk of web app performances to a minimum. Using useMemo( ) -\nIt is a React hook that is used for caching CPU-Expensive functions.\nSometimes in a React app, a CPU-Expensive function gets called repeatedly due to re-renders of a component, which can lead to slow rendering.\nuseMemo( ) hook can be used to cache such functions. By using useMemo( ), the CPU-Expensive function gets called only when it is needed. Using useMemo( ) It is a React hook that is used for caching CPU-Expensive functions.\nSometimes in a React app, a CPU-Expensive function gets called repeatedly due to re-renders of a component, which can lead to slow rendering.\nuseMemo( ) hook can be used to cache such functions. By using useMemo( ), the CPU-Expensive function gets called only when it is needed. It is a React hook that is used for caching CPU-Expensive functions. Sometimes in a React app, a CPU-Expensive function gets called repeatedly due to re-renders of a component, which can lead to slow rendering.\nuseMemo( ) hook can be used to cache such functions. By using useMemo( ), the CPU-Expensive function gets called only when it is needed.  Using React.PureComponent -\nIt is a base component class that checks the state and props of a component to know whether the component should be updated.\nInstead of using the simple React.Component, we can use React.PureComponent to reduce the re-renders of a component unnecessarily. Using React.PureComponent - It is a base component class that checks the state and props of a component to know whether the component should be updated.\nInstead of using the simple React.Component, we can use React.PureComponent to reduce the re-renders of a component unnecessarily. It is a base component class that checks the state and props of a component to know whether the component should be updated. Instead of using the simple React.Component, we can use React.PureComponent to reduce the re-renders of a component unnecessarily. Maintaining State Colocation -\nThis is a process of moving the state as close to where you need it as possible.\nSometimes in React app, we have a lot of unnecessary states inside the parent component which makes the code less readable and harder to maintain. Not to forget, having many states inside a single component leads to unnecessary re-renders for the component.\nIt is better to shift states which are less valuable to the parent component, to a separate component. Maintaining State Colocation - This is a process of moving the state as close to where you need it as possible.\nSometimes in React app, we have a lot of unnecessary states inside the parent component which makes the code less readable and harder to maintain. Not to forget, having many states inside a single component leads to unnecessary re-renders for the component.\nIt is better to shift states which are less valuable to the parent component, to a separate component. This is a process of moving the state as close to where you need it as possible. Sometimes in React app, we have a lot of unnecessary states inside the parent component which makes the code less readable and harder to maintain. Not to forget, having many states inside a single component leads to unnecessary re-renders for the component. It is better to shift states which are less valuable to the parent component, to a separate component. Lazy Loading -\n It is a technique used to reduce the load time of a React app. Lazy loading helps reduce the risk of web app performances to a minimum. Lazy Loading - It is a technique used to reduce the load time of a React app. Lazy loading helps reduce the risk of web app performances to a minimum. It is a technique used to reduce the load time of a React app. Lazy loading helps reduce the risk of web app performances to a minimum.",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "19. What are the different ways to style a React component?",
        "answer": "There are many different ways through which one can style a React component. Some of the ways are : Inline Styling: We can directly style an element using inline style attributes. Make sure the value of style is a JavaScript object: Inline Styling: We can directly style an element using inline style attributes. Make sure the value of style is a JavaScript object: Inline Styling: class RandomComponent extends React.Component {\n render() {\n   return (\n     <div>\n       <h3 style={{ color: \"Yellow\" }}>This is a heading</h3>\n       <p style={{ fontSize: \"32px\" }}>This is a paragraph</p>\n     </div>\n   );\n }\n} class RandomComponent extends React.Component {\n render() {\n   return (\n     <div>\n       <h3 style={{ color: \"Yellow\" }}>This is a heading</h3>\n       <p style={{ fontSize: \"32px\" }}>This is a paragraph</p>\n     </div>\n   );\n }\n} Using JavaScript object: We can create a separate JavaScript object and set the desired style properties. This object can be used as the value of the inline style attribute. Using JavaScript object: We can create a separate JavaScript object and set the desired style properties. This object can be used as the value of the inline style attribute. Using JavaScript object: class RandomComponent extends React.Component {\n paragraphStyles = {\n   color: \"Red\",\n   fontSize: \"32px\"\n };\n\n headingStyles = {\n   color: \"blue\",\n   fontSize: \"48px\"\n };\n\n render() {\n   return (\n     <div>\n       <h3 style={this.headingStyles}>This is a heading</h3>\n       <p style={this.paragraphStyles}>This is a paragraph</p>\n     </div>\n   );\n }\n} class RandomComponent extends React.Component {\n paragraphStyles = {\n   color: \"Red\",\n   fontSize: \"32px\"\n };\n\n headingStyles = {\n   color: \"blue\",\n   fontSize: \"48px\"\n };\n\n render() {\n   return (\n     <div>\n       <h3 style={this.headingStyles}>This is a heading</h3>\n       <p style={this.paragraphStyles}>This is a paragraph</p>\n     </div>\n   );\n }\n} CSS Stylesheet: We can create a separate CSS file and write all the styles for the component inside that file. This file needs to be imported inside the component file. CSS Stylesheet: We can create a separate CSS file and write all the styles for the component inside that file. This file needs to be imported inside the component file. CSS Stylesheet: import './RandomComponent.css';\n\nclass RandomComponent extends React.Component {\n render() {\n   return (\n     <div>\n       <h3 className=\"heading\">This is a heading</h3>\n       <p className=\"paragraph\">This is a paragraph</p>\n     </div>\n   );\n }\n} import './RandomComponent.css';\n\nclass RandomComponent extends React.Component {\n render() {\n   return (\n     <div>\n       <h3 className=\"heading\">This is a heading</h3>\n       <p className=\"paragraph\">This is a paragraph</p>\n     </div>\n   );\n }\n} CSS Modules: We can create a separate CSS module and import this module inside our component. Create a file with “.module.css”‘ extension, styles.module.css: CSS Modules: We can create a separate CSS module and import this module inside our component. Create a file with “.module.css”‘ extension, styles.module.css: CSS Modules: .paragraph{\n color:\"red\";\n border:1px solid black;\n} .paragraph{\n color:\"red\";\n border:1px solid black;\n} We can import this file inside the component and use it: import styles from  './styles.module.css';\n\nclass RandomComponent extends React.Component {\n render() {\n   return (\n     <div>\n       <h3 className=\"heading\">This is a heading</h3>\n       <p className={styles.paragraph} >This is a paragraph</p>\n     </div>\n   );\n }\n} import styles from  './styles.module.css';\n\nclass RandomComponent extends React.Component {\n render() {\n   return (\n     <div>\n       <h3 className=\"heading\">This is a heading</h3>\n       <p className={styles.paragraph} >This is a paragraph</p>\n     </div>\n   );\n }\n}",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "20. How to prevent re-renders in React?",
        "answer": "Reason for re-renders in React:\nRe-rendering of a component and its child components occur when props or the state of the component has been changed.\nRe-rendering components that are not updated, affects the performance of an application.\nHow to prevent re-rendering: Reason for re-renders in React:\nRe-rendering of a component and its child components occur when props or the state of the component has been changed.\nRe-rendering components that are not updated, affects the performance of an application. Reason for re-renders in React: Re-rendering of a component and its child components occur when props or the state of the component has been changed.\nRe-rendering components that are not updated, affects the performance of an application. Re-rendering of a component and its child components occur when props or the state of the component has been changed. Re-rendering components that are not updated, affects the performance of an application. How to prevent re-rendering: How to prevent re-rendering: Consider the following components: class Parent extends React.Component {\nstate = { messageDisplayed: false };\ncomponentDidMount() {\n  this.setState({ messageDisplayed: true });\n}\nrender() {\n  console.log(\"Parent is getting rendered\");\n  return (\n    <div className=\"App\">\n      <Message />\n    </div>\n  );\n}\n}\nclass Message extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = { message: \"Hello, this is vivek\" };\n}  \nrender() {\n  console.log(\"Message is getting rendered\");\n  return (\n    <div>\n      <p>{this.state.message}</p>\n    </div>\n  );\n}\n} class Parent extends React.Component {\nstate = { messageDisplayed: false };\ncomponentDidMount() {\n  this.setState({ messageDisplayed: true });\n}\nrender() {\n  console.log(\"Parent is getting rendered\");\n  return (\n    <div className=\"App\">\n      <Message />\n    </div>\n  );\n}\n}\nclass Message extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = { message: \"Hello, this is vivek\" };\n}  \nrender() {\n  console.log(\"Message is getting rendered\");\n  return (\n    <div>\n      <p>{this.state.message}</p>\n    </div>\n  );\n}\n} The Parent component is the parent component and the Message is the child component. Any change in the parent component will lead to re-rendering of the child component as well. To prevent the re-rendering of child components, we use the shouldComponentUpdate( ) method: The Parent component is the parent component and the Message is the child component. Any change in the parent component will lead to re-rendering of the child component as well. To prevent the re-rendering of child components, we use the shouldComponentUpdate( ) method: Parent Message **Note- Use shouldComponentUpdate( ) method only when you are sure that it’s a static component. **Note- Use shouldComponentUpdate( ) method only when you are sure that it’s a static component. class Message extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = { message: \"Hello, this is vivek\" };\n}\nshouldComponentUpdate() {\n  console.log(\"Does not get rendered\");\n  return false;\n}\nrender() {\n  console.log(\"Message is getting rendered\");\n  return (\n    <div>\n      <p>{this.state.message}</p>\n    </div>\n  );\n}\n} class Message extends React.Component {\nconstructor(props) {\n  super(props);\n  this.state = { message: \"Hello, this is vivek\" };\n}\nshouldComponentUpdate() {\n  console.log(\"Does not get rendered\");\n  return false;\n}\nrender() {\n  console.log(\"Message is getting rendered\");\n  return (\n    <div>\n      <p>{this.state.message}</p>\n    </div>\n  );\n}\n} As one can see in the code above, we have returned false from the shouldComponentUpdate( ) method, which prevents the child component from re-rendering. false",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "21. Explain Strict Mode in React.",
        "answer": "StrictMode is a tool added in version 16.3 of React to highlight potential problems in an application. It performs additional checks on the application. version 16.3 function App() {\n return (\n   <React.StrictMode>\n     <div classname=\"App\">\n       <Header/>\n       <div>\n         Page Content\n       </div>\n       <Footer/>\n     </div>\n   </React.StrictMode>\n );\n} function App() {\n return (\n   <React.StrictMode>\n     <div classname=\"App\">\n       <Header/>\n       <div>\n         Page Content\n       </div>\n       <Footer/>\n     </div>\n   </React.StrictMode>\n );\n} To enable StrictMode, <React.StrictMode> tags need to be added inside the application: <React.StrictMode> import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n<React.StrictMode>\n  <App />\n</React.StrictMode>,\nrootElement\n); import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n<React.StrictMode>\n  <App />\n</React.StrictMode>,\nrootElement\n); StrictMode currently helps with the following issues: Identifying components with unsafe lifecycle methods: \nCertain lifecycle methods are unsafe to use in asynchronous react applications. With the use of third-party libraries, it becomes difficult to ensure that certain lifecycle methods are not used.\nStrictMode helps in providing us with a warning if any of the class components use an unsafe lifecycle method.\nWarning about the usage of legacy string API:\nIf one is using an older version of React, callback ref is the recommended way to manage refs instead of using the string refs. StrictMode gives a warning if we are using string refs to manage refs.\nWarning about the usage of findDOMNode:\nPreviously, findDOMNode( ) method was used to search the tree of a DOM node. This method is deprecated in React. Hence, the StrictMode gives us a warning about the usage of this method.\nWarning about the usage of legacy context API (because the API is error-prone). Identifying components with unsafe lifecycle methods: \nCertain lifecycle methods are unsafe to use in asynchronous react applications. With the use of third-party libraries, it becomes difficult to ensure that certain lifecycle methods are not used.\nStrictMode helps in providing us with a warning if any of the class components use an unsafe lifecycle method. Identifying components with unsafe lifecycle methods: Certain lifecycle methods are unsafe to use in asynchronous react applications. With the use of third-party libraries, it becomes difficult to ensure that certain lifecycle methods are not used.\nStrictMode helps in providing us with a warning if any of the class components use an unsafe lifecycle method. Certain lifecycle methods are unsafe to use in asynchronous react applications. With the use of third-party libraries, it becomes difficult to ensure that certain lifecycle methods are not used. StrictMode helps in providing us with a warning if any of the class components use an unsafe lifecycle method. Warning about the usage of legacy string API:\nIf one is using an older version of React, callback ref is the recommended way to manage refs instead of using the string refs. StrictMode gives a warning if we are using string refs to manage refs. Warning about the usage of legacy string API: If one is using an older version of React, callback ref is the recommended way to manage refs instead of using the string refs. StrictMode gives a warning if we are using string refs to manage refs. If one is using an older version of React, callback ref is the recommended way to manage refs instead of using the string refs. StrictMode gives a warning if we are using string refs to manage refs. callback ref refs string refs string refs Warning about the usage of findDOMNode:\nPreviously, findDOMNode( ) method was used to search the tree of a DOM node. This method is deprecated in React. Hence, the StrictMode gives us a warning about the usage of this method. Warning about the usage of findDOMNode: Previously, findDOMNode( ) method was used to search the tree of a DOM node. This method is deprecated in React. Hence, the StrictMode gives us a warning about the usage of this method. Previously, findDOMNode( ) method was used to search the tree of a DOM node. This method is deprecated in React. Hence, the StrictMode gives us a warning about the usage of this method. Warning about the usage of legacy context API (because the API is error-prone). Warning about the usage of legacy context API (because the API is error-prone).",
        "reference": "interviewbit.com",
        "role": "react"
    },
    {
        "question": "1) What is React?",
        "answer": "React is a declarative, efficient, flexible open source front-end JavaScript library developed by Facebook in 2011. It follows the component-based approach for building reusable UI components, especially for single page application. It is used for developing interactive view layer of web and mobile apps. It was created by Jordan Walke, a software engineer at Facebook. It was initially deployed on Facebook's News Feed section in 2011 and later used in its products like WhatsApp & Instagram.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "2) What are the features of React?",
        "answer": "React framework gaining quick popularity as the best framework among web developers. The main features of React are:\nADVERTISEMENT\nJSX\nComponents\nOne-way Data Binding\nVirtual DOM\nSimplicity\nPerformance\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "3) What are the most crucial advantages of using React?",
        "answer": "Following is a list of the most crucial advantages of using React:\nReact is easy to learn and use\nReact comes with good availability of documentation, tutorials, and training resources. It is easy for any developer to switch from JavaScript background to React and easily understand and start creating web apps using React. Anyone with little knowledge of JavaScript can start building web applications using React.\nReact follows the MVC architecture.\nReact is the V (view part) in the MVC (Model-View-Controller) architecture model and is referred to as \"one of the JavaScript frameworks.\" It is not fully featured but has many advantages of the open-source JavaScript User Interface (UI) library, which helps execute the task in a better manner.\nReact uses Virtual DOM to improve efficiency.\nReact uses virtual DOM to render the view. The virtual DOM is a virtual representation of the real DOM. Each time the data changes in a react app, a new virtual DOM gets created. Creating a virtual DOM is much faster than rendering the UI inside the browser. Therefore, with the use of virtual DOM, the efficiency of the app improves. That's why React provides great efficiency.\nCreating dynamic web applications is easy.\nIn React, creating a dynamic web application is much easier. It requires less coding and gives more functionality. It uses JSX (JavaScript Extension), which is a particular syntax letting HTML quotes and HTML tag syntax to render particular subcomponents.\nReact is SEO-friendly.\nReact facilitates a developer to develop an engaging user interface that can be easily navigated in various search engines. It also allows server-side rendering, which is also helpful to boost the SEO of your app.\nReact allows reusable components.\nReact web applications are made up of multiple components where each component has its logic and controls. These components provide a small, reusable piece of HTML code as an output that can be reused wherever you need them. The code reusability helps developers to make their apps easier to develop and maintain. It also makes the nesting of the components easy and allows developers to build complex applications of simple building blocks. The reuse of components also increases the pace of development.\nSupport of handy tools\nReact provides a lot of handy tools that can make the task of the developers understandable and easier. Use these tools in Chrome and Firefox dev extension, allowing us to inspect the React component hierarchies in the virtual DOM. It also allows us to select the particular components and examine and edit their current props and state.\nReact has a rich set of libraries.\nReact has a huge ecosystem of libraries and provides you the freedom to choose the tools, libraries, and architecture for developing the best application based on your requirement.\n\nScope for testing the codes\nReact web applications are easy to test. These applications provide a scope where the developer can test and debug their codes with the help of native tools.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "4) What are the biggest limitations of React?",
        "answer": "Following is the list of the biggest limitations of React:\nReact is just a library. It is not a complete framework.\nIt has a huge library which takes time to understand.\nIt may be difficult for the new programmers to understand and code.\nReact uses inline templating and JSX, which may be difficult and act as a barrier. It also makes the coding complex.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "5) What is JSX?",
        "answer": "JSX stands for JavaScript XML. It is a React extension which allows writing JavaScript code that looks similar to HTML. It makes HTML file easy to understand. The JSX file makes the React application robust and boosts its performance. JSX provides you to write XML-like syntax in the same file where you write JavaScript code, and then preprocessor (i.e., transpilers like Babel) transform these expressions into actual JavaScript code. Just like XML/HTML, JSX tags have a tag name, attributes, and children.\nExample\nclass App extends React.Component {  \n  render() {  \n    return(  \n      <div>  \n        <h1>Hello JavaTpoint</h1>  \n      </div>  \n    )  \n  }  \n}  \n\nIn the above example, text inside <h1> tag return as JavaScript function to the render function. After compilation, the JSX expression becomes a normal JavaScript function, as shown below.\nReact.createElement(\"h1\", null, \"Hello JavaTpoint\");  \nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "6) Why can't browsers read JSX?",
        "answer": "Browsers cannot read JSX directly because they can only understand JavaScript objects, and JSX is not a regular JavaScript object. Thus, we need to transform the JSX file into a JavaScript object using transpilers like Babel and then pass it to the browser.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "7) Why we use JSX?",
        "answer": "It is faster than regular JavaScript because it performs optimization while translating the code to JavaScript.\nInstead of separating technologies by putting markup and logic in separate files, React uses components that contain both.\nt is type-safe, and most of the errors can be found at compilation time.\nIt makes easier to create templates.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "8) What do you understand by Virtual DOM?",
        "answer": "A Virtual DOM is a lightweight JavaScript object which is an in-memory representation of real DOM. It is an intermediary step between the render function being called and the displaying of elements on the screen. It is similar to a node tree which lists the elements, their attributes, and content as objects and their properties. The render function creates a node tree of the React components and then updates this node tree in response to the mutations in the data model caused by various actions done by the user or by the system.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "Virtual DOM works in three steps:\n1. Whenever any data changes in the React App, the entire UI is re-rendered in Virtual DOM representation.\n\n2. Now, the difference between the previous DOM representation and the new DOM is calculated.\n\n3. Once the calculations are completed, the real DOM updated with only those things which are changed.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "10) How is React different from Angular?",
        "answer": "The React is different from Angular in the following ways.\nAngular React\nAuthor Google Facebook Community\nDeveloper Misko Hevery Jordan Walke\nInitial Release October 2010 March 2013\nLanguage JavaScript, HTML JSX\nType Open Source MVC Framework Open Source JS Framework\nRendering Client-Side Server-Side\nData-Binding Bi-directional Uni-directional\nDOM Regular DOM Virtual DOM\nTesting Unit and Integration Testing Unit Testing\nApp Architecture MVC Flux\nPerformance Slow Fast, due to virtual DOM.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "11) How React's ES6 syntax is different from ES5 syntax?",
        "answer": "The React's ES6 syntax has changed from ES5 syntax in the following aspects.\nrequire vs. Import\n// ES5  \nvar React = require('react');  \n   // ES6  \nimport React from 'react';  \nexports vs. export\n// ES5  \nmodule.exports = Component;  \n   // ES6  \nexport default Component;  \ncomponent and function\n// ES5  \nvar MyComponent = React.createClass({  \n    render: function() {  \n        return(  \n          <h3>Hello JavaTpoint</h3>  \n        );  \n    }  \n});  \n   // ES6  \nclass MyComponent extends React.Component {  \n    render() {  \n        return(  \n          <h3>Hello Javatpoint</h3>  \n        );  \n    }  \n}  \nprops\n// ES5  \nvar App = React.createClass({  \n    propTypes: { name: React.PropTypes.string },  \n    render: function() {  \n        return(  \n           <h3>Hello, {this.props.name}!</h3>  \n        );  \n    }  \n});  \n   // ES6  \nclass App extends React.Component {  \n    render() {  \n        return(  \n          <h3>Hello, {this.props.name}!</h3>  \n        );  \n    }  \n}  \nstate\nvar App = React.createClass({  \n    getInitialState: function() {  \n        return { name: 'world' };  \n    },  \n    render: function() {  \n        return(  \n          <h3>Hello, {this.state.name}!</h3>  \n        );  \n    }  \n});  \n   // ES6  \nclass App extends React.Component {  \n    constructor() {  \n        super();  \n        this.state = { name: 'world' };  \n    }  \n    render() {  \n        return(  \n          <h3>Hello, {this.state.name}!</h3>  \n        );  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "12) What is the difference between ReactJS and React Native?",
        "answer": "The main differences between ReactJS and React Native are given below.\nSN ReactJS React Native\n1. Initial release in 2013. Initial release in 2015.\n2. It is used for developing web applications. It is used for developing mobile applications.\n3. It can be executed on all platforms. It is not platform independent. It takes more effort to be executed on all platforms.\n4. It uses a JavaScript library and CSS for animations. It comes with built-in animation libraries.\n5. It uses React-router for navigating web pages. It has built-in Navigator library for navigating mobile applications.\n6. It uses HTML tags. It does not use HTML tags.\n7. In this, the Virtual DOM renders the browser code. In this, Native uses its API to render code for mobile applications.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "13) What is the difference between Real DOM and Virtual DOM?",
        "answer": "The following table specifies the key differences between the Real DOM and Virtual DOM:\nReal DOM Virtual DOM\nThe real DOM updates slower. The virtual DOM updates faster.\nThe real DOM can directly update HTML. The virtual DOM cannot directly update HTML.\nThe virtual DOM updates the JSX if the element updates.\nIn real DOM, DOM manipulation is very expensive. In virtual DOM, DOM manipulation is very easy.\nThere is a lot of memory wastage in The real DOM. There is no memory wastage in the virtual DOM.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "\"",
        "answer": "In React, components are the building blocks of React applications. These components divide the entire React application's UI into small, independent, and reusable pieces of code. React renders each of these components independently without affecting the rest of the application UI. Hence, we can say that, in React, everything is a component.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "It is mandatory for each React component to have a render() function. Render function is used to return the HTML which you want to display in a component. If you need to rendered more than one HTML element, you need to grouped together inside single enclosing tag (parent tag) such as <div>, <form>, <group> etc. This function returns the same result each time it is invoked.\nExample: If you need to display a heading, you can do this as below.\nimport React from 'react'  \n   class App extends React.Component {  \n   render (){  \n      return (  \n         <h1>Hello World</h1>  \n      )  \n   }  \n}  \nexport default App  \nPoints to Note:\nEach render() function contains a return statement.\nThe return statement can have only one parent HTML tag.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "16) How can you embed two or more components into one?",
        "answer": "You can embed two or more components into the following way:\nimport React from 'react'  \n   class App extends React.Component {  \n   render (){  \n      return (  \n         <h1>Hello World</h1>  \n      )  \n   }  \n}  \n   class Example extends React.Component {  \n   render (){  \n      return (  \n         <h1>Hello JavaTpoint</h1>  \n      )  \n   }  \n}  \nexport default App",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "17) What is Props?",
        "answer": "Props stand for \"Properties\" in React. They are read-only inputs to components. Props are an object which stores the value of attributes of a tag and work similar to the HTML attributes. It gives a way to pass data from the parent to the child components throughout the application.\nIt is similar to function arguments and passed to the component in the same way as arguments passed in a function.\nProps are immutable so we cannot modify the props from inside the component. Inside the components, we can add attributes called props. These attributes are available in the component as this.props and can be used to render dynamic data in our render method.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "18) What is a State in React?",
        "answer": "The State is an updatable structure which holds the data and information about the component. It may be changed over the lifetime of the component in response to user action or system event. It is the heart of the react component which determines the behavior of the component and how it will render. It must be kept as simple as possible.\nLet's create a \"User\" component with \"message state.\"\nimport React from 'react'  \n  class User extends React.Component {  \n  constructor(props) {  \n    super(props)  \n      this.state = {  \n      message: 'Welcome to JavaTpoint'  \n    }  \n  }  \n    render() {  \n    return (  \n      <div>  \n        <h1>{this.state.message}</h1>  \n      </div>  \n    )  \n  }  \n}  \nexport default User  \nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "The major differences between States and Props are given below.\nSN Props State\n1. Props are read-only. State changes can be asynchronous.\n2. Props are immutable. State is mutable.\n3. Props allow you to pass data from one component to other components as an argument. State holds information about the components.\n4. Props can be accessed by the child component. State cannot be accessed by child components.\n5. Props are used to communicate between components. States can be used for rendering dynamic changes with the component.\n6. The stateless component can have Props. The stateless components cannot have State.\n7. Props make components reusable. The State cannot make components reusable.\n8. Props are external and controlled by whatever renders the component. The State is internal and controlled by the component itself.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "20) How can you update the State of a component?",
        "answer": "We can update the State of a component using this.setState() method. This method does not always replace the State immediately. Instead, it only adds changes to the original State. It is a primary method which is used to update the user interface(UI) in response to event handlers and server responses.\nExample\nimport React, { Component } from 'react';  \nimport PropTypes from 'prop-types';  \n  class App extends React.Component {  \n   constructor() {  \n      super();        \n      this.state = {  \n          msg: \"Welcome to JavaTpoint\"  \n      };      \n      this.updateSetState = this.updateSetState.bind(this);  \n   }  \n   updateSetState() {  \n       this.setState({  \n          msg:\"Its a best ReactJS tutorial\"  \n       });  \n   }  \n   render() {  \n      return (  \n         <div>  \n             <h1>{this.state.msg}</h1>  \n             <button onClick = {this.updateSetState}>SET STATE</button>  \n         </div>  \n      );  \n   }  \n}  \nexport default App;  \nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "The difference between stateless and stateful components are:\nSN Stateless Component Stateful Component\n1. The stateless components do not hold or manage state. The stateful components can hold or manage state.\n2. It does not contain the knowledge of past, current, and possible future state changes. It can contain the knowledge of past, current, and possible future changes in state.\n3. It is also known as a functional component. It is also known as a class component.\n4. It is simple and easy to understand. It is complex as compared to the stateless component.\n5. It does not work with any lifecycle method of React. It can work with all lifecycle method of React.\n6. The stateless components cannot be reused. The stateful components can be reused.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "22) What is arrow function in React? How is it used?",
        "answer": "The Arrow function is the new feature of the ES6 standard. If you need to use arrow functions, it is not necessary to bind any event to 'this.' Here, the scope of 'this' is global and not limited to any calling function. So If you are using Arrow Function, there is no need to bind 'this' inside the constructor. It is also called 'fat arrow '(=>) functions.\n//General way  \nrender() {      \n    return(  \n        <MyInput onChange={this.handleChange.bind(this) } />  \n    );  \n}  \n//With Arrow Function  \nrender() {    \n    return(  \n        <MyInput onChange={ (e) => this.handleOnChange(e) } />  \n    );  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "23) What is an event in React?",
        "answer": "An event is an action which triggers as a result of the user action or system generated event like a mouse click, loading of a web page, pressing a key, window resizes, etc. In React, the event handling system is very similar to handling events in DOM elements. The React event handling system is known as Synthetic Event, which is a cross-browser wrapper of the browser's native event.\nHandling events with React have some syntactical differences, which are:\nReact events are named as camelCase instead of lowercase.\nWith JSX, a function is passed as the event handler instead of a string.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "24) How do you create an event in React?",
        "answer": "We can create an event as follows.\nclass Display extends React.Component({      \n    show(msgEvent) {  \n        // code     \n    },     \n    render() {        \n        // Here, we render the div with an onClick prop      \n        return (              \n          <div onClick={this.show}>Click Me</div>   \n        );      \n    }  \n});  \nExample\nimport React, { Component } from 'react';  \nclass App extends React.Component {  \n    constructor(props) {  \n        super(props);  \n        this.state = {  \n            companyName: ''  \n        };  \n    }  \n    changeText(event) {  \n        this.setState({  \n            companyName: event.target.value  \n        });  \n    }  \n    render() {  \n        return (  \n            <div>  \n                <h2>Simple Event Example</h2>  \n                <label htmlFor=\"name\">Enter company name: </label>  \n                <input type=\"text\" id=\"companyName\" onChange={this.changeText.bind(this)}/>  \n                <h4>You entered: { this.state.companyName }</h4>  \n            </div>  \n        );  \n    }  \n}  \nexport default App;  \nFor More Information, Click here.\nADVERTISEMENT",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "25) What are synthetic events in React?",
        "answer": "A synthetic event is an object which acts as a cross-browser wrapper around the browser's native event. It combines the behavior of different browser's native event into one API, including stopPropagation() and preventDefault().\nIn the given example, e is a Synthetic event.\nfunction ActionLink() {  \n    function handleClick(e) {  \n        e.preventDefault();  \n        console.log('You had clicked a Link.');  \n    }  \n    return (  \n        <a href=\"#\" onClick={handleClick}>  \n              Click_Me  \n        </a>  \n    );  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "26) what is the difference between controlled and uncontrolled components?",
        "answer": "The difference between controlled and uncontrolled components are:\nSN Controlled Uncontrolled\n1. It does not maintain its internal state. It maintains its internal states.\n2. Here, data is controlled by the parent component. Here, data is controlled by the DOM itself.\n3. It accepts its current value as a prop. It uses a ref for their current values.\n4. It allows validation control. It does not allow validation control.\n5. It has better control over the form elements and data. It has limited control over the form elements and data.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "Lists are used to display data in an ordered format. In React, Lists can be created in a similar way as we create it in JavaScript. We can traverse the elements of the list using the map() function.\nExample\nimport React from 'react';   \nimport ReactDOM from 'react-dom';   \n  function NameList(props) {  \n  const myLists = props.myLists;  \n  const listItems = myLists.map((myList) =>  \n    <li>{myList}</li>  \n  );  \n  return (  \n    <div>  \n        <h2>Rendering Lists inside component</h2>  \n              <ul>{listItems}</ul>  \n    </div>  \n  );  \n}  \nconst myLists = ['Peter', 'Sachin', 'Kevin', 'Dhoni', 'Alisa'];   \nReactDOM.render(  \n  <NameList myLists={myLists} />,  \n  document.getElementById('app')  \n);  \nexport default App;  \nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "28) What is the significance of keys in React?",
        "answer": "A key is a unique identifier. In React, it is used to identify which items have changed, updated, or deleted from the Lists. It is useful when we dynamically created components or when the users alter the lists. It also helps to determine which components in a collection needs to be re-rendered instead of re-rendering the entire set of components every time. It increases application performance.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "29) How are forms created in React?",
        "answer": "Forms allow the users to interact with the application as well as gather information from the users. Forms can perform many tasks such as user authentication, adding user, searching, filtering, etc. A form can contain text fields, buttons, checkbox, radio button, etc.\nReact offers a stateful, reactive approach to build a form. The forms in React are similar to HTML forms. But in React, the state property of the component is only updated via setState(), and a JavaScript function handles their submission. This function has full access to the data which is entered by the user into a form.\nimport React, { Component } from 'react';  \n  class App extends React.Component {  \n  constructor(props) {  \n      super(props);  \n      this.state = {value: ''};  \n      this.handleChange = this.handleChange.bind(this);  \n      this.handleSubmit = this.handleSubmit.bind(this);  \n  }  \n  handleChange(event) {  \n      this.setState({value: event.target.value});  \n  }  \n  handleSubmit(event) {  \n      alert('You have submitted the input successfully: ' + this.state.value);  \n      event.preventDefault();  \n  }  \n  render() {  \n      return (  \n          <form onSubmit={this.handleSubmit}>  \n            <h1>Controlled Form Example</h1>  \n            <label>  \n                Name:  \n                <input type=\"text\" value={this.state.value} onChange={this.handleChange} />  \n            </label>  \n            <input type=\"submit\" value=\"Submit\" />  \n         </form>  \n      );  \n  }  \n}  \nexport default App;  \nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "30) What are the different phases of React component's lifecycle?",
        "answer": "The different phases of React component's lifecycle are:\nInitial Phase: It is the birth phase of the React lifecycle when the component starts its journey on a way to the DOM. In this phase, a component contains the default Props and initial State. These default properties are done in the constructor of a component.\nMounting Phase: In this phase, the instance of a component is created and added into the DOM.\nUpdating Phase: It is the next phase of the React lifecycle. In this phase, we get new Props and change State. This phase can potentially update and re-render only when a prop or state change occurs. The main aim of this phase is to ensure that the component is displaying the latest version of itself. This phase repeats again and again.\nUnmounting Phase: It is the final phase of the React lifecycle, where the component instance is destroyed and unmounted(removed) from the DOM.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "The important React lifecycle methods are:\ngetInitialState(): It is used to specify the default value of this.state. It is executed before the creation of the component.\ncomponentWillMount(): It is executed before a component gets rendered into the DOM.\ncomponentDidMount(): It is executed when the component gets rendered and placed on the DOM. Now, you can do any DOM querying operations.\ncomponentWillReceiveProps(): It is invoked when a component receives new props from the parent class and before another render is called. If you want to update the State in response to prop changes, you should compare this.props and nextProps to perform State transition by using this.setState() method.\nshouldComponentUpdate(): It is invoked when a component decides any changes/updation to the DOM and returns true or false value based on certain conditions. If this method returns true, the component will update. Otherwise, the component will skip the updating.\ncomponentWillUpdate(): It is invoked before rendering takes place in the DOM. Here, you can't change the component State by invoking this.setState() method. It will not be called, if shouldComponentUpdate() returns false.\ncomponentDidUpdate(): It is invoked immediately after rendering takes place. In this method, you can put any code inside this which you want to execute once the updating occurs.\ncomponentWillUnmount(): It is invoked immediately before a component is destroyed and unmounted permanently. It is used to clear up the memory spaces such as invalidating timers, event listener, canceling network requests, or cleaning up DOM elements. If a component instance is unmounted, you cannot mount it again.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "32) What are Pure Components?",
        "answer": "Pure components introduced in React 15.3 version. The React.Component and React.PureComponent differ in the shouldComponentUpdate() React lifecycle method. This method decides the re-rendering of the component by returning a boolean value (true or false). In React.Component, shouldComponentUpdate() method returns true by default. But in React.PureComponent, it compares the changes in state or props to re-render the component. The pure component enhances the simplicity of the code and performance of the application.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "33) What are Higher Order Components(HOC)?",
        "answer": "In React, Higher Order Component is an advanced technique for reusing component logic. It is a function that takes a component and returns a new component. In other words, it is a function which accepts another function as an argument. According to the official website, it is not the feature(part) in React API, but a pattern that emerges from React's compositional nature.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "34) What can you do with HOC?",
        "answer": "You can do many tasks with HOC, some of them are given below:\nCode Reusability\nProps manipulation\nState manipulation\nRender highjacking",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "35) What is the difference between Element and Component?",
        "answer": "The main differences between Elements and Components are:\nSN Element Component\n1. An element is a plain JavaScript object which describes the component state and DOM node, and its desired properties. A component is the core building block of React application. It is a class or function which accepts an input and returns a React element.\n2. It only holds information about the component type, its properties, and any child elements inside it. It can contain state and props and has access to the React lifecycle methods.\n3. It is immutable. It is mutable.\n4. We cannot apply any methods on elements. We can apply methods on components.\n5. Example:\nconst element = React.createElement(\n'div',\n{id: 'login-btn'},\n'Login'\n)\nExample:\nfunction Button ({ onLogin }) {\nreturn React.createElement(\n'div',\n{id: 'login-btn', onClick: onLogin},\n'Login'\n)\n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "36) How to write comments in React?",
        "answer": "In React, we can write comments as we write comments in JavaScript. It can be in two ways:\n1. Single Line Comments: We can write comments as /* Block Comments */ with curly braces:\n{/* Single Line comment */}  \n2. Multiline Comments: If we want to comment more that one line, we can do this as\n{ /*  \n   Multi \n   line \n   comment \n*/ }",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "37) Why is it necessary to start component names with a capital letter?",
        "answer": "In React, it is necessary to start component names with a capital letter. If we start the component name with lower case, it will throw an error as an unrecognized tag. It is because, in JSX, lower case tag names are considered as HTML tags.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "38) What are fragments?",
        "answer": "In was introduced in React 16.2 version. In React, Fragments are used for components to return multiple elements. It allows you to group a list of multiple children without adding an extra node to the DOM.\nExample\nrender() {  \n  return (  \n    <React.Fragment>  \n      <ChildA />  \n      <ChildB />  \n      <ChildC />  \n    </React.Fragment>  \n  )  \n}  \nThere is also a shorthand syntax exists for declaring Fragments, but it's not supported in many tools:\nrender() {  \n  return (  \n    <>  \n      <ChildA />  \n      <ChildB />  \n      <ChildC />  \n    </>  \n  )  \n}  \nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "39) Why are fragments better than container divs?",
        "answer": "Fragments are faster and consume less memory because it did not create an extra DOM node.\nSome CSS styling like CSS Grid and Flexbox have a special parent-child relationship and add <div> tags in the middle, which makes it hard to keep the desired layout.\nThe DOM Inspector is less cluttered.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "40) How to apply validation on props in React?",
        "answer": "Props validation is a tool which helps the developers to avoid future bugs and problems. It makes your code more readable. React components used special property PropTypes that help you to catch bugs by validating data types of values passed through props, although it is not necessary to define components with propTypes.\nWe can apply validation on props using App.propTypes in React component. When some of the props are passed with an invalid type, you will get the warnings on JavaScript console. After specifying the validation patterns, you need to set the App.defaultProps.\nclass App extends React.Component {  \n          render() {}  \n}  \nComponent.propTypes = { /*Definition */};  \nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "41) What is create-react-app?",
        "answer": "Create React App is a tool introduced by Facebook to build React applications. It provides you to create single-page React applications. The create-react-app are preconfigured, which saves you from time-consuming setup and configuration like Webpack or Babel. You need to run a single command to start the React project, which is given below.\n$ npx create-react-app my-app  \nThis command includes everything which we need to build a React app. Some of them are given below:\nIt includes React, JSX, ES6, and Flow syntax support.\nIt includes Autoprefixed CSS, so you don't need -webkit- or other prefixes.\nIt includes a fast, interactive unit test runner with built-in support for coverage reporting.\nIt includes a live development server that warns about common mistakes.\nIt includes a build script to bundle JS, CSS, and images for production, with hashes and source maps.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "42) How can you create a component in React?",
        "answer": "There are two possible ways to create a component in React:\nFunction Components: This is the simplest way to create a component in React. These are the pure JavaScript functions that accept props object as the first parameter and return React elements:\nfunction Greeting({ message }) {  \n  return <h1>{`Hello, ${message}`}</h1>  \n}  \nClass Components: The class components method facilitates you to use ES6 class to define a component. The above function component can be written as:\nclass Greeting extends React.Component {  \n  render() {  \n    return <h1>{`Hello, ${this.props.message}`}</h1>  \n  }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "43) When do we prefer to use a class component over a function component?",
        "answer": "If a component needs state or lifecycle methods, we should use the class component; otherwise, use the function component. However, after React 16.8, with the addition of Hooks, you could use state, lifecycle methods, and other features that were only available in the class component right in your function component.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "44) Is it possible for a web browser to read JSX directly?",
        "answer": "Web browsers can't read JSX directly. This is because the web browsers are built to read the regular JS objects only, and JSX is not a regular JavaScript object.\nIf you want a web browser to read a JSX file, you must transform the files into a regular JavaScript object. For this purpose, Babel is used.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "45) What do you understand by the state in React?",
        "answer": "In react, the state of a component is an object that holds some information that may change over the component's lifetime. It would be best to try to make your state as simple as possible and minimize the number of stateful components.\nLet's see how to create a user component with message state:\nclass User extends React.Component {  \n  constructor(props) {  \n    super(props)  \n    this.state = {  \n      message: 'Welcome to React world'  \n    }  \n  }  \n  render() {  \n    return (  \n      <div>  \n        <h1>{this.state.message}</h1>  \n      </div>  \n    )  \n  }  \n}   \nThe state is very similar to props, but it is private and fully controlled by the component. i.e., It is not accessible to any other component till the owner component decides to pass it.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "46) What are the main changes that appear in React's ES6 syntax compared to ES5 syntax?/How different is React's ES6 syntax compared to ES5?",
        "answer": "Following are the most visible syntax we can see while comparing ES6 and ES5:\nrequire vs import\nSyntax in ES5:\nvar React = require('react');  \nSyntax in ES6:\nimport React from 'react';  \nexport vs exports\nSyntax in ES5:\nmodule.exports = Component;  \nSyntax in ES6:\nexport default Component;  \ncomponent and function\nSyntax in ES5:\nvar MyComponent = React.createClass({  \n    render: function() {  \n        return  \n<h3>Hello JavaTpoint!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass MyComponent extends React.Component {  \n    render() {  \n        return  \n<h3>Hello JavaTpoint!</h3>  \n;  \n    }  \n}  \nprops\nSyntax in ES5:\nvar App = React.createClass({  \n    propTypes: { name: React.PropTypes.string },  \n    render: function() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    render() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n}  \nstate\nSyntax in ES5:\nvar App = React.createClass({  \n    getInitialState: function() {  \n        return { name: 'world' };  \n    },  \n    render: function() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    constructor() {  \n        super();  \n        this.state = { name: 'world' };  \n    }  \n    render() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "require vs import",
        "answer": "Syntax in ES5:\nvar React = require('react');  \nSyntax in ES6:\nimport React from 'react';  \nexport vs exports\nSyntax in ES5:\nmodule.exports = Component;  \nSyntax in ES6:\nexport default Component;  \ncomponent and function\nSyntax in ES5:\nvar MyComponent = React.createClass({  \n    render: function() {  \n        return  \n<h3>Hello JavaTpoint!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass MyComponent extends React.Component {  \n    render() {  \n        return  \n<h3>Hello JavaTpoint!</h3>  \n;  \n    }  \n}  \nprops\nSyntax in ES5:\nvar App = React.createClass({  \n    propTypes: { name: React.PropTypes.string },  \n    render: function() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    render() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n}  \nstate\nSyntax in ES5:\nvar App = React.createClass({  \n    getInitialState: function() {  \n        return { name: 'world' };  \n    },  \n    render: function() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    constructor() {  \n        super();  \n        this.state = { name: 'world' };  \n    }  \n    render() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "export vs exports",
        "answer": "Syntax in ES5:\nmodule.exports = Component;  \nSyntax in ES6:\nexport default Component;  \ncomponent and function\nSyntax in ES5:\nvar MyComponent = React.createClass({  \n    render: function() {  \n        return  \n<h3>Hello JavaTpoint!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass MyComponent extends React.Component {  \n    render() {  \n        return  \n<h3>Hello JavaTpoint!</h3>  \n;  \n    }  \n}  \nprops\nSyntax in ES5:\nvar App = React.createClass({  \n    propTypes: { name: React.PropTypes.string },  \n    render: function() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    render() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n}  \nstate\nSyntax in ES5:\nvar App = React.createClass({  \n    getInitialState: function() {  \n        return { name: 'world' };  \n    },  \n    render: function() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    constructor() {  \n        super();  \n        this.state = { name: 'world' };  \n    }  \n    render() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "component and function",
        "answer": "Syntax in ES5:\nvar MyComponent = React.createClass({  \n    render: function() {  \n        return  \n<h3>Hello JavaTpoint!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass MyComponent extends React.Component {  \n    render() {  \n        return  \n<h3>Hello JavaTpoint!</h3>  \n;  \n    }  \n}  \nprops\nSyntax in ES5:\nvar App = React.createClass({  \n    propTypes: { name: React.PropTypes.string },  \n    render: function() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    render() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n}  \nstate\nSyntax in ES5:\nvar App = React.createClass({  \n    getInitialState: function() {  \n        return { name: 'world' };  \n    },  \n    render: function() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    constructor() {  \n        super();  \n        this.state = { name: 'world' };  \n    }  \n    render() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "props",
        "answer": "Syntax in ES5:\nvar App = React.createClass({  \n    propTypes: { name: React.PropTypes.string },  \n    render: function() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    render() {  \n        return   \n<h3>Hello, {this.props.name}!</h3>  \n;  \n    }  \n}  \nstate\nSyntax in ES5:\nvar App = React.createClass({  \n    getInitialState: function() {  \n        return { name: 'world' };  \n    },  \n    render: function() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    constructor() {  \n        super();  \n        this.state = { name: 'world' };  \n    }  \n    render() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "state",
        "answer": "Syntax in ES5:\nvar App = React.createClass({  \n    getInitialState: function() {  \n        return { name: 'world' };  \n    },  \n    render: function() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n});  \nSyntax in ES6:\nclass App extends React.Component {  \n    constructor() {  \n        super();  \n        this.state = { name: 'world' };  \n    }  \n    render() {  \n        return  \n<h3>Hello, {this.state.name}!</h3>  \n;  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "47) What do you understand by props in React?",
        "answer": "In React, the props are inputs to components. They are single values or objects containing a set of values passed to components on creation using a naming convention similar to HTML-tag attributes. They are data passed down from a parent component to a child component.\nThe main purpose of props in React is to provide the following component functionality:\nPass custom data to your component.\nTrigger state changes.\nUse via this.props.reactProp inside component's render() method.\nFor example, let us create an element with reactProp property:\n<Element reactProp={'1'} />  \nThis reactProp name becomes a property attached to React's native props object, which already exists on all React library components.\nprops.reactProp",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "48) What do you understand by refs in React?",
        "answer": "Refs is the shorthand used for references in React. It is an attribute which helps to store a reference to particular DOM nodes or React elements. It provides a way to access React DOM nodes or React elements and how to interact with it. It is used when we want to change the value of a child component, without making the use of props.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "49) How to create refs?",
        "answer": "Refs can be created by using React.createRef() and attached to React elements via the ref attribute. It is commonly assigned to an instance property when a component is created, and then can be referenced throughout the component.\nclass MyComponent extends React.Component {  \n  constructor(props) {  \n    super(props);  \n    this.callRef = React.createRef();  \n  }  \n  render() {  \n    return <div ref={this.callRef} />;  \n  }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "50) What are Forward Refs?",
        "answer": "Ref forwarding is a feature which is used for passing a ref through a component to one of its child components. It can be performed by making use of the React.forwardRef() method. It is particularly useful with higher-order components and specially used in reusable component libraries.\nExample\nimport React, { Component } from 'react';  \nimport { render } from 'react-dom';  \n  const TextInput = React.forwardRef((props, ref) => (  \n  <input type=\"text\" placeholder=\"Hello World\" ref={ref} />  \n));  \n  const inputRef = React.createRef();  \n  class CustomTextInput extends React.Component {  \n  handleSubmit = e => {  \n    e.preventDefault();  \n    console.log(inputRef.current.value);  \n  };  \n  render() {  \n    return (  \n      <div>  \n        <form onSubmit={e => this.handleSubmit(e)}>  \n          <TextInput ref={inputRef} />  \n          <button>Submit</button>  \n        </form>  \n      </div>  \n    );  \n  }  \n}  \nexport default App;  \nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "51) Which is the preferred option callback refs or findDOMNode()?",
        "answer": "The preferred option is to use callback refs over findDOMNode() API. Because callback refs give better control when the refs are set and unset whereas findDOMNode() prevents certain improvements in React in the future.\nclass MyComponent extends Component {  \n  componentDidMount() {  \n    findDOMNode(this).scrollIntoView()  \n  }  \n  render() {  \n    return <div />  \n  }  \n}  \nThe recommended approach is:\nclass MyComponent extends Component {  \n  componentDidMount() {  \n    this.node.scrollIntoView()  \n  }  \n  render() {  \n    return <div ref={node => this.node = node} />  \n  }  \n}  \nclass MyComponent extends Component {  \n  componentDidMount() {  \n    this.node.scrollIntoView()  \n  }  \n  render() {  \n    return <div ref={node => this.node = node} />  \n  }  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "52) What is the use of Refs?",
        "answer": "The Ref in React is used in the following cases:\nIt is used to return a reference to the element.\nIt is used when we need DOM measurements such as managing focus, text selection, or media playback.\nIt is used in triggering imperative animations.\nIt is used when integrating with third-party DOM libraries.\nIt can also use as in callbacks.\nFor More Information, Click here.\nReact Router Interview Questions\n53) What is React Router?\nReact Router is a standard routing library system built on top of the React. It is used to create Routing in the React application using React Router Package. It helps you to define multiple routes in the app. It provides the synchronous URL on the browser with data that will be displayed on the web page. It maintains the standard structure and behavior of the application and mainly used for developing single page web applications.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "53) What is React Router?",
        "answer": "React Router is a standard routing library system built on top of the React. It is used to create Routing in the React application using React Router Package. It helps you to define multiple routes in the app. It provides the synchronous URL on the browser with data that will be displayed on the web page. It maintains the standard structure and behavior of the application and mainly used for developing single page web applications.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "54) Why do we need a Router in React?",
        "answer": "React Router plays an important role to display multiple views in a single page application. It is used to define multiple routes in the app. When a user types a specific URL into the browser, and if this URL path matches any 'route' inside the router file, the user will be redirected to that particular Route. So, we need to add a Router library to the React app, which allows creating multiple routes with each leading to us a unique view.\n<switch>  \n      <h1>React Router Example</h1>  \n      <Route path=\"/\" component={Home} />  \n      <Route path=\"/about\" component={About} />  \n      <Route path=\"/contact\" component={Contact} />  \n</switch>",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "The important advantages of React Router are given below:\nIn this, it is not necessary to set the browser history manually.\nLink uses to navigate the internal links in the application. It is similar to the anchor tag.\nIt uses Switch feature for rendering.\nThe Router needs only a Single Child element.\nIn this, every component is specified in <Route>.\nThe packages are split into three packages, which are Web, Native, and Core. It supports the compact size of the React application.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "56) How is React Router different from Conventional Routing?",
        "answer": "The difference between React Routing and Conventional Routing are:\nSN Conventional Routing React Routing\n1. In Conventional Routing, each view contains a new file. In React Routing, there is only a single HTML page involved.\n2. The HTTP request is sent to a server to receive the corresponding HTML page. Only the History attribute <BrowserRouter> is changed.\n3. In this, the user navigates across different pages for each view. In this, the user is thinking he is navigating across different pages, but its an illusion only.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "57) Why you get \"Router may have only one child element\" warning?",
        "answer": "It is because you have not to wrap your Route's in a <Switch> block or <div> block which renders a route exclusively.\nExample\nrender((  \n  <Router>  \n    <Route {/* ... */} />  \n    <Route {/* ... */} />  \n  </Router>  \n)  \nshould be\nrender(  \n  <Router>  \n    <Switch>  \n      <Route {/* ... */} />  \n      <Route {/* ... */} />  \n    </Switch>  \n  </Router>  \n)",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "58) Why switch keyword used in React Router v4?",
        "answer": "The 'switch' keyword is used to display only a single Route to rendered amongst the several defined Routes. The <Switch> component is used to render components only when the path will be matched. Otherwise, it returns to the not found component.\n\nReact Styling Interview Questions\n59) How to use styles in React?\nWe can use style attribute for styling in React applications, which adds dynamically-computed styles at render time. It accepts a JavaScript object in camelCased properties rather than a CSS string. The style attribute is consistent with accessing the properties on DOM nodes in JavaScript.\nExample\nconst divStyle = {  \n  color: 'blue',  \n  backgroundImage: 'url(' + imgUrl + ')'  \n};  \n  function HelloWorldComponent() {  \n  return <div style={divStyle}>Hello World!</div>  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "59) How to use styles in React?",
        "answer": "We can use style attribute for styling in React applications, which adds dynamically-computed styles at render time. It accepts a JavaScript object in camelCased properties rather than a CSS string. The style attribute is consistent with accessing the properties on DOM nodes in JavaScript.\nExample\nconst divStyle = {  \n  color: 'blue',  \n  backgroundImage: 'url(' + imgUrl + ')'  \n};  \n  function HelloWorldComponent() {  \n  return <div style={divStyle}>Hello World!</div>  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "60) How many ways can we style the React Component?",
        "answer": "We can style React Component in mainly four ways, which are given below:\nInline Styling\nCSS Stylesheet\nCSS Module\nStyled Components\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "CSS Module is a CSS file where all class names and animation names are scoped locally by default. It is available only for the component which imports it, and without your permission, it cannot be applied to any other Components. You can create CSS Module file with the .module.css extension.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "62) What are Styled Components?",
        "answer": "Styled-Components is a library for React. It is the successor of CSS Modules. It uses enhance CSS for styling React component systems in your application, which is written with a mixture of JavaScript and CSS. It is scoped to a single component and cannot leak to any other element in the page.\nThe styled-components provides:\nAutomatic critical CSS\nNo class name bugs\nEasier deletion of CSS\nSimple dynamic styling\nPainless maintenance\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "63) What are hooks in React?",
        "answer": "Hooks are the new feature introduced in React 16.8 version that facilitates us to use state and other React features without writing a class.\nSee the following example of useState hook:\nimport { useState } from 'react';  \nfunction Example() {  \n  // Declare a new state variable, which we'll call \"count\"  \n  const [count, setCount] = useState(0);  \n  return (  \n    <div>  \n      <p>You clicked {count} times</p>  \n      <button onClick={() => setCount(count + 1)}>  \n        Click on this button  \n      </button>  \n    </div>  \n  );  \n}",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "64) What are the rules you should follow for the hooks in React?",
        "answer": "We have to follow the following two rules to use hooks in React:\nYou should call hooks only at the top level of your React functions and not inside the loops, conditions, or nested functions. This is used to ensure that hooks are called in the same order each time a component renders, and it also preserves the state of hooks between multiple useState and useEffect calls.\nYou should call hooks from React functions only. Don't call hooks from regular JavaScript functions.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "65) What are forms in React?",
        "answer": "In React, forms are used to enable users to interact with web applications. Following is a list of the most common usage of forms in React:\nForms facilitate users to interact with the application. By using forms, the users can communicate with the application and enter the required information whenever required.\nForms contain certain elements, such as text fields, buttons, checkboxes, radio buttons, etc., that can make the application more interactive and beautiful.\nForms are the best possible way to take inputs from the users.\nForms are used for many different tasks such as user authentication, searching, filtering, indexing, etc.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "66) What is an error boundary or error boundaries?",
        "answer": "An error boundary is a concept introduced in version 16 of React. Error boundaries provide a way to find out the errors that occur in the render phase. Any component which uses one of the following lifecycle methods is considered an error boundary. Let's see the places where an error boundary can detect an error:\nRender phase\nInside a lifecycle method\nInside the constructor\nLet's see an example to understand it better:\nWithout using error boundaries:\nclass CounterComponent extends React.Component{  \n constructor(props){  \n   super(props);  \n   this.state = {  \n     counterValue: 0  \n   }  \n   this.incrementCounter = this.incrementCounter.bind(this);  \n }  \n incrementCounter(){  \n   this.setState(prevState => counterValue = prevState+1);  \n }  \n render(){  \n   if(this.state.counter === 2){  \n     throw new Error('Crashed');  \n   }  \n   return(  \n     <div>  \n       <button onClick={this.incrementCounter}>Increment Value</button>  \n       <p>Value of counter: {this.state.counterValue}</p>  \n     </div>  \n   )  \n }  \n}  \nIn the above code, you can see that when the counterValue equals 2, it throws an error inside the render method. We know that any error inside the render method leads to unmounting of the component so, to display an error that occurs inside the render method, we use error boundaries. When we are not using the error boundary, we see a blank page instead of seeing an error.\nWith error boundaries:\nWe have specified earlier that error boundary is a component using one or both of the following methods:\nstatic getDerivedStateFromError\ncomponentDidCatch\nSee the following code where we create an error boundary to handle errors in render phase:\nclass ErrorBoundary extends React.Component {  \n constructor(props) {  \n   super(props);  \n   this.state = { hasError: false };  \n }  \n static getDerivedStateFromError(error) {       \n   return { hasError: true };   \n }  \n  componentDidCatch(error, errorInfo) {         \n   logErrorToMyService(error, errorInfo);   \n }  \n render() {  \n   if (this.state.hasError) {       \n     return <h4>Something went wrong</h4>       \n   }  \n   return this.props.children;  \n }  \n}  \nYou can see in the above code the getDerivedStateFromError function renders the fallback UI interface when the render method has an error.\nThe componentDidCatch logs the error information to an error tracking service.\nNow with error boundary, we can render the CounterComponent in the following way:\n<ErrorBoundary>  \n  <CounterComponent/>  \n</ErrorBoundary>",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "67) In which cases do error boundaries not catch errors?",
        "answer": "Following are some cases in which error boundaries don't catch errors:\nError boundaries don't catch errors inside the event handlers.\nDuring the server-side rendering.\nIn the case when errors are thrown in the error boundary code itself.\nAsynchronous code using setTimeout or requestAnimationFrame callbacks.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "68) What were the major problems with MVC framework?",
        "answer": "The major problems with the MVC framework are:\nDOM manipulation was very expensive.\nIt makes the application slow and inefficient.\nThere was a huge memory wastage.\nIt makes the application debugging hard.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "Flux is an application architecture that Facebook uses internally for building the client-side web application with React. It is neither a library nor a framework. It is a kind of architecture that complements React as view and follows the concept of Unidirectional Data Flow model. It is useful when the project has dynamic data, and we need to keep the data updated in an effective manner.\n\n\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "70) What is Redux?",
        "answer": "Redux is an open-source JavaScript library used to manage application state. React uses Redux for building the user interface. The Redux application is easy to test and can run in different environments showing consistent behavior. It was first introduced by Dan Abramov and Andrew Clark in 2015.\nReact Redux is the official React binding for Redux. It allows React components to read data from a Redux Store, and dispatch Actions to the Store to update data. Redux helps apps to scale by providing a sensible way to manage state through a unidirectional data flow model. React Redux is conceptually simple. It subscribes to the Redux store, checks to see if the data which your component wants have changed, and re-renders your component.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "71) What are the three principles that Redux follows?",
        "answer": "The three principles that redux follows are:\nSingle source of truth: The State of your entire application is stored in an object/state tree inside a single Store. The single State tree makes it easier to keep changes over time. It also makes it easier to debug or inspect the application.\nThe State is read-only: There is only one way to change the State is to emit an action, an object describing what happened. This principle ensures that neither the views nor the network callbacks can write directly to the State.\nChanges are made with pure functions: To specify how actions transform the state tree, you need to write reducers (pure functions). Pure functions take the previous State and Action as a parameter and return a new State.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "The components of Redux are given below.\nSTORE: A Store is a place where the entire State of your application lists. It is like a brain responsible for all moving parts in Redux.\nACTION: It is an object which describes what happened.\nREDUCER: It determines how the State will change.\nFor More Information, Click here.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "",
        "answer": "Reducers read the payloads from the actions and then updates the Store via the State accordingly. It is a pure function which returns a new state from the initial State. It returns the previous State as it is if no work needs to be done.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "74) What is the significance of Store in Redux?",
        "answer": "A Store is an object which holds the application's State and provides methods to access the State, dispatch Actions and register listeners via subscribe(listener). The entire State tree of an application is saved in a single Store which makes the Redux simple and predictable. We can pass middleware to the Store which handles the processing of data as well as keep a log of various actions that change the Store's State. All the Actions return a new state via reducers.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "75) How is Redux different from Flux?",
        "answer": "The Redux is different from Flux in the following manner.\nSN Redux Flux\n1. Redux is an open-source JavaScript library used to manage application State. Flux is neither a library nor a framework. It is a kind of architecture that complements React as view and follows the concept of Unidirectional Data Flow model.\n2. Store's State is immutable. Store's State is mutable.\n3. In this, Store and change logic are separate. In this, the Store contains State and change logic.\n4. It has only a single Store. It can have multiple Store.\n5. Redux does not have Dispatcher concept. It has single Dispatcher, and all actions pass through that Dispatcher.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "76) What are the advantages of Redux?",
        "answer": "The main advantages of React Redux are:\nReact Redux is the official UI bindings for react Application. It is kept up-to-date with any API changes to ensure that your React components behave as expected.\nIt encourages good 'React' architecture.\nIt implements many performance optimizations internally, which allows to components re-render only when it actually needs.\nIt makes the code maintenance easy.\nRedux's code written as functions which are small, pure, and isolated, which makes the code testable and independent.",
        "reference": "javatpoint.com",
        "role": "react"
    },
    {
        "question": "77) How to access the Redux store outside a component?",
        "answer": "You need to export the Store from the module where it created with createStore() method. Also, you need to assure that it will not pollute the global window space.\nstore = createStore(myReducer)  \nexport default store",
        "reference": "javatpoint.com",
        "role": "react"
    }
]