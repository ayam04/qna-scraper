[
    {
        "question": "1. Find the frequency of each letter in the given string.",
        "answer": "String = ‘the quick brown fox jumps over the lazy dog.’\nWe have the problem statement wherein we have to find out the frequency of each letter in the given string i.e we have to find out how many times each letter is occuring.\nLet’s define our approach towards the problem statement:\nWe will make use of a dictionary to store the result, why? Because you see we can keep the result in the form of a key-value pair. How? The alphabets out there are our key and the occurrence that we have to find out will be our values.\nWe can make use of a For Loop to traverse through the string and for every loop we will count the number of times the characters are occurring using the count().\nBut before that we also have to do a bit of data cleaning. If you properly observe the string, it has spaces and punctuations in there. So if we don’t remove it, it will eventually be counted and that is something we don’t want. So as to remove the punctuation we will make use of the lambda and the filter() along with the isalpha(), isdigit() and isspace() function.\nNow that we are clear with the approach lets write down the code:\n# The original input string\nOriginalString = \"The quick brown fox jumps over the lazy dog.\"\n\n# Splitting the string and removing spaces and punctuation.\nCleanedString = ''.join(filter(lambda x: x.isalpha() or x.isspace() or x.isdigit(), OriginalString.split()))\n\n# To Bring Consistency in the string, converting everything to lowercase\nCleanedString = CleanedString.lower()\n\n#dictionary comprehension for the frequency count&nbsp;\nresult = {x: CleanedString.count(x) for x in CleanedString}&nbsp;\n\n# Printing the result dictionary\nprint(result)\nOutput:\n{‘t’: 2, ‘h’: 2, ‘e’: 3, ‘q’: 1, ‘u’: 2, ‘i’: 1, ‘c’: 1, ‘k’: 1, ‘b’: 1, ‘r’: 2, ‘o’: 3, ‘w’: 1, ‘n’: 1, ‘f’: 1, ‘x’: 1, ‘j’: 1, ‘m’: 1, ‘p’: 1, ‘s’: 1, ‘v’: 1, ‘l’: 1, ‘a’: 1, ‘z’: 1, ‘y’: 1}",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "2. What are loops in Python? How do you write a nested for loop program?",
        "answer": "In Python programming, a loop is a sequence of instructions that gets executed repeatedly until and unless an exit condition is reached. Let’s take a problem statement to understand the usage. Let’s say I want to print “Python” 5 times. There are multiple ways of approaching the same problem statement. One is, writing the print statement 5 times, as shown below:\n print(&ldquo;Python&rdquo;) print(&ldquo;Python&rdquo;) print(&ldquo;Python&rdquo;) print(&ldquo;Python&rdquo;) print(&ldquo;Python&rdquo;) \nBut now, if I want to print it 100 times or let us say, 1000 times, will I be writing the print statement 1000 times? Though that is possible, it is an inefficient way of approaching a problem statement. Here Loops comes to rescue, which helps us to execute a block of code again and again. There are two types of loops in Python:\nFor Loop: For loop is mostly used in cases where we have range data or problems with sequential traversal, like traversing a list, string or an array. Here is the syntax for For Loop:\n for iterator_var in sequence: statements(s) to be executed \nIf we take up the previous problem statements of printing “Python”, 5 times, but now using a for loop. It will be as shown below:\n for i in range(0,5): print(\"Python\") \nIn the above code, we are using the range function to generate a range of 0 to (n-1) i.e (5-1) = 4. The iterator_var, here referred to as ‘ i ’ will traverse through all the elements in the range (0,1,2,3,4). And for each time the loop runs “Python” will get printed. It can be better understood with the help of a dry run as shown below:\nValue of i Print Python Next value of i from range\n0 Python 1\n1 Python 2\n2 Python 3\n3 Python 4\n4 Python Range ends, Exit Loop\nWhile Loop: While loops are mostly used in such cases, where we want to run a block of code repeatedly until and unless a condition is satisfied.\nHere is the syntax for While Loop:\n Iterator_var = 0 while expression: statement(s) Iterator_var increment \nIf we take up the previous problem statements of printing “Python”, 5 times, but now using a while loop. It will be as shown below:\n count = 0 while (count &amp;amp;lt; 5) print(\"Python\") count = count + 1 \nIn the above code, we are setting a count variable to 0 that will count the number of times Python is getting printed. Then, we have the while loop that checks for the condition if it is true, Python gets printed, and the count gets incremented by 1 every time until and unless exit condition is reached. Here is the dry run given below:\ncount while(count > 5) Print Python count = count + 1\n0 TRUE Python 1\n1 TRUE Python 2\n2 TRUE Python 3\n3 TRUE Python 4\n4 TRUE Python 5\n5 FALSE Exit Condition Reached, Loop Exits\nIn Python, a Loop within another loop is called a Nested Loop. This is applicable for both For Loop and While Loop. Below are the code snippets for Nested For Loop and Nested While Loop: Nested For Loop:\n for iterator_var in sequence: for iterator_var in sequence: statements(s) statements(s) \nNested While Loop:\n while expression: while expression: statement(s) statement(s)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "3. What is the difference between Python Arrays and Lists?",
        "answer": "Criteria Python Arrays  Python Lists\nDefinition Arrays are data structures that hold fixed-size elements of the same type. Lists are versatile data structures that can hold elements of different types and sizes.\nMutable Arrays are mutable, meaning their elements can be modified once created. Lists are mutable, allowing for modification of elements after creation.\nSize Array size is fixed upon creation and cannot be changed. Lists can dynamically resize to accommodate new elements or remove existing elements.\nHomogeneous Arrays store elements of the same data type, ensuring homogeneity. Lists can store elements of different data types, allowing heterogeneity.\nAccess Elements in an array can be accessed using indexing. Elements in a list can be accessed using indexing.\nOperations Arrays support mathematical and logical operations on their elements efficiently. Lists provide a wide range of built-in methods and operations for manipulation and data handling.\nMemory Arrays consume less memory compared to lists. Lists consume more memory due to their flexibility and dynamic resizing.\nWatch this Video on Python for Data Science Tutorial",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "4. Write a program in Python to find the largest and second-largest element in a list using Python?",
        "answer": "Here the problem statement says that we have to find out the largest and second largest element from a list containing.\nThe approach towards such a problem statement is simple. We will sort the list in ascending order using the sorted() and then with the help of negative indexing we will be returning the last and the second last element.\n\n \n# Defining a function\ndef LargestAndSecondLargest(Data):\n  # Sorting the list in Ascending Order\n  Data = sorted(Data)\n  # Extracting the last element (Largest Element)\n  largestElement = Data[-1]\n  # Extracting the second last element (Second Largest Element)\n  SecondlargestElement = Data[-2]\n  # Returning the variables containing the elements.\n  return largestElement, SecondlargestElement\n\nData = [20,15,8,12,19]\nLargestAndSecondLargest(Data)\nOutput:\n(78, 10)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "5. Create a Python program that will print the highest sequence of 1s in an array of 0s and 1s?",
        "answer": "a = [1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1]\n# Variable to Store the count of one\ncountofOne = 0\n# Variable to Store the previous count only if the countofOne is greater than the LastCountofOne\nLastCountofOne = 0\n\n# For Loop to traverse through all the element in the array\nfor i in range(len(a)):\n  # Check if the element is 1\n  if a[i] == 1:\n    # Count increased by 1\n    countofOne += 1\n  else:\n    # Checking if countofOne &amp;gt; LastCountofOne\n    if(LastCountofOne &amp;lt; countofOne):\n      # Swapping the value to LastCountofOne if the above condition is True\n      LastCountofOne = countofOne\n      # Set countofOne to zero as we are interrupted by zero\n      countofOne = 0\n\n# Comparing the last value of countofOne with LastCountofOne\nif(LastCountofOne &amp;gt; countofOne):\n  # Print LastCountofOne\n  print(LastCountofOne)\nelse:\n  # Print countofOne\n  print(countofOne)\nOutput:\n8",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "6. In the given array, write a list comprehension that will print the sum of even numbers.",
        "answer": "First of all, we have to understand what an Even Number is. An even number is a number that when divided by 2 leaves a remainder 0 (zero). To return the remainder in a division we make use of the modulus operator(%).\nHere is the approach we are following for the problem statement:\nLooping through all the elements in a list using For Loop\nChecking if the element leaves a remainder zero on division by 2 (x%2 == 0)\nIf the condition seems to be True add it to the Sum counter initialized as zero\nLastly printing the Output as the sum of all even numbers in a list.\nNow that we are clear about our approach to the problem statement. Let’s have a look at the program below:\n# Sample Data in a List\nsample = [1,2,3,4,5,6,7,8,9,10] \n# Defining the variable sum to zero\nSum = 0\n# Looping through elements in the list and checking if it is an even number or not and adding\nSum = sum([x for x in sample if x%2 == 0])\n# Printing the Sum of Even Numbers\nprint(Sum)\nOutput:\n30",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "7. Write a function to output separate lists containing even and odd elements from a given array.",
        "answer": "Let’s take a look at the program, here our approach is written as follows:\nCheck if the given element is even or odd\nReturn two separate lists with even and odd elements\n# Defining a Function\ndef EvenOdd(Data):\n  # Checking if the number is even\n  print([x for x in Data if x%2 == 0])\n  # Cheking if the number is odd\n  print([x for x in Data if x%2 != 0])\n\n# Sample Data\nData = [1,2,3,4,5,6,7,8,9,10]\n# Function Call\nEvenOdd(Data)\n \nOutput:\n[2, 4, 6, 8, 10]\n[1, 3, 5, 7, 9]\nThe above program will create two separate lists after checking if the elements are even or odd in the given sample, and print both the lists at the end of the execution.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "8. What is file handling in Python? What are the various file-handling operations in Python?",
        "answer": "File handling also known as Python I/O involves working with files on a computer’s file system using Python as a programming language.\nPython File Handling Operations can be categorized into the following categories:\nReading a file\nCreating a file\nWriting in a file\nDeleting a file\nHave a Look at this blog on File Handling in Python",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "9. Create a Python program to depict the functioning of stacks and queues?",
        "answer": "# Program to show the implementation of stack\nstack = []\nx = list(range(0,10,3))\nfor i in range(1,6):\n  if i < len(x):\n    stack.append(x[i])\n  else:\n    stack.pop()\n  print(stack)\nOutput:\n[3]\n[3, 6]\n[3, 6, 9]\n[3, 6]\n[3]\n# Program to show the implementation of Queue - FIFO\n#Implementation of Queue - FIFO\nqueue = []\nx = list(range(0,10,3))\nfor i in range(1,6):\n  if i < len(x):\n    queue.append(x[i])\n  else:\n    queue.pop(0)\n  print(queue)\nOutput:\n[3]\n[3, 6]\n[3, 6, 9]\n[6, 9]\n[9]",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "10. Write a Python program to print a list of primes in a given range.",
        "answer": "In this program where we need to check if the number is a prime number or not, we are making use of a very simple approach. Firstly we need to understand what is a Prime Number? A whole number greater than 1 cannot be exactly divided by any whole number other than itself and 1.\nLet’s formulate the approach:\nCheck if the number is greater or less than 1. If less than one returns that it is not a prime number immediately as the definition says “A Whole number greater than 1”\nIf not less than one, check if the number has some other factors or not. If it has returned that it is not a prime number.\nLastly, if it passes all the tests returns that it is a prime number. \nNow let’s have a look at the program to check if the number is a prime number or not.\n# Defining a Function\ndef isPrime(num):\n  # Checking if num > 1 because there are no prime numbers less than 1\n  if(num > 1):\n    # Looping through the elements in a range of 2,num to find factors\n    for i in range(2,num):\n        # if three is a factor other than 1\n        if(num % i == 0):\n            # Return Fales in Flag i.e not a prime number\n            flag = False\n            # End the Loop\n            break\n    else:\n        # If there is no factor other than 1 return True in Flag\n        flag = True\n  else:\n      # IF the number is less than 1 return False in Flag\n      flag = False\n  # Finally return the Final value of the flag\n  return flag\n\n# Sample input\nnum = 5\n# Check if the flag is True or False\nif (isPrime(num)):\n  # If Flag is True print\n  print(\"It is a Prime Number\")\nelse:\n  # If Flag is False print\n  print(\"It is a not a Prime Number\")",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "11. What are collections? What is the significance of collections in Python?",
        "answer": "Collections refer to those data structures or containers that are capable of holding collective data in a single variable. \nLet’s take an example to understand it. Suppose you have lots of books and are trying to build a library. Each book is different, some are about life lessons, some are about stories, and some are about magic, etc. In Python, collections are like those collections of books. They help you organize lots of things (like numbers, words, or other data) in an organized way, just like how you organize your books in your library.\nThere are four different data structures in collections:\nList: List is one of the most versatile data structures in python. Here are the characteristics of a list to be remembered:\nLists are mutable data types i.e once declared, a list can be modified.\nLists can contain heterogeneous elements i.e elements with different data types.\nLists also allow duplicate values.\n# This is an empty list \nMylist = []\n# Let's add some values to it\nMylist = [1,2,\"Intellipaat\", \"Live\", 23.45, True]\n# Printing the list\nprint(Mylist)\nTuple: Tuples are similar to lists, they are usually used to store related data. Here are the characteristics of a list to be remembered:\nTuples are immutable data types, i.e once declared, a tuple can’t be modified.\nTuple can contain heterogeneous elements i.e elements with different data types.\nTuples also allow duplicate values.\nHere is the syntax to define a tuple:\n# This is an empty tuple\nMyTuple = ()\n# Let's add some values to it\nMyTuple = (1,2,\"Intellipaat\", \"Live\", 23.45, True)\n# Printing the tuple\nprint(MyTuple) \nDictionary: Think of them like real-world dictionaries where you look up a word (key) to find its definition (value). Here are the characteristics of a list to be remembered:\nDictionaries are mutable data types i.e once declared, can be modified later.\nDictionaries can contain heterogeneous elements i.e elements with different data types.\nDictionaries store data in the form of Key, Value pairs.\nDictionaries cannot have two elements with the same key.\nHere is the syntax to define a dictionary:\n# This is an empty dictionary\nMyDict = {}\n# Let's add some values to it\nMyDict = {\"Name\": \"Intellipaat\", \"Industry\": \"EdTech\", \"Revenue\": 120}\n# Printing the dictionary\nprint(MyDict) \nSet: Sets are useful for tasks like removing duplicates from a list or performing mathematical set operations like union, intersection, and difference. Here are the characteristics of a list to be remembered:\nSets are unordered, i.e the items in a set do not have a defined order.\nSets are mutable data types i.e once declared, can be modified later.\nHere is the syntax to define a dictionary:\n# This is an empty set\nMySet = {}\n# Let's add some values to it\nMySet = {1,2,\"Intellipaat\", \"Live\", 23.45, True}\n# Printing the set\nprint(MySet)\nThe significance of collections in Python is to handle complex data structures and algorithms efficiently. By choosing the right collection for the task at hand, you can write cleaner, more organized code that is easier to understand and maintain.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "12. Write a program to check even odd numbers using shorthand if else statements.",
        "answer": "Before directly jumping onto writing the program, lets understand what is the ultimate goal, the ultimate goal of the program should be checking if a number is odd or even. \nLet’s first understand even and odd numbers. When can a number be even? A number is even when it is divided by two and returns a remainder zero. Now we know that the remainder can be determined with the help of the modulus function (%), which returns the remainder of the division. Now, let’s go ahead and write the program.\n# Defining the Function\ndef EvenOdd(n):\n  print(\"Even Number\") if(n%2 == 0) else print(\"Odd Number\")\n\n# Calling the Function:\nEvenOdd(21) # Output: Odd Number\nEvenOdd(12) # Output: Even Number",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "13. Write a Python program that will reverse a string without using the slicing operation or reverse() function?",
        "answer": "# Defining the function\ndef reverseString(x):\n  # Declaring an empty String\n  NewString = \"\"\n  # Traversing through individual characters in a string\n  for i in x:\n    # Add the character to the empty string\n    NewString = i + NewString\n  # return the new string\n  return NewString\n\n# Sample String\nstring = \"Intellipaat\"\n# Function Call\nReversedString = reverseString(string)\n# Printing Output\nprint(ReversedString)\nOutput:\ntaapilletnI",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "14. Write a Python program that removes duplicates from a list?",
        "answer": "Removing duplicates from a list can be done very easily by converting the list into a set and then back to a list. As it is a property of a set that can only contain unique.\n# Sample Data in List\nSample = [1,1,0,0,1,0,2,0,3,2,2,4,4,2,3]\n# Converting the list to set to remove duplicates\nSetSample = set(Sample)\n# Converting the set to a list again\nListSample = list(SetSample)\n# Printing the Output\nprint(ListSample)\nOutput:\n[0, 1, 2, 3, 4]",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "15. What is method overriding? Explain with an example in Python?",
        "answer": "Method overriding is a polymorphism concept where a method overrides its parent class method during inheritance. Let’s take a look at a simple example:\nclass Animals:\n  def species(self, x):\n    self.x = x\n    print(\"species of the animal is : {}\".format(self.x))\n\nclass Snakes(Animals):\n  def species(self):\n    print(\"Species is Reptiles\")\n\n#calling the parent class method\nobj = Animals()\nobj.species(\"Amphibian\")\n\n#calling the class object overrides the parent class method\nobj1 = Snakes()\nobj1.species()\nOutput:\nspecies of the animal is : Amphibian\nSpecies is Reptiles",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "16. What is String Manipulation, Give a few examples.",
        "answer": "A string is a collection of letters or characters. String manipulation is the process of modifying the characters of a string. It involves various operations, such as changing the letter cases, slicing, and concatenating two or more strings. In Python, there are several pre-built functions that we can use to modify a string.\nHere are a few examples of string manipulation:\nString Concatenation: It is a method of combining two or more strings together. Let us understand it using a very simple Python program:\nstr1 = \"Hello\" #first string\nstr2 = \"World\" #second string\nresult = str1 + \"  \" + str2 \nprint(result)  #output: Hello World\nIn this code, we have created two variables, str1 and str2 which are storing two strings, “Hello” and “World”. Then, we have created a third variable in which we are storing the final output. Using the “+” operator, we are concatenating two strings.\nSlice a string: It is a process of extracting substrings from a string. Let us see how we can perform the string slicing.\nstr = \"Intellipaat\"\nsubstring = str[0:7] \nprint(substring)  # Output: Intelli\nIn this code, we have a str variable storing “Intellipaat‘. We are extracting a substring from a string using the indexes str[start_index:end_index]. This method allows us to extract a portion of a string by specifying a start index and an end index. In this case, the start index is 0 and the end index is 7 (excluding 7).\nSplit a string: Dividing a string into a list of substrings.\nIn this code, we are splitting the str string into two words:  “Hello” & “World”. The final output we will get is a list of words.\nstr = \"Hello,World\"\nfruits = str.split(\",\") # Here we have used a split method to split the string into two substrings based on the specified delimiter, which is a comma in this case.\n\nprint(fruits)  \n# Output: [‘Hello’, 'World’]\nCase conversion: Using the lower or upper functions, we can change the cases of strings. Here is a very simple python program to convert the case of a string:\nstr = \"Intelli Paat\"\nlowercase_str = str.lower() # This built-in function is going to convert all the string letters to lower case\nuppercase_str = str.upper() # And this one will convert all the string letters to upper case.\nprint(lowercase_str)  # Output: intelli paat\nprint(uppercase_str)  # Output: INTELLI PAAT\nReverse a string: Here is an example of how we can reverse a string. \nIn this code, we are using slicing to reverse a string.\nstr = \"Hello World\"[::-1]\nprint(str)\n\n#Output: dlroW olleH",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "17. What distinguishes lists from tuples?",
        "answer": "Here are the major differences between List and Tuples: \nLists Tuples\nLists are mutable, i.e., they can be edited Tuples possess immutability, denoting their incapability of being modified like lists.\nLists are usually slower than tuples Tuples are faster than lists\nLists consume a lot of memory Tuples consume less memory comparatively\nLists have a higher likelihood of experiencing unexpected changes, making them less reliable in terms of errors Tuples offer increased reliability due to their resistance to unexpected modifications",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "18. What is PEP 8?",
        "answer": "PEP in Python stands for Python Enhancement Proposal. It comprises a collection of guidelines that outline the optimal approach for crafting and structuring Python code to improve readability and clarity of the code.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "19. What are the key features of Python?",
        "answer": "The key features of Python are as follows:\nPython is a Free and Open source programming language i.e. Python is available to all for free and anyone as a developer can contribute to the code.\nPython is a high-level programming language that makes it easy for the user to read, understand, and learn the language.\nPython is an object-oriented programming language except having access specifiers. Other than access specifiers (public and private keywords), Python has classes, inheritance, and all other usual OOPs concepts.\nPython has gained a lot of popularity over the years as a result of which it has a large community.\nPython is a portable language i.e. a code written on Mac can also run on Windows.\nPython has the support of a wide range of standard libraries as well as third-party libraries.\nGo through the Data Science with Python Course in Hyderabad to get a clear understanding of Python and become a Python developer today!\nGet 100% Hike!\nMaster Most in Demand Skills Now !\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "20. How is memory managed in Python?",
        "answer": "Python makes use of automatic memory management through garbage collection.\nThe garbage collector keeps track of objects and frees memory when they are no longer in use.\nPython uses reference counting to manage memory, incrementing and decrementing reference counts as needed.\nA cyclic garbage collector handles objects with circular references.\nPython also provides tools like context managers and the “with” statement to release resources automatically.\nPython’s memory management simplifies coding by handling memory allocation and deallocation automatically.\nTo become a professional business analyst, check out Intellipaat’s Business Analyst Certification Course in Bangalore taught by industry experts.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "21. What is PYTHONPATH?",
        "answer": "PYTHONPATH serves as an environment variable within the Python programming language, empowering users to define supplementary directories for Python to search when seeking modules and packages. This variable serves as a search path and helps Python locate the necessary files to import when executing code. By setting the PYTHONPATH variable, users can extend the default search path and customize the module search behavior according to their needs. This feature enables developers to organize and structure their Python projects efficiently, facilitating easier module importation and enhancing code reusability.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "22. What is the difference between modules and libraries?",
        "answer": "In Python, modules are like standalone files that house specific code components, such as functions and variables. On the other hand, libraries are essentially vast collections of modules, and they come with pre-built functions and tools tailored for specific tasks or domains. These libraries not only simplify the development process but also enhance Python’s capabilities by providing readily available solutions for various programming challenges.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "23. What are Python namespaces?",
        "answer": "A Python namespace ensures that the names assigned to objects within a program are unique and can be used without conflict. In Python, namespaces are implemented as dictionaries where the object’s name serves as the key and the object itself serves as the value.\nLet’s examine some examples of namespaces:\nThe Local Namespace is specific to a function and contains the names defined within that function. It is created temporarily when the function is called and is cleared once the function finishes executing.\nThe Global Namespace includes names from imported modules or packages that are used in the current project. It is created when the package is imported into the script and remains accessible throughout the script’s execution.\nThe Built-in Namespace comprises the built-in functions provided by Python’s core, as well as specific names dedicated to various types of exceptions.\nWant to become a master in Python programming? Check out this Python Training for Data Science and excel in your Python career!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "24. Explain Inheritance and its types in Python with an example?",
        "answer": "Python embraces the principles of object-oriented programming and allows classes to acquire the characteristics of another class, a concept known as inheritance. This facilitates code reuse, promoting efficiency. The original class from which properties are inherited is referred to as the superclass or parent class, while the class inheriting those properties is known as the derived or child class. Python supports various types of inheritance, including the following:\n\nMultiple Inheritance: Python supports multiple inheritance, enabling a derived class to inherit attributes and methods from multiple parent classes, facilitating code reuse, and enhancing flexibility.\nMultilevel Inheritance: With multilevel inheritance, a derived class inherits properties and methods from a parent class, which in turn inherits from another parent class, establishing a hierarchical relationship between classes.\nHierarchical Inheritance: In hierarchical inheritance, multiple classes inherit properties and methods from a common superclass, resulting in a tree-like structure where each derived class has its own specialized functionality.\nSingle Inheritance: In Python, single inheritance allows a derived class to inherit properties and methods from a single superclass, promoting code reuse and organizational structure.\nHybrid Inheritance: Hybrid inheritance combines different types of inheritance, such as single, multiple, or multilevel inheritance, to create complex class hierarchies that fulfill specific programming requirements, ensuring maximum code reuse and flexibility.\nKnow the difference between Functional Programming and Object Oriented Programming",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "25. What is __init__ in Python?",
        "answer": "In Python classes, the reserved method init serves a similar purpose as constructors in object-oriented programming (OOP) terminology. When a new object is created, the init method is automatically called, initializing the object and allocating memory for it. This method can also be utilized to set initial values for variables.\nBelow is an example:\nclass Human:\n    def __init__(self, age):\n        self.age = age\n    def say(self):\n        print('Hello, my age is', self.age)\nh = Human(22)\nh.say()\nOutput:\nHello, my age is 22",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "26. Why do we need NumPy in Python?",
        "answer": "NumPy is a core Python library for efficient numerical computing. It offers high-performance multidimensional array objects and tools for working with these arrays. Leveraging C for speed, it allows for vectorized operations, broadcasting, and direct array arithmetic, which boosts performance and reduces code complexity. Integral to Python’s scientific stack, it enables seamless integration with libraries like Pandas and Matplotlib. NumPy is memory-efficient, and provides extensive mathematical functionality, and its arrays form the basis of most Python-based data science applications. Its indispensability lies in its ability to handle large data sets with speed and precision.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "27. Is this statement true “Python is a case-sensitive language”?",
        "answer": "Yes, Python is a case-sensitive language. In Python, it is important to note that “Function” and “function” are distinct entities, similar to how SQL and Pascal handle them differently.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "28. Difference between loc and iloc?",
        "answer": "loc and iloc are two functions provided by the Pandas library in Python to access different parts of a DataFrame. They are primarily used for selecting rows and columns.\nAspect loc iloc\nType of Indexing Label-based Integer position-based\nInput Accepts labels of rows and columns. Accepts integer positions for rows and columns\nSlicing End label is inclusive in the range End position is exclusive in the range\nSubsetting Can select rows with a particular label and condition Can select rows by integer locations regardless of the DataFrame index\nMixed Selection Allows using labels for both rows and columns Uses integer positions for both rows and columns\nCallable Supports callable functions Also supports callable functions",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "29. What do you understand by iterators in Python?",
        "answer": "Python iterators are objects that allow you to access elements of a collection one at a time. They use the __iter__() and __next__() methods to retrieve the next element until there are no more. Iterators are commonly used in for loops and can be created for custom objects. They promote efficient memory usage and enable lazy evaluation of elements. In summary, iterators provide a convenient way to iterate over data structures in a controlled and efficient manner.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "30. Do we need to declare variables with respective data types in Python?",
        "answer": "No. Python is a dynamically typed language, i.e., the Python Interpreter automatically identifies the data type of a variable based on the type of value assigned.\nWant to know How to Become a Python Developer? Check out this blog to know the complete process.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "31. What do you know about Dict and List Comprehension?",
        "answer": "Python Comprehensions are like decorators that help to build altered and filtered lists, dictionaries, or sets from a given list, dictionary, or a set. Comprehension is a powerful feature in Python that offers a convenient way to create lists, dictionaries, and sets with concise expressions. It eliminates the need for explicit loops, which can help reduce code size and save time during development.\nComprehensions are beneficial in the following scenarios:\nPerforming mathematical operations on the entire list\nPerforming conditional filtering operations on the entire list\nCombining multiple lists into one\nFlattening a multi-dimensional list\nFor example:\nmy_list = [2, 3, 5, 7, 11]\nsquared_list = [x**2 for x in my_list]    # list comprehension\n# output => [4 , 9 , 25 , 49 , 121]\nsquared_dict = {x:x**2 for x in my_list}    # dict comprehension\n# output =>{11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49}",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "32. What is the method to write comments in Python?",
        "answer": "Python comments are statements used by the programmer to increase the readability of the code. With the help of the #, you can define a single comment. Another way of commenting is to use the docstrings (strings enclosed within triple quotes).\nFor example:\n#Comments in Python \nprint(\"Comments in Python \")\nMaster Python by taking up this online Python Course in Bangalore!!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "33. Is multiple inheritance supported in Python?",
        "answer": "Yes, unlike Java, Python provides users with a range of support in terms of inheritance and its usage. Multiple inheritance refers to a scenario where a class is instantiated from more than one individual parent class. This provides a lot of functionality and advantages to users.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "34. What is the difference between range & xrange?",
        "answer": "Functions in Python, range() and xrange(), are used to iterate inside a for loop for a fixed number of times. Functionality-wise, both these functions are the same. The difference comes when talking about the Python version support for these functions and their return values.\nrange() Method xrange() Method\nIn Python 3, xrange() is not supported; instead, the range() function is used to iterate inside for loops. The xrange() function is used in Python 2 to iterate inside for loops.\nIt returns a list. It returns a generator object as it doesn’t really generate a static list at the runtime.\nIt takes more memory as it keeps the entire list of iterating numbers in memory. It takes less memory as it keeps only one number at a time in memory.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "35. What do you understand by the word Tkinter?",
        "answer": "Tkinter is a built-in Python module that is used to create GUI applications and it is Python’s standard toolkit for GUI development. Tkinter comes pre-loaded with Python so there is no separate installation needed. You can start using it by importing it into your script.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "36. Is Python fully object-oriented?",
        "answer": "Python follows an object-oriented programming paradigm and has all the basic OOPs concepts, such as inheritance, polymorphism, and more, with the exception of access specifiers. Python doesn’t support strong encapsulation (adding a private keyword before data members). Although, it has a convention that can be used for data hiding, i.e., prefixing a data member with two underscores.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "37. Differentiate between NumPy and SciPy?",
        "answer": "NumPy SciPy\nNumPy stands for Numerical Python SciPy stands for Scientific Python\nIt is used for efficient and general numeric computations on numerical data saved in arrays. E.g., sorting, indexing, reshaping, and more This module is a collection of tools in Python used to perform operations such as integration, differentiation, and more\nThere are some linear algebraic functions available in this module, but they are not full-fledged Full-fledged algebraic functions are available in SciPy for algebraic computations",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "38. Explain all file processing modes supported in Python?",
        "answer": "Python has various file-processing modes.\nFor opening files, there are three modes:\nread-only mode (r)\nwrite-only mode (w)\nread–write mode (rw)\nFor opening a text file using the above modes, we will have to append ‘t’ with them as follows:\nread-only mode (rt)\nwrite-only mode (wt)\nread–write mode (rwt)\nSimilarly, a binary file can be opened by appending ‘b’ with them as follows:\nread-only mode (rb)\nwrite-only mode (wb)\nread–write mode (rwb)\nTo append the content in the files, we can use the append mode (a):\nFor text files, the mode would be ‘at’\nFor binary files, it would be ‘ab’",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "39. What do file-related modules in Python do? Can you name some file-related modules in Python?",
        "answer": "Python comes with some file-related modules that have functions to manipulate text files and binary files in a file system. These modules can be used to create text or binary files, update content by carrying out operations like copy, delete, and more.\nSome file-related modules are os, os.path, and shutil.os. The os.path module has functions to access the file system, while the shutil.os module can be used to copy or delete files.\nKnow about Python developer roles and responsibilities to begin a career as a Python developer.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "40. Explain the use of the 'with' statement and its syntax?",
        "answer": "In Python, using the ‘with’ statement, we can open a file and close it as soon as the block of code, where ‘with’ is used, exits. In this way, we can opt for not using the close() method.\nwith open(\"filename\", \"mode\") as file_var:",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "41. Write a code to display the contents of a file in reverse?",
        "answer": "To display the contents of a file in reverse, the following code can be used:\nfilename = \"filename.txt\"\nwith open(filename, \"r\") as file:\n    lines = file.readlines()\n\nfor line in reversed(lines):\n    print(line.rstrip())\nNow in these questions lets look at some python interview coding questions",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "42. Which one of the following statements is not valid?",
        "answer": "xyz = 1,000,000\nx y z = 1000 2000 3000\nx,y,z = 1000, 2000, 3000\nx_y_z = 1,000,000\nThe second statement is invalid. This is invalid because variable names in Python cannot contain spaces, and multiple variables cannot be assigned in this way without commas to separate them. Additionally, the values to be assigned are not separated by commas, making the statement syntactically incorrect.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "43. Write a command to open the file c:\\hello.txt for writing?",
        "answer": "Command:\nf= open(“hello.txt”, “wt”)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "44. What does len() do?",
        "answer": "len() is an inbuilt function used to calculate the length of sequences like list, python string, and array.\nmy_list = [1, 2, 3, 4, 5]\nlength = len(my_list)\nprint(length)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "45. What does *args and **kwargs mean in Python?",
        "answer": ".*args: It is used to pass multiple arguments in a function.\n**kwargs: It is used to pass multiple keyworded arguments in a function in Python.\nWant to know about the real-world uses of Python? Read our detailed blog on Python Project ideas now.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "46. How will you remove duplicate elements from a list?",
        "answer": "To remove duplicate elements from the list, we use the set() function.\nConsider the below example:\ndemo_list = [5, 4, 4, 6, 8, 12, 12, 1, 5]\nunique_list = list(set(demo_list))\noutput = [1, 5, 6, 8, 12]",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "47. How to delete files in Python?",
        "answer": "You need to import the OS Module and use os.remove() function for deleting a file in Python.\nconsider the code below:\nimport os\nos.remove(\"file_name.txt\")",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "48. How will you read a random line in a file?",
        "answer": "We can read a random line in a file using the random module.\nFor example:\nimport random\ndef read_random(fname):\nlines = open(fname).read().splitlines()\nreturn random.choice(lines)\nprint(read_random('hello.txt'))",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "49. Write a Python program to count the total number of lines in a text file?",
        "answer": "Refer to the code below to count the total number of lines in a text file-\ndef file_count(fname):\n    with open(fname) as f:\n        for i, _ in enumerate(f):\n            pass\n    return i + 1\n\nprint(\"Total number of lines in the text file:\",\nfile_count(\"file.txt\"))",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "50. What would be the output if I ran the following code block?",
        "answer": "list1 = [2, 33, 222, 14, 25]\nprint(list1[-2])\n14\n33\n25\nError\nAns. output:14\nIn Python, negative indexing allows you to access elements from the end of the list. The index -1 represents the last element, -2 represents the second-to-last element, and so on.\nIn the given code, list1[-2] refers to the second-to-last element in the list list1, which is 14. Therefore, the output of the code will be 14.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "51. What is the purpose of “is”, “not” and “in” operators?",
        "answer": "Operators are referred to as special functions that take one or more values (operands) and produce a corresponding result.\nis: returns the true value when both the operands are true  (Example: “x” is ‘x’)\nnot: returns the inverse of the boolean value based upon the operands (example:”1” returns “0” and vice-versa\nin: helps to check if the element is present in a given Sequence or not",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "52. Explain the use of ternary operators in Python?",
        "answer": "The ternary operator is the operator that is used to show conditional statements in Python. This consists of the boolean true or false values with a statement that has to be checked.\nSyntax:\nx , y=10,20\ncount = x if x < y else y [/code] Explanation: The expression count = x if x < y else y is evaluated as follows:\nIf the condition x < y is true, then the value of x is assigned to count. This means that if the value of x is less than the value of y, the count will be equal to x.\nIf the condition x < y is false, then the value of y is assigned to count. This means that if the value of x is not less than the value of y, the ecount will be equal to y.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "53. What is the process for appending values to a Python array?",
        "answer": "In Python, adding elements in an array can be easily done with the help of extend(), append(), and insert() functions.\nConsider the following example:\nx=arr.array('d', [11.1 , 2.1 ,3.1] )\nx.append(10.1)\nprint(x)   #[11.1,2.1,3.1,10.1]\nx.extend([8.3,1.3,5.3])\nprint(x)  #[11.1,2.1,3.1,10.1,8.3,1.3,5.3]\nx.insert(2,6.2)\nprint(x)        # [11.1,2.1,6.2,3.1,10.1,8.3,1.3,5.3]",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "54. What is the procedure for deleting values from a Python array?",
        "answer": "Elements can be removed from a Python array by using pop() or remove() methods.\npop(): This function will return the removed element.\nremove(): It will not return the removed element.\nConsider the below example :\nx=arr.array('d', [8.1, 2.4, 6.8, 1.1, 7.7, 1.2, 3.6])\nprint(x.pop())\nprint(x.pop(3))\nx.remove(8.1)\nprint(x)\nOutput:\n3.6\n1.1  # element popped at 3 rd  index\narray('d', [ 2.4, 6.8, 7.7, 1.2])\nAre you interested in learning Python from experts? Enroll in our online Python Course in Chennai today!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "55. Write a code to sort a numerical list in Python?",
        "answer": "The following code can be used to sort a numerical list in Python:\nnumbers = [\"2\", \"5\", \"7\", \"8\", \"1\"]\nnumbers = [int(i) for i in numbers]\nnumbers.sort()\nprint(numbers)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "56. How will you reverse a list in Python?",
        "answer": "To reverse a list in Python, you can use the slicing technique. Here’s a brief explanation of the process:\nStart with the original list that you want to reverse.\nUse the slicing syntax [::-1] to create a new list that includes all elements from the original list in reverse order.\nAssign the reversed list to a new variable or overwrite the original list with the reversed version.\noriginal_list = [1, 2, 3, 4, 5]\nreversed_list = original_list[::-1]",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "57. How will you remove the last object from a list in Python?",
        "answer": "my_list = [1, 2, 3, 4, 5]\nmy_list.pop()\nHere, −1 represents the last element of the list. Hence, the pop() function removes the last object (obj) from the list.\nGet certified in Python from the top Python Course in Delhi now!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "58. What is the method for generating random numbers in Python?",
        "answer": "This is achieved by importing the random module. It is the module that is used to generate random numbers.\nSyntax:\nimport random\nrandom.random # returns the  floating point random number between the range of [0,1].",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "59. Explain how to convert a string to all lowercase?",
        "answer": "To convert a string to all lowercase in Python, you can use the built-in lower() method. The lower() method is available for strings and returns a new string with all characters converted to lowercase.\nFor Example:\ndemo_string='ROSES'\nprint(demo_string.lower())\nLearn the complete Python Training in Hyderabad in 24 hours!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "60. What benefits do NumPy arrays provide compared to (nested) Python lists?",
        "answer": "Nested Lists:\nPython lists are efficient, general-purpose containers that support efficient operations like insertion, appending, deletion, and concatenation.\nThe limitations of lists are that they don’t support “vectorized” operations like element-wise addition and multiplication, and the fact that they can contain objects of differing types means that Python must store the data type information for every element, and must execute type dispatching code when operating on each element.\nNumpy:\nNumPy is more efficient and more convenient, as you get a lot of vector and matrix operations for free, this helps avoid unnecessary work and complexity of the code. NumPy is also efficiently implemented when compared to nested lists.\nNumPy array is faster and contains a lot of built-in functions, that will help in FFTs, convolutions, fast searching, linear algebra, basic statistics, histograms, etc.\n\nAdvanced Python Interview Questions for Experienced",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "61. What is functional programming? Does Python follow a functional programming style? If yes, list a few methods to implement functionally oriented programming in Python?",
        "answer": "Functional programming is a coding style where the main source of logic in a program comes from functions.\nIncorporating functional programming in our codes means writing pure functions.\nPure functions are functions that cause little or no changes outside the scope of the function. These changes are referred to as side effects. To reduce side effects, pure functions are used, which makes the code easy-to-follow, test, or debug.\nPython follows a functional programming style. Following are some examples of functional programming in Python.\nfilter(): Filter lets us filter some values based on a conditional logic.\nlist(filter(lambda x:x>6,range(9))) [7, 8]\n\nmap(): Map applies a function to every element in an iterable.\nlist(map(lambda x:x**2,range(5))) [0, 1, 4, 9, 16, 25]\n\nreduce(): Reduce repeatedly reduces a sequence pair-wise until it reaches a single value.\n\nfrom functools import reduce >>> reduce(lambda x,y:x-y,[1,2,3,4,5]) -13",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "62. Explain monkey patching in Python?",
        "answer": "Monkey patching is the term used to denote modifications that are done to a class or a module during runtime. This can only be done as Python supports changes in the behavior of the program while it is being executed.\nThe following is an example, denoting monkey patching in Python:\n# monkeyy.py\nclass X:\n    def func(self):\n        print(\"func() is being called\")\nThe above module (monkeyy) is used to change the behavior of a function at runtime as shown below:\nimport monkeyy\ndef monkey_f(self):\n    print(\"monkey_f() is being called\")\n# Replacing the address of \"func\" with \"monkey_f\"\nmonkeyy.X.func = monkey_f\n\nobj = monkeyy.X()\n\n# Calling the function \"func\" whose address was replaced with \nthe function \"monkey_f()\"\nobj.func()",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "63. Explain about generators in Python?",
        "answer": "Generators in Python are special functions that can be used to create iterable objects. Unlike regular functions that return a value and then terminate, generators use the yield keyword to suspend execution temporarily and yield a value one at a time. This makes generators memory efficient, as they don’t generate the entire sequence of values upfront but rather generate values on-demand.\nGenerators are helpful when dealing with large datasets or when the complete sequence of values is not needed at once. They allow us to iterate over a potentially infinite sequence without consuming excessive memory.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "64. Explain the difference between pickling and unpickling?",
        "answer": "The Pickle module accepts the Python object, and converts it into a string representation and stores it into a file by using the dump function. This process is called pickling. On the other hand, the process of retrieving the original Python objects from the string representation is called unpickling.\nWant to know about the real-world uses of Python? Read our detailed blog on Python Applications now.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "65. What is the difference between %, /, // ?",
        "answer": "In Python, %, /, and // are arithmetic operators with distinct functions:\nThe ‘ % ’ is the modulo operator, which returns the remainder of a division. For instance, 5 % 2 would return 1.\nThe ‘ / ’ is the division operator that performs floating-point division and returns a float. For example, 5 / 2 would return 2.5.\nThe ‘ // ’ is the floor division operator that performs division but rounds down the result to the nearest whole number. So 5 // 2 would return 2.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "66. What are decorators?",
        "answer": "In Python, decorators serve as essential functions that enable the addition of functionality to an already existing function without altering its structure. These decorators are denoted by the @decorator_name syntax in Python and are invoked in a bottom-up manner. Below is an example illustrating how decorators work correctly:\ndef decorator_lowercase(function):   # defining a Python decorator\n    def wrapper():\n        result = function()\n        result_lowercase = result.lower()\n        return result_lowercase\n    return wrapper\n@decorator_lowercase ## calling the decorator\ndef intro():                     # Normal function\n    return 'Hello, I AM SAM'\n\nprint(intro())\nOutput: ‘hello,i am sam’",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "67. What is scope resolution?",
        "answer": "In Python, a scope defines the region of code where an object remains valid and accessible. Every object in Python operates within its designated scope. Namespaces are used to uniquely identify objects within a program, and each namespace is associated with a specific scope where objects can be used without any prefix. The scope of a variable determines its accessibility and lifespan.\nLet’s explore the different scopes created during code execution:\nLocal scope: This refers to the objects that are defined within the current function and are accessible only within that function.\nGlobal scope: Objects in the global scope are available throughout the execution of the code. \nModule-level scope: This scope encompasses global objects that are associated with the current module in the program. These objects are accessible within the module.\nOutermost scope: This refers to all the built-in names that can be called from anywhere in the program.\nInterested in learning React JS? Click here to learn more about this React JS Certification!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "68. How can you shuffle the elements of a list in Python?",
        "answer": "This can be easily achieved by using the Shuffle() function from the random library, as shown below:\nfrom random import shuffle\nimport random\n \nmy_list = [1, 2, 3, 4, 5]\nrandom.shuffle(my_list)\nprint(my_list)\nThis code will randomly reorder the elements in my_list.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "69. Describe the split(), sub(), and subn() methods found within Python's 're' module?",
        "answer": "These methods belong to the Python RegEx or ‘re’ module and are used to modify strings.\nsplit(): This method is used to split a given string into a list.\nsub(): This method is used to find a substring where a regex pattern matches, and then it replaces the matched substring with a different string.\nsubn(): This method is similar to the sub() method, but it returns the new string, along with the number of replacements.\nLearn more about Python from this Python Training in Pune to get ahead in your career!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "70. What is a map function in Python?",
        "answer": "The map() function in Python has two parameters, function and iterable. The map() function is a powerful tool that allows you to apply a specified function to every element within an iterable. It takes two arguments: the function you want to apply and the iterable containing the elements you want to process. This function is a versatile way to perform operations on multiple items simultaneously, making your code more efficient and concise\nFor example:\ndef calculateSq(n):\nreturn n*n\nnumbers = (2, 3, 4, 5)\nresult = map( calculateSq, numbers)\nInterested in learning Python? Check out this Python Course in Mumbai!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "71. Why doesn't Python deallocate all memory upon exit?",
        "answer": "Whenever Python exits, especially those Python modules, which are having circular references to other objects or the objects that are referenced from the global namespaces, the memory is not always de-allocated or freed.\nIt is not possible to de-allocate those portions of memory that are reserved by the C library.\nOn exit, because of having its own efficient clean-up mechanism, Python will try to de-allocate every object.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "72. Can you write an efficient code to count the number of capital letters in a file?",
        "answer": "The normal solution for this problem statement would be as follows:\nwith open(SOME_LARGE_FILE) as countletter:\ncount = 0\ntext = countletter.read()\nfor character in text:\n    if character.isupper():\n        count += 1\nTo make this code more efficient the whole code block can be converted into a one-line code using the feature called generator expression. With this, the equivalent code line of the above code block would be as follows:\ncount = sum(1 for line in countletter for character in line if character.isupper())",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "73. How does Python Flask handle database requests?",
        "answer": "Flask supports a database-powered application (RDBS). Such a system requires creating a schema, which needs piping the schema.sql file into the sqlite3 command. Python developers need to install the sqlite3 command to create or initiate the database in Flask.\nFlask allows to request for a database in three ways:\nbefore_request(): They are called before a request and pass no arguments.\nafter_request(): They are called after a request and pass the response that will be sent to the client.\nteardown_request(): They are called in a situation when an exception is raised and responses are not guaranteed. They are called after the response has been constructed. They are not allowed to modify the request, and their values are ignored.\nSign up for the Full Stack Developer Course to begin your career journey today.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "74. What is a docstring in Python?",
        "answer": "Python lets users include a description (or quick notes) for their methods using documentation strings or docstrings. Docstrings are different from regular comments in Python. Rather than being completely ignored by the Python interpreter, like in the case of comments, these are defined within triple quotes.\nSyntax:\n\"\"\"\nUsing docstring as a comment.\nThis code add two numbers\n\"\"\"\nx=7\ny=9\nz=x+y\nprint(z)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "75. What is regression?",
        "answer": "Regression is termed as a supervised machine learning algorithm technique, which is used to find the correlation between variables. It helps predict the value of the dependent variable (y) based on the independent variable (x). It is mainly used for prediction, time series modeling, forecasting, and determining the causal-effect relationship between variables.\nScikit library is used in Python to implement the regression and all machine learning algorithms.\nThere are two different types of regression algorithms in machine learning :\nLinear Regression: Used when the variables are continuous and numeric in nature\nLogistic Regression: Used when the variables are continuous and categorical in nature",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "76. What is classification?",
        "answer": "Classification refers to a predictive modeling process where a class label is predicted for a given example of input data. It helps categorize the provided input into a label that other observations with similar features have. For example, it can be used for classifying a mail whether it is spam or not, or for checking whether users will churn or not based on their behavior.\nThese are some of the classification algorithms used in Machine Learning:\nDecision tree\nRandom forest classifier\nSupport vector machine",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "77. Write a program in Python to execute the Bubble sort algorithm?",
        "answer": "Check out the code below to execute bubble sort-\ndef bubbleSort(x):\n    n = len(x)\n    # Traverse through all array elements\n    for i in range(n-1):\n        for j in range(0, n-i-1):\n            if x[j] > x[j+1]:\n                x[j], x[j+1] = x[j+1], x[j]\n\n# Driver code to test above\narr = [25, 34, 47, 21, 22, 11, 37]\nbubbleSort(arr)\n\nprint(\"Sorted array is:\")\nfor i in range(len(arr)):\n    print(arr[i])\nOutput:\n11,21,22,25,34,37,47",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "78. Create a Python sorting algorithm for a dataset of numbers?",
        "answer": "code to sort a list in Python:\nmy_list = [\"8\", \"4\", \"3\", \"6\", \"2\"]\n\nmy_list = [int(i) for i in list]\n\nmy_list.sort()\n\nprint (my_list)\nOutput:\n2,3,4,6,8",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "79. Write a Program to print ASCII Value of a character in Python?",
        "answer": "Check the below code to print the ASCII value:\nx= 'a'\n\n# print the ASCII value of the assigned character stored in x\n\nprint(\" ASCII value of '\" + x + \"' is\", ord(x))\nOutput: 65",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "80. What is the lambda function in Python?",
        "answer": "A Python lambda function is an anonymous function (a function that does not have a name). To define anonymous functions, we use the ‘lambda’ keyword instead of the ‘def’ keyword, hence the name ‘lambda function’. Lambda functions can have any number of arguments but only one statement.\nFor example:\nl = lambda x,y : x*y\nprint(a(5, 6))\nOutput:30\nAny more queries? Feel free to share all your doubts with us in our Python Community and get them clarified today!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "81. What does 'self' mean in Python?",
        "answer": "Self is an object or an instance of a class. This is explicitly included as the first parameter in Python. On the other hand, in Java it is optional. It helps differentiate between the methods and attributes of a class with local variables.\nThe self variable in the init method refers to the newly created object, while in other methods, it refers to the object whose method was called.\nSyntax:\nClass A:\n    def func(self):\n        print(\"Hi\")",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "82. What is the difference between append() and extend() methods?",
        "answer": "Both append() and extend() methods are used to add elements at the end of a list.\nThe primary differentiation between the append() and extend() methods in Python is that append() is used to add a single element to the end of a list. In contrast, open () is used to append multiple aspects, such as another list or an iterable, to the end of a list.\nFor in-depth knowledge, check out our Python Tutorial and boost your Python skills!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "83. Which one of the following is not the correct syntax for creating a set in Python?",
        "answer": "set([[1,2],[3,4],[4,5]])\nset([1,2,2,3,4,5])\n{1,2,3,4}\nset((1,2,3,4))\nAns.\nset([[1,2],[3,4],[4,5]])\nExplanation: The argument given for the set must be iterable.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "84. What is the difference between / and // operators in Python?",
        "answer": "/: is a division operator and returns the value of the quotient.\n10/3\n3.33\n//: is known as the floor division operator and is used to return the value of the quotient before the decimal point.\n10//3\n3",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "85. What is Pandas?",
        "answer": "Pandas is an open-source Python library , which supports data structures for data-based operations associated with data analyzing and data manipulation. Pandas, with its rich sets of features, fits in every role of data operation, whether it be related to implementing different algorithms or solving complex business problems. Pandas helps to deal with a number of files in performing certain operations on the data stored by files.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "86. What are DataFrames?",
        "answer": "A dataframe refers to a two dimensional mutable data structure or data aligned in a tabular form with labeled axes(rows and column).\nSyntax:\npandas.DataFrame( data, index, columns, dtype)\ndata: It refers to various forms like ndarray, series, map, lists, dict, constants and can take other DataFrame as Input.\nIndex: This argument is optional as the index for row labels will be automatically taken care of by Pandas library.\ncolumns: This argument is optional as the index for column labels will be automatically taken care of by the Pandas library.\ndtype: It refers to the data type of each column.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "87. What is the difference between DataFrames and Series?",
        "answer": "A Series is a one-dimensional array-like object in pandas that can hold any data type, while a DataFrame is a two-dimensional, table-like structure with potentially heterogeneously-typed columns. You can think of a DataFrame as a collection of Series objects that share the same index.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "88. What is the process for merging DataFrames in Pandas?",
        "answer": "Different DataFrames can be easily combined with the help of functions listed below:\nAppend(): This function is used for the horizontal stacking of DataFrames.\ndata_frame1.append(data_frame2)\nconcat(): This function is used for vertical stacking and is best suited when the DataFrames to be combined possess the same column and similar fields.\npd.concat([data_frame1, data_frame2])\njoin(): This function is used to extract data from different DataFrames, which have one or more columns in common.\ndata_frame1.join(data_frame2)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "89. How do you split the data in train and test dataset in Python?",
        "answer": "This can be achieved by using the scikit machine learning  library and importing train_test_split function in Python as shown below:\nfrom sklearn.model_selection import train_test_split\n\n# test size = 30% and train = 70%\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=0)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "90. Why is a set known as unordered? Is it mutable or immutable?",
        "answer": "A set is called “unordered” because the items in a set don’t have a specific order or sequence like a list does. It’s more like a collection of items, and you can’t access them by their position.\nSets in Python are mutable, which means you can add or remove items from a set after it’s created. However, the items within the set (the elements) are themselves immutable, meaning they cannot be changed. You can add or remove elements from a set, but you can’t modify the elements themselves once they’re in the set.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "91. Explain the difference between percentile and quantiles in Python?",
        "answer": "In Python, percentiles and quantiles are related but different concepts.\nPercentiles divide a dataset into 100 equal parts, allowing you to understand the relative position of a value within the entire dataset. For example, the 25th percentile corresponds to the value below which 25% of the data falls.\nQuantiles, on the other hand, divide the dataset into any number of equal parts, such as quartiles (four parts) or quintiles (five parts). They offer a more flexible way to segment the data for analysis.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "92. What is SVM?",
        "answer": "Support vector machine (SVM) is a supervised machine learning model that considers the classification algorithms for two-group classification problems. Support vector machine is a representation of the training data as points in space are separated into categories with the help of a Support Vector Machine (SVM) is a supervised machine learning model for classifying data into two groups. It is particularly suitable for binary classification problems. SVM represents the training data as points in space and aims to separate them into distinct categories. The separation is achieved by identifying a clear gap between the data points, and the SVM model strives to maximize the width of this gap.\nWant to become a Machine Learning expert? Enroll in our Machine Learning Certification Today!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "93. Write a program in Python to produce Star triangle?",
        "answer": "The below code produces a star triangle-\ndef Star_triangle(n):\n    for x in range(n):\n        print(' '*(n-x-1)+'*'*(2*x+1))\n\nStar_triangle(9)\nOutput:\n*\n***\n*****\n*******\n*********\n***********\n*************\n***************\n*****************\nLearn how to calculate the Fibonacci Series in C with this easy-to-follow blog!",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "94. Write a program to produce Fibonacci series in Python?",
        "answer": "The Fibonacci series refers to a series where an element is the sum of two elements prior to it.\nn = int(input(“number of terms? “))\nn1, n2 = 0, 1\ncount = 0\nif n <= 0: print(\"Please enter a positive integer\") elseif n == 1: print(\"Fibonacci sequence upto\", n, \":\") print(n1) else: print(\"Fibonacci sequence:\") while count < n: print(n1) nth = n1 + n2 n1 = n2 n2 = nth count += 1 [/code]",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "95. Write a program in Python to check if a number is prime?",
        "answer": "The below code is used to check if a number is prime or not\nnum = 13\n\nif num > 1:\n    for i in range(2, int(num/2)+1):\n        if (num % i) == 0:\n            print(num, \"is not a prime number\")\n            break\n    else:\n        print(num, \"is a prime number\")\nelse:\n    print(num, \"is not a prime number\")\nOutput:\n13 is a prime number\n\nPython OOPs Interview Questions",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "96. What are classes and objects?",
        "answer": "A class is a blueprint for creating objects. It contains member functions, attributes, etc. that get instantiated when the object is called.\nOn the other hand, an object is nothing but an instance of a class, possessing state, identity, and functionality, and is used to call class members.\nLet’s take a look at a simple example:\nHere, we will create a class named office using Python\nclass Office:\ndef __init__(self): \nprint(\"class is created\")\n\ndef sample(self):\nself.employee = \"ramesh\"\nprint(self.employee)\n\nNow we will create an object for the class Office.\n#Object is created\nobj = Office()\n#using object to call member functions and their attributes\nobj.sample()\nHere the output shows the creation of a class in Python, and using an object to call member functions and their attributes.\nOutput:\nclass is created\nramesh",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "97. What is abstraction?",
        "answer": "One of the pillars of object-oriented programming is abstraction. Abstraction is a very simple process where only the necessary details are shown and the background computations or processes stay hidden. To simplify, let’s try to understand abstraction with an example:\nLet’s say you visit a motor showroom to buy your new car. The dealer will take you for a quick ride to show you the features of the car.\nThe noticeable thing here is that you will be shown the entire car, but you will not be able to figure out how the actual combustion and other necessary details to move the car are working. And this is exactly how abstraction works: only the necessary details are shown, and internal functionality is hidden from the users.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "98. What are constructors?",
        "answer": "Constructors are called when an object is created for a class. Constructors are used to instantiate the objects and assign values to them. Let’s take a look at a simple example:\nclass Office:\ndef __init__(self): \nprint(\"class is created\")\n\n#Object is created\nobj = Office()\nAs soon as the object is created, the constructor is called, and the output shows “class is created.” Similarly, we can use constructors like list(), int() to instantiate and assign values to them.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "99. Write a program to depict inheritance and its types in Python?",
        "answer": "Let’s take a look at a simple example in Python to understand inheritance and its types:\n#single inheritance\nclass Animals:\ndef House(self):\nprint(\"lives in Jungle\")\n\nclass Snakes(Animals):\ndef eats(self):\nprint(\"eats insects\")\n\nobj = Snakes()\nobj.House()\nobj.eats()\nOutput:\nlives in Jungle\neats insects\n\n#multiple inheritance\nclass Maths:\ndef Marks(self): \nself.maths = 90\n\nclass English:\ndef Marks(self):\nself.english = 85\n\nclass Result(Maths, English):\ndef __init__(self):\nMaths.Marks(self)\nEnglish.Marks(self)\n\n\ndef result(self):\nself.res = (self.maths + self.english) // 2\nprint(\"The result is : {}%\".format(self.res))\n\n\nobj = Result()\nobj.result()\nOutput:\nThe result is : 87%\n#multi-level inheritance\nclass Vehicle:\ndef __init__(self):\nself.Type = \"Commercial\"\nprint(\"Vehicle Type : {}\".format(self.Type))\n\nclass Name(Vehicle):\ndef __init__(self):\nself.Name = \"Ashok Leyland\"\nprint(\"Vehicle Name: \".format(self.Name))\n\nclass Final(Name):\ndef __init__(self):\nName.__init__(self)\nVehicle.__init__(self)\nself.Tyres = 8\nprint(\"Number of tyres is: {}\".format(self.Tyres))\n\n\nobj = Final()\nOutput:\nVehicle Name:\nVehicle Type : Commercial\nNumber of tyres is: 8\n\nPython Pandas Interview Questions",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "100. What are some of the string operations that can be performed using Pandas in Python?",
        "answer": "There are various operations you can perform using Pandas in Python. Some of the examples are as follows:\nMaking all the strings uppercase\nimport pandas as pd\n\nsample = pd.Series(['Rohit Sharma',\n\n                    'Virat Kohli',\n\n                    'Shubman Gill',\n\n                    'Ravindra Jadeja',\n\n                    'KL Rahul'])\n\n\n\n\n#make all strings to uppercase letters\n\nsample.str.upper()\nOutput:\n0       ROHIT SHARMA\n1        VIRAT KOHLI\n2       SHUBMAN GILL\n3    RAVINDRA JADEJA\n4           KL RAHUL\ndtype: object\nMaking all the strings lowercase\nimport pandas as pd\n\nsample = pd.Series(['Rohit Sharma',\n\n                    'Virat Kohli',\n\n                    'Shubman Gill',\n\n                    'Ravindra Jadeja',\n\n                    'KL Rahul'])\n\n\n\n\n#make all strings to lowercase letters\n\nsample.str.lower()\nOutput:\n0       rohit sharma\n\n1        virat kohli\n\n2       shubman gill\n\n3    ravindra jadeja\n\n4           kl rahul\n\ndtype: object\nCheck whether the string starts with a pattern\nimport pandas as pd\n\nsample = pd.Series(['Rohit Sharma',\n\n                    'Virat Kohli',\n\n                    'Shubman Gill',\n\n                    'Ravindra Jadeja',\n\n                    'KL Rahul'])\n\n\n\n\n#make all strings to uppercase letters\n\nsample.str.startswith('R')\nOutput:\n0     True\n1    False\n2    False\n3     True\n4    False\ndtype: bool\nSplitting the strings\nimport pandas as pd\n\nsample = pd.Series(['Rohit Sharma',\n\n                    'Virat Kohli',\n\n                    'Shubman Gill',\n\n                    'Ravindra Jadeja',\n\n                    'KL Rahul'])\n\n\n\n\n#make all strings to uppercase letters\n\nsample.str.split(\" \")\nOutput:\n0       [Rohit, Sharma]\n1        [Virat, Kohli]\n2       [Shubman, Gill]\n3    [Ravindra, Jadeja]\n4           [KL, Rahul]\ndtype: object\nFinding the string\nimport pandas as pd\n\nsample = pd.Series(['Rohit Sharma',\n\n                    'Virat Kohli',\n\n                    'Shubman Gill',\n\n                    'Ravindra Jadeja',\n\n                    'KL Rahul'])\n\n\n\n\n#make all strings to uppercase letters\n\nsample.str.find(\"R\")\nOutput:\n0    0\n1   -1\n2   -1\n3    0\n4    3\ndtype: int64\nStripping the whitespaces in the string\nimport pandas as pd\n\nsample = pd.Series([' Rohit Sharma ',\n\n                    ' Virat Kohli  ',\n\n                    ' Shubman Gill    ',\n\n                    '   Ravindra Jadeja  ',\n\n                    '     KL Rahul '])\n\n\n\n\n#make all strings to uppercase letters\n\nsample.str.strip()\nOutput:\n0       Rohit Sharma\n1        Virat Kohli\n2       Shubman Gill\n3    Ravindra Jadeja\n4           KL Rahul\ndtype: object\nReplacing a string with another\nimport pandas as pd\n\nsample = pd.Series(['Rohit Sharma',\n\n                    'Virat Kohli',\n\n                    'Shubman Gill',\n\n                    'Ravindra Jadeja',\n\n                    'KL Rahul'])\n\n\n\n\n#make all strings to uppercase letters\n\nsample.str.replace('Shubman Gill', 'Rishabh Pant')\nOutput:\n0       Rohit Sharma\n1        Virat Kohli\n2       Rishabh Pant\n3    Ravindra Jadeja\n4           KL Rahul\ndtype: object",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "101. How can you perform stacking operations on a Pandas DataFrame?",
        "answer": "Stacking is used to reshape the DataFrames. Let’s take a look at a simple example:\nsample = pd.DataFrame([[65, 158], [92, 183]],\n\n                      index=['Ramesh', 'Suresh'],\n\n                      columns=['weight', 'height'])\n\n\n\n\nsample.stack()\nOutput:\nRamesh  weight     65\nheight    158\nSuresh   weight     92\nheight    183\ndtype: int64",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "102. How do you remove the index from a Pandas DataFrame?",
        "answer": "To remove the index from a dataframe, we can add a simple line of code as follows:\nimport pandas as pd\n\ndata = pd.DataFrame({\"student_id\": [29, 59, 72, 54],\n\n                       \"Name\": ['sravan', 'jyothika',\n\n                                'harsha', 'ramya'],})\n\n\n\n\ndata.index = data['student_id']\n\ndel data['student_id']\n\n\n\n\ndata\nOutput:",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "103. How do you create a dataframe, and what are some of the operations you can perform on Pandas DataFrames?",
        "answer": "There are several ways to create a dataframe in Python, some of them are as follows:\npd.DataFrame([['Ajay', 23], ['Neelam', 25], ['Anita', 42]], columns=['Name', 'Age'])\nOutput:\n\n2.\nDataFrame({'Name': ['Ajay', 'Neelam', 'Anita'],\n\n              'Age': [23,25,42]})\n\n3.\nDataFrame([{'Name': 'Ajay', 'Age': 23},\n\n{'Name': 'Neelam', 'Age': 25},\n\n{'Name': 'Anita', 'Age': 42}])\n\nSome of the operations that you can perform on the data frames are as follows:\nManipulation\nData imputation\nMerging operations\nMeasures of central tendency\nMeasures of kurtosis\nMeasures of spread\nVisualizations",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "104. How do you create a series in Pandas in different ways?",
        "answer": "A series in Pandas can be created in the following ways:\nSeries(range(0,100, 10), index=[x for x in range(0,20, 2)])\nOutput:\n0      0\n2     10\n4     20\n6     30\n8     40\n10    50\n12    60\n14    70\n16    80\n18    90\ndtype: int64\nx = [1,2,3,4,5]\ny = ['One', 'Two', 'Three', 'Four', 'Five']\n\npd.Series(y, index = x)\n[code language=\"python\"]\nOutput:\n1      One\n2      Two\n3    Three\n4     Four\n5     Five\ndtype: object\ndictionary = {'One': 1, 'Two': 2, 'Three':3, 'Four':4, 'Five':5}\npd.Series(dictionary)\nOutput:\nOne      1\nTwo      2\nThree    3\nFour     4\nFive     5\ndtype: int64\n\nNumpy Interview Questions",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "105. Create a Numpy array in the shape of 2x3 with random integers in the range 0-100. Reshape the array in the shape 3x2 and print the updated shape of the resultant array?",
        "answer": "import numpy as np\n\narr1= np.random.randint(0,101, (2,3))\n\nprint(arr1)\n\nnewarr1= arr1.reshape(3,2)\n\nprint(newarr1.shape)\nOutput:\n[[35 61 24]\n[20 38 31]]\n(3, 2)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "106. Create an array that will have days from an entire year in the datetime format using the datetime64 Numpy method?",
        "answer": "from datetime import datetime\n\nimport random\n\ndarr = np.arange('2024-01-01', '2025-01-01',dtype='datetime64')\n\nprint(darr)\nThe print statement will give us the desired output.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "107. For the given two arrays A and B, find the correlation coefficients?",
        "answer": "A = np.array([[11,17,42],[21,19,27]])\nB = np.array([[12,44,39],[62,81,10]])\nA = np.array([[11,17,42],[21,19,27]])\n\nB = np.array([[12,44,39],[62,81,10]])\n\ncorr= np.corrcoef(A,B)\n\nprint(corr)\nOutput:\n[[ 1.          0.9106039   0.53232532 -0.90264562]\n[ 0.9106039   1.          0.13487934 -0.99982205]\n[ 0.53232532  0.13487934  1.         -0.11616343]\n[-0.90264562 -0.99982205 -0.11616343  1.        ]]",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "108. Given an array A, perform the following operations?",
        "answer": "A = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15], [16,17,18]])\nHorizontal split\nVertical Split\nRow Split\nColumn Split\nA = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15], [16,17,18]])\nHorizontal split\nha= np.hsplit(A,3)\n\nprint(ha)\nOutput:\n[array([[ 1],\n[ 4],\n[ 7],\n[10],\n[13],\n[16]]), array([[ 2],\n[ 5],\n[ 8],\n[11],\n[14],\n[17]]), array([[ 3],\n[ 6],\n[ 9],\n[12],\n[15],\n[18]])]\nVertical split\nva= np.vsplit(A,6) #or can also do A,3 ; A,2\n\nprint(va)\nOutput:\n[array([[1, 2, 3]]), array([[4, 5, 6]]), array([[7, 8, 9]]), array([[10, 11, 12]]), array([[13, 14, 15]]), array([[16, 17, 18]])]\nRow Split\nra= A[0 , : ]\n\nprint(ra)\nOutput:\n[1 2 3]\nColumn Split\nca= A[: , 0]\n\nprint(ca)\nOutput:\n[ 1  4  7 10 13 16]",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "109. For the given two arrays A and B. a = np.array([[2,9],[6,13]]) b = np.array([[1,4],[3,11]]) Perform the following operations: a. Cross product of A and B. b. Dot product of A and B. c. Matrix multiplication of A and B. d. Square root of A and B?",
        "answer": "a = np.array([[2,9],[6,13]])\n\nb = np.array([[1,4],[3,11]])\nCross Product\ncross=np.cross(a,b)\n\nprint(cross)\nOutput:\n[-1 27]\nDot Product\ndot = np.dot(a,b)\n\nprint(dot)\nOutput:\n[[ 29 107]\n[ 45 167]]\nMatrix multiplication\nm_multi= np.multiply(a,b)\n\nprint(m_multi)\nOutput:\n[[  2  36]\n[ 18 143]]\nSquare root\nsq_a= np.sqrt(a)\n\nprint(sq_a)\nOutput:\n[[1.41421356 3.        ]\n[2.44948974 3.60555128]]\n\nPython Libraries Interview Questions",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "110. What is Matplotlib, and how and why do you use it using Python?",
        "answer": "Matplotlib is a powerful open-source data visualization library in Python that helps us create static and interactive plots. This library gives us some of the simplest functions to create a plot. Different types of plots are provided, including bar plots, line plots, area plots, box plots, scatter plots, etc.\nLet’s see how to use this library with an example of creating a bar plot.\nStep 1: Matplotlib library in Python needs to be imported before use. We can install this library with the help of pip, which is a package management system.\n\nStep 2: We need to import the library\n\nStep 3: Collect data that you want to visualize. This data can be in the form of a list, tuple, dataframe, etc.\nStep 4: Visualizing the bar plot in the simplest way. We can further customize it to make it look better.\n\nUses of Matplotlib:\nMatplotlib is open-source.\nProvides simple functions to visualize\nSupports different forms of data\nGives high-quality images in different formats.\nCan run on different platforms",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "111. How do you use Scipy, and what are some of the operations you can perform using Python?",
        "answer": "SciPy in Python refers to Scientific Python. It is an open-source library built on NumPy to perform signal processing, numerical operations, linear algebra, and more. SciPy has more features when it comes to computations compared to NumPy. Some of the sub-packages in SciPy include: scipy.special, scipy.signal, scipy.stats, scipy.linalg etc.\nHow to use SciPy:\nStep1: Install the library\n\nStep 2: Import the library\n\nStep 3: Using the library. We have different sub-packages in SciPy, as mentioned above, so let’s discuss some of them below.\nscipy.special\nContains advanced mathematical functions, like gamma, square root, elliptic functions etc.\nBelow is the code for the gamma function in scipy.special.\n\nscipy.stats\nUsed to provide a wide range of statistical operations to analyze the data.\nBelow is the code to extract 5 random samples from a normal distribution.\n\nscipy.signal\nUsed in signal processing tasks.\nBelow is the code for creating hamming-type windows, which are used for filter design and spectral analysis.\n\nscipy.linalg\nUsed for advanced linear algebra tasks.\nBelow is the code to find the eigenvalues and vectors of a matrix.\n\nAbove are some of the many operations we have in the Scipy library.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "112. Plotly is one of the most popular Python libraries. Give an example using Python?",
        "answer": "Plotly is a Python library well known for its interactive plots. Just like other libraries, Plotly also provides a large variety of plots. Let’s look at the example below:\nStep 1: Import necessary libraries like graph objects from the Plotly library and Numpy\n\nStep 2: Gather data necessary for plotting the graph.\n\nStep 3: Specify the kind of plot. In our case, it’s the scatter plot.\n\nStep 4: Specify a title and labels for the x and y axis.\n\nStep 5: Combining trace and layout to create a figure.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "113. Which library would you use to perform linear algebra operations using Python?",
        "answer": "The NumPy library offers a package – numpy.linalg that can be used to perform linear algebra operations using Python.\nHere is a simple example to show how you can use it:\nimport numpy\na = numpy.array([[1, 2], [2, 6]])\nnumpy.linalg.det(a)\nOutput:\n2.0\n\nPython Interview Questions for Data Science",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "114. Why would you use NumPy arrays instead of lists in Python?",
        "answer": "NumPy arrays provide users with three main advantages, as shown below:\nNumPy arrays consume a lot less memory, thereby making the code more efficient.\nNumPy arrays execute faster and do not add heavy processing to the runtime.\nNumPy has a highly readable syntax, making it easy and convenient for programmers.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "115. How can you use Python libraries for web scraping?",
        "answer": "Web scraping is a process where we visit a webpage and scrape the desired data from the webpage in a format that can be a .json format and analyze or use it according to our requirements. The Python libraries that prove to be a very good addition to the tally in terms of web scraping are Beautiful Soup, Scrapy, Requests, etc.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "116. How do you identify missing values and deal with missing values in Dataframe?",
        "answer": "Identification:\nisnull() and isna() functions are used to identify the missing values in your data loaded into dataframe.\nmissing_count=data_frame1.isnull().sum()\nHandling missing Values:\nThere are two ways of handling the missing values :\nReplace the  missing values with 0\ndf[‘col_name’].fillna(0)\nReplace the missing values with the mean value of that column\ndf[‘col_name’] = df[‘col_name’].fillna((df[‘col_name’].mean()))\n\nPython Coding Interview Questions",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "117. Create a palindrome checker using Python. Using item assignment to an empty array?",
        "answer": "string = 'madame'\nres = []\ndef checker(x):\nres = x[::-1]\nif res == x:\nprint('Palindrome')\n\nelse:\nprint(\"not a palindrome\")\n\nchecker(string)\nOutput:\nnot a palindrome",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "118. Write a Python program that will print the length of an array without using the len() function?",
        "answer": "a = [1,2,3,4,5]\ncount = 0\nfor i in a:\ncount = count + 1\n\nprint(count)\nOutput:\n5",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "119. Write a program to find the greatest of the two numbers?",
        "answer": "We can get the indices of N maximum values from a NumPy array using the below code:\nimport numpy as np\n\nar = np.array([1, 3, 2, 4, 5, 6])\n\nprint(ar.argsort()[-3:][::-1])",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "120. What is the easiest way to calculate percentiles when using Python?",
        "answer": "The easiest and the most efficient way you can calculate percentiles in Python is to make use of NumPy arrays and its functions.\nConsider the following example:\nimport numpy as np\na = np.array([1,2,3,4,5,6,7])\np = np.percentile(a, 50) #Returns the 50th percentile, which is also the median\nprint(p)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "121. Write a Python program to check whether a given string is a palindrome or not, without using an iterative method?",
        "answer": "A palindrome is a word, phrase, or sequence that reads the same backward as forward, e.g., madam, nurses run, etc.\nConsider the below code:\ndef fun(string):\ns1 = string\ns = string[::-1]\nif s1 == s:\nreturn True\nelse:\nreturn False\n\nprint(fun(\"madam\"))\n\nPython Technical Interview Questions",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "122. Write a Python program to calculate the sum of a list of numbers?",
        "answer": "def sum(num):\nif len(num) == 1:\nreturn num[0] # With only one element in the list, the sum result will be equal to the element.\nelse:\nreturn num[0] + sum(num[1:])\n\nprint(sum([2, 4, 5, 6, 7]))",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "123. Write a program to find the greatest of the two numbers?",
        "answer": "x = 5\ny = 10\nprint(\"x is greater\") if x > y else print('Both are equal') if x == y else print('Y is greater')\nOutput:\nY is greater\n\nx = 15\ny = 5\nprint(\"x is greater\") if x > y else print('Both are equal') if x == y else print('Y is greater')\nOutput:\nx is greater\n\nx = 15\ny = 15\nprint(\"x is greater\") if x > y else print('Both are equal') if x == y else print('Y is greater')\nOutput:\nBoth are equal",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "124. Write a Python program to check if the given input is an Armstrong number or not?",
        "answer": "def armstrong(num):\nsum = 0\ntemp = num\nwhile temp > 0:\nx = temp % 10\nsum = sum + x**3\ntemp = temp // 10\n\nprint(\"armstrong\") if sum == num else print(\"not an armstrong\")\n\n\narmstrong(153)\nOutput:\nArmstrong",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "125. Create a Python program to depict list comprehension?",
        "answer": "Here is a simple example of how to create a list using list comprehension.\n[x**2 for x in range(0,100,10)]\nOutput:\n[0, 100, 400, 900, 1600, 2500, 3600, 4900, 6400, 8100]",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "126. Create a Python program that will depict dictionary comprehension in Python?",
        "answer": "A simple example of how to create a dictionary using dictionary comprehension\n{x: x**2 for x in range(0,100,10)}\nOutput:\n{0: 0,\n10: 100,\n20: 400,\n30: 900,\n40: 1600,\n50: 2500,\n60: 3600,\n70: 4900,\n80: 6400,\n90: 8100}",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "127. Write a Python program to show abstraction in Python?",
        "answer": "from abc import ABC, abstractmethod\n\nclass A(ABC):\n@abstractmethod\ndef sum(self):\npass\n\n\nclass B(A):\ndef sum(self, a, b):\nself.a = a\nself.b = b\nreturn self.a // self.b\n\nobj = B()\nobj.sum(30,4)\nOutput:\n7.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "128. What is a regular expression, and how do you use it in Python?",
        "answer": "The concept of regular expressions emerges with the need to optimize searching algorithms for strings. Match patterns called regular expressions are used to find or replace the matching patterns in strings while performing string operations.\nLet’s take a look at a simple example to understand the usage of regular expressions:\nimport re\nstring = \"Intellipaat is a fast growing global Ed-Tech brand\"\nx = re.search('\\s', string) #first white space search\nx.start()\nOutput:\n11",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "129. What are character classes in regular expressions?",
        "answer": "The following are some of the character classes in regular expressions:\n1. [abc] – Matching the alphabets i.e a b or c.\n2. [a-z] [A-Z] – Matching the alphabets both lowercase and uppercase, in the range a to z.\n3. [0-9] – matching the letters in the range specified.\n4. [a-zA-Z0-9] – To match any alphanumeric character.\n5. [^abc] – Match anything but a b or c.",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "130. How do you use multi-line comments in Python?",
        "answer": "To use multi-line comments, we can use a very simple approach shown below:\n“””\nthis is a\nmulti line\ncomment\n“””\nprint(“Multi line comment above”)",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "131. What is exception handling? How do you handle exceptions in Python?",
        "answer": "In programming languages, there are two terminologies, i.e., errors and exceptions. Errors, on the other hand, stop the execution of the program, like syntax errors, name errors, etc., but the exceptions change the normal flow of the program. So it becomes necessary to handle exceptions during the execution of the program, and that is known as exception handling.\nLet’s take a look at a simple example to understand how you can handle exceptions using Python:\nHere in a normal scenario, the program would throw an error, but we can handle the exception using the try-and-catch block.\nx = 5\ny = \"10\"\ntry:\nz = x + int(y)\nprint(z)\nexcept TypeError:\nprint(\"Error: cannot add an int and a str\")\nOutput:\n15",
        "reference": "intellipaat.com",
        "role": "python"
    },
    {
        "question": "1. What is __init__?",
        "answer": "__init__ is a contructor method in Python and is automatically called to allocate memory when a new object/instance is created. All classes have a __init__ method associated with them. It helps in distinguishing methods and attributes of a class from local variables. __init__ __init__ # class definition\nclass Student:\n   def __init__(self, fname, lname, age, section):\n       self.firstname = fname\n       self.lastname = lname\n       self.age = age\n       self.section = section\n# creating a new object\nstu1 = Student(\"Sara\", \"Ansh\", 22, \"A2\") # class definition\nclass Student:\n   def __init__(self, fname, lname, age, section):\n       self.firstname = fname\n       self.lastname = lname\n       self.age = age\n       self.section = section\n# creating a new object\nstu1 = Student(\"Sara\", \"Ansh\", 22, \"A2\") # class definition class Student: class Student def __init__(self, fname, lname, age, section): def __init__ self, fname, lname, age, section # creating a new object \"Sara\" \"Ansh\" 22 \"A2\"",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "2. What is the difference between Python Arrays and lists?",
        "answer": "Arrays in python can only contain elements of same data types i.e., data type of array should be homogeneous. It is a thin wrapper around C language arrays and consumes far less memory than lists.\nLists in python can contain elements of different data types i.e., data type of lists can be heterogeneous. It has the disadvantage of consuming large memory. Arrays in python can only contain elements of same data types i.e., data type of array should be homogeneous. It is a thin wrapper around C language arrays and consumes far less memory than lists. Lists in python can contain elements of different data types i.e., data type of lists can be heterogeneous. It has the disadvantage of consuming large memory. import array\na = array.array('i', [1, 2, 3])\nfor i in a:\n    print(i, end=' ')    #OUTPUT: 1 2 3\na = array.array('i', [1, 2, 'string'])    #OUTPUT: TypeError: an integer is required (got type str)\na = [1, 2, 'string']\nfor i in a:\n   print(i, end=' ')    #OUTPUT: 1 2 string import array\na = array.array('i', [1, 2, 3])\nfor i in a:\n    print(i, end=' ')    #OUTPUT: 1 2 3\na = array.array('i', [1, 2, 'string'])    #OUTPUT: TypeError: an integer is required (got type str)\na = [1, 2, 'string']\nfor i in a:\n   print(i, end=' ')    #OUTPUT: 1 2 string import 'i' 1 2 3 for in print ' ' #OUTPUT: 1 2 3 'i' 1 2 'string' #OUTPUT: TypeError: an integer is required (got type str) 1 2 'string' for in print ' ' #OUTPUT: 1 2 string",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "3. Explain how can you make a Python Script executable on Unix?",
        "answer": "Script file must begin with #!/usr/bin/env python Script file must begin with #!/usr/bin/env python #!/usr/bin/env python",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "4. What is slicing in Python?",
        "answer": "As the name suggests, ‘slicing’ is taking parts of.\nSyntax for slicing is [start : stop : step]\nstart is the starting index from where to slice a list or tuple\nstop is the ending index or where to sop.\nstep is the number of steps to jump.\nDefault value for start is 0, stop is number of items, step is 1.\nSlicing can be done on strings, arrays, lists, and tuples. As the name suggests, ‘slicing’ is taking parts of. Syntax for slicing is [start : stop : step] [start : stop : step] start is the starting index from where to slice a list or tuple start stop is the ending index or where to sop. stop step is the number of steps to jump. step Default value for start is 0, stop is number of items, step is 1. start stop step Slicing can be done on strings, arrays, lists, and tuples. strings, arrays, lists tuples numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(numbers[1 : : 2])  #output : [2, 4, 6, 8, 10] numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(numbers[1 : : 2])  #output : [2, 4, 6, 8, 10] 1 2 3 4 5 6 7 8 9 10 print 1 2 #output : [2, 4, 6, 8, 10]",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "5. What is docstring in Python?",
        "answer": "Documentation string or docstring is a multiline string used to document a specific code segment.\nThe docstring should describe what the function or method does. Documentation string or docstring is a multiline string used to document a specific code segment. The docstring should describe what the function or method does.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "6. What are unit tests in Python?",
        "answer": "Unit test is a unit testing framework of Python.\nUnit testing means testing different components of software separately. Can you think about why unit testing is important? Imagine a scenario, you are building software that uses three components namely A, B, and C. Now, suppose your software breaks at a point time. How will you find which component was responsible for breaking the software? Maybe it was component A that failed, which in turn failed component B, and this actually failed the software. There can be many such combinations.\nThis is why it is necessary to test each and every component properly so that we know which component might be highly responsible for the failure of the software. Unit test is a unit testing framework of Python. Unit testing means testing different components of software separately. Can you think about why unit testing is important? Imagine a scenario, you are building software that uses three components namely A, B, and C. Now, suppose your software breaks at a point time. How will you find which component was responsible for breaking the software? Maybe it was component A that failed, which in turn failed component B, and this actually failed the software. There can be many such combinations. This is why it is necessary to test each and every component properly so that we know which component might be highly responsible for the failure of the software.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "7. What is break, continue and pass in Python?",
        "answer": "Break The break statement terminates the loop immediately and the control flows to the statement after the body of the loop.\nContinue The continue statement terminates the current iteration of the statement, skips the rest of the code in the current iteration and the control flows to the next iteration of the loop.\nPass As explained above, the pass keyword in Python is generally used to fill up empty blocks and is similar to an empty statement represented by a semi-colon in languages such as Java, C++, Javascript, etc. Break The break statement terminates the loop immediately and the control flows to the statement after the body of the loop.\nContinue The continue statement terminates the current iteration of the statement, skips the rest of the code in the current iteration and the control flows to the next iteration of the loop.\nPass As explained above, the pass keyword in Python is generally used to fill up empty blocks and is similar to an empty statement represented by a semi-colon in languages such as Java, C++, Javascript, etc. Break The break statement terminates the loop immediately and the control flows to the statement after the body of the loop.\nContinue The continue statement terminates the current iteration of the statement, skips the rest of the code in the current iteration and the control flows to the next iteration of the loop.\nPass As explained above, the pass keyword in Python is generally used to fill up empty blocks and is similar to an empty statement represented by a semi-colon in languages such as Java, C++, Javascript, etc. Break The break statement terminates the loop immediately and the control flows to the statement after the body of the loop. Break The break statement terminates the loop immediately and the control flows to the statement after the body of the loop. Continue The continue statement terminates the current iteration of the statement, skips the rest of the code in the current iteration and the control flows to the next iteration of the loop. Continue The continue statement terminates the current iteration of the statement, skips the rest of the code in the current iteration and the control flows to the next iteration of the loop. Pass As explained above, the pass keyword in Python is generally used to fill up empty blocks and is similar to an empty statement represented by a semi-colon in languages such as Java, C++, Javascript, etc. Pass As explained above, the pass keyword in Python is generally used to fill up empty blocks and is similar to an empty statement represented by a semi-colon in languages such as Java, C++, Javascript, etc. pat = [1, 3, 2, 1, 2, 3, 1, 0, 1, 3]\nfor p in pat:\n   pass\n   if (p == 0):\n       current = p\n       break\n   elif (p % 2 == 0):\n       continue\n   print(p)    # output => 1 3 1 3 1\nprint(current)    # output => 0 pat = [1, 3, 2, 1, 2, 3, 1, 0, 1, 3]\nfor p in pat:\n   pass\n   if (p == 0):\n       current = p\n       break\n   elif (p % 2 == 0):\n       continue\n   print(p)    # output => 1 3 1 3 1\nprint(current)    # output => 0 1 3 2 1 2 3 1 0 1 3 for in pass if 0 break elif 2 0 continue print # output => 1 3 1 3 1 print # output => 0",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "8. What is the use of self in Python?",
        "answer": "Self is used to represent the instance of the class. With this keyword, you can access the attributes and methods of the class in python. It binds the attributes with the given arguments. self is used in different places and often thought to be a keyword. But unlike in C++, self is not a keyword in Python. Self",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "9. What are global, protected and private attributes in Python?",
        "answer": "Global variables are public variables that are defined in the global scope. To use the variable in the global scope inside a function, we use the global keyword.\nProtected attributes are attributes defined with an underscore prefixed to their identifier eg. _sara. They can still be accessed and modified from outside the class they are defined in but a responsible developer should refrain from doing so.\nPrivate attributes are attributes with double underscore prefixed to their identifier eg. __ansh. They cannot be accessed or modified from the outside directly and will result in an AttributeError if such an attempt is made. Global variables are public variables that are defined in the global scope. To use the variable in the global scope inside a function, we use the global keyword. Global global Protected attributes are attributes defined with an underscore prefixed to their identifier eg. _sara. They can still be accessed and modified from outside the class they are defined in but a responsible developer should refrain from doing so. Protected Private attributes are attributes with double underscore prefixed to their identifier eg. __ansh. They cannot be accessed or modified from the outside directly and will result in an AttributeError if such an attempt is made. Private",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "10. What are modules and packages in Python?",
        "answer": "Python packages and Python modules are two mechanisms that allow for modular programming in Python. Modularizing has several advantages - modular programming Simplicity: Working on a single module helps you focus on a relatively small portion of the problem at hand. This makes development easier and less error-prone.\nMaintainability: Modules are designed to enforce logical boundaries between different problem domains. If they are written in a manner that reduces interdependency, it is less likely that modifications in a module might impact other parts of the program.\nReusability: Functions defined in a module can be easily reused by other parts of the application.\nScoping: Modules typically define a separate namespace, which helps avoid confusion between identifiers from other parts of the program. Simplicity: Working on a single module helps you focus on a relatively small portion of the problem at hand. This makes development easier and less error-prone. Simplicity Maintainability: Modules are designed to enforce logical boundaries between different problem domains. If they are written in a manner that reduces interdependency, it is less likely that modifications in a module might impact other parts of the program. Maintainability Reusability: Functions defined in a module can be easily reused by other parts of the application. Reusability Scoping: Modules typically define a separate namespace, which helps avoid confusion between identifiers from other parts of the program. Scoping Modules, in general, are simply Python files with a .py extension and can have a set of functions, classes, or variables defined and implemented. They can be imported and initialized once using the import statement. If partial functionality is needed, import the requisite classes or functions using from foo import bar. Modules import from foo import bar Packages allow for hierarchial structuring of the module namespace using dot notation. As, modules help avoid clashes between global variable names, in a similar manner, packages help avoid clashes between module names.\nCreating a package is easy since it makes use of the system's inherent file structure. So just stuff the modules into a folder and there you have it, the folder name as the package name. Importing a module or its contents from this package requires the package name as prefix to the module name joined by a dot. Packages dot notation modules packages  Note: You can technically import the package as well, but alas, it doesn't import the modules within the package to the local namespace, thus, it is practically useless. Note: You can technically import the package as well, but alas, it doesn't import the modules within the package to the local namespace, thus, it is practically useless. Note:",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "11. What is pass in Python?",
        "answer": "The pass keyword represents a null operation in Python. It is generally used for the purpose of filling up empty blocks of code which may execute during runtime but has yet to be written. Without the pass statement in the following code, we may run into some errors during code execution. pass pass def myEmptyFunc():\n   # do nothing\n   pass\nmyEmptyFunc()    # nothing happens\n## Without the pass keyword\n# File \"<stdin>\", line 3\n# IndentationError: expected an indented block def myEmptyFunc():\n   # do nothing\n   pass\nmyEmptyFunc()    # nothing happens\n## Without the pass keyword\n# File \"<stdin>\", line 3\n# IndentationError: expected an indented block def myEmptyFunc(): def myEmptyFunc # do nothing pass # nothing happens ## Without the pass keyword # File \"<stdin>\", line 3 # IndentationError: expected an indented block",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "12. What are the common built-in data types in Python?",
        "answer": "There are several built-in data types in Python. Although, Python doesn't require data types to be defined explicitly during variable declarations type errors are likely to occur if the knowledge of data types and their compatibility with each other are neglected. Python provides type() and isinstance() functions to check the type of these variables. These data types can be grouped into the following categories- type() isinstance() None Type:\nNone keyword represents the null values in Python. Boolean equality operation can be performed using these NoneType objects. None Type:\nNone keyword represents the null values in Python. Boolean equality operation can be performed using these NoneType objects. None Type:  None Class Name Description\nNoneType Represents the NULL values in Python. Class Name Description\nNoneType Represents the NULL values in Python. Class Name Description Class Name Description Class Name Description NoneType Represents the NULL values in Python. NoneType Represents the NULL values in Python. NoneType Represents the NULL values in Python. NULL Numeric Types:\nThere are three distinct numeric types - integers, floating-point numbers, and complex numbers. Additionally, booleans are a sub-type of integers. Numeric Types:\nThere are three distinct numeric types - integers, floating-point numbers, and complex numbers. Additionally, booleans are a sub-type of integers. Numeric Types:  integers, floating-point numbers complex numbers booleans Class Name Description\nint Stores integer literals including hex, octal and binary numbers as integers\nfloat Stores literals containing decimal values and/or exponent signs as floating-point numbers\ncomplex Stores complex numbers in the form (A + Bj) and has attributes: real and imag\nbool Stores boolean value (True or False). Class Name Description\nint Stores integer literals including hex, octal and binary numbers as integers\nfloat Stores literals containing decimal values and/or exponent signs as floating-point numbers\ncomplex Stores complex numbers in the form (A + Bj) and has attributes: real and imag\nbool Stores boolean value (True or False). Class Name Description Class Name Description Class Name Description int Stores integer literals including hex, octal and binary numbers as integers\nfloat Stores literals containing decimal values and/or exponent signs as floating-point numbers\ncomplex Stores complex numbers in the form (A + Bj) and has attributes: real and imag\nbool Stores boolean value (True or False). int Stores integer literals including hex, octal and binary numbers as integers int Stores integer literals including hex, octal and binary numbers as integers float Stores literals containing decimal values and/or exponent signs as floating-point numbers float Stores literals containing decimal values and/or exponent signs as floating-point numbers complex Stores complex numbers in the form (A + Bj) and has attributes: real and imag complex Stores complex numbers in the form (A + Bj) and has attributes: real and imag real imag bool Stores boolean value (True or False). bool Stores boolean value (True or False). Note: The standard library also includes fractions to store rational numbers and decimal to store floating-point numbers with user-defined precision. Note: The standard library also includes fractions to store rational numbers and decimal to store floating-point numbers with user-defined precision. Note: fractions decimal Sequence Types:\nAccording to Python Docs, there are three basic Sequence Types - lists, tuples, and range objects. Sequence types have the in and not in operators defined for their traversing their elements. These operators share the same priority as the comparison operations. Sequence Types:\nAccording to Python Docs, there are three basic Sequence Types - lists, tuples, and range objects. Sequence types have the in and not in operators defined for their traversing their elements. These operators share the same priority as the comparison operations. Sequence Types:  lists, tuples, range in not in Class Name Description\nlist Mutable sequence used to store collection of items.\ntuple Immutable sequence used to store collection of items.\nrange Represents an immutable sequence of numbers generated during execution.\nstr Immutable sequence of Unicode code points to store textual data. Class Name Description\nlist Mutable sequence used to store collection of items.\ntuple Immutable sequence used to store collection of items.\nrange Represents an immutable sequence of numbers generated during execution.\nstr Immutable sequence of Unicode code points to store textual data. Class Name Description Class Name Description Class Name Description list Mutable sequence used to store collection of items.\ntuple Immutable sequence used to store collection of items.\nrange Represents an immutable sequence of numbers generated during execution.\nstr Immutable sequence of Unicode code points to store textual data. list Mutable sequence used to store collection of items. list Mutable sequence used to store collection of items. tuple Immutable sequence used to store collection of items. tuple Immutable sequence used to store collection of items. range Represents an immutable sequence of numbers generated during execution. range Represents an immutable sequence of numbers generated during execution. str Immutable sequence of Unicode code points to store textual data. str Immutable sequence of Unicode code points to store textual data. Note: The standard library also includes additional types for processing:\n1. Binary data such as bytearray bytes memoryview , and\n2. Text strings such as str. Note:  Binary data bytearray bytes memoryview  Text strings str Mapping Types: Mapping Types: Mapping Types: A mapping object can map hashable values to random objects in Python. Mappings objects are mutable and there is currently only one standard mapping type, the dictionary. dictionary dictionary Class Name  Description\ndict Stores comma-separated list of key: value pairs Class Name  Description\ndict Stores comma-separated list of key: value pairs Class Name  Description Class Name  Description Class Name Description dict Stores comma-separated list of key: value pairs dict Stores comma-separated list of key: value pairs dict Stores comma-separated list of key: value pairs key: value Set Types:\nCurrently, Python has two built-in set types - set and frozenset. set type is mutable and supports methods like add() and remove(). frozenset type is immutable and can't be modified after creation. Set Types:\nCurrently, Python has two built-in set types - set and frozenset. set type is mutable and supports methods like add() and remove(). frozenset type is immutable and can't be modified after creation. Set Types:  set frozenset set add() remove() frozenset Class Name Description\nset Mutable unordered collection of distinct hashable objects.\nfrozenset Immutable collection of distinct hashable objects. Class Name Description\nset Mutable unordered collection of distinct hashable objects.\nfrozenset Immutable collection of distinct hashable objects. Class Name Description Class Name Description Class Name Description set Mutable unordered collection of distinct hashable objects.\nfrozenset Immutable collection of distinct hashable objects. set Mutable unordered collection of distinct hashable objects. set Mutable unordered collection of distinct hashable objects. frozenset Immutable collection of distinct hashable objects. frozenset Immutable collection of distinct hashable objects. Note: set is mutable and thus cannot be used as key for a dictionary. On the other hand, frozenset is immutable and thus, hashable, and can be used as a dictionary key or as an element of another set. Note: Note: set set is mutable and thus cannot be used as key for a dictionary. On the other hand, frozenset frozenset is immutable and thus, hashable, and can be used as a dictionary key or as an element of another set. Modules:\nModule is an additional built-in type supported by the Python Interpreter. It supports one special operation, i.e., attribute access: mymod.myobj, where mymod is a module and myobj references a name defined in m's symbol table. The module's symbol table resides in a very special attribute of the module __dict__, but direct assignment to this module is neither possible nor recommended.\nCallable Types:\nCallable types are the types to which function call can be applied. They can be user-defined functions, instance methods, generator functions, and some other built-in functions, methods and classes.\nRefer to the documentation at docs.python.org for a detailed view of the callable types. Modules:\nModule is an additional built-in type supported by the Python Interpreter. It supports one special operation, i.e., attribute access: mymod.myobj, where mymod is a module and myobj references a name defined in m's symbol table. The module's symbol table resides in a very special attribute of the module __dict__, but direct assignment to this module is neither possible nor recommended. Modules:  attribute access mymod.myobj mymod myobj __dict__ Callable Types:\nCallable types are the types to which function call can be applied. They can be user-defined functions, instance methods, generator functions, and some other built-in functions, methods and classes.\nRefer to the documentation at docs.python.org for a detailed view of the callable types. Callable Types:  user-defined functions, instance methods, generator functions built-in functions, methods classes  docs.python.org callable types",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "13. What are lists and tuples? What is the key difference between the two?",
        "answer": "Lists and Tuples are both sequence data types that can store a collection of objects in Python. The objects stored in both sequences can have different data types. Lists are represented with square brackets ['sara', 6, 0.19], while tuples are represented with parantheses ('ansh', 5, 0.97).\nBut what is the real difference between the two? The key difference between the two is that while lists are mutable, tuples on the other hand are immutable objects. This means that lists can be modified, appended or sliced on the go but tuples remain constant and cannot be modified in any manner. You can run the following example on Python IDLE to confirm the difference: Lists Tuples equence data types different data types square brackets ['sara', 6, 0.19] parantheses ('ansh', 5, 0.97)  lists are mutable tuples immutable my_tuple = ('sara', 6, 5, 0.97)\nmy_list = ['sara', 6, 5, 0.97]\nprint(my_tuple[0])     # output => 'sara'\nprint(my_list[0])     # output => 'sara'\nmy_tuple[0] = 'ansh'    # modifying tuple => throws an error\nmy_list[0] = 'ansh'    # modifying list => list modified\nprint(my_tuple[0])     # output => 'sara'\nprint(my_list[0])     # output => 'ansh' my_tuple = ('sara', 6, 5, 0.97)\nmy_list = ['sara', 6, 5, 0.97]\nprint(my_tuple[0])     # output => 'sara'\nprint(my_list[0])     # output => 'sara'\nmy_tuple[0] = 'ansh'    # modifying tuple => throws an error\nmy_list[0] = 'ansh'    # modifying list => list modified\nprint(my_tuple[0])     # output => 'sara'\nprint(my_list[0])     # output => 'ansh' 'sara' 6 5 0.97 'sara' 6 5 0.97 print 0 # output => 'sara' print 0 # output => 'sara' 0 'ansh' # modifying tuple => throws an error 0 'ansh' # modifying list => list modified print 0 # output => 'sara' print 0 # output => 'ansh'",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "14. What is Scope in Python?",
        "answer": "Every object in Python functions within a scope. A scope is a block of code where an object in Python remains relevant. Namespaces uniquely identify all the objects inside a program. However, these namespaces also have a scope defined for them where you could use their objects without any prefix. A few examples of scope created during code execution in Python are as follows: A local scope refers to the local objects available in the current function.\nA global scope refers to the objects available throughout the code execution since their inception.\nA module-level scope refers to the global objects of the current module accessible in the program.\nAn outermost scope refers to all the built-in names callable in the program. The objects in this scope are searched last to find the name referenced. A local scope refers to the local objects available in the current function. local scope A global scope refers to the objects available throughout the code execution since their inception. global scope A module-level scope refers to the global objects of the current module accessible in the program. module-level scope An outermost scope refers to all the built-in names callable in the program. The objects in this scope are searched last to find the name referenced. outermost scope Note: Local scope objects can be synced with global scope objects using keywords such as global. Note: global",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "15. What is PEP 8 and why is it important?",
        "answer": "PEP stands for Python Enhancement Proposal. A PEP is an official design document providing information to the Python community, or describing a new feature for Python or its processes. PEP 8 is especially important since it documents the style guidelines for Python Code. Apparently contributing to the Python open-source community requires you to follow these style guidelines sincerely and strictly. Python Enhancement Proposal PEP 8",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "16. What is an Interpreted language?",
        "answer": "An Interpreted language executes its statements line by line. Languages such as Python, Javascript, R, PHP, and Ruby are prime examples of Interpreted languages. Programs written in an interpreted language runs directly from the source code, with no intermediary compilation step.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "17. What is a dynamically typed language?",
        "answer": "Before we understand a dynamically typed language, we should learn about what typing is. Typing refers to type-checking in programming languages. In a strongly-typed language, such as Python, \"1\" + 2 will result in a type error since these languages don't allow for \"type-coercion\" (implicit conversion of data types). On the other hand, a weakly-typed language, such as Javascript, will simply output \"12\" as result. Typing strongly-typed \"1\" + 2 weakly-typed \"12\" Type-checking can be done at two stages - Static - Data Types are checked before execution.\nDynamic - Data Types are checked during execution. Static - Data Types are checked before execution. Static Dynamic - Data Types are checked during execution. Dynamic Python is an interpreted language, executes each statement line by line and thus type-checking is done on the fly, during execution. Hence, Python is a Dynamically Typed Language.  ",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "18. What is Python? What are the benefits of using Python",
        "answer": "Python is a high-level, interpreted, general-purpose programming language. Being a general-purpose language, it can be used to build almost any type of application with the right tools/libraries. Additionally, python supports objects, modules, threads, exception-handling, and automatic memory management which help in modelling real-world problems and building applications to solve these problems. Benefits of using Python: Benefits of using Python: Python is a general-purpose programming language that has a simple, easy-to-learn syntax that emphasizes readability and therefore reduces the cost of program maintenance. Moreover, the language is capable of scripting, is completely open-source, and supports third-party packages encouraging modularity and code reuse.\nIts high-level data structures, combined with dynamic typing and dynamic binding, attract a huge community of developers for Rapid Application Development and deployment. Python is a general-purpose programming language that has a simple, easy-to-learn syntax that emphasizes readability and therefore reduces the cost of program maintenance. Moreover, the language is capable of scripting, is completely open-source, and supports third-party packages encouraging modularity and code reuse. Its high-level data structures, combined with dynamic typing and dynamic binding, attract a huge community of developers for Rapid Application Development and deployment.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "1. What are Dict and List comprehensions?",
        "answer": "Python comprehensions, like decorators, are syntactic sugar constructs that help build altered and filtered lists, dictionaries, or sets from a given list, dictionary, or set. Using comprehensions saves a lot of time and code that might be considerably more verbose (containing more lines of code). Let's check out some examples, where comprehensions can be truly beneficial: syntactic sugar build altered filtered lists Performing mathematical operations on the entire list Performing mathematical operations on the entire list Performing mathematical operations on the entire list my_list = [2, 3, 5, 7, 11]\nsquared_list = [x**2 for x in my_list]    # list comprehension\n# output => [4 , 9 , 25 , 49 , 121]\nsquared_dict = {x:x**2 for x in my_list}    # dict comprehension\n# output => {11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49} my_list = [2, 3, 5, 7, 11]\nsquared_list = [x**2 for x in my_list]    # list comprehension\n# output => [4 , 9 , 25 , 49 , 121]\nsquared_dict = {x:x**2 for x in my_list}    # dict comprehension\n# output => {11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49} 2 3 5 7 11 2 for in # list comprehension # output => [4 , 9 , 25 , 49 , 121] 2 for in # dict comprehension # output => {11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49} Performing conditional filtering operations on the entire list Performing conditional filtering operations on the entire list Performing conditional filtering operations on the entire list my_list = [2, 3, 5, 7, 11]\nsquared_list = [x**2 for x in my_list if x%2 != 0]    # list comprehension\n# output => [9 , 25 , 49 , 121]\nsquared_dict = {x:x**2 for x in my_list if x%2 != 0}    # dict comprehension\n# output => {11: 121, 3: 9 , 5: 25 , 7: 49} my_list = [2, 3, 5, 7, 11]\nsquared_list = [x**2 for x in my_list if x%2 != 0]    # list comprehension\n# output => [9 , 25 , 49 , 121]\nsquared_dict = {x:x**2 for x in my_list if x%2 != 0}    # dict comprehension\n# output => {11: 121, 3: 9 , 5: 25 , 7: 49} 2 3 5 7 11 2 for in if 2 0 # list comprehension # output => [9 , 25 , 49 , 121] 2 for in if 2 0 # dict comprehension # output => {11: 121, 3: 9 , 5: 25 , 7: 49} Combining multiple lists into one Combining multiple lists into one Combining multiple lists into one Comprehensions allow for multiple iterators and hence, can be used to combine multiple lists into one. a = [1, 2, 3]\nb = [7, 8, 9]\n[(x + y) for (x,y) in zip(a,b)]  # parallel iterators\n# output => [8, 10, 12]\n[(x,y) for x in a for y in b]    # nested iterators\n# output => [(1, 7), (1, 8), (1, 9), (2, 7), (2, 8), (2, 9), (3, 7), (3, 8), (3, 9)] a = [1, 2, 3]\nb = [7, 8, 9]\n[(x + y) for (x,y) in zip(a,b)]  # parallel iterators\n# output => [8, 10, 12]\n[(x,y) for x in a for y in b]    # nested iterators\n# output => [(1, 7), (1, 8), (1, 9), (2, 7), (2, 8), (2, 9), (3, 7), (3, 8), (3, 9)] 1 2 3 7 8 9 for in zip # parallel iterators # output => [8, 10, 12] for in for in # nested iterators # output => [(1, 7), (1, 8), (1, 9), (2, 7), (2, 8), (2, 9), (3, 7), (3, 8), (3, 9)] Flattening a multi-dimensional list Flattening a multi-dimensional list Flattening a multi-dimensional list A similar approach of nested iterators (as above) can be applied to flatten a multi-dimensional list or work upon its inner elements. my_list = [[10,20,30],[40,50,60],[70,80,90]]\nflattened = [x for temp in my_list for x in temp]\n# output => [10, 20, 30, 40, 50, 60, 70, 80, 90] my_list = [[10,20,30],[40,50,60],[70,80,90]]\nflattened = [x for temp in my_list for x in temp]\n# output => [10, 20, 30, 40, 50, 60, 70, 80, 90] 10 20 30 40 50 60 70 80 90 for in for in # output => [10, 20, 30, 40, 50, 60, 70, 80, 90] Note: List comprehensions have the same effect as the map method in other languages. They follow the mathematical set builder notation rather than map and filter functions in Python. Note: List comprehensions have the same effect as the map method in other languages. They follow the mathematical set builder notation rather than map and filter functions in Python. Note:",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "2. What are decorators in Python?",
        "answer": "Decorators in Python are essentially functions that add functionality to an existing function in Python without changing the structure of the function itself. They are represented the @decorator_name in Python and are called in a bottom-up fashion. For example: Decorators @decorator_name # decorator function to convert to lowercase\ndef lowercase_decorator(function):\n   def wrapper():\n       func = function()\n       string_lowercase = func.lower()\n       return string_lowercase\n   return wrapper\n# decorator function to split words\ndef splitter_decorator(function):\n   def wrapper():\n       func = function()\n       string_split = func.split()\n       return string_split\n   return wrapper\n@splitter_decorator # this is executed next\n@lowercase_decorator # this is executed first\ndef hello():\n   return 'Hello World'\nhello()   # output => [ 'hello' , 'world' ] # decorator function to convert to lowercase\ndef lowercase_decorator(function):\n   def wrapper():\n       func = function()\n       string_lowercase = func.lower()\n       return string_lowercase\n   return wrapper\n# decorator function to split words\ndef splitter_decorator(function):\n   def wrapper():\n       func = function()\n       string_split = func.split()\n       return string_split\n   return wrapper\n@splitter_decorator # this is executed next\n@lowercase_decorator # this is executed first\ndef hello():\n   return 'Hello World'\nhello()   # output => [ 'hello' , 'world' ] # decorator function to convert to lowercase def lowercase_decorator(function): def lowercase_decorator function def wrapper(): def wrapper return return # decorator function to split words def splitter_decorator(function): def splitter_decorator function def wrapper(): def wrapper return return @splitter_decorator # this is executed next @lowercase_decorator # this is executed first def hello(): def hello return 'Hello World' # output => [ 'hello' , 'world' ] The beauty of the decorators lies in the fact that besides adding functionality to the output of the method, they can even accept arguments for functions and can further modify those arguments before passing it to the function itself. The inner nested function, i.e. 'wrapper' function, plays a significant role here. It is implemented to enforce encapsulation and thus, keep itself hidden from the global scope. accept arguments inner nested function encapsulation # decorator function to capitalize names\ndef names_decorator(function):\n   def wrapper(arg1, arg2):\n       arg1 = arg1.capitalize()\n       arg2 = arg2.capitalize()\n       string_hello = function(arg1, arg2)\n       return string_hello\n   return wrapper\n@names_decorator\ndef say_hello(name1, name2):\n   return 'Hello ' + name1 + '! Hello ' + name2 + '!'\nsay_hello('sara', 'ansh')   # output => 'Hello Sara! Hello Ansh!' # decorator function to capitalize names\ndef names_decorator(function):\n   def wrapper(arg1, arg2):\n       arg1 = arg1.capitalize()\n       arg2 = arg2.capitalize()\n       string_hello = function(arg1, arg2)\n       return string_hello\n   return wrapper\n@names_decorator\ndef say_hello(name1, name2):\n   return 'Hello ' + name1 + '! Hello ' + name2 + '!'\nsay_hello('sara', 'ansh')   # output => 'Hello Sara! Hello Ansh!' # decorator function to capitalize names def names_decorator(function): def names_decorator function def wrapper(arg1, arg2): def wrapper arg1, arg2 return return @names_decorator def say_hello(name1, name2): def say_hello name1, name2 return 'Hello ' '! Hello ' '!' 'sara' 'ansh' # output => 'Hello Sara! Hello Ansh!'",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "3. What is Scope Resolution in Python?",
        "answer": "Sometimes objects within the same scope have the same name but function differently. In such cases, scope resolution comes into play in Python automatically. A few examples of such behavior are: Python modules namely 'math' and 'cmath' have a lot of functions that are common to both of them - log10(), acos(), exp() etc. To resolve this ambiguity, it is necessary to prefix them with their respective module, like math.exp() and cmath.exp().\nConsider the code below, an object temp has been initialized to 10 globally and then to 20 on function call. However, the function call didn't change the value of the temp globally. Here, we can observe that Python draws a clear line between global and local variables, treating their namespaces as separate identities. Python modules namely 'math' and 'cmath' have a lot of functions that are common to both of them - log10(), acos(), exp() etc. To resolve this ambiguity, it is necessary to prefix them with their respective module, like math.exp() and cmath.exp(). log10() acos() exp() math.exp() cmath.exp() Consider the code below, an object temp has been initialized to 10 globally and then to 20 on function call. However, the function call didn't change the value of the temp globally. Here, we can observe that Python draws a clear line between global and local variables, treating their namespaces as separate identities. temp = 10   # global-scope variable\ndef func():\n     temp = 20   # local-scope variable\n     print(temp)\nprint(temp)   # output => 10\nfunc()    # output => 20\nprint(temp)   # output => 10 temp = 10   # global-scope variable\ndef func():\n     temp = 20   # local-scope variable\n     print(temp)\nprint(temp)   # output => 10\nfunc()    # output => 20\nprint(temp)   # output => 10 10 # global-scope variable def func(): def func 20 # local-scope variable print print # output => 10 # output => 20 print # output => 10 This behavior can be overridden using the global keyword inside the function, as shown in the following example: global temp = 10   # global-scope variable\ndef func():\n     global temp\n     temp = 20   # local-scope variable\n     print(temp)\nprint(temp)   # output => 10\nfunc()    # output => 20\nprint(temp)   # output => 20 temp = 10   # global-scope variable\ndef func():\n     global temp\n     temp = 20   # local-scope variable\n     print(temp)\nprint(temp)   # output => 10\nfunc()    # output => 20\nprint(temp)   # output => 20 10 # global-scope variable def func(): def func global 20 # local-scope variable print print # output => 10 # output => 20 print # output => 20",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "4. What are Python namespaces? Why are they used?",
        "answer": "A namespace in Python ensures that object names in a program are unique and can be used without any conflict. Python implements these namespaces as dictionaries with 'name as key' mapped to a corresponding 'object as value'. This allows for multiple namespaces to use the same name and map it to a separate object. A few examples of namespaces are as follows: Local Namespace includes local names inside a function. the namespace is temporarily created for a function call and gets cleared when the function returns.\nGlobal Namespace includes names from various imported packages/ modules that are being used in the current project. This namespace is created when the package is imported in the script and lasts until the execution of the script.\nBuilt-in Namespace includes built-in functions of core Python and built-in names for various types of exceptions. Local Namespace includes local names inside a function. the namespace is temporarily created for a function call and gets cleared when the function returns. Local Namespace Global Namespace includes names from various imported packages/ modules that are being used in the current project. This namespace is created when the package is imported in the script and lasts until the execution of the script. Global Namespace Built-in Namespace includes built-in functions of core Python and built-in names for various types of exceptions. Built-in Namespace The lifecycle of a namespace depends upon the scope of objects they are mapped to. If the scope of an object ends, the lifecycle of that namespace comes to an end. Hence, it isn't possible to access inner namespace objects from an outer namespace. lifecycle of a namespace  ",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "5. How is memory managed in Python?",
        "answer": "Memory management in Python is handled by the Python Memory Manager. The memory allocated by the manager is in form of a private heap space dedicated to Python. All Python objects are stored in this heap and being private, it is inaccessible to the programmer. Though, python does provide some core API functions to work upon the private heap space.\nAdditionally, Python has an in-built garbage collection to recycle the unused memory for the private heap space. Memory management in Python is handled by the Python Memory Manager. The memory allocated by the manager is in form of a private heap space dedicated to Python. All Python objects are stored in this heap and being private, it is inaccessible to the programmer. Though, python does provide some core API functions to work upon the private heap space. Python Memory Manager private heap space Additionally, Python has an in-built garbage collection to recycle the unused memory for the private heap space.  ",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "6. What is lambda in Python? Why is it used?",
        "answer": "Lambda is an anonymous function in Python, that can accept any number of arguments, but can only have a single expression. It is generally used in situations requiring an anonymous function for a short time period. Lambda functions can be used in either of the two ways: Assigning lambda functions to a variable: Assigning lambda functions to a variable: mul = lambda a, b : a * b\nprint(mul(2, 5))    # output => 10 mul = lambda a, b : a * b\nprint(mul(2, 5))    # output => 10 lambda print 2 5 # output => 10 Wrapping lambda functions inside another function: Wrapping lambda functions inside another function: def myWrapper(n):\n return lambda a : a * n\nmulFive = myWrapper(5)\nprint(mulFive(2))    # output => 10 def myWrapper(n):\n return lambda a : a * n\nmulFive = myWrapper(5)\nprint(mulFive(2))    # output => 10 def myWrapper(n): def myWrapper n return lambda 5 print 2 # output => 10",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "7. Explain how to delete a file in Python?",
        "answer": "Use command os.remove(file_name) os.remove(file_name) import os\nos.remove(\"ChangedFile.csv\")\nprint(\"File Removed!\") import os\nos.remove(\"ChangedFile.csv\")\nprint(\"File Removed!\") import \"ChangedFile.csv\" print \"File Removed!\"",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "8. What are negative indexes and why are they used?",
        "answer": "Negative indexes are the indexes from the end of the list or tuple or string.\nArr[-1] means the last element of array Arr[] Negative indexes are the indexes from the end of the list or tuple or string. Arr[-1] means the last element of array Arr[] Arr[-1] Arr[] arr = [1, 2, 3, 4, 5, 6]\n#get the last element\nprint(arr[-1]) #output 6\n#get the second last element\nprint(arr[-2]) #output 5 arr = [1, 2, 3, 4, 5, 6]\n#get the last element\nprint(arr[-1]) #output 6\n#get the second last element\nprint(arr[-2]) #output 5 1 2 3 4 5 6 #get the last element print 1 #output 6 #get the second last element print 2 #output 5",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "9. What does *args and **kwargs mean?",
        "answer": "*args *args *args is a special syntax used in the function definition to pass variable-length arguments.\n“*” means variable length and “args” is the name used by convention. You can use any other. *args is a special syntax used in the function definition to pass variable-length arguments. “*” means variable length and “args” is the name used by convention. You can use any other. def multiply(a, b, *argv):\n   mul = a * b\n   for num in argv:\n       mul *= num\n   return mul\nprint(multiply(1, 2, 3, 4, 5)) #output: 120 def multiply(a, b, *argv):\n   mul = a * b\n   for num in argv:\n       mul *= num\n   return mul\nprint(multiply(1, 2, 3, 4, 5)) #output: 120 def multiply(a, b, *argv): def multiply a, b, *argv for in return print 1 2 3 4 5 #output: 120 **kwargs **kwargs **kwargs is a special syntax used in the function definition to pass variable-length keyworded arguments.\nHere, also, “kwargs” is used just by convention. You can use any other name.\nKeyworded argument means a variable that has a name when passed to a function.\nIt is actually a dictionary of the variable names and its value. **kwargs is a special syntax used in the function definition to pass variable-length keyworded arguments. Here, also, “kwargs” is used just by convention. You can use any other name. Keyworded argument means a variable that has a name when passed to a function. It is actually a dictionary of the variable names and its value. def tellArguments(**kwargs):\n   for key, value in kwargs.items():\n       print(key + \": \" + value)\ntellArguments(arg1 = \"argument 1\", arg2 = \"argument 2\", arg3 = \"argument 3\")\n#output:\n# arg1: argument 1\n# arg2: argument 2\n# arg3: argument 3 def tellArguments(**kwargs):\n   for key, value in kwargs.items():\n       print(key + \": \" + value)\ntellArguments(arg1 = \"argument 1\", arg2 = \"argument 2\", arg3 = \"argument 3\")\n#output:\n# arg1: argument 1\n# arg2: argument 2\n# arg3: argument 3 def tellArguments(**kwargs): def tellArguments **kwargs for in print \": \" \"argument 1\" \"argument 2\" \"argument 3\" #output: # arg1: argument 1 # arg2: argument 2 # arg3: argument 3",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "10. Explain split() and join() functions in Python?",
        "answer": "You can use split() function to split a string based on a delimiter to a list of strings.\nYou can use join() function to join a list of strings based on a delimiter to give a single string. You can use split() function to split a string based on a delimiter to a list of strings. split() You can use join() function to join a list of strings based on a delimiter to give a single string. join() string = \"This is a string.\"\nstring_list = string.split(' ') #delimiter is ‘space’ character or ‘ ‘\nprint(string_list) #output: ['This', 'is', 'a', 'string.']\nprint(' '.join(string_list)) #output: This is a string. string = \"This is a string.\"\nstring_list = string.split(' ') #delimiter is ‘space’ character or ‘ ‘\nprint(string_list) #output: ['This', 'is', 'a', 'string.']\nprint(' '.join(string_list)) #output: This is a string. \"This is a string.\" ' ' #delimiter is ‘space’ character or ‘ ‘ print #output: ['This', 'is', 'a', 'string.'] print ' ' #output: This is a string.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "11. What are iterators in Python?",
        "answer": "An iterator is an object.\nIt remembers its state i.e., where it is during iteration (see code below to see how)\n__iter__() method initializes an iterator.\nIt has a __next__() method which returns the next item in iteration and points to the next element. Upon reaching the end of iterable object __next__() must return StopIteration exception.\nIt is also self-iterable.\nIterators are objects with which we can iterate over iterable objects like lists, strings, etc. An iterator is an object. It remembers its state i.e., where it is during iteration (see code below to see how) __iter__() method initializes an iterator. It has a __next__() method which returns the next item in iteration and points to the next element. Upon reaching the end of iterable object __next__() must return StopIteration exception. It is also self-iterable. Iterators are objects with which we can iterate over iterable objects like lists, strings, etc. class ArrayList:\n   def __init__(self, number_list):\n       self.numbers = number_list\n   def __iter__(self):\n       self.pos = 0\n       return self\n   def __next__(self):\n       if(self.pos < len(self.numbers)):\n           self.pos += 1\n           return self.numbers[self.pos - 1]\n       else:\n           raise StopIteration\narray_obj = ArrayList([1, 2, 3])\nit = iter(array_obj)\nprint(next(it)) #output: 2\nprint(next(it)) #output: 3\nprint(next(it))\n#Throws Exception\n#Traceback (most recent call last):\n#...\n#StopIteration class ArrayList:\n   def __init__(self, number_list):\n       self.numbers = number_list\n   def __iter__(self):\n       self.pos = 0\n       return self\n   def __next__(self):\n       if(self.pos < len(self.numbers)):\n           self.pos += 1\n           return self.numbers[self.pos - 1]\n       else:\n           raise StopIteration\narray_obj = ArrayList([1, 2, 3])\nit = iter(array_obj)\nprint(next(it)) #output: 2\nprint(next(it)) #output: 3\nprint(next(it))\n#Throws Exception\n#Traceback (most recent call last):\n#...\n#StopIteration class ArrayList: class ArrayList def __init__(self, number_list): def __init__ self, number_list def __iter__(self): def __iter__ self 0 return def __next__(self): def __next__ self if len 1 return 1 else raise 1 2 3 iter print next #output: 2 print next #output: 3 print next #Throws Exception #Traceback (most recent call last): #... #StopIteration",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "12. How are arguments passed by value or by reference in python?",
        "answer": "Pass by value: Copy of the actual object is passed. Changing the value of the copy of the object will not change the value of the original object.\nPass by reference: Reference to the actual object is passed. Changing the value of the new object will change the value of the original object. Pass by value: Copy of the actual object is passed. Changing the value of the copy of the object will not change the value of the original object. Pass by value Pass by reference: Reference to the actual object is passed. Changing the value of the new object will change the value of the original object. Pass by reference In Python, arguments are passed by reference, i.e., reference to the actual object is passed. def appendNumber(arr):\n   arr.append(4)\narr = [1, 2, 3]\nprint(arr)  #Output: => [1, 2, 3]\nappendNumber(arr)\nprint(arr)  #Output: => [1, 2, 3, 4] def appendNumber(arr):\n   arr.append(4)\narr = [1, 2, 3]\nprint(arr)  #Output: => [1, 2, 3]\nappendNumber(arr)\nprint(arr)  #Output: => [1, 2, 3, 4] def appendNumber(arr): def appendNumber arr 4 1 2 3 print #Output: => [1, 2, 3] print #Output: => [1, 2, 3, 4]",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "13. How Python is interpreted?",
        "answer": "Python as a language is not interpreted or compiled. Interpreted or compiled is the property of the implementation. Python is a bytecode(set of interpreter readable instructions) interpreted generally.\nSource code is a file with .py extension.\nPython compiles the source code to a set of instructions for a virtual machine. The Python interpreter is an implementation of that virtual machine. This intermediate format is called “bytecode”.\n.py source code is first compiled to give .pyc which is bytecode. This bytecode can be then interpreted by the official CPython or JIT(Just in Time compiler) compiled by PyPy. Python as a language is not interpreted or compiled. Interpreted or compiled is the property of the implementation. Python is a bytecode(set of interpreter readable instructions) interpreted generally. Source code is a file with .py extension. Python compiles the source code to a set of instructions for a virtual machine. The Python interpreter is an implementation of that virtual machine. This intermediate format is called “bytecode”. .py source code is first compiled to give .pyc which is bytecode. This bytecode can be then interpreted by the official CPython or JIT(Just in Time compiler) compiled by PyPy.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "14. What is the difference between .py and .pyc files?",
        "answer": ".py files contain the source code of a program. Whereas, .pyc file contains the bytecode of your program. We get bytecode after compilation of .py file (source code). .pyc files are not created for all the files that you run. It is only created for the files that you import.\nBefore executing a python program python interpreter checks for the compiled files. If the file is present, the virtual machine executes it. If not found, it checks for .py file. If found, compiles it to .pyc file and then python virtual machine executes it.\nHaving .pyc file saves you the compilation time. .py files contain the source code of a program. Whereas, .pyc file contains the bytecode of your program. We get bytecode after compilation of .py file (source code). .pyc files are not created for all the files that you run. It is only created for the files that you import. Before executing a python program python interpreter checks for the compiled files. If the file is present, the virtual machine executes it. If not found, it checks for .py file. If found, compiles it to .pyc file and then python virtual machine executes it. Having .pyc file saves you the compilation time.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "15. What is the use of help() and dir() functions?",
        "answer": "help() function in Python is used to display the documentation of modules, classes, functions, keywords, etc. If no parameter is passed to the help() function, then an interactive help utility is launched on the console.\ndir() function tries to return a valid list of attributes and methods of the object it is called upon. It behaves differently with different objects, as it aims to produce the most relevant data, rather than the complete information. help() help() help utility  dir() For Modules/Library objects, it returns a list of all attributes, contained in that module.\nFor Class Objects, it returns a list of all valid attributes and base attributes.\nWith no arguments passed, it returns a list of attributes in the current scope. For Modules/Library objects, it returns a list of all attributes, contained in that module. For Class Objects, it returns a list of all valid attributes and base attributes. With no arguments passed, it returns a list of attributes in the current scope.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "16. What is PYTHONPATH in Python?",
        "answer": "PYTHONPATH is an environment variable which you can set to add additional directories where Python will look for modules and packages. This is especially useful in maintaining Python libraries that you do not wish to install in the global default location.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "17. What are generators in Python?",
        "answer": "Generators are functions that return an iterable collection of items, one at a time, in a set manner. Generators, in general, are used to create iterators with a different approach. They employ the use of yield keyword rather than return to return a generator object.\nLet's try and build a generator for fibonacci numbers - yield return generator  ## generate fibonacci numbers upto n\ndef fib(n):\n   p, q = 0, 1\n   while(p < n):\n       yield p\n       p, q = q, p + q\nx = fib(10)    # create generator object \n \n## iterating using __next__(), for Python2, use next()\nx.__next__()    # output => 0\nx.__next__()    # output => 1\nx.__next__()    # output => 1\nx.__next__()    # output => 2\nx.__next__()    # output => 3\nx.__next__()    # output => 5\nx.__next__()    # output => 8\nx.__next__()    # error\n \n## iterating using loop\nfor i in fib(10):\n   print(i)    # output => 0 1 1 2 3 5 8 ## generate fibonacci numbers upto n\ndef fib(n):\n   p, q = 0, 1\n   while(p < n):\n       yield p\n       p, q = q, p + q\nx = fib(10)    # create generator object \n \n## iterating using __next__(), for Python2, use next()\nx.__next__()    # output => 0\nx.__next__()    # output => 1\nx.__next__()    # output => 1\nx.__next__()    # output => 2\nx.__next__()    # output => 3\nx.__next__()    # output => 5\nx.__next__()    # output => 8\nx.__next__()    # error\n \n## iterating using loop\nfor i in fib(10):\n   print(i)    # output => 0 1 1 2 3 5 8 ## generate fibonacci numbers upto n def fib(n): def fib n 0 1 while yield 10 # create generator object ## iterating using __next__(), for Python2, use next() # output => 0 # output => 1 # output => 1 # output => 2 # output => 3 # output => 5 # output => 8 # error ## iterating using loop for in 10 print # output => 0 1 1 2 3 5 8",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "18. What is pickling and unpickling?",
        "answer": "Python library offers a feature - serialization out of the box. Serializing an object refers to transforming it into a format that can be stored, so as to be able to deserialize it, later on, to obtain the original object. Here, the pickle module comes into play. serialization pickle Pickling: Pickling: Pickling is the name of the serialization process in Python. Any object in Python can be serialized into a byte stream and dumped as a file in the memory. The process of pickling is compact but pickle objects can be compressed further. Moreover, pickle keeps track of the objects it has serialized and the serialization is portable across versions.\nThe function used for the above process is pickle.dump(). Pickling is the name of the serialization process in Python. Any object in Python can be serialized into a byte stream and dumped as a file in the memory. The process of pickling is compact but pickle objects can be compressed further. Moreover, pickle keeps track of the objects it has serialized and the serialization is portable across versions. The function used for the above process is pickle.dump(). pickle.dump() Unpickling: Unpickling: Unpickling is the complete inverse of pickling. It deserializes the byte stream to recreate the objects stored in the file and loads the object to memory.\nThe function used for the above process is pickle.load(). Unpickling is the complete inverse of pickling. It deserializes the byte stream to recreate the objects stored in the file and loads the object to memory. The function used for the above process is pickle.load(). pickle.load() Note: Python has another, more primitive, serialization module called marshall, which exists primarily to support .pyc files in Python and differs significantly from the pickle. Note: Python has another, more primitive, serialization module called marshall, which exists primarily to support .pyc files in Python and differs significantly from the pickle. marshall support .pyc files differs significantly from the pickle  ",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "19. What is the difference between xrange and range in Python?",
        "answer": "xrange() and range() are quite similar in terms of functionality. They both generate a sequence of integers, with the only difference that range() returns a Python list, whereas, xrange() returns an xrange object. xrange() range() range() Python list xrange() xrange object So how does that make a difference? It sure does, because unlike range(), xrange() doesn't generate a static list, it creates the value on the go. This technique is commonly used with an object-type generator and has been termed as \"yielding\". So how does that make a difference? generator yielding Yielding is crucial in applications where memory is a constraint. Creating a static list as in range() can lead to a Memory Error in such conditions, while, xrange() can handle it optimally by using just enough memory for the generator (significantly less in comparison). Yielding Memory Error for i in xrange(10):    # numbers from o to 9\n   print i       # output => 0 1 2 3 4 5 6 7 8 9\nfor i in xrange(1,10):    # numbers from 1 to 9\n   print i       # output => 1 2 3 4 5 6 7 8 9\nfor i in xrange(1, 10, 2):    # skip by two for next\n   print i       # output => 1 3 5 7 9 for i in xrange(10):    # numbers from o to 9\n   print i       # output => 0 1 2 3 4 5 6 7 8 9\nfor i in xrange(1,10):    # numbers from 1 to 9\n   print i       # output => 1 2 3 4 5 6 7 8 9\nfor i in xrange(1, 10, 2):    # skip by two for next\n   print i       # output => 1 3 5 7 9 for in 10 # numbers from o to 9 print # output => 0 1 2 3 4 5 6 7 8 9 for in 1 10 # numbers from 1 to 9 print # output => 1 2 3 4 5 6 7 8 9 for in 1 10 2 # skip by two for next print # output => 1 3 5 7 9 Note: xrange has been deprecated as of Python 3.x. Now range does exactly the same as what xrange used to do in Python 2.x, since it was way better to use xrange() than the original range() function in Python 2.x. Note xrange deprecated Python 3.x range xrange Python 2.x",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "20. How do you copy an object in Python?",
        "answer": "In Python, the assignment statement (= operator) does not copy objects. Instead, it creates a binding between the existing object and the target variable name. To create copies of an object in Python, we need to use the copy module. Moreover, there are two ways of creating copies for the given object using the copy module - = copy copy Shallow Copy is a bit-wise copy of an object. The copied object created has an exact copy of the values in the original object. If either of the values is a reference to other objects, just the reference addresses for the same are copied.\nDeep Copy copies all values recursively from source to target object, i.e. it even duplicates the objects referenced by the source object. Shallow Copy  Deep Copy from copy import copy, deepcopy\nlist_1 = [1, 2, [3, 5], 4]\n## shallow copy\nlist_2 = copy(list_1) \nlist_2[3] = 7\nlist_2[2].append(6)\nlist_2    # output => [1, 2, [3, 5, 6], 7]\nlist_1    # output => [1, 2, [3, 5, 6], 4]\n## deep copy\nlist_3 = deepcopy(list_1)\nlist_3[3] = 8\nlist_3[2].append(7)\nlist_3    # output => [1, 2, [3, 5, 6, 7], 8]\nlist_1    # output => [1, 2, [3, 5, 6], 4] from copy import copy, deepcopy\nlist_1 = [1, 2, [3, 5], 4]\n## shallow copy\nlist_2 = copy(list_1) \nlist_2[3] = 7\nlist_2[2].append(6)\nlist_2    # output => [1, 2, [3, 5, 6], 7]\nlist_1    # output => [1, 2, [3, 5, 6], 4]\n## deep copy\nlist_3 = deepcopy(list_1)\nlist_3[3] = 8\nlist_3[2].append(7)\nlist_3    # output => [1, 2, [3, 5, 6, 7], 8]\nlist_1    # output => [1, 2, [3, 5, 6], 4] from import 1 2 3 5 4 ## shallow copy 3 7 2 6 # output => [1, 2, [3, 5, 6], 7] # output => [1, 2, [3, 5, 6], 4] ## deep copy 3 8 2 7 # output => [1, 2, [3, 5, 6, 7], 8] # output => [1, 2, [3, 5, 6], 4]",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "1. How will you check if a class is a child of another class?",
        "answer": "This is done by using a method called issubclass() provided by python. The method tells us if any class is a child of another class by returning true or false accordingly.\nFor example: issubclass()  For example: class Parent(object):\n   pass   \n \nclass Child(Parent):\n   pass   \n \n# Driver Code\nprint(issubclass(Child, Parent))    #True\nprint(issubclass(Parent, Child))    #False class Parent(object):\n   pass   \n \nclass Child(Parent):\n   pass   \n \n# Driver Code\nprint(issubclass(Child, Parent))    #True\nprint(issubclass(Parent, Child))    #False class Parent(object): class Parent object object pass class Child(Parent): class Child Parent pass # Driver Code print issubclass #True print issubclass #False We can check if an object is an instance of a class by making use of isinstance() method: We can check if an object is an instance of a class by making use of isinstance() method: isinstance() obj1 = Child()\nobj2 = Parent()\nprint(isinstance(obj2, Child))    #False \nprint(isinstance(obj2, Parent))   #True obj1 = Child()\nobj2 = Parent()\nprint(isinstance(obj2, Child))    #False \nprint(isinstance(obj2, Parent))   #True print isinstance #False print isinstance #True",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "2. What is init method in python?",
        "answer": "The init method works similarly to the constructors in Java. The method is run as soon as an object is instantiated. It is useful for initializing any attributes or default behaviour of the object at the time of instantiation.\nFor example: init  class InterviewbitEmployee:\n\n   # init method / constructor\n   def __init__(self, emp_name):\n       self.emp_name = emp_name\n\n   # introduce method\n   def introduce(self):\n       print('Hello, I am ', self.emp_name)\n\nemp = InterviewbitEmployee('Mr Employee')    # __init__ method is called here and initializes the object name with \"Mr Employee\"\nemp.introduce() class InterviewbitEmployee:\n\n   # init method / constructor\n   def __init__(self, emp_name):\n       self.emp_name = emp_name\n\n   # introduce method\n   def introduce(self):\n       print('Hello, I am ', self.emp_name)\n\nemp = InterviewbitEmployee('Mr Employee')    # __init__ method is called here and initializes the object name with \"Mr Employee\"\nemp.introduce() class InterviewbitEmployee: class InterviewbitEmployee # init method / constructor def __init__(self, emp_name): def __init__ self, emp_name # introduce method def introduce(self): def introduce self print 'Hello, I am ' 'Mr Employee' # __init__ method is called here and initializes the object name with \"Mr Employee\"",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "3. Why is finalize used?",
        "answer": "Finalize method is used for freeing up the unmanaged resources and clean up before the garbage collection method is invoked. This helps in performing memory management tasks.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "4. Differentiate between new and override modifiers.",
        "answer": "The new modifier is used to instruct the compiler to use the new implementation and not the base class function. The Override modifier is useful for overriding a base class function inside the child class.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "5. How is an empty class created in python?",
        "answer": "An empty class does not have any members defined in it. It is created by using the pass keyword (the pass command does nothing in python). We can create objects for this class outside the class.\nFor example-  class EmptyClassDemo:\n   pass\nobj=EmptyClassDemo()\nobj.name=\"Interviewbit\"\nprint(\"Name created= \",obj.name) class EmptyClassDemo:\n   pass\nobj=EmptyClassDemo()\nobj.name=\"Interviewbit\"\nprint(\"Name created= \",obj.name) class EmptyClassDemo: class EmptyClassDemo pass \"Interviewbit\" print \"Name created= \" Output:\nName created = Interviewbit Output: ",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "6. Is it possible to call parent class without its instance creation?",
        "answer": "Yes, it is possible if the base class is instantiated by other child classes or if the base class is a static method.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "7. Are access specifiers used in python?",
        "answer": "Python does not make use of access specifiers specifically like private, public, protected, etc. However, it does not derive this from any variables. It has the concept of imitating the behaviour of variables by making use of a single (protected) or double underscore (private) as prefixed to the variable names. By default, the variables without prefixed underscores are public. Example: Example: # to demonstrate access specifiers\nclass InterviewbitEmployee:\n   \n    # protected members\n    _emp_name = None\n    _age = None\n    \n    # private members\n    __branch = None\n    \n    # constructor\n    def __init__(self, emp_name, age, branch): \n         self._emp_name = emp_name\n         self._age = age\n         self.__branch = branch\n    \n    #public member\n    def display():\n        print(self._emp_name +\" \"+self._age+\" \"+self.__branch) # to demonstrate access specifiers\nclass InterviewbitEmployee:\n   \n    # protected members\n    _emp_name = None\n    _age = None\n    \n    # private members\n    __branch = None\n    \n    # constructor\n    def __init__(self, emp_name, age, branch): \n         self._emp_name = emp_name\n         self._age = age\n         self.__branch = branch\n    \n    #public member\n    def display():\n        print(self._emp_name +\" \"+self._age+\" \"+self.__branch) # to demonstrate access specifiers class InterviewbitEmployee: class InterviewbitEmployee # protected members None None # private members None # constructor def __init__(self, emp_name, age, branch): def __init__ self, emp_name, age, branch #public member def display(): def display print \" \" \" \"",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "8. How do you access parent members in the child class?",
        "answer": "Following are the ways using which you can access parent class members within a child class: By using Parent class name: You can use the name of the parent class to access the attributes as shown in the example below: By using Parent class name: You can use the name of the parent class to access the attributes as shown in the example below: By using Parent class name: class Parent(object):  \n   # Constructor\n   def __init__(self, name):\n       self.name = name    \n \nclass Child(Parent): \n   # Constructor\n   def __init__(self, name, age):\n       Parent.name = name\n       self.age = age\n \n   def display(self):\n       print(Parent.name, self.age)\n \n# Driver Code\nobj = Child(\"Interviewbit\", 6)\nobj.display() class Parent(object):  \n   # Constructor\n   def __init__(self, name):\n       self.name = name    \n \nclass Child(Parent): \n   # Constructor\n   def __init__(self, name, age):\n       Parent.name = name\n       self.age = age\n \n   def display(self):\n       print(Parent.name, self.age)\n \n# Driver Code\nobj = Child(\"Interviewbit\", 6)\nobj.display() class Parent(object): class Parent object object # Constructor def __init__(self, name): def __init__ self, name class Child(Parent): class Child Parent # Constructor def __init__(self, name, age): def __init__ self, name, age def display(self): def display self print # Driver Code \"Interviewbit\" 6 By using super(): The parent class members can be accessed in child class using the super keyword. By using super(): The parent class members can be accessed in child class using the super keyword. By using super(): class Parent(object):\n   # Constructor\n   def __init__(self, name):\n       self.name = name    \n \nclass Child(Parent):\n   # Constructor\n   def __init__(self, name, age):         \n       ''' \n       In Python 3.x, we can also use super().__init__(name)\n       ''' \n       super(Child, self).__init__(name)\n       self.age = age\n \n   def display(self):\n      # Note that Parent.name cant be used \n      # here since super() is used in the constructor\n      print(self.name, self.age)\n  \n# Driver Code\nobj = Child(\"Interviewbit\", 6)\nobj.display() class Parent(object):\n   # Constructor\n   def __init__(self, name):\n       self.name = name    \n \nclass Child(Parent):\n   # Constructor\n   def __init__(self, name, age):         \n       ''' \n       In Python 3.x, we can also use super().__init__(name)\n       ''' \n       super(Child, self).__init__(name)\n       self.age = age\n \n   def display(self):\n      # Note that Parent.name cant be used \n      # here since super() is used in the constructor\n      print(self.name, self.age)\n  \n# Driver Code\nobj = Child(\"Interviewbit\", 6)\nobj.display() class Parent(object): class Parent object object # Constructor def __init__(self, name): def __init__ self, name class Child(Parent): class Child Parent # Constructor def __init__(self, name, age): def __init__ self, name, age ''' \n       In Python 3.x, we can also use super().__init__(name)\n       ''' super def display(self): def display self # Note that Parent.name cant be used # here since super() is used in the constructor print # Driver Code \"Interviewbit\" 6",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "9. How does inheritance work in python? Explain it with an example.",
        "answer": "Inheritance gives the power to a class to access all attributes and methods of another class. It aids in code reusability and helps the developer to maintain applications without redundant code. The class inheriting from another class is a child class or also called a derived class. The class from which a child class derives the members are called parent class or superclass. Python supports different kinds of inheritance, they are: Single Inheritance: Child class derives members of one parent class. Single Inheritance: Child class derives members of one parent class. Single Inheritance   # Parent class\nclass ParentClass:\n    def par_func(self):\n         print(\"I am parent class function\")\n\n# Child class\nclass ChildClass(ParentClass):\n    def child_func(self):\n         print(\"I am child class function\")\n\n# Driver code\nobj1 = ChildClass()\nobj1.par_func()\nobj1.child_func() # Parent class\nclass ParentClass:\n    def par_func(self):\n         print(\"I am parent class function\")\n\n# Child class\nclass ChildClass(ParentClass):\n    def child_func(self):\n         print(\"I am child class function\")\n\n# Driver code\nobj1 = ChildClass()\nobj1.par_func()\nobj1.child_func() # Parent class class ParentClass: class ParentClass def par_func(self): def par_func self print \"I am parent class function\" # Child class class ChildClass(ParentClass): class ChildClass ParentClass def child_func(self): def child_func self print \"I am child class function\" # Driver code Multi-level Inheritance: The members of the parent class, A, are inherited by child class which is then inherited by another child class, B. The features of the base class and the derived class are further inherited into the new derived class, C. Here, A is the grandfather class of class C. Multi-level Inheritance: The members of the parent class, A, are inherited by child class which is then inherited by another child class, B. The features of the base class and the derived class are further inherited into the new derived class, C. Here, A is the grandfather class of class C. Multi-level Inheritance:   # Parent class\nclass A:\n   def __init__(self, a_name):\n       self.a_name = a_name\n   \n# Intermediate class\nclass B(A):\n   def __init__(self, b_name, a_name):\n       self.b_name = b_name\n       # invoke constructor of class A\n       A.__init__(self, a_name)\n\n# Child class\nclass C(B):\n   def __init__(self,c_name, b_name, a_name):\n       self.c_name = c_name\n       # invoke constructor of class B\n       B.__init__(self, b_name, a_name)\n       \n   def display_names(self):\n       print(\"A name : \", self.a_name)\n       print(\"B name : \", self.b_name)\n       print(\"C name : \", self.c_name)\n\n#  Driver code\nobj1 = C('child', 'intermediate', 'parent')\nprint(obj1.a_name)\nobj1.display_names() # Parent class\nclass A:\n   def __init__(self, a_name):\n       self.a_name = a_name\n   \n# Intermediate class\nclass B(A):\n   def __init__(self, b_name, a_name):\n       self.b_name = b_name\n       # invoke constructor of class A\n       A.__init__(self, a_name)\n\n# Child class\nclass C(B):\n   def __init__(self,c_name, b_name, a_name):\n       self.c_name = c_name\n       # invoke constructor of class B\n       B.__init__(self, b_name, a_name)\n       \n   def display_names(self):\n       print(\"A name : \", self.a_name)\n       print(\"B name : \", self.b_name)\n       print(\"C name : \", self.c_name)\n\n#  Driver code\nobj1 = C('child', 'intermediate', 'parent')\nprint(obj1.a_name)\nobj1.display_names() # Parent class class A: class A def __init__(self, a_name): def __init__ self, a_name # Intermediate class class B(A): class B A def __init__(self, b_name, a_name): def __init__ self, b_name, a_name # invoke constructor of class A # Child class class C(B): class C B def __init__(self,c_name, b_name, a_name): def __init__ self,c_name, b_name, a_name # invoke constructor of class B def display_names(self): def display_names self print \"A name : \" print \"B name : \" print \"C name : \" #  Driver code 'child' 'intermediate' 'parent' print Multiple Inheritance: This is achieved when one child class derives members from more than one parent class. All features of parent classes are inherited in the child class. Multiple Inheritance: This is achieved when one child class derives members from more than one parent class. All features of parent classes are inherited in the child class. Multiple Inheritance:   # Parent class1\nclass Parent1:\n   def parent1_func(self):\n       print(\"Hi I am first Parent\")\n\n# Parent class2\nclass Parent2:\n   def parent2_func(self):\n       print(\"Hi I am second Parent\")\n\n# Child class\nclass Child(Parent1, Parent2):\n   def child_func(self):\n       self.parent1_func()\n       self.parent2_func()\n\n# Driver's code\nobj1 = Child()\nobj1.child_func() # Parent class1\nclass Parent1:\n   def parent1_func(self):\n       print(\"Hi I am first Parent\")\n\n# Parent class2\nclass Parent2:\n   def parent2_func(self):\n       print(\"Hi I am second Parent\")\n\n# Child class\nclass Child(Parent1, Parent2):\n   def child_func(self):\n       self.parent1_func()\n       self.parent2_func()\n\n# Driver's code\nobj1 = Child()\nobj1.child_func() # Parent class1 class Parent1: class Parent1 def parent1_func(self): def parent1_func self print \"Hi I am first Parent\" # Parent class2 class Parent2: class Parent2 def parent2_func(self): def parent2_func self print \"Hi I am second Parent\" # Child class class Child(Parent1, Parent2): class Child Parent1, Parent2 def child_func(self): def child_func self # Driver's code Hierarchical Inheritance: When a parent class is derived by more than one child class, it is called hierarchical inheritance. Hierarchical Inheritance: When a parent class is derived by more than one child class, it is called hierarchical inheritance. Hierarchical Inheritance:   # Base class\nclass A:\n     def a_func(self):\n         print(\"I am from the parent class.\")\n\n# 1st Derived class\nclass B(A):\n     def b_func(self):\n         print(\"I am from the first child.\")\n\n# 2nd Derived class\nclass C(A):\n     def c_func(self):\n         print(\"I am from the second child.\")\n \n# Driver's code\nobj1 = B()\nobj2 = C()\nobj1.a_func()\nobj1.b_func()    #child 1 method\nobj2.a_func()\nobj2.c_func()    #child 2 method # Base class\nclass A:\n     def a_func(self):\n         print(\"I am from the parent class.\")\n\n# 1st Derived class\nclass B(A):\n     def b_func(self):\n         print(\"I am from the first child.\")\n\n# 2nd Derived class\nclass C(A):\n     def c_func(self):\n         print(\"I am from the second child.\")\n \n# Driver's code\nobj1 = B()\nobj2 = C()\nobj1.a_func()\nobj1.b_func()    #child 1 method\nobj2.a_func()\nobj2.c_func()    #child 2 method # Base class class A: class A def a_func(self): def a_func self print \"I am from the parent class.\" # 1st Derived class class B(A): class B A def b_func(self): def b_func self print \"I am from the first child.\" # 2nd Derived class class C(A): class C A def c_func(self): def c_func self print \"I am from the second child.\" # Driver's code #child 1 method #child 2 method",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "10. How do you create a class in Python?",
        "answer": "To create a class in python, we use the keyword “class” as shown in the example below: class InterviewbitEmployee:\n   def __init__(self, emp_name):\n       self.emp_name = emp_name class InterviewbitEmployee:\n   def __init__(self, emp_name):\n       self.emp_name = emp_name class InterviewbitEmployee: class InterviewbitEmployee def __init__(self, emp_name): def __init__ self, emp_name To instantiate or create an object from the class created above, we do the following: emp_1=InterviewbitEmployee(\"Mr. Employee\") emp_1=InterviewbitEmployee(\"Mr. Employee\") \"Mr. Employee\" To access the name attribute, we just call the attribute using the dot operator as shown below: print(emp_1.emp_name)\n# Prints Mr. Employee print(emp_1.emp_name)\n# Prints Mr. Employee print # Prints Mr. Employee To create methods inside the class, we include the methods under the scope of the class as shown below: class InterviewbitEmployee:\n   def __init__(self, emp_name):\n       self.emp_name = emp_name\n       \n   def introduce(self):\n       print(\"Hello I am \" + self.emp_name) class InterviewbitEmployee:\n   def __init__(self, emp_name):\n       self.emp_name = emp_name\n       \n   def introduce(self):\n       print(\"Hello I am \" + self.emp_name) class InterviewbitEmployee: class InterviewbitEmployee def __init__(self, emp_name): def __init__ self, emp_name def introduce(self): def introduce self print \"Hello I am \" The self parameter in the init and introduce functions represent the reference to the current class instance which is used for accessing attributes and methods of that class. The self parameter has to be the first parameter of any method defined inside the class. The method of the class InterviewbitEmployee can be accessed as shown below: emp_1.introduce() emp_1.introduce() The overall program would look like this: class InterviewbitEmployee:\n   def __init__(self, emp_name):\n       self.emp_name = emp_name\n       \n   def introduce(self):\n       print(\"Hello I am \" + self.emp_name)\n       \n# create an object of InterviewbitEmployee class\nemp_1 = InterviewbitEmployee(\"Mr Employee\")\nprint(emp_1.emp_name)    #print employee name\nemp_1.introduce()        #introduce the employee class InterviewbitEmployee:\n   def __init__(self, emp_name):\n       self.emp_name = emp_name\n       \n   def introduce(self):\n       print(\"Hello I am \" + self.emp_name)\n       \n# create an object of InterviewbitEmployee class\nemp_1 = InterviewbitEmployee(\"Mr Employee\")\nprint(emp_1.emp_name)    #print employee name\nemp_1.introduce()        #introduce the employee class InterviewbitEmployee: class InterviewbitEmployee def __init__(self, emp_name): def __init__ self, emp_name def introduce(self): def introduce self print \"Hello I am \" # create an object of InterviewbitEmployee class \"Mr Employee\" print #print employee name #introduce the employee",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "1. Can you get items of series A that are not available in another series B?",
        "answer": "This can be achieved by using the ~ (not/negation symbol) and isin() method as shown below. ~ isin() import pandas as pd\ndf1 = pd.Series([2, 4, 8, 10, 12])\ndf2 = pd.Series([8, 12, 10, 15, 16])\ndf1=df1[~df1.isin(df2)]\nprint(df1)\n\"\"\"\nOutput:\n0    2\n1    4\ndtype: int64\n\"\"\" import pandas as pd\ndf1 = pd.Series([2, 4, 8, 10, 12])\ndf2 = pd.Series([8, 12, 10, 15, 16])\ndf1=df1[~df1.isin(df2)]\nprint(df1)\n\"\"\"\nOutput:\n0    2\n1    4\ndtype: int64\n\"\"\" import as 2 4 8 10 12 8 12 10 15 16 print \"\"\"\nOutput:\n0    2\n1    4\ndtype: int64\n\"\"\"",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "2. While importing data from different sources, can the pandas library recognize dates?",
        "answer": "Yes, they can, but with some bit of help. We need to add the parse_dates argument while we are reading data from the sources. Consider an example where we read data from a CSV file, we may encounter different date-time formats that are not readable by the pandas library. In this case, pandas provide flexibility to build our custom date parser with the help of lambda functions as shown below: import pandas as pd\nfrom datetime import datetime\ndateparser = lambda date_val: datetime.strptime(date_val, '%Y-%m-%d %H:%M:%S')\ndf = pd.read_csv(\"some_file.csv\", parse_dates=['datetime_column'], date_parser=dateparser) import pandas as pd\nfrom datetime import datetime\ndateparser = lambda date_val: datetime.strptime(date_val, '%Y-%m-%d %H:%M:%S')\ndf = pd.read_csv(\"some_file.csv\", parse_dates=['datetime_column'], date_parser=dateparser) import as from import lambda '%Y-%m-%d %H:%M:%S' \"some_file.csv\" 'datetime_column'",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "3. How will you get the items that are not common to both the given series A and B?",
        "answer": "We can achieve this by first performing the union of both series, then taking the intersection of both series. Then we follow the approach of getting items of union that are not there in the list of the intersection.   The following code demonstrates this: import pandas as pd\nimport numpy as np\ndf1 = pd.Series([2, 4, 5, 8, 10])\ndf2 = pd.Series([8, 10, 13, 15, 17])\np_union = pd.Series(np.union1d(df1, df2))  # union of series\np_intersect = pd.Series(np.intersect1d(df1, df2))  # intersection of series\nunique_elements = p_union[~p_union.isin(p_intersect)]\nprint(unique_elements)\n\"\"\"\nOutput:\n0     2\n1     4\n2     5\n5    13\n6    15\n7    17\ndtype: int64\n\"\"\" import pandas as pd\nimport numpy as np\ndf1 = pd.Series([2, 4, 5, 8, 10])\ndf2 = pd.Series([8, 10, 13, 15, 17])\np_union = pd.Series(np.union1d(df1, df2))  # union of series\np_intersect = pd.Series(np.intersect1d(df1, df2))  # intersection of series\nunique_elements = p_union[~p_union.isin(p_intersect)]\nprint(unique_elements)\n\"\"\"\nOutput:\n0     2\n1     4\n2     5\n5    13\n6    15\n7    17\ndtype: int64\n\"\"\" import as import as 2 4 5 8 10 8 10 13 15 17 # union of series # intersection of series print \"\"\"\nOutput:\n0     2\n1     4\n2     5\n5    13\n6    15\n7    17\ndtype: int64\n\"\"\"",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "4. How will you delete indices, rows and columns from a dataframe?",
        "answer": "To delete an Index: To delete an Index: Execute del df.index.name for removing the index by name.\nAlternatively, the df.index.name can be assigned to None.\nFor example, if you have the below dataframe: Execute del df.index.name for removing the index by name. del df.index.name Alternatively, the df.index.name can be assigned to None. df.index.name For example, if you have the below dataframe: Column 1\n   Names             \n   John               1\n   Jack               2\n   Judy               3\n   Jim                4 Column 1\n   Names             \n   John               1\n   Jack               2\n   Judy               3\n   Jim                4 1 1 2 3 4 To drop the index name “Names”: To drop the index name “Names”: df.index.name = None\n# Or run the below:\n# del df.index.name\nprint(df)\n        Column 1\nJohn          1\nJack          2\nJudy          3\nJim           4 df.index.name = None\n# Or run the below:\n# del df.index.name\nprint(df)\n        Column 1\nJohn          1\nJack          2\nJudy          3\nJim           4 None # Or run the below: # del df.index.name print 1 1 2 3 4 To delete row/column from dataframe: To delete row/column from dataframe: drop() method is used to delete row/column from dataframe.\nThe axis argument is passed to the drop method where if the value is 0, it indicates to drop/delete a row and if 1 it has to drop the column.\nAdditionally, we can try to delete the rows/columns in place by setting the value of inplace to True. This makes sure that the job is done without the need for reassignment.\nThe duplicate values from the row/column can be deleted by using the drop_duplicates() method. drop() method is used to delete row/column from dataframe. drop() The axis argument is passed to the drop method where if the value is 0, it indicates to drop/delete a row and if 1 it has to drop the column. Additionally, we can try to delete the rows/columns in place by setting the value of inplace to True. This makes sure that the job is done without the need for reassignment. The duplicate values from the row/column can be deleted by using the drop_duplicates() method. drop_duplicates()  ",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "5. How to add new column to pandas dataframe?",
        "answer": "A new column can be added to a pandas dataframe as follows: import pandas as pd      \ndata_info = {'first' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),    \n       'second' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}    \n  \ndf = pd.DataFrame(data_info)    \n#To add new column third\ndf['third']=pd.Series([10,20,30],index=['a','b','c'])    \nprint (df)    \n#To add new column fourth\ndf['fourth']=df['first']+info['third']    \nprint (df) import pandas as pd      \ndata_info = {'first' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),    \n       'second' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}    \n  \ndf = pd.DataFrame(data_info)    \n#To add new column third\ndf['third']=pd.Series([10,20,30],index=['a','b','c'])    \nprint (df)    \n#To add new column fourth\ndf['fourth']=df['first']+info['third']    \nprint (df) import as 'first' 1 2 3 'a' 'b' 'c' 'second' 1 2 3 4 'a' 'b' 'c' 'd' #To add new column third 'third' 10 20 30 'a' 'b' 'c' print #To add new column fourth 'fourth' 'first' 'third' print",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "6. What do you understand by reindexing in pandas?",
        "answer": "Reindexing is the process of conforming a dataframe to a new index with optional filling logic. If the values are missing in the previous index, then NaN/NA is placed in the location. A new object is returned unless a new index is produced that is equivalent to the current one. The copy value is set to False. This is also used for changing the index of rows and columns in the dataframe.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "7. How will you identify and deal with missing values in a dataframe?",
        "answer": "We can identify if a dataframe has missing values by using the isnull() and isna() methods. missing_data_count=df.isnull().sum() missing_data_count=df.isnull().sum() sum We can handle missing values by either replacing the values in the column with 0 as follows: df[‘column_name’].fillna(0) df[‘column_name’].fillna(0) 0 Or by replacing it with the mean value of the column df[‘column_name’] = df[‘column_name’].fillna((df[‘column_name’].mean())) df[‘column_name’] = df[‘column_name’].fillna((df[‘column_name’].mean()))",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "8. Can you create a series from the dictionary object in pandas?",
        "answer": "One dimensional array capable of storing different data types is called a series. We can create pandas series from a dictionary object as shown below: import pandas as pd    \ndict_info = {'key1' : 2.0, 'key2' : 3.1, 'key3' : 2.2}  \nseries_obj = pd.Series(dict_info)    \nprint (series_obj)    \nOutput:\nx     2.0\ny     3.1\nz     2.2\ndtype: float64 import pandas as pd    \ndict_info = {'key1' : 2.0, 'key2' : 3.1, 'key3' : 2.2}  \nseries_obj = pd.Series(dict_info)    \nprint (series_obj)    \nOutput:\nx     2.0\ny     3.1\nz     2.2\ndtype: float64 import as 'key1' 2.0 'key2' 3.1 'key3' 2.2 print 2.0 3.1 2.2 If an index is not specified in the input method, then the keys of the dictionaries are sorted in ascending order for constructing the index. In case the index is passed, then values of the index label will be extracted from the dictionary.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "9. How will you combine different pandas dataframes?",
        "answer": "The dataframes can be combines using the below approaches: append() method: This is used to stack the dataframes horizontally. Syntax: append() method: This is used to stack the dataframes horizontally. Syntax: append() method df1.append(df2) df1.append(df2) concat() method: This is used to stack dataframes vertically. This is best used when the dataframes have the same columns and similar fields. Syntax: concat() method: This is used to stack dataframes vertically. This is best used when the dataframes have the same columns and similar fields. Syntax: concat() method: pd.concat([df1, df2]) pd.concat([df1, df2]) join() method: This is used for extracting data from various dataframes having one or more common columns. join() method: This is used for extracting data from various dataframes having one or more common columns. join() method: df1.join(df2) df1.join(df2)",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "10. Define pandas dataframe.",
        "answer": "A dataframe is a 2D mutable and tabular structure for representing data labelled with axes - rows and columns.\nThe syntax for creating dataframe:  The syntax for creating dataframe: import pandas as pd\ndataframe = pd.DataFrame( data, index, columns, dtype) import pandas as pd\ndataframe = pd.DataFrame( data, index, columns, dtype) import as where: data - Represents various forms like series, map, ndarray, lists, dict etc.\nindex - Optional argument that represents an index to row labels.\ncolumns - Optional argument for column labels.\nDtype - the data type of each column. Again optional. data - Represents various forms like series, map, ndarray, lists, dict etc. index - Optional argument that represents an index to row labels. columns - Optional argument for column labels. Dtype - the data type of each column. Again optional.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "11. What do you know about pandas?",
        "answer": "Pandas is an open-source, python-based library used in data manipulation applications requiring high performance. The name is derived from “Panel Data” having multidimensional data. This was developed in 2008 by Wes McKinney and was developed for data analysis.\nPandas are useful in performing 5 major steps of data analysis - Load the data, clean/manipulate it, prepare it, model it, and analyze the data. Pandas is an open-source, python-based library used in data manipulation applications requiring high performance. The name is derived from “Panel Data” having multidimensional data. This was developed in 2008 by Wes McKinney and was developed for data analysis. Pandas are useful in performing 5 major steps of data analysis - Load the data, clean/manipulate it, prepare it, model it, and analyze the data.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "1. How will you reverse the numpy array using one line of code?",
        "answer": "This can be done as shown in the following: reversed_array = arr[::-1] reversed_array = arr[::-1] 1 where arr = original given array, reverse_array is the resultant after reversing all elements in the input. arr",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "2. How will you find the nearest value in a given numpy array?",
        "answer": "We can use the argmin() method of numpy as shown below: import numpy as np\ndef find_nearest_value(arr, value):\n   arr = np.asarray(arr)\n   idx = (np.abs(arr - value)).argmin()\n   return arr[idx]\n#Driver code\narr = np.array([ 0.21169,  0.61391, 0.6341, 0.0131, 0.16541,  0.5645,  0.5742])\nvalue = 0.52\nprint(find_nearest_value(arr, value)) # Prints 0.5645 import numpy as np\ndef find_nearest_value(arr, value):\n   arr = np.asarray(arr)\n   idx = (np.abs(arr - value)).argmin()\n   return arr[idx]\n#Driver code\narr = np.array([ 0.21169,  0.61391, 0.6341, 0.0131, 0.16541,  0.5645,  0.5742])\nvalue = 0.52\nprint(find_nearest_value(arr, value)) # Prints 0.5645 import as def find_nearest_value(arr, value): def find_nearest_value arr, value abs return #Driver code 0.21169 0.61391 0.6341 0.0131 0.16541 0.5645 0.5742 0.52 print # Prints 0.5645",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "3. How will you sort the array based on the Nth column?",
        "answer": "For example, consider an array arr. arr = np.array([[8, 3, 2],\n          [3, 6, 5],\n          [6, 1, 4]]) arr = np.array([[8, 3, 2],\n          [3, 6, 5],\n          [6, 1, 4]]) 8 3 2 3 6 5 6 1 4 Let us try to sort the rows by the 2nd column so that we get: [[6, 1, 4],\n[8, 3, 2],\n[3, 6, 5]] [[6, 1, 4],\n[8, 3, 2],\n[3, 6, 5]] 6 1 4 8 3 2 3 6 5 We can do this by using the sort() method in numpy as: import numpy as np\narr = np.array([[8, 3, 2],\n          [3, 6, 5],\n          [6, 1, 4]])\n#sort the array using np.sort\narr = np.sort(arr.view('i8,i8,i8'),\n       order=['f1'],\n       axis=0).view(np.int) import numpy as np\narr = np.array([[8, 3, 2],\n          [3, 6, 5],\n          [6, 1, 4]])\n#sort the array using np.sort\narr = np.sort(arr.view('i8,i8,i8'),\n       order=['f1'],\n       axis=0).view(np.int) import as 8 3 2 3 6 5 6 1 4 #sort the array using np.sort 'i8,i8,i8' 'f1' 0 int We can also perform sorting and that too inplace sorting by doing: arr.view('i8,i8,i8').sort(order=['f1'], axis=0) arr.view('i8,i8,i8').sort(order=['f1'], axis=0) 'i8,i8,i8' 'f1' 0",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "4. How will you read CSV data into an array in NumPy?",
        "answer": "This can be achieved by using the genfromtxt() method by setting the delimiter as a comma. from numpy import genfromtxt\ncsv_data = genfromtxt('sample_file.csv', delimiter=',') from numpy import genfromtxt\ncsv_data = genfromtxt('sample_file.csv', delimiter=',') from import 'sample_file.csv' ','",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "5. How will you efficiently load data from a text file?",
        "answer": "We can use the method numpy.loadtxt() which can automatically read the file’s header and footer lines and the comments if any. numpy.loadtxt() This method is highly efficient and even if this method feels less efficient, then the data should be represented in a more efficient format such as CSV etc. Various alternatives can be considered depending on the version of NumPy used. Following are the file formats that are supported: Text files: These files are generally very slow, huge but portable and are human-readable.\nRaw binary: This file does not have any metadata and is not portable. But they are fast.\nPickle: These are borderline slow and portable but depends on the NumPy versions.\nHDF5: This is known as the High-Powered Kitchen Sink format which supports both PyTables and h5py format.\n.npy: This is NumPy's native binary data format which is extremely simple, efficient and portable. Text files: These files are generally very slow, huge but portable and are human-readable. Raw binary: This file does not have any metadata and is not portable. But they are fast. Pickle: These are borderline slow and portable but depends on the NumPy versions. HDF5: This is known as the High-Powered Kitchen Sink format which supports both PyTables and h5py format. .npy: This is NumPy's native binary data format which is extremely simple, efficient and portable.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "6. You are given a numpy array and a new column as inputs. How will you delete the second column and replace the column with a new column value?",
        "answer": "Example:\nGiven array: Example:  [[35 53 63]\n[72 12 22]\n[43 84 56]] [[35 53 63]\n[72 12 22]\n[43 84 56]] 35 53 63 72 12 22 43 84 56 New Column values: [  \n   20 \n   30 \n   40\n] [  \n   20 \n   30 \n   40\n] 20 30 40 Solution: Solution: import numpy as np\n#inputs\ninputArray = np.array([[35,53,63],[72,12,22],[43,84,56]])\nnew_col = np.array([[20,30,40]])\n# delete 2nd column\narr = np.delete(inputArray , 1, axis = 1)\n#insert new_col to array\narr = np.insert(arr , 1, new_col, axis = 1)\nprint (arr) import numpy as np\n#inputs\ninputArray = np.array([[35,53,63],[72,12,22],[43,84,56]])\nnew_col = np.array([[20,30,40]])\n# delete 2nd column\narr = np.delete(inputArray , 1, axis = 1)\n#insert new_col to array\narr = np.insert(arr , 1, new_col, axis = 1)\nprint (arr) import as #inputs 35 53 63 72 12 22 43 84 56 20 30 40 # delete 2nd column 1 1 #insert new_col to array 1 1 print",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "7. What are the steps to create 1D, 2D and 3D arrays?",
        "answer": "1D array creation: 1D array creation: 1D array creation: import numpy as np\none_dimensional_list = [1,2,4]\none_dimensional_arr = np.array(one_dimensional_list)\nprint(\"1D array is : \",one_dimensional_arr) import numpy as np\none_dimensional_list = [1,2,4]\none_dimensional_arr = np.array(one_dimensional_list)\nprint(\"1D array is : \",one_dimensional_arr) import as 1 2 4 print \"1D array is : \" 2D array creation: 2D array creation: 2D array creation: import numpy as np\ntwo_dimensional_list=[[1,2,3],[4,5,6]]\ntwo_dimensional_arr = np.array(two_dimensional_list)\nprint(\"2D array is : \",two_dimensional_arr) import numpy as np\ntwo_dimensional_list=[[1,2,3],[4,5,6]]\ntwo_dimensional_arr = np.array(two_dimensional_list)\nprint(\"2D array is : \",two_dimensional_arr) import as 1 2 3 4 5 6 print \"2D array is : \" 3D array creation: 3D array creation: 3D array creation: import numpy as np\nthree_dimensional_list=[[[1,2,3],[4,5,6],[7,8,9]]]\nthree_dimensional_arr = np.array(three_dimensional_list)\nprint(\"3D array is : \",three_dimensional_arr) import numpy as np\nthree_dimensional_list=[[[1,2,3],[4,5,6],[7,8,9]]]\nthree_dimensional_arr = np.array(three_dimensional_list)\nprint(\"3D array is : \",three_dimensional_arr) import as 1 2 3 4 5 6 7 8 9 print \"3D array is : \" ND array creation: This can be achieved by giving the ndmin attribute. The below example demonstrates the creation of a 6D array: ND array creation: This can be achieved by giving the ndmin attribute. The below example demonstrates the creation of a 6D array: ND array creation: import numpy as np\nndArray = np.array([1, 2, 3, 4], ndmin=6)\nprint(ndArray)\nprint('Dimensions of array:', ndArray.ndim) import numpy as np\nndArray = np.array([1, 2, 3, 4], ndmin=6)\nprint(ndArray)\nprint('Dimensions of array:', ndArray.ndim) import as 1 2 3 4 6 print print 'Dimensions of array:'",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "8. How are NumPy arrays advantageous over python lists?",
        "answer": "The list data structure of python is very highly efficient and is capable of performing various functions. But, they have severe limitations when it comes to the computation of vectorized operations which deals with element-wise multiplication and addition. The python lists also require the information regarding the type of every element which results in overhead as type dispatching code gets executes every time any operation is performed on any element. This is where the NumPy arrays come into the picture as all the limitations of python lists are handled in NumPy arrays.\nAdditionally, as the size of the NumPy arrays increases, NumPy becomes around 30x times faster than the Python List. This is because the Numpy arrays are densely packed in the memory due to their homogenous nature. This ensures the memory free up is also faster. The list data structure of python is very highly efficient and is capable of performing various functions. But, they have severe limitations when it comes to the computation of vectorized operations which deals with element-wise multiplication and addition. The python lists also require the information regarding the type of every element which results in overhead as type dispatching code gets executes every time any operation is performed on any element. This is where the NumPy arrays come into the picture as all the limitations of python lists are handled in NumPy arrays. Additionally, as the size of the NumPy arrays increases, NumPy becomes around 30x times faster than the Python List. This is because the Numpy arrays are densely packed in the memory due to their homogenous nature. This ensures the memory free up is also faster.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "9. What do you understand by NumPy?",
        "answer": "NumPy is one of the most popular, easy-to-use, versatile, open-source, python-based, general-purpose package that is used for processing arrays. NumPy is short for NUMerical PYthon. This is very famous for its highly optimized tools that result in high performance and powerful N-Dimensional array processing feature that is designed explicitly to work on complex arrays. Due to its popularity and powerful performance and its flexibility to perform various operations like trigonometric operations, algebraic and statistical computations, it is most commonly used in performing scientific computations and various broadcasting functions. The following image shows the applications of NumPy:  ",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "10. How will you find the shape of any given NumPy array?",
        "answer": "We can use the shape attribute of the numpy array to find the shape. It returns the shape of the array in terms of row count and column count of the array. import numpy as np\narr_two_dim = np.array([(\"x1\",\"x2\", \"x3\",\"x4\"),\n             (\"x5\",\"x6\", \"x7\",\"x8\" )])\narr_one_dim = np.array([3,2,4,5,6])\n# find and print shape\nprint(\"2-D Array Shape: \", arr_two_dim.shape)\nprint(\"1-D Array Shape: \", arr_one_dim.shape)\n\"\"\"\nOutput:\n2-D Array Shape:  (2, 4)\n1-D Array Shape:  (5,)\n\"\"\" import numpy as np\narr_two_dim = np.array([(\"x1\",\"x2\", \"x3\",\"x4\"),\n             (\"x5\",\"x6\", \"x7\",\"x8\" )])\narr_one_dim = np.array([3,2,4,5,6])\n# find and print shape\nprint(\"2-D Array Shape: \", arr_two_dim.shape)\nprint(\"1-D Array Shape: \", arr_one_dim.shape)\n\"\"\"\nOutput:\n2-D Array Shape:  (2, 4)\n1-D Array Shape:  (5,)\n\"\"\" import as \"x1\" \"x2\" \"x3\" \"x4\" \"x5\" \"x6\" \"x7\" \"x8\" 3 2 4 5 6 # find and print shape print \"2-D Array Shape: \" print \"1-D Array Shape: \" \"\"\"\nOutput:\n2-D Array Shape:  (2, 4)\n1-D Array Shape:  (5,)\n\"\"\"",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "1. Differentiate between deep and shallow copies.",
        "answer": "Shallow copy does the task of creating new objects storing references of original elements. This does not undergo recursion to create copies of nested objects. It just copies the reference details of nested objects.\nDeep copy creates an independent and new copy of an object and even copies all the nested objects of the original element recursively. Shallow copy does the task of creating new objects storing references of original elements. This does not undergo recursion to create copies of nested objects. It just copies the reference details of nested objects. Deep copy creates an independent and new copy of an object and even copies all the nested objects of the original element recursively.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "2. What is main function in python? How do you invoke it?",
        "answer": "In the world of programming languages, the main is considered as an entry point of execution for a program. But in python, it is known that the interpreter serially interprets the file line-by-line. This means that python does not provide main() function explicitly. But this doesn't mean that we cannot simulate the execution of main. This can be done by defining user-defined main() function and by using the __name__ property of python file. This __name__ variable is a special built-in variable that points to the name of the current module. This can be done as shown below: main() main() __name__ __name__ def main():\n   print(\"Hi Interviewbit!\")\nif __name__==\"__main__\":\n   main() def main():\n   print(\"Hi Interviewbit!\")\nif __name__==\"__main__\":\n   main() def main(): def main print \"Hi Interviewbit!\" if \"__main__\"",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "3. Are there any tools for identifying bugs and performing static analysis in python?",
        "answer": "Yes, there are tools like PyChecker and Pylint which are used as static analysis and linting tools respectively. PyChecker helps find bugs in python source code files and raises alerts for code issues and their complexity. Pylint checks for the module’s coding standards and supports different plugins to enable custom features to meet this requirement.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "4. Define PIP.",
        "answer": "PIP stands for Python Installer Package. As the name indicates, it is used for installing different python modules. It is a command-line tool providing a seamless interface for installing different python modules. It searches over the internet for the package and installs them into the working directory without the need for any interaction with the user. The syntax for this is: pip install <package_name> pip install <package_name>",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "5. Define PYTHONPATH.",
        "answer": "It is an environment variable used for incorporating additional directories during the import of a module or a package. PYTHONPATH is used for checking if the imported packages or modules are available in the existing directories. Not just that, the interpreter uses this environment variable to identify which module needs to be loaded.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "6. Define GIL.",
        "answer": "GIL stands for Global Interpreter Lock. This is a mutex used for limiting access to python objects and aids in effective thread synchronization by avoiding deadlocks. GIL helps in achieving multitasking (and not parallel computing). The following diagram represents how GIL works.   Based on the above diagram, there are three threads. First Thread acquires the GIL first and starts the I/O execution. When the I/O operations are done, thread 1 releases the acquired GIL which is then taken up by the second thread. The process repeats and the GIL are used by different threads alternatively until the threads have completed their execution. The threads not having the GIL lock goes into the waiting state and resumes execution only when it acquires the lock.",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "7. What are the differences between pickling and unpickling?",
        "answer": "Pickling is the conversion of python objects to binary form. Whereas, unpickling is the conversion of binary form data to python objects. The pickled objects are used for storing in disks or external memory locations. Unpickled objects are used for getting the data back as python objects upon which processing can be done in python. Python provides a pickle module for achieving this. Pickling uses the pickle.dump() method to dump python objects into disks. Unpickling uses the pickle.load() method to get back the data as python objects. pickle pickle.dump() pickle.load()  ",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "8. Can you easily check if all characters in the given string is alphanumeric?",
        "answer": "This can be easily done by making use of the isalnum() method that returns true in case the string has only alphanumeric characters. For Example - \"abdc1321\".isalnum() #Output: True\n\"xyz@123$\".isalnum() #Output: False \"abdc1321\".isalnum() #Output: True\n\"xyz@123$\".isalnum() #Output: False \"abdc1321\" #Output: True \"xyz@123$\" #Output: False Another way is to use match() method from the re (regex) module as shown: match() import re\nprint(bool(re.match('[A-Za-z0-9]+$','abdc1321'))) # Output: True\nprint(bool(re.match('[A-Za-z0-9]+$','xyz@123$'))) # Output: False import re\nprint(bool(re.match('[A-Za-z0-9]+$','abdc1321'))) # Output: True\nprint(bool(re.match('[A-Za-z0-9]+$','xyz@123$'))) # Output: False import print bool '[A-Za-z0-9]+$' 'abdc1321' # Output: True print bool '[A-Za-z0-9]+$' 'xyz@123$' # Output: False",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "9. How can you generate random numbers?",
        "answer": "Python provides a module called random using which we can generate random numbers. We have to import a random module and call the random() method as shown below:\nThe random() method generates float values lying between 0 and 1 randomly. We have to import a random module and call the random() method as shown below:\nThe random() method generates float values lying between 0 and 1 randomly. random() The random() method generates float values lying between 0 and 1 randomly. The random() method generates float values lying between 0 and 1 randomly. import random\n print(random.random()) import random\n print(random.random()) import print To generate customised random numbers between specified ranges, we can use the randrange() method\nSyntax: randrange(beginning, end, step)\nFor example: To generate customised random numbers between specified ranges, we can use the randrange() method\nSyntax: randrange(beginning, end, step)\nFor example: randrange()  randrange(beginning, end, step)  import random\nprint(random.randrange(5,100,2)) import random\nprint(random.randrange(5,100,2)) import print 5 100 2",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "10. What are lambda functions?",
        "answer": "Lambda functions are generally inline, anonymous functions represented by a single expression. They are used for creating function objects during runtime. They can accept any number of parameters. They are usually used where functions are required only for a short period. They can be used as: mul_func = lambda x,y : x*y\nprint(mul_func(6, 4))\n# Output: 24 mul_func = lambda x,y : x*y\nprint(mul_func(6, 4))\n# Output: 24 lambda print 6 4 # Output: 24",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "11. What are some of the most commonly used built-in modules in Python?",
        "answer": "Python modules are the files having python code which can be functions, variables or classes. These go by .py extension. The most commonly available built-in modules are: os\nmath\nsys\nrandom\nre\ndatetime\nJSON os math sys random re datetime JSON",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "12. Differentiate between a package and a module in python.",
        "answer": "The module is a single python file. A module can import other modules (other python files) as objects. Whereas, a package is the folder/directory where different sub-packages and the modules reside. A python module is created by saving a file with the extension of .py. This file will have classes and functions that are reusable in the code as well as across modules. .py A python package is created by following the below steps: Create a directory and give a valid name that represents its operation.\nPlace modules of one kind in this directory.\nCreate __init__.py file in this directory. This lets python know the directory we created is a package. The contents of this package can be imported across different modules in other packages to reuse the functionality. Create a directory and give a valid name that represents its operation. Place modules of one kind in this directory. Create __init__.py file in this directory. This lets python know the directory we created is a package. The contents of this package can be imported across different modules in other packages to reuse the functionality. __init__.py",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "1. How will you access the dataset of a publicly shared spreadsheet in CSV format stored in Google Drive?",
        "answer": "We can use the StringIO module from the io module to read from the Google Drive link and then we can use the pandas library using the obtained data source. from io import StringIO\nimport pandas\ncsv_link = \"https://docs.google.com/spreadsheets/d/...\"\ndata_source = StringIO.StringIO(requests.get(csv_link).content))\ndataframe = pd.read_csv(data_source)\nprint(dataframe.head()) from io import StringIO\nimport pandas\ncsv_link = \"https://docs.google.com/spreadsheets/d/...\"\ndata_source = StringIO.StringIO(requests.get(csv_link).content))\ndataframe = pd.read_csv(data_source)\nprint(dataframe.head()) from import import \"https://docs.google.com/spreadsheets/d/...\" print Conclusion: In this article, we have seen commonly asked interview questions for a python developer. These questions along with regular problem practice sessions will help you crack any python based interviews. Over the years, python has gained a lot of popularity amongst the developer’s community due to its simplicity and ability to support powerful computations. Due to this, the demand for good python developers is ever-growing. Nevertheless, to mention, the perks of being a python developer are really good. Along with theoretical knowledge in python, there is an emphasis on the ability to write good-quality code as well. So, keep learning and keep practising problems and without a doubt, you can crack any interviews. Looking to get certified in Python? Check out Scaler Topic's Free Python course with certification. Free Python course Free Python course Important Resources: Python Interview Questions for Data Science\nPython Basic Programs\nPython MCQ\nPython Commands\nPython Developer Resume\nPython Projects\nDifference Between Python 2 and 3\nPython Frameworks\nPython Documentation\nNumpy Tutorial\nPython Vs R\nPython Vs Javascript\nDifference Between C and Python\nPython Vs Java\nFeatures of Python\nGolang vs Python\nPython Developer Skills\nOnline Python Compiler Python Interview Questions for Data Science Python Interview Questions for Data Science Python Basic Programs Python Basic Programs Python MCQ Python MCQ Python Commands Python Commands Python Developer Resume Python Developer Resume Python Projects Python Projects Difference Between Python 2 and 3 Difference Between Python 2 and 3 Python Frameworks Python Frameworks Python Documentation Python Documentation Numpy Tutorial Numpy Tutorial Python Vs R Python Vs R Python Vs Javascript Python Vs Javascript Difference Between C and Python Difference Between C and Python Python Vs Java Python Vs Java Features of Python Features of Python Golang vs Python Golang vs Python Python Developer Skills Python Developer Skills Online Python Compiler Online Python Compiler",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "2. Write a Program to combine two different dictionaries. While combining, if you find the same keys, you can add the values of these same keys. Output the new dictionary",
        "answer": "We can use the Counter method from the collections module from collections import Counter\nd1 = {'key1': 50, 'key2': 100, 'key3':200}\nd2 = {'key1': 200, 'key2': 100, 'key4':300}\nnew_dict = Counter(d1) + Counter(d2)\nprint(new_dict) from collections import Counter\nd1 = {'key1': 50, 'key2': 100, 'key3':200}\nd2 = {'key1': 200, 'key2': 100, 'key4':300}\nnew_dict = Counter(d1) + Counter(d2)\nprint(new_dict) from import 'key1' 50 'key2' 100 'key3' 200 'key1' 200 'key2' 100 'key4' 300 print",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "3. Write a Program to convert date from yyyy-mm-dd format to dd-mm-yyyy format.",
        "answer": "We can again use the re module to convert the date string as shown below: import re\ndef transform_date_format(date):\n   return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', date)\ndate_input = \"2021-08-01\"\nprint(transform_date_format(date_input)) import re\ndef transform_date_format(date):\n   return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', date)\ndate_input = \"2021-08-01\"\nprint(transform_date_format(date_input)) import def transform_date_format(date): def transform_date_format date return r'(\\d{4})-(\\d{1,2})-(\\d{1,2})' '\\\\3-\\\\2-\\\\1' \"2021-08-01\" print You can also use the datetime module as shown below: from datetime import datetime\nnew_date = datetime.strptime(\"2021-08-01\", \"%Y-%m-%d\").strftime(\"%d:%m:%Y\")\nprint(new_data) from datetime import datetime\nnew_date = datetime.strptime(\"2021-08-01\", \"%Y-%m-%d\").strftime(\"%d:%m:%Y\")\nprint(new_data) from import \"2021-08-01\" \"%Y-%m-%d\" \"%d:%m:%Y\" print",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "4. Write a Program to match a string that has the letter ‘a’ followed by 4 to 8 'b’s.",
        "answer": "We can use the re module of python to perform regex pattern comparison here. import re\ndef match_text(txt_data):\n       pattern = 'ab{4,8}'\n       if re.search(pattern,  txt_data):    #search for pattern in txt_data\n           return 'Match found'\n       else:\n           return('Match not found')\nprint(match_text(\"abc\"))         #prints Match not found\nprint(match_text(\"aabbbbbc\"))    #prints Match found import re\ndef match_text(txt_data):\n       pattern = 'ab{4,8}'\n       if re.search(pattern,  txt_data):    #search for pattern in txt_data\n           return 'Match found'\n       else:\n           return('Match not found')\nprint(match_text(\"abc\"))         #prints Match not found\nprint(match_text(\"aabbbbbc\"))    #prints Match found import def match_text(txt_data): def match_text txt_data 'ab{4,8}' if #search for pattern in txt_data return 'Match found' else return 'Match not found' print \"abc\" #prints Match not found print \"aabbbbbc\" #prints Match found",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "5. Write a Program to solve the given equation assuming that a,b,c,m,n,o are constants:",
        "answer": "ax + by = c\nmx + ny = o ax + by = c\nmx + ny = o By solving the equation, we get: a, b, c, m, n, o = 5, 9, 4, 7, 9, 4\ntemp = a*n - b*m\nif n != 0:\n   x = (c*n - b*o) / temp\n   y = (a*o - m*c) / temp\n   print(str(x), str(y)) a, b, c, m, n, o = 5, 9, 4, 7, 9, 4\ntemp = a*n - b*m\nif n != 0:\n   x = (c*n - b*o) / temp\n   y = (a*o - m*c) / temp\n   print(str(x), str(y)) 5 9 4 7 9 4 if 0 print str str",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "6. Write a Program to add two integers >0 without using the plus operator.",
        "answer": "We can use bitwise operators to achieve this. def add_nums(num1, num2):\n   while num2 != 0:\n       data = num1 & num2\n       num1 = num1 ^ num2\n       num2 = data << 1\n   return num1\nprint(add_nums(2, 10)) def add_nums(num1, num2):\n   while num2 != 0:\n       data = num1 & num2\n       num1 = num1 ^ num2\n       num2 = data << 1\n   return num1\nprint(add_nums(2, 10)) def add_nums(num1, num2): def add_nums num1, num2 while 0 1 return print 2 10",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "7. Write a program to check and return the pairs of a given array A whose sum value is equal to a target value N.",
        "answer": "This can be done easily by using the phenomenon of hashing. We can use a hash map to check for the current value of the array, x. If the map has the value of (N-x), then there is our pair. def print_pairs(arr, N):\n   # hash set\n   hash_set = set()\n    \n   for i in range(0, len(arr)):\n       val = N-arr[i]\n       if (val in hash_set):    #check if N-x is there in set, print the pair\n           print(\"Pairs \" + str(arr[i]) + \", \" + str(val))\n       hash_set.add(arr[i])\n\n# driver code\narr = [1, 2, 40, 3, 9, 4]\nN = 3\nprint_pairs(arr, N) def print_pairs(arr, N):\n   # hash set\n   hash_set = set()\n    \n   for i in range(0, len(arr)):\n       val = N-arr[i]\n       if (val in hash_set):    #check if N-x is there in set, print the pair\n           print(\"Pairs \" + str(arr[i]) + \", \" + str(val))\n       hash_set.add(arr[i])\n\n# driver code\narr = [1, 2, 40, 3, 9, 4]\nN = 3\nprint_pairs(arr, N) def print_pairs(arr, N): def print_pairs arr, N # hash set set for in range 0 len if in #check if N-x is there in set, print the pair print \"Pairs \" str \", \" str # driver code 1 2 40 3 9 4 3",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "8. Write a program for counting the number of every character of a given text file.",
        "answer": "The idea is to use collections and pprint module as shown below: import collections\nimport pprint\nwith open(\"sample_file.txt\", 'r') as data:\n count_data = collections.Counter(data.read().upper())\n count_value = pprint.pformat(count_data)\nprint(count_value) import collections\nimport pprint\nwith open(\"sample_file.txt\", 'r') as data:\n count_data = collections.Counter(data.read().upper())\n count_value = pprint.pformat(count_data)\nprint(count_value) import import with open \"sample_file.txt\" 'r' as print",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "9. WAP (Write a program) which takes a sequence of numbers and check if all numbers are unique.",
        "answer": "You can do this by converting the list to set by using set() method and comparing the length of this set with the length of the original list. If found equal, return True. def check_distinct(data_list):\n if len(data_list) == len(set(data_list)):\n   return True\n else:\n   return False;\nprint(check_distinct([1,6,5,8]))     #Prints True\nprint(check_distinct([2,2,5,5,7,8])) #Prints False def check_distinct(data_list):\n if len(data_list) == len(set(data_list)):\n   return True\n else:\n   return False;\nprint(check_distinct([1,6,5,8]))     #Prints True\nprint(check_distinct([2,2,5,5,7,8])) #Prints False def check_distinct(data_list): def check_distinct data_list if len len set return True else return False print 1 6 5 8 #Prints True print 2 2 5 5 7 8 #Prints False",
        "reference": "interviewbit.com",
        "role": "python"
    },
    {
        "question": "10. Write python function which takes a variable number of arguments.",
        "answer": "A function that takes variable arguments is called a function prototype. Syntax: def function_name(*arg_list) def function_name(*arg_list) def function_name(*arg_list) def function_name *arg_list For example: def func(*var):\n   for i in var:\n       print(i)\nfunc(1)\nfunc(20,1,6) def func(*var):\n   for i in var:\n       print(i)\nfunc(1)\nfunc(20,1,6) def func(*var): def func *var for in print 1 20 1 6 The * in the function argument represents variable arguments in the function.",
        "reference": "interviewbit.com",
        "role": "python"
    }
]