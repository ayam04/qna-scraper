[
    {
        "question": "1. What is JUnit?",
        "answer": "JUnit is a unit testing framework for the Java Programming Language. It is written in Java and is an Open Source Software maintained by the JUnit.org community.",
        "reference": "intellipaat.com",
        "role": "junit"
    },
    {
        "question": "2. What are important features of JUnit?",
        "answer": "Import features of JUnit are:\nIt is an open source framework.\nProvides Annotation to identify the test methods.\nProvides Assertions for testing expected results.\nProvides Test runners for running tests.\nJUnit tests can be run automatically and they check their own results and provide immediate feedback.\nJUnit tests can be organized into test suites containing test cases and even other test suites.\nJUnit shows test progress in a bar that is green if test is going fine and it turns red when a test fails.",
        "reference": "intellipaat.com",
        "role": "junit"
    },
    {
        "question": "3. What is a Unit Test Case?",
        "answer": "A Unit Test Case is a part of code which ensures that the another part of code (method) works as expected. A formal written unit test case is characterized by a known input and by an expected output, which is worked out before the test is executed. The known input should test a precondition and the expected output should test a post condition.",
        "reference": "intellipaat.com",
        "role": "junit"
    },
    {
        "question": "4. Why does JUnit only report the first failure in a single test?",
        "answer": "Reporting multiple failures in a single test is generally a sign that the test does too much and it is too big a unit test. JUnit is designed to work best with a number of small tests. It executes each test within a separate instance of the test class. It reports failure on each test.",
        "reference": "intellipaat.com",
        "role": "junit"
    },
    {
        "question": "5. In Java, assert is a keyword. Won’t this conflict with JUnit’sassert() method?",
        "answer": "JUnit 3.7 deprecated assert() and replaced it with assertTrue(), which works exactly the same way. JUnit 4 is compatible with the assert keyword. If you run with the -ea JVM switch, assertions that fail will be reported by JUnit.\n\nAdvanced Junit Interview Questions",
        "reference": "intellipaat.com",
        "role": "junit"
    },
    {
        "question": "6. How do I test things that must be run in a J2EE container (e.g. servlets, EJBs)?",
        "answer": "Refactoring J2EE components to delegate functionality to other objects that don’t have to be run in a J2EE container will improve the design and testability of the software. Cactus is an open source JUnit extension that can be used for unit testing server-side java code.",
        "reference": "intellipaat.com",
        "role": "junit"
    },
    {
        "question": "7. What are JUnit classes? List some of them?",
        "answer": "JUnit classes are important classes which are used in writing and testing JUnits. Some of the important classes are:\nAssert – A set of assert methods.\nTest Case – It defines the fixture to run multiple tests.\nTest Result – It collects the results of executing a test case.\nTest Suite – It is a Composite of Tests.",
        "reference": "intellipaat.com",
        "role": "junit"
    },
    {
        "question": "8. What are annotations and how are they useful in JUnit?",
        "answer": "Annotations are like meta-tags that you can add to you code and apply them to methods or in class. The annotation in JUnit gives us information about test methods , which methods are going to run before & after test methods, which methods run before & after all the methods, which methods or class will be ignore during execution.",
        "reference": "intellipaat.com",
        "role": "junit"
    },
    {
        "question": "9. What Is JunitTestCase?",
        "answer": "JUnit Test Case is the base class, junit. framework.TestCase, that allows you to create a test case. (Although, TestCase class is no longer supported in JUnit 4.4.)\nA test case defines the fixture to run multiple tests. To define a test case\nImplement a subclass of TestCase\nDefine instance variables that store the state of the fixture\nInitialize the fixture state by overriding setUp\nClean-up after a test by overriding tearDown\nEach test runs in its own fixture so there can be no side effects among test runs.",
        "reference": "intellipaat.com",
        "role": "junit"
    },
    {
        "question": "1. What is a test suite?",
        "answer": "A test suite is a bundle of multiple unit test cases which can be run together. The following image represents how to test suite looks like:   We can use @RunWith and @Suite annotations over the test class for running the test suite.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "2. What is Unit Testing?",
        "answer": "Unit testing is a software testing strategy that tests single entities like methods or classes at a time. This helps to ensure that the product quality is met as per the business requirements. It also helps in reducing the technical debt of the application by helping developers discover issues in the code logic due to any changes. It also gives insights into how the code logic implemented could impact future changes. The lifecycle of the unit testing process is as shown in the image below:  ",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "3. Why do we use JUnit? Who uses JUnit more - Developers or Testers?",
        "answer": "JUnit is used more often by developers for implementing unit test cases for the functionalities they have developed. However, these days testers also use this framework for performing unit testing of the applications. JUnit is used due to the following reasons: Helps in automating test cases.\nHelps in reducing defects in the code logic whenever the logic changes.\nHelps in reducing the cost of testing as the bugs are identified, captured and addressed at early phases in the software development.\nHelps to identify the gaps in coding and gives a chance to refactor the code. Helps in automating test cases. Helps in reducing defects in the code logic whenever the logic changes. Helps in reducing the cost of testing as the bugs are identified, captured and addressed at early phases in the software development. Helps to identify the gaps in coding and gives a chance to refactor the code.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "4. What are the features of JUnit?",
        "answer": "Following are the features of JUnit: features of JUnit JUnit is an open-source framework.\nSupports automated testing of test suites.\nProvides annotations for identifying the test methods.\nProvides assertions to test expected results or exceptions of the methods under test.\nProvides a platform for running test cases automatically and checking their results and giving feedback. JUnit is an open-source framework. Supports automated testing of test suites. Provides annotations for identifying the test methods. Provides assertions to test expected results or exceptions of the methods under test. Provides a platform for running test cases automatically and checking their results and giving feedback.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "5. Is it mandatory to write test cases for every logic?",
        "answer": "No, it is not mandatory. However, test cases can be written for the logic which can be reasonably broken and tested independently.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "6. What are some of the important annotations provided by JUnit?",
        "answer": "Some of the annotations provided by JUnit are as follows: @Test: This annotation over a public method of void return type can be run as a test case. This is a replacement of the org.junit.TestCase annotation.\n@Before: This is used when we want to execute the preconditions or any initialisation based statements before running every test case.\n@BeforeClass: This is used when we want to execute statements before all test cases. The statements may include test connections, common setup initialisation etc.\n@After: This is used when we want to execute statements after each test case. The statements can be resetting the variables, deleting extra memory used etc.\n@AfterClass: This is used when certain statements are required to be executed after all the test cases of the class are run. Releasing resource connections post-execution of test cases is one such example.\n@Ignores: This is used when some statements are required to be ignored during the execution of test cases.\n@Test(timeout=x): This is used when some timeout during the execution of test cases is to be set. The value of x is an integer that represents the time within which the tests have to be completed.\n@Test(expected=NullPointerException.class): This is used when some exception thrown by the target method needs to be asserted. @Test: This annotation over a public method of void return type can be run as a test case. This is a replacement of the org.junit.TestCase annotation. @Test org.junit.TestCase @Before: This is used when we want to execute the preconditions or any initialisation based statements before running every test case. @Before @BeforeClass: This is used when we want to execute statements before all test cases. The statements may include test connections, common setup initialisation etc. @BeforeClass @After: This is used when we want to execute statements after each test case. The statements can be resetting the variables, deleting extra memory used etc. @After @AfterClass: This is used when certain statements are required to be executed after all the test cases of the class are run. Releasing resource connections post-execution of test cases is one such example. @AfterClass @Ignores: This is used when some statements are required to be ignored during the execution of test cases. @Ignores @Test(timeout=x): This is used when some timeout during the execution of test cases is to be set. The value of x is an integer that represents the time within which the tests have to be completed. @Test(timeout=x) @Test(expected=NullPointerException.class): This is used when some exception thrown by the target method needs to be asserted. @Test(expected=NullPointerException.class)",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "7. How will you write a simple JUnit test case?",
        "answer": "Let us understand how to write a simple JUnit Test Case using an example. Consider a Calculator class that has a method that adds 2 numbers: public class Calculator {\n   public int add(int num1, int num2) {\n       return num1 + num2;\n   }\n} public class Calculator {\n   public int add(int num1, int num2) {\n       return num1 + num2;\n   }\n} public class Calculator class Calculator public int add(int num1, int num2) public int add (int num1, int num2) int int return Let us write a test case in JUnit 5 to this method under a class named CalculatorTest. import static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.Test;\npublic class CalculatorTest {\n   Calculator calcObject;\n   @BeforeEach                                         \n   void setUp() {\n       calcObject = new Calculator();\n   }\n   @Test                                               \n   @DisplayName(\"Add 2 numbers\")   \n   void addTest() {\n       assertEquals(15, calcObject.add(10, 5));  \n   }\n   @RepeatedTest(5)                                    \n   @DisplayName(\"Adding a number with zero to return the same number\")\n   void testAddWithZero() {\n       assertEquals(15, calcObject.add(0, 15));\n   }\n} import static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.RepeatedTest;\nimport org.junit.jupiter.api.Test;\npublic class CalculatorTest {\n   Calculator calcObject;\n   @BeforeEach                                         \n   void setUp() {\n       calcObject = new Calculator();\n   }\n   @Test                                               \n   @DisplayName(\"Add 2 numbers\")   \n   void addTest() {\n       assertEquals(15, calcObject.add(10, 5));  \n   }\n   @RepeatedTest(5)                                    \n   @DisplayName(\"Adding a number with zero to return the same number\")\n   void testAddWithZero() {\n       assertEquals(15, calcObject.add(0, 15));\n   }\n} import static import import import import public class CalculatorTest class CalculatorTest @BeforeEach void setUp() void setUp () new @Test @DisplayName(\"Add 2 numbers\") void addTest() void addTest () 15 10 5 @RepeatedTest(5) @DisplayName(\"Adding a number with zero to return the same number\") void testAddWithZero() void testAddWithZero () 15 0 15 From the above example, we can see that: @BeforeEach annotated method runs before each test case. In JUnit 4, this annotation was @Before.\n@Test annotation indicates that the method is a test method.\n@DisplayName is used for defining the test name displayed to the user.\nassertEquals() method is used for validating whether the expected and actual values are equal.\n@RepeatedTest annotation indicates that the test method will be run 5 times. @BeforeEach annotated method runs before each test case. In JUnit 4, this annotation was @Before. @Before @Test annotation indicates that the method is a test method. @DisplayName is used for defining the test name displayed to the user. assertEquals() method is used for validating whether the expected and actual values are equal. @RepeatedTest annotation indicates that the test method will be run 5 times.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "8. What will happen if the return type of the JUnit method is String?",
        "answer": "The test case execution will fail because the JUnit methods are designed to return void.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "9. What is the importance of @Test annotation?",
        "answer": "@Test annotation is used for marking the method as a test method.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "10. What is a JUnit fixture?",
        "answer": "Fixture represents a fixed state of object sets used as a baseline for running test methods. This is to ensure there is a fixed and well-known environment where the results of the test methods are repeatable when run multiple times. The fixture has the following 2 methods: setUp()This runs before every test case is run.\ntearDown() This method is run after every test is run. setUp()This runs before every test case is run. setUp() tearDown() This method is run after every test is run. tearDown()",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "11. What is JUnit?",
        "answer": "JUnit is an open-source, Java-based unit testing framework that plays a crucial role in achieving the culture of TDD (Test Driven Development). The TDD culture lays strong emphasis on setting up the test data for testing a logic that would be implemented once the testing is successful. JUnit helps to increase the software stability as it helps in identifying the bug in the code logic at an early stage without requiring the software to go to production. This helps in reducing the time required to debug any issues later on.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "12. What is mocking and stubbing?",
        "answer": "Mocking is a phenomenon where an object mimics a real object. Whereas, stubbing are the codes responsible for taking place of another component. Mockito, EasyMock are some of the mocking frameworks in Java.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "13. What are the JUnit Assert Methods?",
        "answer": "Assert methods are utility methods that support assert conditions in test cases. They belong to the Assert class in JUnit 4 and the Assertions class in JUnit 5. It is recommended to import the assert methods statically to the test class for avoiding using the class as a prefix to the method. Let us consider an example of the Multiplier class: public class Multiplier{\n   public int multiply(int num1, int num2){\n       return num1 * num2;\n   }\n} public class Multiplier{\n   public int multiply(int num1, int num2){\n       return num1 * num2;\n   }\n} Following are some of the assert methods: assertEquals(): This method compares 2 objects for equality by making use of the equals() method of the object. This is shown in the test case that multiplies 2 methods and checks for the expected and actual value below. assertEquals(): This method compares 2 objects for equality by making use of the equals() method of the object. This is shown in the test case that multiplies 2 methods and checks for the expected and actual value below. assertEquals() @Test                                               \n@DisplayName(\"Multiplying 2 numbers\")   \npublic void multiplyTest() {\n    assertEquals(50, multiplier.multiply(10, 5));  \n} @Test                                               \n@DisplayName(\"Multiplying 2 numbers\")   \npublic void multiplyTest() {\n    assertEquals(50, multiplier.multiply(10, 5));  \n} When two objects are found to be equal based on the equals() method implementation of the object, then assertEquals() returns normally. Else, an exception will be thrown and the test will stop its execution. assertTrue(): This method tests whether the value of a variable is true. assertTrue(): This method tests whether the value of a variable is true. assertTrue() @Test                                               \npublic void checkNumTest() {\n    int num1 = 20;\n    assertTrue(\"Number is not equal to 0\", num1!=0);\n} @Test                                               \npublic void checkNumTest() {\n    int num1 = 20;\n    assertTrue(\"Number is not equal to 0\", num1!=0);\n} If the assertion fails, then an exception will be thrown and the test execution will be stopped. assertFalse(): This method tests whether the value of a variable is false. assertFalse(): This method tests whether the value of a variable is false. assertFalse() @Test                                               \npublic void checkNumTest() {\n    int num1 = -20;\n    assertFalse(\"Number is not greater than 0\",num1>0);\n} @Test                                               \npublic void checkNumTest() {\n    int num1 = -20;\n    assertFalse(\"Number is not greater than 0\",num1>0);\n} If the assertion fails, then an exception will be thrown and the test execution will be stopped. assertNull(): This method tests if a variable is null. If null, it returns normally else an exception will be thrown and the test stops execution. assertNull(): This method tests if a variable is null. If null, it returns normally else an exception will be thrown and the test stops execution. assertNull() @Test                                               \npublic void checkNullTest() {\n    int num1 = null;\n    assertNull(\"Number is null\",num1);\n} @Test                                               \npublic void checkNullTest() {\n    int num1 = null;\n    assertNull(\"Number is null\",num1);\n} assertNotNull(): This method tests whether a variable is not null. If it is not null, then the test returns normally else an exception will be thrown and the test stops its execution. assertNotNull(): This method tests whether a variable is not null. If it is not null, then the test returns normally else an exception will be thrown and the test stops its execution. assertNotNull() @Test                                               \npublic void checkNotNullTest() {\n    int num1 = null;\n    assertNotNull(\"Number is null\",num1);\n} @Test                                               \npublic void checkNotNullTest() {\n    int num1 = null;\n    assertNotNull(\"Number is null\",num1);\n} assertSame(): This method checks if two references of the object are pointing to the same object. assertSame(): This method checks if two references of the object are pointing to the same object. assertSame() @Test                                               \n   public void checkAssertSameTest() {\n        Object num1 = new Object();\n        Object num2 = new Object();\n        assertSame(num1, num2);\n   } @Test                                               \n   public void checkAssertSameTest() {\n        Object num1 = new Object();\n        Object num2 = new Object();\n        assertSame(num1, num2);\n   } If the object references are pointing to the same object, the test runs normally else, it will throw an exception and the test execution is aborted. assertNotSame(): This method checks if two references of an object are not pointing to the same object. assertNotSame(): This method checks if two references of an object are not pointing to the same object. assertNotSame() @Test                                               \npublic void checkAssertSameTest() {\n     Object num1 = new Object();\n     Object num2 = new Object();\n     assertSame(num1, num2);\n} @Test                                               \npublic void checkAssertSameTest() {\n     Object num1 = new Object();\n     Object num2 = new Object();\n     assertSame(num1, num2);\n} If the object references are not pointing to the same object, the test runs normally else, it will throw an exception and the test execution is aborted. assertThat(): This method compares the object to org.hamcrest.Matcher for checking if it matches whatever the Matcher class requires for the object to match. Consider the following code. assertThat(): This method compares the object to org.hamcrest.Matcher for checking if it matches whatever the Matcher class requires for the object to match. Consider the following code. assertThat() import static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.hasItems;\nimport org.junit.jupiter.api.Test;\n\npublic class MultiplierTest {\n    @Test\n    public void assertThatTest() {\n        assertThat(\n          Arrays.asList(1,2,3,4), \n          hasItems(2,3));\n    }\n} import static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.hasItems;\nimport org.junit.jupiter.api.Test;\n\npublic class MultiplierTest {\n    @Test\n    public void assertThatTest() {\n        assertThat(\n          Arrays.asList(1,2,3,4), \n          hasItems(2,3));\n    }\n} In this code, we will be asserting that the list has some items specified in the hamcrest’s hasItems() method. If the assertThat is successful, i.e if the list indeed has items specified, then the test runs normally. Else, the test throws an exception and the test stops executing. assertThat",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "14. What is the importance of @RunWith annotation?",
        "answer": "@RunWith annotation lets us run the JUnit tests with other custom JUnit Runners like SpringJUnit4ClassRunner, MockitoJUnitRunner etc. We can also do parameterized testing in JUnit by making use of @RunWith(Parameterized.class).",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "15. How does JUnit help in achieving tests isolation?",
        "answer": "For calling test methods, JUnit creates separate individual instances of the test class. For example, if the test class contains 10 tests, then JUnit creates 10 instances of the class to execute the test methods. In this way, every test is isolated from the other.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "1. Why does JUnit report only the first failure in a single attempt?",
        "answer": "JUnit is usually designed in a way that it deals with smaller tests and is capable of running each assessment with a boundary of separate analysis. Due to this, it reports only the first failure on each test case attempt.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "2. Why can't we use System.out.println() for testing and debugging?",
        "answer": "If we use System.out.println() for debugging, then we would have to do a manual scan of the outputs every time program is executed to ensure that the output printed is the expected output. Also, in the longer run, writing JUnit tests will be easier and will take lesser time. Writing test cases will be like an initial investment and then, later on, we can later automatically test them on the classes. System.out.println()",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "3. How can we run JUnit from the command window?",
        "answer": "The first step is to set the CLASSPATH with the library path. Then invoke the JUnit runner by running the command: java org.junit.runner.JUnitCore java org.junit.runner.JUnitCore To run the test class via commandline, we would first have to compile the class. This can be done by running: javac -d target -cp target:junit-platform-console-standalone-1.7.2.jar src/test/java/com/pathTo/DemoTest.java javac -d target -cp target:junit-platform-console-standalone-1.7.2.jar src/test/java/com/pathTo/DemoTest.java Then we can run the compiled test class using the console launcher of JUnit by running the following command: java -jar junit-platform-console-standalone-1.7.2.jar --class-path target --select-class com.pathTo.DemoTest java -jar junit-platform-console-standalone-1.7.2.jar --class-path target --select-class com.pathTo.DemoTest",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "4. How do you assert exceptions thrown in JUnit 4 tests?",
        "answer": "Consider an example to see how to write test cases for asserting exceptions. import org.apache.commons.lang3.StringUtils;\npublic final class ExceptionDemo {\n   public String convertToUpperCase(String input) {\n       if (StringUtils.isEmpty(input)) {\n           throw new IllegalArgumentException(\"Input empty, cannot convert to upper case!!\");\n       }\n       return input.toUpperCase();\n   }\n} import org.apache.commons.lang3.StringUtils;\npublic final class ExceptionDemo {\n   public String convertToUpperCase(String input) {\n       if (StringUtils.isEmpty(input)) {\n           throw new IllegalArgumentException(\"Input empty, cannot convert to upper case!!\");\n       }\n       return input.toUpperCase();\n   }\n} import public final class ExceptionDemo class ExceptionDemo public String convertToUpperCase(String input) public convertToUpperCase (String input) if throw new \"Input empty, cannot convert to upper case!!\" return The method convertToUpperCase() defined in the ExceptionDemo class would throw an IllegalArgumentException if an empty string is passed as an input to the method.\nLet us write unit test cases for asserting the exception thrown in the code. In JUnit, there are 3 different ways of achieving this and they are as follows: convertToUpperCase() ExceptionDemo IllegalArgumentException  try-catch idiom: We can use the try-catch block for asserting exception as shown below: try-catch idiom: @Test\npublic void convertToUpperCaseWithTryCatchTest{\n   try {\n       exceptionDemo.convertToUpperCase(\"\");\n       fail(\"It should throw IllegalArgumentException\");\n   } catch (IllegalArgumentException e) {\n       Assertions.assertThat(e)\n               .isInstanceOf(IllegalArgumentException.class)\n               .hasMessage(\"Input empty, cannot convert to upper case!!\");\n   }\n} @Test\npublic void convertToUpperCaseWithTryCatchTest{\n   try {\n       exceptionDemo.convertToUpperCase(\"\");\n       fail(\"It should throw IllegalArgumentException\");\n   } catch (IllegalArgumentException e) {\n       Assertions.assertThat(e)\n               .isInstanceOf(IllegalArgumentException.class)\n               .hasMessage(\"Input empty, cannot convert to upper case!!\");\n   }\n} @Test public void try \"\" \"It should throw IllegalArgumentException\" catch \"Input empty, cannot convert to upper case!!\" @Test expected annotation: @Test expected annotation: Here we give the expected exception as value to the expected parameter of the @Test annotation as:@Test(expected = IllegalArgumentException.class) @Test(expected = IllegalArgumentException.class) When no exception is thrown by the target method under test, then we will get the below message: java.lang.AssertionError: Expected exception: java.lang.IllegalArgumentException java.lang.AssertionError: Expected exception: java.lang.IllegalArgumentException Care has to be taken here while defining the expected Exception. We should not expect general Exception, RuntimeException or even a Throwable type of exceptions as that is a bad practice. If we do so, then there are chances that the code can throw an exception in other places and the test case can pass. Here we cannot assert the message in the exception. The code snippet of the test method would be: @Test(expected = IllegalArgumentException.class)\npublic void convertToUpperCaseExpectedTest() {\n    exceptionDemo.convertToUpperCase(\"\");\n} @Test(expected = IllegalArgumentException.class)\npublic void convertToUpperCaseExpectedTest() {\n    exceptionDemo.convertToUpperCase(\"\");\n} @Test(expected = IllegalArgumentException.class) public void convertToUpperCaseExpectedTest() public void convertToUpperCaseExpectedTest () \"\" Junit @Rule: Junit @Rule The same example can be created using the ExceptedException rule. The rule must be a public field marked with @Rule annotation. @Rule\npublic ExpectedException exceptionRule = ExpectedException.none();\n\n@Test\npublic void convertToUpperCaseRuleTest() {\n    exceptionRule.expect(IllegalArgumentException.class);\n    exceptionRule.expectMessage(\"Input empty, cannot convert to upper case!!\");\n    exceptionDemo.convertToUpperCase(\"\");\n} @Rule\npublic ExpectedException exceptionRule = ExpectedException.none();\n\n@Test\npublic void convertToUpperCaseRuleTest() {\n    exceptionRule.expect(IllegalArgumentException.class);\n    exceptionRule.expectMessage(\"Input empty, cannot convert to upper case!!\");\n    exceptionDemo.convertToUpperCase(\"\");\n} @Rule public @Test public void convertToUpperCaseRuleTest() public void convertToUpperCaseRuleTest () \"Input empty, cannot convert to upper case!!\" \"\" In this approach, when the exception is not thrown, we will get: java.lang.AssertionError: Expected test to throw (an instance of java.lang.IllegalArgumentException and exception with the message “Input empty, cannot convert to upper case!!”) java.lang.AssertionError: Expected test to throw (an instance of java.lang.IllegalArgumentException and exception with the message “Input empty, cannot convert to upper case!!”) Expected test to throw (an instance of java.lang.IllegalArgumentException and exception with the message “Input empty, cannot convert to upper case!!”) throw (an instance of java.lang.IllegalArgumentException and exception with the message “Input empty, cannot convert to upper case!!”) case",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "5. What are the differences between @Before, @After, @BeforeClass and @AfterClass?",
        "answer": "The order of execution of these annotations is as shown below:   @Before @After @BeforeClass @AfterClass\nMethods annotated with @Before are executed before each test case. Methods annotated with @After are executed after each test case. Methods annotated with @BeforeClass are executed once before the start of all the test cases. Methods annotated with @AfterClass are executed once all the tests have completed their execution.\nThis is used for preparing the test environment like to read inputs, initialise the variables etc. This is used for cleaning up the test environment like deleting the temporary data, restoring the value of variables to default. This helps in saving memory. This is used for performing time-intensive set-up activities like connecting to any resource that is common across all tests. Methods annotated with this API needs to be defined as static methods for working with JUnit. This is used for performing time-intensive cleanup activities like disconnecting from a resource that is common across all tests. Methods annotated with this annotation has to be defined as static methods for it to work with JUnit. @Before @After @BeforeClass @AfterClass\nMethods annotated with @Before are executed before each test case. Methods annotated with @After are executed after each test case. Methods annotated with @BeforeClass are executed once before the start of all the test cases. Methods annotated with @AfterClass are executed once all the tests have completed their execution.\nThis is used for preparing the test environment like to read inputs, initialise the variables etc. This is used for cleaning up the test environment like deleting the temporary data, restoring the value of variables to default. This helps in saving memory. This is used for performing time-intensive set-up activities like connecting to any resource that is common across all tests. Methods annotated with this API needs to be defined as static methods for working with JUnit. This is used for performing time-intensive cleanup activities like disconnecting from a resource that is common across all tests. Methods annotated with this annotation has to be defined as static methods for it to work with JUnit. @Before @After @BeforeClass @AfterClass @Before @After @BeforeClass @AfterClass @Before @After @BeforeClass @AfterClass Methods annotated with @Before are executed before each test case. Methods annotated with @After are executed after each test case. Methods annotated with @BeforeClass are executed once before the start of all the test cases. Methods annotated with @AfterClass are executed once all the tests have completed their execution.\nThis is used for preparing the test environment like to read inputs, initialise the variables etc. This is used for cleaning up the test environment like deleting the temporary data, restoring the value of variables to default. This helps in saving memory. This is used for performing time-intensive set-up activities like connecting to any resource that is common across all tests. Methods annotated with this API needs to be defined as static methods for working with JUnit. This is used for performing time-intensive cleanup activities like disconnecting from a resource that is common across all tests. Methods annotated with this annotation has to be defined as static methods for it to work with JUnit. Methods annotated with @Before are executed before each test case. Methods annotated with @After are executed after each test case. Methods annotated with @BeforeClass are executed once before the start of all the test cases. Methods annotated with @AfterClass are executed once all the tests have completed their execution. Methods annotated with @Before are executed before each test case. Methods annotated with @After are executed after each test case. Methods annotated with @BeforeClass are executed once before the start of all the test cases. Methods annotated with @AfterClass are executed once all the tests have completed their execution. This is used for preparing the test environment like to read inputs, initialise the variables etc. This is used for cleaning up the test environment like deleting the temporary data, restoring the value of variables to default. This helps in saving memory. This is used for performing time-intensive set-up activities like connecting to any resource that is common across all tests. Methods annotated with this API needs to be defined as static methods for working with JUnit. This is used for performing time-intensive cleanup activities like disconnecting from a resource that is common across all tests. Methods annotated with this annotation has to be defined as static methods for it to work with JUnit. This is used for preparing the test environment like to read inputs, initialise the variables etc. This is used for cleaning up the test environment like deleting the temporary data, restoring the value of variables to default. This helps in saving memory. This is used for performing time-intensive set-up activities like connecting to any resource that is common across all tests. Methods annotated with this API needs to be defined as static methods for working with JUnit. This is used for performing time-intensive cleanup activities like disconnecting from a resource that is common across all tests. Methods annotated with this annotation has to be defined as static methods for it to work with JUnit.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "6. What are Hamcrest Matchers?",
        "answer": "Hamcrest is a JUnit framework used to write matcher objects that provides ‘match’ rules definition in a declarative manner. They are used in UI validation, data filtering and for writing flexible unit tests. Hamcrest matches are used in the assertThat() method in JUnit. We can use one or more matchers within this assert method. Some of the matcher methods are as follows: Matcher Description Example\nallOf() This calculates the logical conjunction of multiple matchers and the object under consideration should match all of the matcher given.\nassertThat(\"InterviewBit\",allOf(startsWith(\"In\"),containsString(“Bit”))) \n--> All conditions should match for assertThat to pass.\nanyOf() This is used for calculating the logical disjunction of multiple matchers. This means that the object under consideration matches ANY of the specified matchers.\nassertThat( \"InterviewBit\",anyOf(containsString( \"Bit\" ),containsString( \"unit\" ))); \n-->Any of the conditions should match for assertThat to pass.\ndescribedAs() This adds a description to the matcher.\nassertThat(\"Friday\", describedAs(\"Friday is not Sunday\", is(not(\"Sunday\"))));\nis() This decorates another matcher by retaining its behavior. and checks for the equality of the objects. It allows tests to be more expressive and meaningful.\nassertThat(\"InterviewBit\",is(equalTo(\"InterviewBit\")))\nanything() This matcher always returns true.\nassertThat(\"InterviewBit\",is(anything(\"foo bar\")));\nequalTo() This checks for the equality of objects.\nassertThat(\"InterviewBit\",equalTo(\"InterviewBit\"));\ninstanceOf() This tests whether the value is an instance of any class.\nassertThat(instance,instanceOf(InstanceClass.class));\nhasItems() This creates matcher for iterables which matches when consecutive passes over Iterable yields at least one item equal to corresponding item from list of items. The iterable stops as soon as matching item is found.\nassertThat(Arrays.asList(\"Interviewbit\", \"Junit\", \"Interview\",\"Questions\"), hasItems(\"Junit\", \"Questions\"))\nnot() This creates matcher which wraps existing matcher but inverts logic by which it should match.\nassertThat(\"InterviewBit\", is(not(equalTo(\"Junit\"))));\nnullValue() This creates matcher which matches if object that is examined is null.\nassertThat(obj, is(nullValue())); Matcher Description Example\nallOf() This calculates the logical conjunction of multiple matchers and the object under consideration should match all of the matcher given.\nassertThat(\"InterviewBit\",allOf(startsWith(\"In\"),containsString(“Bit”))) \n--> All conditions should match for assertThat to pass.\nanyOf() This is used for calculating the logical disjunction of multiple matchers. This means that the object under consideration matches ANY of the specified matchers.\nassertThat( \"InterviewBit\",anyOf(containsString( \"Bit\" ),containsString( \"unit\" ))); \n-->Any of the conditions should match for assertThat to pass.\ndescribedAs() This adds a description to the matcher.\nassertThat(\"Friday\", describedAs(\"Friday is not Sunday\", is(not(\"Sunday\"))));\nis() This decorates another matcher by retaining its behavior. and checks for the equality of the objects. It allows tests to be more expressive and meaningful.\nassertThat(\"InterviewBit\",is(equalTo(\"InterviewBit\")))\nanything() This matcher always returns true.\nassertThat(\"InterviewBit\",is(anything(\"foo bar\")));\nequalTo() This checks for the equality of objects.\nassertThat(\"InterviewBit\",equalTo(\"InterviewBit\"));\ninstanceOf() This tests whether the value is an instance of any class.\nassertThat(instance,instanceOf(InstanceClass.class));\nhasItems() This creates matcher for iterables which matches when consecutive passes over Iterable yields at least one item equal to corresponding item from list of items. The iterable stops as soon as matching item is found.\nassertThat(Arrays.asList(\"Interviewbit\", \"Junit\", \"Interview\",\"Questions\"), hasItems(\"Junit\", \"Questions\"))\nnot() This creates matcher which wraps existing matcher but inverts logic by which it should match.\nassertThat(\"InterviewBit\", is(not(equalTo(\"Junit\"))));\nnullValue() This creates matcher which matches if object that is examined is null.\nassertThat(obj, is(nullValue())); Matcher Description Example Matcher Description Example Matcher Description Example allOf() This calculates the logical conjunction of multiple matchers and the object under consideration should match all of the matcher given.\nassertThat(\"InterviewBit\",allOf(startsWith(\"In\"),containsString(“Bit”))) \n--> All conditions should match for assertThat to pass.\nanyOf() This is used for calculating the logical disjunction of multiple matchers. This means that the object under consideration matches ANY of the specified matchers.\nassertThat( \"InterviewBit\",anyOf(containsString( \"Bit\" ),containsString( \"unit\" ))); \n-->Any of the conditions should match for assertThat to pass.\ndescribedAs() This adds a description to the matcher.\nassertThat(\"Friday\", describedAs(\"Friday is not Sunday\", is(not(\"Sunday\"))));\nis() This decorates another matcher by retaining its behavior. and checks for the equality of the objects. It allows tests to be more expressive and meaningful.\nassertThat(\"InterviewBit\",is(equalTo(\"InterviewBit\")))\nanything() This matcher always returns true.\nassertThat(\"InterviewBit\",is(anything(\"foo bar\")));\nequalTo() This checks for the equality of objects.\nassertThat(\"InterviewBit\",equalTo(\"InterviewBit\"));\ninstanceOf() This tests whether the value is an instance of any class.\nassertThat(instance,instanceOf(InstanceClass.class));\nhasItems() This creates matcher for iterables which matches when consecutive passes over Iterable yields at least one item equal to corresponding item from list of items. The iterable stops as soon as matching item is found.\nassertThat(Arrays.asList(\"Interviewbit\", \"Junit\", \"Interview\",\"Questions\"), hasItems(\"Junit\", \"Questions\"))\nnot() This creates matcher which wraps existing matcher but inverts logic by which it should match.\nassertThat(\"InterviewBit\", is(not(equalTo(\"Junit\"))));\nnullValue() This creates matcher which matches if object that is examined is null.\nassertThat(obj, is(nullValue())); allOf() This calculates the logical conjunction of multiple matchers and the object under consideration should match all of the matcher given.\nassertThat(\"InterviewBit\",allOf(startsWith(\"In\"),containsString(“Bit”))) \n--> All conditions should match for assertThat to pass. allOf() This calculates the logical conjunction of multiple matchers and the object under consideration should match all of the matcher given. assertThat(\"InterviewBit\",allOf(startsWith(\"In\"),containsString(“Bit”))) \n--> All conditions should match for assertThat to pass. assertThat(\"InterviewBit\",allOf(startsWith(\"In\"),containsString(“Bit”))) assertThat(\"InterviewBit\",allOf(startsWith(\"In\"),containsString(“Bit”))) --> All conditions should match for assertThat to pass. anyOf() This is used for calculating the logical disjunction of multiple matchers. This means that the object under consideration matches ANY of the specified matchers.\nassertThat( \"InterviewBit\",anyOf(containsString( \"Bit\" ),containsString( \"unit\" ))); \n-->Any of the conditions should match for assertThat to pass. anyOf() This is used for calculating the logical disjunction of multiple matchers. This means that the object under consideration matches ANY of the specified matchers. assertThat( \"InterviewBit\",anyOf(containsString( \"Bit\" ),containsString( \"unit\" ))); \n-->Any of the conditions should match for assertThat to pass. assertThat( \"InterviewBit\",anyOf(containsString( \"Bit\" ),containsString( \"unit\" ))); assertThat( \"InterviewBit\",anyOf(containsString( \"Bit\" ),containsString( \"unit\" ))); -->Any of the conditions should match for assertThat to pass. describedAs() This adds a description to the matcher.\nassertThat(\"Friday\", describedAs(\"Friday is not Sunday\", is(not(\"Sunday\")))); describedAs() This adds a description to the matcher. assertThat(\"Friday\", describedAs(\"Friday is not Sunday\", is(not(\"Sunday\")))); assertThat(\"Friday\", describedAs(\"Friday is not Sunday\", is(not(\"Sunday\")))); assertThat(\"Friday\", describedAs(\"Friday is not Sunday\", is(not(\"Sunday\")))); is() This decorates another matcher by retaining its behavior. and checks for the equality of the objects. It allows tests to be more expressive and meaningful.\nassertThat(\"InterviewBit\",is(equalTo(\"InterviewBit\"))) is() This decorates another matcher by retaining its behavior. and checks for the equality of the objects. It allows tests to be more expressive and meaningful. assertThat(\"InterviewBit\",is(equalTo(\"InterviewBit\"))) assertThat(\"InterviewBit\",is(equalTo(\"InterviewBit\"))) assertThat(\"InterviewBit\",is(equalTo(\"InterviewBit\"))) anything() This matcher always returns true.\nassertThat(\"InterviewBit\",is(anything(\"foo bar\"))); anything() This matcher always returns true. assertThat(\"InterviewBit\",is(anything(\"foo bar\"))); assertThat(\"InterviewBit\",is(anything(\"foo bar\"))); assertThat(\"InterviewBit\",is(anything(\"foo bar\"))); equalTo() This checks for the equality of objects.\nassertThat(\"InterviewBit\",equalTo(\"InterviewBit\")); equalTo() This checks for the equality of objects. assertThat(\"InterviewBit\",equalTo(\"InterviewBit\")); assertThat(\"InterviewBit\",equalTo(\"InterviewBit\")); assertThat(\"InterviewBit\",equalTo(\"InterviewBit\")); instanceOf() This tests whether the value is an instance of any class.\nassertThat(instance,instanceOf(InstanceClass.class)); instanceOf() This tests whether the value is an instance of any class. assertThat(instance,instanceOf(InstanceClass.class)); assertThat(instance,instanceOf(InstanceClass.class)); assertThat(instance,instanceOf(InstanceClass.class)); hasItems() This creates matcher for iterables which matches when consecutive passes over Iterable yields at least one item equal to corresponding item from list of items. The iterable stops as soon as matching item is found.\nassertThat(Arrays.asList(\"Interviewbit\", \"Junit\", \"Interview\",\"Questions\"), hasItems(\"Junit\", \"Questions\")) hasItems() This creates matcher for iterables which matches when consecutive passes over Iterable yields at least one item equal to corresponding item from list of items. The iterable stops as soon as matching item is found. assertThat(Arrays.asList(\"Interviewbit\", \"Junit\", \"Interview\",\"Questions\"), hasItems(\"Junit\", \"Questions\")) assertThat(Arrays.asList(\"Interviewbit\", \"Junit\", \"Interview\",\"Questions\"), hasItems(\"Junit\", \"Questions\")) assertThat(Arrays.asList(\"Interviewbit\", \"Junit\", \"Interview\",\"Questions\"), hasItems(\"Junit\", \"Questions\")) not() This creates matcher which wraps existing matcher but inverts logic by which it should match.\nassertThat(\"InterviewBit\", is(not(equalTo(\"Junit\")))); not() This creates matcher which wraps existing matcher but inverts logic by which it should match. assertThat(\"InterviewBit\", is(not(equalTo(\"Junit\")))); assertThat(\"InterviewBit\", is(not(equalTo(\"Junit\")))); assertThat(\"InterviewBit\", is(not(equalTo(\"Junit\")))); nullValue() This creates matcher which matches if object that is examined is null.\nassertThat(obj, is(nullValue())); nullValue() This creates matcher which matches if object that is examined is null. assertThat(obj, is(nullValue())); assertThat(obj, is(nullValue())); assertThat(obj, is(nullValue()));",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "7. What is the relationship between the cyclomatic complexity of code and unit tests?",
        "answer": "The code cyclomatic complexity is calculated based on the number of decision points of the code that contributes to different execution paths as shown in the image below:   This is why, higher the cyclomatic complexity, the more difficult is to attain the required code coverage.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "8. What is the keyboard shortcut for running the Junit test cases in eclipse IDE?",
        "answer": "We can press Alt+Shift+X for running the test. We can also right-click on the project, select Run As and then select JUnit Test. If the test method needs to be rerun, then we can press Ctrl+F11.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "9. Define code coverage. What are the different types of code coverages?",
        "answer": "The extent to which the source code is unit tested is called coverage. There are three types of coverage techniques, they are: Statement coverage: This ensures that each statement/line in the source code is executed and tested.\nDecision coverage: This ensures that every decision point that results in true or false is executed and run.\nPath coverage: This ensures that every possible route from a given point is run and tested. Statement coverage: This ensures that each statement/line in the source code is executed and tested. Statement coverage Decision coverage: This ensures that every decision point that results in true or false is executed and run. Decision coverage Path coverage: This ensures that every possible route from a given point is run and tested. Path coverage",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "10. Is it possible to test the Java method for a timeout in JUnit?",
        "answer": "Yes, it is possible. @Test annotation provides a timeout parameter that takes value in milliseconds in JUnit that is used for instructing JUnit to pass or fail the test method based on execution time. For instance, if a test method has Test annotation as @Test(timeout=30), then it means that if the execution does not complete in 30ms, then the test case will be failed. This helps in verifying the SLA of the Java method. @Test(timeout=30)",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "11. What are some of the best practices to be followed while writing code for making it more testable?",
        "answer": "Following are some of the best practices that can be followed while coding to make the code more testable: Make use of interfaces as a wrapper to implementation classes. This helps testers to replace the class with mocks or stubs to test the module.\nUse dependency injection wherever needed instead of creating. new objects. This makes it easy for testing individual modules and also supply dependency in the test configuration.\nAvoid using static methods as that makes it difficult to test because they cannot be called polymorphically. Make use of interfaces as a wrapper to implementation classes. This helps testers to replace the class with mocks or stubs to test the module. Use dependency injection wherever needed instead of creating. new objects. This makes it easy for testing individual modules and also supply dependency in the test configuration. Avoid using static methods as that makes it difficult to test because they cannot be called polymorphically.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "12. How can we test protected methods?",
        "answer": "For testing protected methods, the test class should be declared in the same package as that of the target class.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "13. How can we do testing for private methods?",
        "answer": "It is generally not required to test private methods directly. Since they are private, it is assumed that they are called from public methods. If these methods are working as expected, then by extension it is considered that the private methods are working correctly. However, we can explore how the private methods are tested using reflection. Let us consider we have a public class Item with private method getItemName() as shown below: Item getItemName() public class Item {\n   private String getItemName(String itemName) { \n          //Some logic\n          if(itemName.equals(\"computer\")) {\n          return itemName;\n          }\n         return \"laptop\"; \n   }\n} public class Item {\n   private String getItemName(String itemName) { \n          //Some logic\n          if(itemName.equals(\"computer\")) {\n          return itemName;\n          }\n         return \"laptop\"; \n   }\n} public class Item class Item private String getItemName(String itemName) private getItemName (String itemName) //Some logic if \"computer\" return return \"laptop\" Consider we have a test class ItemTest that tests this method as shown below: import static org.junit.Assert.assertEquals;\nimport java.lang.reflect.Method;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\npublic class ItemTest {\n   public static Item item;\n   \n   @BeforeClass\n   public static void beforeClass() {\n       item = new Item();\n   }\n   \n   @Test\n   public void testGetItemNameSuccess() throws Exception {\n       String expectedName = \"computer\";\n       Method method = Item.class.getDeclaredMethod(\"getItemName\", String.class);\n       method.setAccessible(true);\n       String actualName = (String) method.invoke(item, actualName);\n       assertEquals(expectedName, actualName);\n   }\n} import static org.junit.Assert.assertEquals;\nimport java.lang.reflect.Method;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\npublic class ItemTest {\n   public static Item item;\n   \n   @BeforeClass\n   public static void beforeClass() {\n       item = new Item();\n   }\n   \n   @Test\n   public void testGetItemNameSuccess() throws Exception {\n       String expectedName = \"computer\";\n       Method method = Item.class.getDeclaredMethod(\"getItemName\", String.class);\n       method.setAccessible(true);\n       String actualName = (String) method.invoke(item, actualName);\n       assertEquals(expectedName, actualName);\n   }\n} import static import import import public class ItemTest class ItemTest public static @BeforeClass public static void beforeClass() public static void beforeClass () new @Test public void testGetItemNameSuccess() throws Exception public void testGetItemNameSuccess () throws \"computer\" \"getItemName\" true In the above code, we see that we can test the private method by using getDeclaredMethod method of the Method class that belongs to reflection strategy. Since we know that the private methods cant be invoked directly, we can use the Method class object’s invoke() method and send the input parameters. Then as usual, we can compare the results with the expected and the actual methods. getDeclaredMethod",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "14. How can you test a generics class?",
        "answer": "Generics allows creating classes, interfaces or methods that operate with different data types at a time. In order to test Generic entities, we can test it for one or two datatypes for the logic since the datatype allocation are evaluated at compilation time for type-correctness.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "15. What are the best practices for writing Unit Test Cases?",
        "answer": "A standard unit test case comprises a known input and an expected output. These two things need to be known before we run the test case. A known input is tested for a precondition and an expected output is tested by postcondition. Following are the best practices for writing unit test cases: For every method, we need to have at least two unit test cases - a positive test case and a negative test case.\nIf there are sub-requirements for a requirement, then those sub-requirements should have their own positive and negative test cases.\nEach test case should be independent of other test cases. If we make a chain of unit test cases, then it would not be possible for finding the root cause of the test case failures.\nMock all the external services that are used by the modules under test. This is necessary because we do not want to unnecessarily debug our modules under test due to the failures of the external systems.\nConfiguration settings need not be tested as they won’t be part of any unit code. Even if we want to inspect the configuration, then test whether the loading code is working or not.\nThe unit test cases should be named consistently and clearly. The names of the test cases should be dependent on the operations that the test case would test. For every method, we need to have at least two unit test cases - a positive test case and a negative test case. If there are sub-requirements for a requirement, then those sub-requirements should have their own positive and negative test cases. Each test case should be independent of other test cases. If we make a chain of unit test cases, then it would not be possible for finding the root cause of the test case failures. Mock all the external services that are used by the modules under test. This is necessary because we do not want to unnecessarily debug our modules under test due to the failures of the external systems. Configuration settings need not be tested as they won’t be part of any unit code. Even if we want to inspect the configuration, then test whether the loading code is working or not. The unit test cases should be named consistently and clearly. The names of the test cases should be dependent on the operations that the test case would test.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "16. What are the differences between JUnit 4 and JUnit 5?",
        "answer": "Category JUnit 4 JUnit 5\nAnnotation for executing method before all test methods run in the current class @BeforeClass @BeforeAll\nAnnotation for executing method after all test methods run in the current class @AfterClass @AfterAll\nAnnotation for executing method before each test case @Before @BeforeEach\nAnnotation for executing method after each test method @After @AfterEach\nArchitecture It has everything like platform, annotations etc bundled in a single jar file. JUnit 5 is composed of 3 sub-units - JUnit Platform, JUnit Jupiter and JUnit Vintage\nRequired JDK Version This needs Java 5 or higher versions. This needs Java 8 or above.\nAssertions Assert methods are present in org.junit.Assert package for validating expected and actual outputs. Assert methods are present in the org.junit.jupiter.Assertions package. The methods also have overloaded methods for supporting error messages in case tests fail. Category JUnit 4 JUnit 5\nAnnotation for executing method before all test methods run in the current class @BeforeClass @BeforeAll\nAnnotation for executing method after all test methods run in the current class @AfterClass @AfterAll\nAnnotation for executing method before each test case @Before @BeforeEach\nAnnotation for executing method after each test method @After @AfterEach\nArchitecture It has everything like platform, annotations etc bundled in a single jar file. JUnit 5 is composed of 3 sub-units - JUnit Platform, JUnit Jupiter and JUnit Vintage\nRequired JDK Version This needs Java 5 or higher versions. This needs Java 8 or above.\nAssertions Assert methods are present in org.junit.Assert package for validating expected and actual outputs. Assert methods are present in the org.junit.jupiter.Assertions package. The methods also have overloaded methods for supporting error messages in case tests fail. Category JUnit 4 JUnit 5 Category JUnit 4 JUnit 5 Category JUnit 4 JUnit 5 Annotation for executing method before all test methods run in the current class @BeforeClass @BeforeAll\nAnnotation for executing method after all test methods run in the current class @AfterClass @AfterAll\nAnnotation for executing method before each test case @Before @BeforeEach\nAnnotation for executing method after each test method @After @AfterEach\nArchitecture It has everything like platform, annotations etc bundled in a single jar file. JUnit 5 is composed of 3 sub-units - JUnit Platform, JUnit Jupiter and JUnit Vintage\nRequired JDK Version This needs Java 5 or higher versions. This needs Java 8 or above.\nAssertions Assert methods are present in org.junit.Assert package for validating expected and actual outputs. Assert methods are present in the org.junit.jupiter.Assertions package. The methods also have overloaded methods for supporting error messages in case tests fail. Annotation for executing method before all test methods run in the current class @BeforeClass @BeforeAll Annotation for executing method before all test methods run in the current class @BeforeClass @BeforeAll Annotation for executing method after all test methods run in the current class @AfterClass @AfterAll Annotation for executing method after all test methods run in the current class @AfterClass @AfterAll Annotation for executing method before each test case @Before @BeforeEach Annotation for executing method before each test case @Before @BeforeEach Annotation for executing method after each test method @After @AfterEach Annotation for executing method after each test method @After @AfterEach Architecture It has everything like platform, annotations etc bundled in a single jar file. JUnit 5 is composed of 3 sub-units - JUnit Platform, JUnit Jupiter and JUnit Vintage Architecture It has everything like platform, annotations etc bundled in a single jar file. JUnit 5 is composed of 3 sub-units - JUnit Platform, JUnit Jupiter and JUnit Vintage Required JDK Version This needs Java 5 or higher versions. This needs Java 8 or above. Required JDK Version This needs Java 5 or higher versions. This needs Java 8 or above. Assertions Assert methods are present in org.junit.Assert package for validating expected and actual outputs. Assert methods are present in the org.junit.jupiter.Assertions package. The methods also have overloaded methods for supporting error messages in case tests fail. Assertions Assert methods are present in org.junit.Assert package for validating expected and actual outputs. org.junit.Assert Assert methods are present in the org.junit.jupiter.Assertions package. The methods also have overloaded methods for supporting error messages in case tests fail. org.junit.jupiter.Assertions",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "17. What are the differences between JUnit and TestNG?",
        "answer": "JUnit TestNG\nOpen-source unit testing framework for writing test cases. TestNG is similar to JUnit but with extended functionalities.\nJUnit does not support advanced annotations. This supports advanced and special annotations too.\nJUnit does not support parallel testing. TestNG supports multiple threads to run parallelly.\nGroup test is not supported. TestNG is supported in TestNG.\nThe naming convention for annotations like Before, After, Expected are confusing. The naming convention for understanding annotations like BeforeMethod, AfterMethod, ExpectedException is easy to understand based on their functionality.\nCannot rerun failed cases. Can rerun failed tests. JUnit TestNG\nOpen-source unit testing framework for writing test cases. TestNG is similar to JUnit but with extended functionalities.\nJUnit does not support advanced annotations. This supports advanced and special annotations too.\nJUnit does not support parallel testing. TestNG supports multiple threads to run parallelly.\nGroup test is not supported. TestNG is supported in TestNG.\nThe naming convention for annotations like Before, After, Expected are confusing. The naming convention for understanding annotations like BeforeMethod, AfterMethod, ExpectedException is easy to understand based on their functionality.\nCannot rerun failed cases. Can rerun failed tests. JUnit TestNG JUnit TestNG JUnit TestNG Open-source unit testing framework for writing test cases. TestNG is similar to JUnit but with extended functionalities.\nJUnit does not support advanced annotations. This supports advanced and special annotations too.\nJUnit does not support parallel testing. TestNG supports multiple threads to run parallelly.\nGroup test is not supported. TestNG is supported in TestNG.\nThe naming convention for annotations like Before, After, Expected are confusing. The naming convention for understanding annotations like BeforeMethod, AfterMethod, ExpectedException is easy to understand based on their functionality.\nCannot rerun failed cases. Can rerun failed tests. Open-source unit testing framework for writing test cases. TestNG is similar to JUnit but with extended functionalities. Open-source unit testing framework for writing test cases. TestNG is similar to JUnit but with extended functionalities. JUnit does not support advanced annotations. This supports advanced and special annotations too. JUnit does not support advanced annotations. This supports advanced and special annotations too. JUnit does not support parallel testing. TestNG supports multiple threads to run parallelly. JUnit does not support parallel testing. TestNG supports multiple threads to run parallelly. Group test is not supported. TestNG is supported in TestNG. Group test is not supported. TestNG is supported in TestNG. The naming convention for annotations like Before, After, Expected are confusing. The naming convention for understanding annotations like BeforeMethod, AfterMethod, ExpectedException is easy to understand based on their functionality. The naming convention for annotations like Before, After, Expected are confusing. The naming convention for understanding annotations like BeforeMethod, AfterMethod, ExpectedException is easy to understand based on their functionality. Cannot rerun failed cases. Can rerun failed tests. Cannot rerun failed cases. Can rerun failed tests.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "18. How to ignore tests in JUnit?",
        "answer": "We need to ignore test cases when we have certain functionalities that are not certain or they are under development. To wait for the completion of the code, we can avoid running these test cases. In JUnit 4, we can achieve this by using @Ignore annotation over the test methods. In JUnit 5, we can do it using @Disabled annotation over the test methods.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "19. What is the purpose of @Before and @After annotations in JUnit 4?",
        "answer": "These are the annotations present in JUnit 4. Methods annotated with @Before will be called and run before the execution of each test case. Methods annotated with @After will be called and executed after the execution of each test case. If we have 5 test cases in a JUnit class, then the methods annotated with these two would be run 5 times. In JUnit 5, the annotations @Before and @After are renamed to @BeforeEach and @AfterEach for making it more readable.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "1. Why do we need mocking in unit testing?",
        "answer": "Mocking is the process of creating and using mock objects that simulates the behaviour of real objects and is used to isolate the behaviour of the module under test from its external dependencies or services. These are particularly useful in unit testing and help in making unit test cases repeatable and predictable. Mocking is required in the following cases: Whenever the module under test has dependencies that are not fully implemented. For example, if we have a module that calls a REST API that is still in progress, then to test our module, it is advised to mock the API call and perform unit testing of our module.\nWhenever the module under test updates the system states. For example, whenever the module involves database calls that creates or updates or delete data from the system, it is very much important to mock those objects.\nEven if we have DB calls that just retrieves the data, it is advised to mock those because of the risk of DB availability. Whenever the module under test has dependencies that are not fully implemented. For example, if we have a module that calls a REST API that is still in progress, then to test our module, it is advised to mock the API call and perform unit testing of our module. Whenever the module under test updates the system states. For example, whenever the module involves database calls that creates or updates or delete data from the system, it is very much important to mock those objects. Even if we have DB calls that just retrieves the data, it is advised to mock those because of the risk of DB availability.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "2. What is Mockito? What are some of its advantages?",
        "answer": "Mockito is an open-source, Java-based, mocking framework that allows the creation of test objects that simulate the behaviour (mock) of real-world objects. This helps in achieving test-driven or behaviour-driven development. The framework allows developers to verify system behaviours without establishing expectations. Mockito framework attempts to eliminate expect-run-verify development patterns by removing external specifications and dependencies. Some of the advantages of Mockito are: Mocks are created at runtime, hence reordering method input parameters or renaming interface methods will not break test code.\nMockito supports returning of values.\nIt supports exception simulation\nIt provides a check on the order of method calls.\nIt helps in creating mock objects using annotation. Mocks are created at runtime, hence reordering method input parameters or renaming interface methods will not break test code. Mockito supports returning of values. It supports exception simulation It provides a check on the order of method calls. It helps in creating mock objects using annotation.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "3. When and why should we use spy?",
        "answer": "Spy is a partial mock object supported by the Mockito framework. Following are the features of spy objects: Whenever mock is not set up, interaction on spy results in real method calls. Spy objects allow verifying interactions such as whether the method was called and how many times it was called, etc.\nThey provide flexibility for setting up partial mocks. For instance, if an object has 2 methods, and we want one method to be mocked and the other to be called actually, then we can use spies. Whenever mock is not set up, interaction on spy results in real method calls. Spy objects allow verifying interactions such as whether the method was called and how many times it was called, etc. They provide flexibility for setting up partial mocks. For instance, if an object has 2 methods, and we want one method to be mocked and the other to be called actually, then we can use spies. The main difference between mock and spy is that in mock, we create a complete fake object whereas, in spy, we have a hybrid of a real object and fake/stubbed methods.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "4. What is the difference between thenReturn and doReturn?",
        "answer": "thenReturn and doReturn are used for setting up stubs and are provided by the Mockito framework. They are generally used along with when clause as --> when-thenReturn and doReturn-when. when-thenReturn is used in most cases due to better readability. doReturn when-thenReturn doReturn-when when-thenReturn Following are the differences between thenReturn and doReturn: thenReturn doReturn Type safety:\ndoReturn takes Object parameter, unlike thenReturn. Hence there is no type check in doReturn at compile time. In the case of thenReturn, whenever the type mismatches during runtime, the WrongTypeOfReturnValue exception is raised. This is why when-thenReturn is a better option whenever we know the type.\nNo side-effect:\nSince doReturn does not have type safety, there are no side effects when it is being used. Whenever thenReturn is used, if the type mismatch occurs, an exception is thrown which might result in the abortion of test cases. Type safety:\ndoReturn takes Object parameter, unlike thenReturn. Hence there is no type check in doReturn at compile time. In the case of thenReturn, whenever the type mismatches during runtime, the WrongTypeOfReturnValue exception is raised. This is why when-thenReturn is a better option whenever we know the type. Type safety  doReturn thenReturn doReturn thenReturn WrongTypeOfReturnValue when-thenReturn No side-effect:\nSince doReturn does not have type safety, there are no side effects when it is being used. Whenever thenReturn is used, if the type mismatch occurs, an exception is thrown which might result in the abortion of test cases. No side-effect:  doReturn thenReturn",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "5. What is the main difference between @Mock and @InjectMocks?",
        "answer": "@Mock annotation is used for creating mocks whereas @InjectMocks is used for creating class objects. Whenever the actual method body has to be executed of a given class, then we can use @InjectMocks.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "6. Why can’t we mock static methods in Mockito?",
        "answer": "Static methods belong to the class and not to any objects which means that all instances of the class use the same static method. They are more like procedural code and are used in legacy systems. Mock libraries create mocks at runtime utilizing dynamic instance creation using interfaces or inheritance. Since static methods are not linked with any instance, it is not possible to mock them using Mockito. However, we have frameworks like PowerMock that supports static methods.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "7. How can we mock void methods in Mockito?",
        "answer": "Consider we have a method called updateItem() which internally calls a void method called updateItem() which interacts with the database and updates the object. updateItem() updateItem() public Item updateItem(Item item) {\n    if (item == null || item.getItemId() < 0) {\n        throw new IllegalArgumentException(\"Invalid Id\");\n    }\n    itemRepository.updateItem(item); //void method that updates database state\n    return item;\n} public Item updateItem(Item item) {\n    if (item == null || item.getItemId() < 0) {\n        throw new IllegalArgumentException(\"Invalid Id\");\n    }\n    itemRepository.updateItem(item); //void method that updates database state\n    return item;\n} public Item updateItem(Item item) public updateItem (Item item) if null 0 throw new \"Invalid Id\" //void method that updates database state return We can mock the void method in the following ways: 1. doNothing-when: This is used when we do not want to check for the return parameters and skip the actual execution. When this mocked method is called, then it does nothing. The test case would be: doNothing-when @Test\npublic void updateItemTest() {\n    Item item = new Item(2, \"Item 1\"); \n    doNothing().when(itemRepository).updateItem(any(Item.class));\n    itemService.updateItem(item);\n} @Test\npublic void updateItemTest() {\n    Item item = new Item(2, \"Item 1\"); \n    doNothing().when(itemRepository).updateItem(any(Item.class));\n    itemService.updateItem(item);\n} 2. doAnswer-when: We can also make use of doAnswer-when whenever we need to perform additional actions like computing return values based on method parameters when a mocked method is called. This is done using the following: doAnswer-when @Test\npublic void updateItemTest() {\n    Item item = new Item(2, \"Item 2\");\n    doAnswer((args) -> {\n        System.out.println(\"doAnswer block entered.\");\n        assertEquals(customer, args.getArgument(0));\n        return null;\n   }).when(itemRepository).updateItem(any(Item.class));\n    itemService.updateItem(item);\n} @Test\npublic void updateItemTest() {\n    Item item = new Item(2, \"Item 2\");\n    doAnswer((args) -> {\n        System.out.println(\"doAnswer block entered.\");\n        assertEquals(customer, args.getArgument(0));\n        return null;\n   }).when(itemRepository).updateItem(any(Item.class));\n    itemService.updateItem(item);\n} 3. doThrow-when: If we want to throw an exception from void methods or any normal methods, then we can use doThrow-when as shown below: doThrow-when @Test(expected = Exception.class)\npublic void updateItemTest() {\n    Item item = new Item(3, \"Item 3\");\n    doThrow(new Exception(\"Item Invalid\")).when(itemRepository).updateItem(any(Item.class));\n    itemService.updateItem(item);\n} @Test(expected = Exception.class)\npublic void updateItemTest() {\n    Item item = new Item(3, \"Item 3\");\n    doThrow(new Exception(\"Item Invalid\")).when(itemRepository).updateItem(any(Item.class));\n    itemService.updateItem(item);\n} Conclusion Writing Unit Test Cases has various advantages like design testability, code testability, enhances code maintainability and helps developers enforce object-oriented principles that aids to avoid code smells like long methods, large conditions, long classes etc. It helps to identify any existing logic flaw in the application. Due to these reasons, it has become important for developers to know how to unit test the functionalities developed by them. JUnit is one such popular framework that has robust support for unit testing.",
        "reference": "interviewbit.com",
        "role": "junit"
    },
    {
        "question": "1) What is Testing?",
        "answer": "Testing is the process of checking the functionality of the application whether it fulfills the requirement or not.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "2) What is JUnit?",
        "answer": "JUnit is the testing framework, it is used for unit testing of Java code.\nJUnit = Java + Unit Testing  \nMore details...",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "3) What is unit testing?",
        "answer": "The process of testing individual functionality (known as a unit) of the application is called unit testing.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "4) What is the difference between manual testing and automated testing?",
        "answer": "Manual testing is performed by Human, so it is time-consuming and costly. Automated testing is performed by testing tools or programs, so it is fast and less costly.\nMore details...",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "",
        "answer": "Following are some disadvantages of manual testing:\nADVERTISEMENT\nThe testing is very time consuming and is very tiring.\nThe testing demands a very big investment in the human resources.\nThe testing is less reliable\nThe testing cannot be programmed.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "",
        "answer": "Some of the advantages of automated testing are:\nIt is very fast.\nInvestment is very less.\nTesting is more reliable.\nThe testing can be programmed.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "7) Is it necessary to write the test case for every logic?",
        "answer": "No, we should write the test case only for that logic that can be reasonably broken.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "8) What are the useful JUnit extensions?",
        "answer": "JWebUnit\nXMLUnit\nCactus\nMockObject",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "9) What are the features of JUnit?",
        "answer": "Opensource\nAnnotation support for test cases\nAssertion support for checking the expected result\nTest runner support to execute the test case\n10) How is the testing of the 'protected' method done?\nTo test the protected method, the test class is declared in the same package as the target class.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "10) How is the testing of the 'protected' method done?",
        "answer": "To test the protected method, the test class is declared in the same package as the target class.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "11) How is the testing of 'private' method done?",
        "answer": "There is no direct way for testing of the private method; hence manual testing is to be performed, or the method is changed to \"protected\" method.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "12) If the JUnit method's return type is 'string', what will happen?",
        "answer": "JUnit test methods are designed to return 'void'. So the execution will fail.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "13) Is the use of 'main' method possible for unit testing?",
        "answer": "Yes",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "14) Is it necessary to write the test class to test every class?",
        "answer": "No",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "15) What does XMLUnit provide?",
        "answer": "Junit extension class, XMLTestCase and set of supporting classes is provided by the XMLUnit.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "",
        "answer": "Cactus Framework\nCactus Integration Module",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "17) What are the methods in fixtures?",
        "answer": "setup\ntearDown",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "18) What is the Unit Test Case?",
        "answer": "A Unit Test Case is the combination of input data and expected output result. It is defined to test the functionality of a unit.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "19) What is the use of @Test annotation?",
        "answer": "The @Test annotation is used to mark the method as the test method.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "20) What is the test suit?",
        "answer": "The test suit allows us to group multiple test cases so that it can be run together. TestSuit is the container class under junit.framework.TestSuite package.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "21) What does test runner?",
        "answer": "The test runner is used to execute the test cases.",
        "reference": "javatpoint.com",
        "role": "junit"
    },
    {
        "question": "22) What are the important JUnit annotations?",
        "answer": "The test runner is used to execute the test cases.\n@Test\n@BeforeClass\n@Before\n@After\n@AfterClass",
        "reference": "javatpoint.com",
        "role": "junit"
    }
]