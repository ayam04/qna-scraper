[
    {
        "question": "1. What is REST API?",
        "answer": "Representational State Transfer Application Programming Interface, or REST API, is a term that refers to a set of guidelines and practices used to create and put into use networked applications. By specifying a standardized method of accessing and manipulating resources, RESTful APIs facilitate communication across various software systems over the internet.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "2. What is the difference between API and REST API?",
        "answer": "API refers to a set of rules and tools that enable software programs to communicate and interact with one another. On the other hand, REST API refers to an API that adheres to the REST architectural style’s concepts and limits, utilizing common HTTP methods and resource-based communication.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "3. What do you mean by RESTful web services?",
        "answer": "RESTful web services, short for Representational State Transfer, are an architectural style used in web development to design networked applications. It relies on HTTP methods like GET, POST, PUT, and DELETE to perform CRUD operations on resources. RESTful services use URLs to uniquely identify resources and employ standard data formats such as JSON or XML for data exchange. The key principles of REST include statelessness, meaning each request from a client must contain all the information required to understand and process it. These services are lightweight, scalable, and widely adopted due to their simplicity, making them a popular choice for building APIs and web applications.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "4. What are the features of RESTful web services?",
        "answer": "The features of RESTful web services are mentioned below: \nStateless: The server does not store client context between requests.\nUniform Interface: RESTful APIs follow standard rules and conventions.\nResource-Oriented: APIs are centered around resources that are identified by unique URLs.\nRepresentation of Resources: Resources are represented using standard data formats (e.g., JSON, XML).\nStateless Server: The server treats each request independently and does not maintain the client state.\nCaching: APIs can support caching of responses to improve performance.\nLayered System: APIs can be designed as a layered system for the separation of concerns.\nClient-Server Architecture: The client handles the user interface, and the server handles business logic and data storage.\nStateless Communication: Stateless communication implies that each client request has all of the necessary information for the server to process and that the server has no knowledge or recollection of the client’s prior interactions or state between requests.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "5. What is the definition of messaging in terms of RESTful web services?",
        "answer": "In the context of RESTful web services, messaging refers to the exchange of information or communication between the client and the server using HTTP messages. These messages are sent as requests and responses; they follow the standard HTTP protocol.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "6. Explain ‘Addressing’ in RESTful web services.",
        "answer": "Addressing in RESTful web services refers to the mechanism by which resources are identified and accessed using URLs (Uniform Resource Locators). URLs play a crucial role in addressing this, as they provide a unique and standardized way to locate and interact with resources in the system.\nThe URL format is mentioned below: \n<protocol>://<application-name>/<type-of-resource>/<id-of-resource>",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "7. Why are REST services easily scalable?",
        "answer": "REST services are easily scalable due to several inherent characteristics of the RESTful architecture. Here are the key reasons why REST services are scalable:\nStateless Communication: RESTful services follow a stateless communication model, allowing requests to be processed independently and in parallel.\nResource-Oriented Design: REST APIs are centered around resources, allowing individual resources to be scaled independently.\nCacheability: RESTful services support caching, thereby reducing the load on the server by reusing stored responses.\nLoad Balancing: Load balancers distribute incoming requests across multiple servers, thus ensuring an even workload distribution.\nHorizontal Scaling: REST services can be horizontally scaled by adding more servers or instances to handle increased demand.\nCloud Infrastructure: REST services can leverage cloud platforms with auto-scaling capabilities for efficient resource allocation.\nGet 100% Hike!\nMaster Most in Demand Skills Now!\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "8. Differentiate between POST and PUT methods.",
        "answer": "POST Method\nThis method is used to build new server resources.\nThis method is not idempotent. Hence, multiple identical requests may result in different outcomes.\nThe POST Method is typically used for submitting data to create a new resource.\nIn this method, the server processes the request, creates a new resource, and responds with a representation of the created resource.\nPUT Method\nThis method is used to update or replace an existing resource on the server or to create a resource if one doesn’t exist.\nThis method is idempotent. Hence, sending the same request multiple times will have the same outcome.\nThe PUT method is typically used for updating or replacing an entire resource.\nIn this method, the server replaces or updates the identified resource with the representation provided and responds with a representation of the updated resource.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "9. Which are the HTTP request methods that are supported by REST?",
        "answer": "REST is compatible with a number of HTTP request methods, including GET, POST, PUT, DELETE, HEAD, OPTIONS, and others.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "10. What is CRUD?",
        "answer": "CRUD, an acronym for Create, Read, Update, and Delete, represents the fundamental operations performed on resources in a REST API. It encapsulates the four essential actions necessary for data manipulation. The ‘Create’ operation involves adding new resources; ‘Read’ retrieves resources; ‘Update’ modifies existing resources; and ‘Delete’ removes resources from the system. REST APIs employ HTTP methods to map these CRUD operations to resources. For instance, ‘POST’ for Create, ‘GET’ for Read, ‘PUT’ for Update, and ‘DELETE’ for Delete. This standardized approach ensures a consistent and uniform way to interact with resources, promoting simplicity, scalability, and interoperability in RESTful web services.\n\nIntermediate REST API Interview Questions",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "11. What are the main parts of an HTTP response?",
        "answer": "The main parts of an HTTP response are the HTTP version, Status line, HTTP Response Header, and HTTP Response Body.\nCheck out the Top Web Developer Interview Questions.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "12. What do you know about JAX-RS?",
        "answer": "JAX-RS is an abbreviation that stands for Java API for RESTful Web Services. It is a Java-based API that provides recommendations and annotations for developing RESTful web services. The Java EE (Enterprise Edition) platform contains JAX-RS, which is designed to make the creation of RESTful APIs in Java easier.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "13. What are the most common HTTP response status codes that you see while working with REST API?",
        "answer": "The most common HTTP response status codes are mentioned below: \n200 OK: The 200 OK is a status code that represents a successful request. After the successful processing of such a request, it is utilized for GET, POST, PUT, and DELETE operations.\n201 Created: When a new resource is successfully generated as a result of a POST request, this code is returned. It is often followed by a Location header that contains the URL of the newly generated resource.\n204 No Content: This status code signals the user that the server has successfully processed the request, although no content was returned in the response body. It is often used in DELETE operations.\n400 Bad Request: The 400 Bad Request is a status code that signals the user that the server was unsuccessful in understanding the request. This status code can show up in this instance due to multiple reasons, including incorrect syntax, missing arguments, or invalid data. This is often followed by an error message explaining the problem.\n401 Unauthorized: 401 Unauthorized is a status code that is used to indicate the fact that the particular request needs authentication and that the user has failed to submit valid credentials or that the resource that was requested was not authorized.\n403 Forbidden: 403 Forbidden is a status code that pops up in cases where the server has understood the request, although the user is not allowed to access the resource that has been requested. The status code 403 Forbidden is different from 401 Unauthorized since, in the former, no authentication is required.\n404 Not Found: 404 Not Found is a status code that shows up in instances where the resource that was requested is not to be found on the server. The presence of this status code signifies that the server was unsuccessful in finding a resource that matches the specified URL.\n500 Internal Server Error: The presence of this code indicates that the server has encountered an unexpected error while processing the request. Being a general error response, the status code 500 Internal Server Error does not provide any information about the problem.\n503 Service Unavailable: The presence of the status code 503 Service Unavailable is commonly seen when the server is trying to signal the user that it is unable to process the request for the time being; usually, this happens due to server overload or because the server is undergoing maintenance.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "14. What is a resource?",
        "answer": "A server-side object with a label serves as a resource in the REST architecture. Resources are accompanied by a list of methods, related data, and relationships to other resources on the server.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "15. What is a URI?",
        "answer": "URI, or Uniform Resource Identifier, is a term used in the computer world. It is used for the names of all the resources that are connected to the World Wide Web.\nCheck out our PHP Interview Questions to ace your next interview!",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "16. What is caching in REST API?",
        "answer": "To quickly obtain a server answer in the future, the REST API maintains a copy of the response in a specific area of computer memory. This temporary technique is known as “caching.”",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "17. What’s a real-world example of a REST API?",
        "answer": "Several examples can be drawn from the real world to talk about REST APIs, some of which have been mentioned below:\nPayment Processing Apps with PayPal API: These apps allow users to conduct secure online transactions. The PayPal API enables developers to manage subscriptions, issue refunds, collect payments, and access transactional information.\nTravel Apps with Google Maps API: These are the applications for travel that offer mapping and navigation functions. Developers can display maps, compute distances, provide directions, look for points of interest, and incorporate Street View photographs by integrating the API.\nSocial Media Apps with Facebook Graph API: Social networking apps that integrate with the Facebook Graph API can link users’ accounts, retrieve profiles, publish updates, and otherwise communicate with the Facebook platform. Developers may access social features like images, news feeds, timelines, friend requests, and Facebook Page data thanks to the API.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "18. What are the advantages of REST?",
        "answer": "The advantages of REST are mentioned below: \nSimplicity and ease of understanding.\nScalability and performance due to statelessness\nFlexibility in choosing data formats\nInteroperability with different systems and platforms.\nSupport for caching mechanisms to improve performance\nStateless nature and server independence.\nIntegration with existing web standards and protocols.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "19. What are the disadvantages of RESTful web services?",
        "answer": "The disadvantages of RESTful web services are mentioned below: \nLack of standardization in API design and contract\nLimited functionality beyond CRUD operations.\nDevelopers must incorporate security mechanisms to ensure that client requests are self-contained and contain all necessary information for server processing.\nLack of built-in support for complex transaction management.\nRequires careful resource design to maintain scalability.\nInefficiency when dealing with large or hierarchical data structures.\nLack of discoverability without additional documentation or standards.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "20. What is the difference between REST and SOAP?",
        "answer": "The differences between REST and SOAP are enumerated below:\nREST (Representational State Transfer)\nBased on the principles of the web and utilizes the HTTP protocol.\nLightweight and simple, utilizing JSON or XML for data representation.\nProtocol-independent, although it commonly uses HTTP.\nThere is no standardized service discovery language; it is often documented informally.\nFlexible and scalable, which makes REST suitable for most scenarios.\nSOAP (Simple Object Access Protocol)\nUses XML-based messaging and can work over different protocols.\nStructured and verbose with a well-defined XML message format.\nSOAP is a protocol in itself, which adds a layer of abstraction.\nDescribed using WSDL for service discovery and code generation.\nMore complex and suitable for enterprise-centric environments with strict requirements for security, reliability, and transaction management.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "21. Mentioned the different types of API architectures.",
        "answer": "There are six different types of API Architectures, which are mentioned below: \nMonolithic Architecture: The entire application is a single unit; it is simple but hard to scale.\nService-Oriented Architecture (SOA): This application is composed of multiple services communicating over a network.\nMicroservices Architecture: These are small, independent services meant for better scalability and maintainability.\nEvent-Driven Architecture (EDA): These services communicate through events for loose coupling and scalability.\nServerless Architecture: These functions are executed in response to events or API invocations; they are managed by the cloud provider.\nGraphQL Architecture: This query language allows clients to request specific data efficiently.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "22. What is AJAX?",
        "answer": "AJAX is a web development method that enables data to be transferred asynchronously between a web browser and server without necessitating a complete page reload. It makes it possible for dynamic updates and improves user interaction with websites.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "23. Which frameworks can JAX-RS implement in the RESTful web?",
        "answer": "Frameworks that can be used to implement JAX-RS in RESTful web services are Jersey, Apache CXF, RESTEasy, Spring Boot, and Apache TomEE.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "24. Mention the markup language that can be used in restful web API.",
        "answer": "The two markup languages that can be used with RESTful web APIs are JSON and XML.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "25. Why is proper representation of resources necessary?",
        "answer": "The client can readily grasp the format and identify the resources when they are properly represented and presented.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "26. Mention the important aspects of RESTful web services implementation.",
        "answer": "Mentioned below are some important aspects of implementing RESTful web services:\nResource Design: Identify and define the resources that are to be exposed through the API.\nHTTP Status Codes: Return appropriate status codes to communicate the outcome of the requests.\nRequest and Response Formats: Determine standardized formats for data exchange, such as JSON or XML.\nUniform Interface: Follow principles like standard HTTP methods and hypermedia-driven navigation.\nAuthentication and Security: Implement secure authentication and authorization mechanisms.\nError Handling: Provide meaningful error messages and troubleshooting guidance.\nVersioning: Consider strategies to manage API changes and ensure backward compatibility.\nDocumentation: Create comprehensive documentation to guide developers in using the API.\nTesting and Monitoring: Thoroughly test the API and implement monitoring for performance and issues.\nScalability and Performance: Design for scalability and optimize performance factors like caching and data retrieval.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "27. Mention the different application integration styles.",
        "answer": "Mentioned below are the various application integration styles:\nPoint-to-Point Integration: Direct connections between applications for data exchange\nPublish-Subscribe (Pub-Sub) Integration: Messaging-based communication through a broker\nService-Oriented Architecture (SOA): Loosely coupled services with well-defined interfaces\nMessage-Oriented Middleware (MOM): Asynchronous messaging between applications\nEnterprise Service Bus (ESB): Centralized infrastructure for integration\nRepresentational State Transfer (REST): API-based communication that uses HTTP methods\nEvent-Driven Architecture (EDA): Communication through events and event processing\nMicroservices Architecture: Small, independent services that communicate via lightweight protocols\n\nAdvanced REST API Interview Questions",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "28. Can you use GET requests instead of PUT to create a resource?",
        "answer": "No, a POST request is required to create a resource in a RESTful API. POST inquiries are used to add new resources, whereas GET queries are used to retrieve existing ones.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "29. What is the concept of statelessness in REST?",
        "answer": "In REST, statelessness refers to the absence of client state storage on the server between requests. Each request must be distinct and self-contained, and it must contain all pertinent information. This improves request processing reliability, scalability, and design simplicity.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "30. How do you keep REST APIs secure?",
        "answer": "Mentioned below are some ways to keep REST APIs secure:\nImplement authentication and authorization mechanisms.\nUse HTTPS for secure communication.\nValidate and sanitize user inputs to prevent vulnerabilities.\nApply rate-limiting to protect against abusive requests.\nSet appropriate security headers in API responses.\nEncrypt sensitive data and use strong hashing algorithms for passwords.\nImplement logging and monitoring to detect suspicious activities.\nConduct regular security testing and assessments.\nFollow secure coding practices throughout development.\nStay updated with the latest security practices and patch vulnerabilities promptly.\nGet 100% Hike!\nMaster Most in Demand Skills Now!\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "31. What are Idempotent methods? How is it relevant in the RESTful web services domain?",
        "answer": "HTTP idempotent techniques can be safely repeated or retried several times without yielding different results. In other words, repeating a request should have the same effect as making it once. For several reasons, idempotent procedures are critical in the design and implementation of RESTful web services. Mentioned below are some key reasons for the same:\nReliability: Idempotent techniques ensure that repeating a request, be it due to network difficulties or client retries, does not result in unwanted side effects or inconsistent server states. This increases the system’s dependability and robustness.\nCaching: HTTP caches idempotent methods by default. Caches can save the response to an idempotent request and serve it to subsequent identical requests, decreasing server load and enhancing performance.\nSafe Repeat: When a request fails or times out, idempotent methods allow clients to repeat it without the fear of creating conflicts or undesired changes. Retrying an idempotent request should have no negative consequences.\nScalability: Idempotent procedures make it easier to create scalable systems. Since the same request can be processed numerous times without affecting the outcome, it is simpler to divide requests across multiple servers or handle concurrent requests.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "32. How is JAXB related to RESTful web API?",
        "answer": "The JAXB Java API allows Java objects to be translated into XML representations and vice versa. By transforming XML payloads to Java objects, JAXB can make it simpler for RESTful web APIs to handle XML payloads.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "33. Can you tell what constitutes the core components of HTTP requests?",
        "answer": "In REST, any HTTP request has five main components, which are mentioned below:\nMethod/Verb: This section describes the methods that the request action represents. GET, PUT, POST, DELETE, and other methods are examples.\nURI: This portion is used to uniquely identify the server’s resources.\nHTTP Version: This section specifies the version of the HTTP protocol that you are using. HTTP v1.1 is an example.\nRequest Header: This section contains request metadata such as client type, supported content formats, message format, cache settings, and so on.\nRequest Body: This section contains the actual message text that will be sent to the server.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "34. What is HATEOAS (Hypermedia as the Engine of Application State) in the context of REST API, and why is it considered an important constraint of RESTful architecture?",
        "answer": "Hypermedia as the Engine of Application State (HATEOAS) is a fundamental constraint in RESTful architecture for APIs. It refers to the principle of including hypermedia links in the API responses to guide clients dynamically through available actions. The API acts as a navigable web of resources interconnected by hyperlinks, allowing clients to discover and interact with resources without prior knowledge of their structure or endpoints. \nThis feature promotes a decoupled and flexible design, thereby enabling the server to evolve independently while maintaining backward compatibility. HATEOAS enhances the scalability, discoverability, and adaptability of REST APIs, making it a crucial element in building truly RESTful systems.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "35. Explain how you would implement authentication and authorization in a RESTful API for different types of clients (e.g., web browsers, mobile apps, and third-party applications). Discuss the pros and cons of various authentication methods, such as OAuth, API keys, JSON Web Tokens (JWT), and session-based authentication.",
        "answer": "Implementing authentication and authorization in a RESTful API for various client types involves careful selection of suitable methods to ensure security and flexibility. For web browsers, session-based authentication is commonly used, which relies on cookies to maintain user sessions. While this method is straightforward, it may not be ideal for stateless APIs, and it lacks scalability.\nMobile apps can benefit from OAuth, a widely adopted protocol that provides delegated access to resources without exposing user credentials. OAuth offers granular control over permissions and enhances security, although it requires proper implementation to prevent token leakage or misuse.\nThird-party applications often utilize API keys for authentication. While simple to implement, API keys lack sophistication and may not support fine-grained access control, potentially leading to security issues.\nJSON Web Tokens (JWT) offer a self-contained and stateless approach; they contain user information within the token itself, which reduces server-side state management. JWT’s flexibility allows it to be used across different client types, making it a popular choice. However, proper token management is crucial to prevent token tampering and unauthorized access.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "36. When designing a RESTful API, what strategies would you use to achieve versioning and handle backward compatibility effectively? Discuss the pros and cons of different versioning approaches, such as URL versioning, custom headers, and media type versioning.",
        "answer": "When designing a RESTful API, it is crucial to effectively achieve versioning and handle backward compatibility. Three main strategies for versioning are URL versioning, custom headers, and media-type versioning.\nURL versioning involves incorporating the version number in the API endpoint (e.g., /api/v1/resource). This approach is straightforward and cache-friendly; however, it can clutter the URL, and it lacks flexibility if the API evolves significantly.\nCustom headers utilize HTTP headers like “Accept-Version” to specify the desired version. It keeps the URL clean and allows clients to request the version explicitly, although it requires additional header parsing and may not be as intuitive.\nMedia type versioning employs the “Accept” header with custom media types (e.g., application/vnd.company.resource.v1+json). It provides a clear separation of concerns and is flexible for version negotiation, but the implementation can be complex and challenging for clients to understand.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "37. How can you optimize a RESTful API for performance and scalability, especially in high-traffic scenarios? Discuss techniques such as caching, load balancing, connection pooling, and asynchronous processing to improve API responsiveness and handle large volumes of concurrent requests.",
        "answer": "Optimizing a RESTful API for performance and scalability, particularly in high-traffic scenarios, involves implementing various techniques to enhance responsiveness and handle concurrent requests efficiently. \nCaching plays a vital role by storing frequently requested data, reducing the need for repeated computations, and minimizing database calls. Load balancing evenly distributes incoming traffic across multiple servers, preventing overloading and ensuring a smooth user experience. Connection pooling optimizes resource usage by reusing established database connections, thus reducing connection creation overhead. \nAsynchronous processing offloads time-consuming tasks to background threads, enabling the API to handle numerous requests simultaneously without blocking the main execution flow. These techniques ensure a robust, scalable, and high-performing REST API that is capable of handling substantial user loads.",
        "reference": "intellipaat.com",
        "role": "rest-api"
    },
    {
        "question": "1. What do you understand by RESTful Web Services?",
        "answer": "RESTful web services are services that follow REST architecture. REST stands for Representational State Transfer and uses HTTP protocol (web protocol) for implementation. These services are lightweight, provide maintainability, scalability, support communication among multiple applications that are developed using different programming languages. They provide means of accessing resources present at server required for the client via the web browser by means of request headers, request body, response body, status codes, etc.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "2. Define Messaging in terms of RESTful web services.",
        "answer": "The technique of sending a message from the REST client to the REST server in the form of an HTTP request and the server responding back with the response as HTTP Response is called Messaging. The messages contained constitute the data and the metadata about the message.  ",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "3. Can you tell the disadvantages of RESTful web services?",
        "answer": "The disadvantages are: As the services follow the idea of statelessness, it is not possible to maintain sessions. (Session simulation responsibility lies on the client-side to pass the session id)\nREST does not impose security restrictions inherently. It inherits the security measures of the protocols implementing it. Hence, care must be chosen to implement security measures like integrating SSL/TLS based authentications, etc. As the services follow the idea of statelessness, it is not possible to maintain sessions. (Session simulation responsibility lies on the client-side to pass the session id) REST does not impose security restrictions inherently. It inherits the security measures of the protocols implementing it. Hence, care must be chosen to implement security measures like integrating SSL/TLS based authentications, etc.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "4. What are the HTTP Methods?",
        "answer": "HTTP Methods are also known as HTTP Verbs. They form a major portion of uniform interface restriction followed by the REST that specifies what action has to be followed to get the requested resource. Below are some examples of HTTP Methods: GET: This is used for fetching details from the server and is basically a read-only operation.\nPOST: This method is used for the creation of new resources on the server.\nPUT: This method is used to update the old/existing resource on the server or to replace the resource.\nDELETE: This method is used to delete the resource on the server.\nPATCH: This is used for modifying the resource on the server.\nOPTIONS: This fetches the list of supported options of resources present on the server. GET: This is used for fetching details from the server and is basically a read-only operation. POST: This method is used for the creation of new resources on the server. PUT: This method is used to update the old/existing resource on the server or to replace the resource. DELETE: This method is used to delete the resource on the server. PATCH: This is used for modifying the resource on the server. OPTIONS: This fetches the list of supported options of resources present on the server. The POST, GET, PUT, DELETE corresponds to the create, read, update, delete operations which are most commonly called CRUD Operations. CRUD Operations   GET, HEAD, OPTIONS are safe and idempotent methods whereas PUT and DELETE methods are only idempotent. POST and PATCH methods are neither safe nor idempotent.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "5. What are HTTP Status codes?",
        "answer": "These are the standard codes that refer to the predefined status of the task at the server. Following are the status codes formats available: 1xx - represents informational responses\n2xx - represents successful responses\n3xx - represents redirects\n4xx - represents client errors\n5xx - represents server errors 1xx - represents informational responses 2xx - represents successful responses 3xx - represents redirects 4xx - represents client errors 5xx - represents server errors Most commonly used status codes are: 200 - success/OK\n201 - CREATED - used in POST or PUT methods.\n304 - NOT MODIFIED - used in conditional GET requests to reduce the bandwidth use of the network. Here, the body of the response sent should be empty.\n400 - BAD REQUEST - This can be due to validation errors or missing input data.\n401- UNAUTHORIZED - This is returned when there is no valid authentication credentials sent along with the request.\n403 - FORBIDDEN - sent when the user does not have access (or is forbidden) to the resource.\n404 - NOT FOUND - Resource method is not available.\n500 - INTERNAL SERVER ERROR - server threw some exceptions while running the method.\n502 - BAD GATEWAY - Server was not able to get the response from another upstream server. 200 - success/OK 201 - CREATED - used in POST or PUT methods. 304 - NOT MODIFIED - used in conditional GET requests to reduce the bandwidth use of the network. Here, the body of the response sent should be empty. 400 - BAD REQUEST - This can be due to validation errors or missing input data. 401- UNAUTHORIZED - This is returned when there is no valid authentication credentials sent along with the request. 403 - FORBIDDEN - sent when the user does not have access (or is forbidden) to the resource. 404 - NOT FOUND - Resource method is not available. 500 - INTERNAL SERVER ERROR - server threw some exceptions while running the method. 502 - BAD GATEWAY - Server was not able to get the response from another upstream server.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "6. What do you understand by JAX-RS?",
        "answer": "As the name itself stands (JAX-RS= Java API for RESTful Web Services) is a Java-based specification defined by JEE for the implementation of RESTful services. The JAX-RS library makes usage of annotations from Java 5 onwards to simplify the process of web services development. The latest version is 3.0 which was released in June 2020. This specification also provides necessary support to create REST clients.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "7. What is the concept of statelessness in REST?",
        "answer": "The REST architecture is designed in such a way that the client state is not maintained on the server. This is known as statelessness. The context is provided by the client to the server using which the server processes the client’s request. The session on the server is identified by the session identifier sent by the client.  ",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "8. What are the features of RESTful Web Services?",
        "answer": "Every RESTful web service has the following features: The service is based on the Client-Server model.\nThe service uses HTTP Protocol for fetching data/resources, query execution, or any other functions.\nThe medium of communication between the client and server is called “Messaging”.\nResources are accessible to the service by means of URIs.\nIt follows the statelessness concept where the client request and response are not dependent on others and thereby provides total assurance of getting the required data.\nThese services also use the concept of caching to minimize the server calls for the same type of repeated requests.\nThese services can also use SOAP services as implementation protocol to REST architectural pattern. The service is based on the Client-Server model. The service uses HTTP Protocol for fetching data/resources, query execution, or any other functions. The medium of communication between the client and server is called “Messaging”. Resources are accessible to the service by means of URIs. It follows the statelessness concept where the client request and response are not dependent on others and thereby provides total assurance of getting the required data. These services also use the concept of caching to minimize the server calls for the same type of repeated requests. These services can also use SOAP services as implementation protocol to REST architectural pattern.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "9. What is URI?",
        "answer": "Uniform Resource Identifier is the full form of URI which is used for identifying each resource of the REST architecture. URI is of the format: Uniform Resource Identifier <protocol>://<service-name>/<ResourceType>/<ResourceID> <protocol>://<service-name>/<ResourceType>/<ResourceID> There are 2 types of URI:   URN: Uniform Resource Name identifies the resource by means of a name that is both unique and persistent.\nURN doesn’t always specify where to locate the resource on the internet. They are used as templates that are used by other parsers to identify the resource.\nThese follow the urn scheme and usually prefixed with urn:. Examples include\nurn:isbn:1234567890 is used for identification of book based on the ISBN number in a library application.\nurn:mpeg:mpeg7:schema:2001 is the default namespace rules for metadata of MPEG-7 video.\nWhenever a URN identifies a document, they are easily translated into a URL by using “resolver” after which the document can be downloaded.\nURL: Uniform Resource Locator has the information regarding fetching of a resource from its location.\nExamples include:\nhttp://abc.com/samplePage.html\nftp://sampleServer.com/sampleFile.zip\nfile:///home/interviewbit/sampleFile.txt\nURLs start with a protocol (like ftp, http etc) and they have the information of the network hostname (sampleServer.com) and the path to the document(/samplePage.html). It can also have query parameters. URN: Uniform Resource Name identifies the resource by means of a name that is both unique and persistent.\nURN doesn’t always specify where to locate the resource on the internet. They are used as templates that are used by other parsers to identify the resource.\nThese follow the urn scheme and usually prefixed with urn:. Examples include\nurn:isbn:1234567890 is used for identification of book based on the ISBN number in a library application.\nurn:mpeg:mpeg7:schema:2001 is the default namespace rules for metadata of MPEG-7 video.\nWhenever a URN identifies a document, they are easily translated into a URL by using “resolver” after which the document can be downloaded. URN: URN doesn’t always specify where to locate the resource on the internet. They are used as templates that are used by other parsers to identify the resource.\nThese follow the urn scheme and usually prefixed with urn:. Examples include\nurn:isbn:1234567890 is used for identification of book based on the ISBN number in a library application.\nurn:mpeg:mpeg7:schema:2001 is the default namespace rules for metadata of MPEG-7 video.\nWhenever a URN identifies a document, they are easily translated into a URL by using “resolver” after which the document can be downloaded. URN doesn’t always specify where to locate the resource on the internet. They are used as templates that are used by other parsers to identify the resource. These follow the urn scheme and usually prefixed with urn:. Examples include\nurn:isbn:1234567890 is used for identification of book based on the ISBN number in a library application.\nurn:mpeg:mpeg7:schema:2001 is the default namespace rules for metadata of MPEG-7 video. urn urn: urn:isbn:1234567890 is used for identification of book based on the ISBN number in a library application.\nurn:mpeg:mpeg7:schema:2001 is the default namespace rules for metadata of MPEG-7 video. urn:isbn:1234567890 is used for identification of book based on the ISBN number in a library application. urn:isbn:1234567890 urn:mpeg:mpeg7:schema:2001 is the default namespace rules for metadata of MPEG-7 video. urn:mpeg:mpeg7:schema:2001 Whenever a URN identifies a document, they are easily translated into a URL by using “resolver” after which the document can be downloaded. URL: Uniform Resource Locator has the information regarding fetching of a resource from its location.\nExamples include:\nhttp://abc.com/samplePage.html\nftp://sampleServer.com/sampleFile.zip\nfile:///home/interviewbit/sampleFile.txt\nURLs start with a protocol (like ftp, http etc) and they have the information of the network hostname (sampleServer.com) and the path to the document(/samplePage.html). It can also have query parameters. URL: Examples include:\nhttp://abc.com/samplePage.html\nftp://sampleServer.com/sampleFile.zip\nfile:///home/interviewbit/sampleFile.txt\nURLs start with a protocol (like ftp, http etc) and they have the information of the network hostname (sampleServer.com) and the path to the document(/samplePage.html). It can also have query parameters. Examples include:\nhttp://abc.com/samplePage.html\nftp://sampleServer.com/sampleFile.zip\nfile:///home/interviewbit/sampleFile.txt http://abc.com/samplePage.html\nftp://sampleServer.com/sampleFile.zip\nfile:///home/interviewbit/sampleFile.txt http://abc.com/samplePage.html http://abc.com/samplePage.html ftp://sampleServer.com/sampleFile.zip ftp://sampleServer.com/sampleFile.zip file:///home/interviewbit/sampleFile.txt file:///home/interviewbit/sampleFile.txt URLs start with a protocol (like ftp, http etc) and they have the information of the network hostname (sampleServer.com) and the path to the document(/samplePage.html). It can also have query parameters.  ",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "10. What is a REST Resource?",
        "answer": "Every content in the REST architecture is considered a resource. The resource is analogous to the object in the object-oriented programming world. They can either be represented as text files, HTML pages, images, or any other dynamic data. The REST Server provides access to these resources whereas the REST client consumes (accesses and modifies) these resources. Every resource is identified globally by means of a URI. The REST Server provides access to these resources whereas the REST client consumes (accesses and modifies) these resources. Every resource is identified globally by means of a URI.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "1. Differentiate between SOAP and REST?",
        "answer": "SOAP  REST\nSOAP - Simple Object Access Protocol  REST - Representational State Transfer\nSOAP is a protocol used to implement web services. REST is an architectural design pattern for developing web services\nSOAP cannot use REST as it is a protocol. REST architecture can have SOAP protocol as part of the implementation.\nSOAP specifies standards that are meant to be followed strictly. REST defines standards but they need not be strictly followed.\nSOAP client is more tightly coupled to the server which is similar to desktop applications having strict contracts. The REST client is more flexible like a browser and does not depend on how the server is developed unless it follows the protocols required for establishing communication.\nSOAP supports only XML transmission between the client and the server. REST supports data of multiple formats like XML, JSON, MIME, Text, etc.\nSOAP reads are not cacheable. REST read requests can be cached.\nSOAP uses service interfaces for exposing the resource logic. REST uses URI to expose the resource logic.\nSOAP is slower. REST is faster.\nSince SOAP is a protocol, it defines its own security measures. REST only inherits the security measures based on what protocol it uses for the implementation.\nSOAP is not commonly preferred, but they are used in cases which require stateful data transfer and more reliability. REST is commonly preferred by developers these days as it provides more scalability and maintainability. SOAP  REST\nSOAP - Simple Object Access Protocol  REST - Representational State Transfer\nSOAP is a protocol used to implement web services. REST is an architectural design pattern for developing web services\nSOAP cannot use REST as it is a protocol. REST architecture can have SOAP protocol as part of the implementation.\nSOAP specifies standards that are meant to be followed strictly. REST defines standards but they need not be strictly followed.\nSOAP client is more tightly coupled to the server which is similar to desktop applications having strict contracts. The REST client is more flexible like a browser and does not depend on how the server is developed unless it follows the protocols required for establishing communication.\nSOAP supports only XML transmission between the client and the server. REST supports data of multiple formats like XML, JSON, MIME, Text, etc.\nSOAP reads are not cacheable. REST read requests can be cached.\nSOAP uses service interfaces for exposing the resource logic. REST uses URI to expose the resource logic.\nSOAP is slower. REST is faster.\nSince SOAP is a protocol, it defines its own security measures. REST only inherits the security measures based on what protocol it uses for the implementation.\nSOAP is not commonly preferred, but they are used in cases which require stateful data transfer and more reliability. REST is commonly preferred by developers these days as it provides more scalability and maintainability. SOAP  REST SOAP  REST SOAP REST SOAP - Simple Object Access Protocol  REST - Representational State Transfer\nSOAP is a protocol used to implement web services. REST is an architectural design pattern for developing web services\nSOAP cannot use REST as it is a protocol. REST architecture can have SOAP protocol as part of the implementation.\nSOAP specifies standards that are meant to be followed strictly. REST defines standards but they need not be strictly followed.\nSOAP client is more tightly coupled to the server which is similar to desktop applications having strict contracts. The REST client is more flexible like a browser and does not depend on how the server is developed unless it follows the protocols required for establishing communication.\nSOAP supports only XML transmission between the client and the server. REST supports data of multiple formats like XML, JSON, MIME, Text, etc.\nSOAP reads are not cacheable. REST read requests can be cached.\nSOAP uses service interfaces for exposing the resource logic. REST uses URI to expose the resource logic.\nSOAP is slower. REST is faster.\nSince SOAP is a protocol, it defines its own security measures. REST only inherits the security measures based on what protocol it uses for the implementation.\nSOAP is not commonly preferred, but they are used in cases which require stateful data transfer and more reliability. REST is commonly preferred by developers these days as it provides more scalability and maintainability. SOAP - Simple Object Access Protocol  REST - Representational State Transfer SOAP - Simple Object Access Protocol REST - Representational State Transfer SOAP is a protocol used to implement web services. REST is an architectural design pattern for developing web services SOAP is a protocol used to implement web services. REST is an architectural design pattern for developing web services SOAP cannot use REST as it is a protocol. REST architecture can have SOAP protocol as part of the implementation. SOAP cannot use REST as it is a protocol. REST architecture can have SOAP protocol as part of the implementation. SOAP specifies standards that are meant to be followed strictly. REST defines standards but they need not be strictly followed. SOAP specifies standards that are meant to be followed strictly. REST defines standards but they need not be strictly followed. SOAP client is more tightly coupled to the server which is similar to desktop applications having strict contracts. The REST client is more flexible like a browser and does not depend on how the server is developed unless it follows the protocols required for establishing communication. SOAP client is more tightly coupled to the server which is similar to desktop applications having strict contracts. The REST client is more flexible like a browser and does not depend on how the server is developed unless it follows the protocols required for establishing communication. SOAP supports only XML transmission between the client and the server. REST supports data of multiple formats like XML, JSON, MIME, Text, etc. SOAP supports only XML transmission between the client and the server. REST supports data of multiple formats like XML, JSON, MIME, Text, etc. SOAP reads are not cacheable. REST read requests can be cached. SOAP reads are not cacheable. REST read requests can be cached. SOAP uses service interfaces for exposing the resource logic. REST uses URI to expose the resource logic. SOAP uses service interfaces for exposing the resource logic. REST uses URI to expose the resource logic. SOAP is slower. REST is faster. SOAP is slower. REST is faster. Since SOAP is a protocol, it defines its own security measures. REST only inherits the security measures based on what protocol it uses for the implementation. Since SOAP is a protocol, it defines its own security measures. REST only inherits the security measures based on what protocol it uses for the implementation. SOAP is not commonly preferred, but they are used in cases which require stateful data transfer and more reliability. REST is commonly preferred by developers these days as it provides more scalability and maintainability. SOAP is not commonly preferred, but they are used in cases which require stateful data transfer and more reliability. REST is commonly preferred by developers these days as it provides more scalability and maintainability.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "2. While creating URI for web services, what are the best practices that needs to be followed?",
        "answer": "Below is the list of best practices that need to be considered with designing URI for web services: While defining resources, use plural nouns. Example: To identify user resource, use the name “users” for that resource.\nWhile using the long name for resources, use underscore or hyphen. Avoid using spaces between words. For example, to define authorized users resource, the name can be “authorized_users” or “authorized-users”.\nThe URI is case-insensitive, but as part of best practice, it is recommended to use lower case only.\nWhile developing URI, the backward compatibility must be maintained once it gets published. When the URI is updated, the older URI must be redirected to the new one using the HTTP status code 300.\nUse appropriate HTTP methods like GET, PUT, DELETE, PATCH, etc. It is not needed or recommended to use these method names in the URI. Example: To get user details of a particular ID, use /users/{id} instead of /getUser\nUse the technique of forward slashing to indicate the hierarchy between the resources and the collections. Example: To get the address of the user of a particular id, we can use: /users/{id}/address While defining resources, use plural nouns. Example: To identify user resource, use the name “users” for that resource. While using the long name for resources, use underscore or hyphen. Avoid using spaces between words. For example, to define authorized users resource, the name can be “authorized_users” or “authorized-users”. The URI is case-insensitive, but as part of best practice, it is recommended to use lower case only. While developing URI, the backward compatibility must be maintained once it gets published. When the URI is updated, the older URI must be redirected to the new one using the HTTP status code 300. Use appropriate HTTP methods like GET, PUT, DELETE, PATCH, etc. It is not needed or recommended to use these method names in the URI. Example: To get user details of a particular ID, use /users/{id} instead of /getUser /users/{id} /getUser Use the technique of forward slashing to indicate the hierarchy between the resources and the collections. Example: To get the address of the user of a particular id, we can use: /users/{id}/address /users/{id}/address",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "3. What are the best practices to develop RESTful web services?",
        "answer": "RESTful web services use REST API as means of implementation using the HTTP protocol. REST API is nothing but an application programming interface that follows REST architectural constraints such as statelessness, cacheability, maintainability, and scalability. It has become very popular among the developer community due to its simplicity. Hence, it is very important to develop safe and secure REST APIs that follow good conventions. Below are some best practices for developing REST APIs: Since REST supports multiple data formats, it is however good practice to develop REST APIs that accept and responds with JSON data format whenever possible. This is because a majority of the client and server technologies have inbuilt support to read and parse JSON objects with ease, thereby making JSON the standard object notation.\nTo ensure that the application responds using JSON data format, the response header should have Content-Type set to as application/JSON, this is because certain HTTP clients look at the value of this response header to parse the objects appropriately.\nTo ensure that the request sends the data in JSON format, again the Content-Type must be set to application/JSON on the request header.\nWhile naming the resource endpoints, ensure to use plural nouns and not verbs. The API endpoints should be clear, brief, easy to understand, and informative. Using verbs in the resource name doesn’t contribute much information because an HTTP request already has what the request is doing in its HTTP method/verb. An appropriate HTTP verb should be used to represent the task of the API endpoint.\nBelow are the most commonly used HTTP methods to define the verb:\nGET - indicates get/retrieve the resource data\nPOST - indicates create new resource data\nPUT - indicates update the existing resource data\nDELETE - indicates remove the resource data\nTo represent the hierarchy of resources, use the nesting in the naming convention of the endpoints. In case, you want to retrieve data of one object residing in another object, the endpoint should reflect this to communicate what is happening. For example, to get the address of an author, we can use the GET method for the URI /authors/:id/address'\nPlease ensure there are no more than 2 or 3 levels of nesting as the name of the URI can become too long and unwieldy.\nError Handling should be done gracefully by returning appropriate error codes the application has encountered. REST has defined standard HTTP Status codes that can be sent along with the response based on the scenario.\nError codes should also be accompanied by appropriate error messages that can help the developers to take corrective actions. However, the message should not be too elaborate as well which can help the hacker to hack your application.\nCommon status codes are:\n400 - Bad Request – client-side error - failed input validation.\n401 - Unauthorized – The user is not authenticated and hence does not have authority to access the resource.\n403 - Forbidden – User is authenticated but is not authorized to access the resource.\n404 - Not Found – The resource is not found.\n500 - Internal server error – This is a very generic server-side error that is thrown when the server goes down. This shouldn’t be returned by the programmer explicitly.\n502 - Bad Gateway – Server did not receive a valid response from the upstream server.\n503 - Service Unavailable – Some unexpected things happened on the server such as system failure, overload, etc.\nWhile retrieving huge resource data, it is advisable to include filtering and pagination of the resources. This is because returning huge data all at once can slow down the system and reduce the application performance. Hence, filter some items reduces the data to some extent. Pagination of data is done to ensure only some results are sent at a time. Doing this can increase the server performance and reduce the burden of the server resources.\nGood security practices are a must while developing REST APIs. The client-server communication must be private due to the nature of data sensitivity. Hence, incorporating SSL/TLS becomes the most important step while developing APIs as they facilitate establishing secure communication. SSL certificates are easier to get and load on the server.\nApart from the secure channels, we need to ensure that not everyone should be able to access the resource. For example, normal users should not access the data of admins or another user. Hence, role-based access controls should be in place to make sure only the right set of users can access the right set of data.\nSince REST supports the feature of caching, we can use this feature to cache the data in order to improve the application performance. Caching is done to avoid querying the database for a request repeated times. Caching makes data retrieval fast. However, care must be taken to ensure that the cache has updated data and not outdated ones. Frequent cache update measures need to be incorporated. There are many cache providers like Redis that can assist in caching.\nAPI Versioning: Versioning needs to be done in case we are planning to make any changes with the existing endpoints. We do not want to break communication between our application and the apps that consume our application while we are working on the API release. The transition has to be seamless. Semantic versioning can be followed. For example, 3.0.1 represents 3rd major version with the first patch. Usually, in the API endpoints, we define /v1,/v2, etc at the beginning of the API path. Since REST supports multiple data formats, it is however good practice to develop REST APIs that accept and responds with JSON data format whenever possible. This is because a majority of the client and server technologies have inbuilt support to read and parse JSON objects with ease, thereby making JSON the standard object notation.\nTo ensure that the application responds using JSON data format, the response header should have Content-Type set to as application/JSON, this is because certain HTTP clients look at the value of this response header to parse the objects appropriately.\nTo ensure that the request sends the data in JSON format, again the Content-Type must be set to application/JSON on the request header. To ensure that the application responds using JSON data format, the response header should have Content-Type set to as application/JSON, this is because certain HTTP clients look at the value of this response header to parse the objects appropriately.\nTo ensure that the request sends the data in JSON format, again the Content-Type must be set to application/JSON on the request header. To ensure that the application responds using JSON data format, the response header should have Content-Type set to as application/JSON, this is because certain HTTP clients look at the value of this response header to parse the objects appropriately. application/JSON To ensure that the request sends the data in JSON format, again the Content-Type must be set to application/JSON on the request header. application/JSON While naming the resource endpoints, ensure to use plural nouns and not verbs. The API endpoints should be clear, brief, easy to understand, and informative. Using verbs in the resource name doesn’t contribute much information because an HTTP request already has what the request is doing in its HTTP method/verb. An appropriate HTTP verb should be used to represent the task of the API endpoint.\nBelow are the most commonly used HTTP methods to define the verb:\nGET - indicates get/retrieve the resource data\nPOST - indicates create new resource data\nPUT - indicates update the existing resource data\nDELETE - indicates remove the resource data Below are the most commonly used HTTP methods to define the verb:\nGET - indicates get/retrieve the resource data\nPOST - indicates create new resource data\nPUT - indicates update the existing resource data\nDELETE - indicates remove the resource data Below are the most commonly used HTTP methods to define the verb:\nGET - indicates get/retrieve the resource data\nPOST - indicates create new resource data\nPUT - indicates update the existing resource data\nDELETE - indicates remove the resource data GET - indicates get/retrieve the resource data\nPOST - indicates create new resource data\nPUT - indicates update the existing resource data\nDELETE - indicates remove the resource data GET - indicates get/retrieve the resource data POST - indicates create new resource data PUT - indicates update the existing resource data DELETE - indicates remove the resource data To represent the hierarchy of resources, use the nesting in the naming convention of the endpoints. In case, you want to retrieve data of one object residing in another object, the endpoint should reflect this to communicate what is happening. For example, to get the address of an author, we can use the GET method for the URI /authors/:id/address'\nPlease ensure there are no more than 2 or 3 levels of nesting as the name of the URI can become too long and unwieldy. /authors/:id/address' Please ensure there are no more than 2 or 3 levels of nesting as the name of the URI can become too long and unwieldy. Please ensure there are no more than 2 or 3 levels of nesting as the name of the URI can become too long and unwieldy. Error Handling should be done gracefully by returning appropriate error codes the application has encountered. REST has defined standard HTTP Status codes that can be sent along with the response based on the scenario.\nError codes should also be accompanied by appropriate error messages that can help the developers to take corrective actions. However, the message should not be too elaborate as well which can help the hacker to hack your application.\nCommon status codes are:\n400 - Bad Request – client-side error - failed input validation.\n401 - Unauthorized – The user is not authenticated and hence does not have authority to access the resource.\n403 - Forbidden – User is authenticated but is not authorized to access the resource.\n404 - Not Found – The resource is not found.\n500 - Internal server error – This is a very generic server-side error that is thrown when the server goes down. This shouldn’t be returned by the programmer explicitly.\n502 - Bad Gateway – Server did not receive a valid response from the upstream server.\n503 - Service Unavailable – Some unexpected things happened on the server such as system failure, overload, etc. Error codes should also be accompanied by appropriate error messages that can help the developers to take corrective actions. However, the message should not be too elaborate as well which can help the hacker to hack your application.\nCommon status codes are:\n400 - Bad Request – client-side error - failed input validation.\n401 - Unauthorized – The user is not authenticated and hence does not have authority to access the resource.\n403 - Forbidden – User is authenticated but is not authorized to access the resource.\n404 - Not Found – The resource is not found.\n500 - Internal server error – This is a very generic server-side error that is thrown when the server goes down. This shouldn’t be returned by the programmer explicitly.\n502 - Bad Gateway – Server did not receive a valid response from the upstream server.\n503 - Service Unavailable – Some unexpected things happened on the server such as system failure, overload, etc. Error codes should also be accompanied by appropriate error messages that can help the developers to take corrective actions. However, the message should not be too elaborate as well which can help the hacker to hack your application. Common status codes are:\n400 - Bad Request – client-side error - failed input validation.\n401 - Unauthorized – The user is not authenticated and hence does not have authority to access the resource.\n403 - Forbidden – User is authenticated but is not authorized to access the resource.\n404 - Not Found – The resource is not found.\n500 - Internal server error – This is a very generic server-side error that is thrown when the server goes down. This shouldn’t be returned by the programmer explicitly.\n502 - Bad Gateway – Server did not receive a valid response from the upstream server.\n503 - Service Unavailable – Some unexpected things happened on the server such as system failure, overload, etc. 400 - Bad Request – client-side error - failed input validation.\n401 - Unauthorized – The user is not authenticated and hence does not have authority to access the resource.\n403 - Forbidden – User is authenticated but is not authorized to access the resource.\n404 - Not Found – The resource is not found.\n500 - Internal server error – This is a very generic server-side error that is thrown when the server goes down. This shouldn’t be returned by the programmer explicitly.\n502 - Bad Gateway – Server did not receive a valid response from the upstream server.\n503 - Service Unavailable – Some unexpected things happened on the server such as system failure, overload, etc. 400 - Bad Request – client-side error - failed input validation. 401 - Unauthorized – The user is not authenticated and hence does not have authority to access the resource. 403 - Forbidden – User is authenticated but is not authorized to access the resource. 404 - Not Found – The resource is not found. 500 - Internal server error – This is a very generic server-side error that is thrown when the server goes down. This shouldn’t be returned by the programmer explicitly. 502 - Bad Gateway – Server did not receive a valid response from the upstream server. 503 - Service Unavailable – Some unexpected things happened on the server such as system failure, overload, etc. While retrieving huge resource data, it is advisable to include filtering and pagination of the resources. This is because returning huge data all at once can slow down the system and reduce the application performance. Hence, filter some items reduces the data to some extent. Pagination of data is done to ensure only some results are sent at a time. Doing this can increase the server performance and reduce the burden of the server resources. Good security practices are a must while developing REST APIs. The client-server communication must be private due to the nature of data sensitivity. Hence, incorporating SSL/TLS becomes the most important step while developing APIs as they facilitate establishing secure communication. SSL certificates are easier to get and load on the server.\nApart from the secure channels, we need to ensure that not everyone should be able to access the resource. For example, normal users should not access the data of admins or another user. Hence, role-based access controls should be in place to make sure only the right set of users can access the right set of data. Apart from the secure channels, we need to ensure that not everyone should be able to access the resource. For example, normal users should not access the data of admins or another user. Hence, role-based access controls should be in place to make sure only the right set of users can access the right set of data. Apart from the secure channels, we need to ensure that not everyone should be able to access the resource. For example, normal users should not access the data of admins or another user. Hence, role-based access controls should be in place to make sure only the right set of users can access the right set of data. Since REST supports the feature of caching, we can use this feature to cache the data in order to improve the application performance. Caching is done to avoid querying the database for a request repeated times. Caching makes data retrieval fast. However, care must be taken to ensure that the cache has updated data and not outdated ones. Frequent cache update measures need to be incorporated. There are many cache providers like Redis that can assist in caching. API Versioning: Versioning needs to be done in case we are planning to make any changes with the existing endpoints. We do not want to break communication between our application and the apps that consume our application while we are working on the API release. The transition has to be seamless. Semantic versioning can be followed. For example, 3.0.1 represents 3rd major version with the first patch. Usually, in the API endpoints, we define /v1,/v2, etc at the beginning of the API path. /v1 /v2",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "4. What are Idempotent methods? How is it relevant in RESTful web services domain?",
        "answer": "The meaning of idempotent is that even after calling a single request multiple times, the outcome of the request should be the same. While designing REST APIs, we need to keep in mind to develop idempotent APIs. This is because the consumers can write client-side code which can result in duplicate requests intentionally or not. Hence, fault-tolerant APIs need to be designed so that they do not result in erroneous responses. Idempotent methods ensure that the responses to a request if called once or ten times or more than that remain the same. This is equivalent to adding any number with 0.\nREST provides idempotent methods automatically. GET, PUT, DELETE, HEAD, OPTIONS, and TRACE are the idempotent HTTP methods. POST is not idempotent.\nPOST is not idempotent because POST APIs are usually used for creating a new resource on the server. While calling POST methods N times, there will be N new resources. This does not result in the same outcome at a time.\nMethods like GET, OPTIONS, TRACE, and HEAD are idempotent because they do not change the state of resources on the server. They are meant for resource retrieval whenever called. They do not result in write operations on the server thereby making it idempotent.\nPUT methods are generally used for updating the state of resources. If you call PUT methods N times, the first request updates the resource and the subsequent requests will be overwriting the same resource again and again without changing anything. Hence, PUT methods are idempotent.\nDELETE methods are said to be idempotent because when calling them for N times, the first request results in successful deletion (Status Code 200), and the next subsequent requests result in nothing - Status Code 204. The response is different, but there is no change of resources on the server-side.\nHowever, if you are attempting to delete the resource present, at last, every time you hit the API, such as the request DELETE /user/last which deletes the last user record, then calling the request N times would delete N resources on the server. This does not make DELETE idempotent. In such cases, as part of good practices, it is advisable to use POST requests. Idempotent methods ensure that the responses to a request if called once or ten times or more than that remain the same. This is equivalent to adding any number with 0. REST provides idempotent methods automatically. GET, PUT, DELETE, HEAD, OPTIONS, and TRACE are the idempotent HTTP methods. POST is not idempotent.\nPOST is not idempotent because POST APIs are usually used for creating a new resource on the server. While calling POST methods N times, there will be N new resources. This does not result in the same outcome at a time.\nMethods like GET, OPTIONS, TRACE, and HEAD are idempotent because they do not change the state of resources on the server. They are meant for resource retrieval whenever called. They do not result in write operations on the server thereby making it idempotent.\nPUT methods are generally used for updating the state of resources. If you call PUT methods N times, the first request updates the resource and the subsequent requests will be overwriting the same resource again and again without changing anything. Hence, PUT methods are idempotent.\nDELETE methods are said to be idempotent because when calling them for N times, the first request results in successful deletion (Status Code 200), and the next subsequent requests result in nothing - Status Code 204. The response is different, but there is no change of resources on the server-side.\nHowever, if you are attempting to delete the resource present, at last, every time you hit the API, such as the request DELETE /user/last which deletes the last user record, then calling the request N times would delete N resources on the server. This does not make DELETE idempotent. In such cases, as part of good practices, it is advisable to use POST requests. POST is not idempotent because POST APIs are usually used for creating a new resource on the server. While calling POST methods N times, there will be N new resources. This does not result in the same outcome at a time.\nMethods like GET, OPTIONS, TRACE, and HEAD are idempotent because they do not change the state of resources on the server. They are meant for resource retrieval whenever called. They do not result in write operations on the server thereby making it idempotent.\nPUT methods are generally used for updating the state of resources. If you call PUT methods N times, the first request updates the resource and the subsequent requests will be overwriting the same resource again and again without changing anything. Hence, PUT methods are idempotent.\nDELETE methods are said to be idempotent because when calling them for N times, the first request results in successful deletion (Status Code 200), and the next subsequent requests result in nothing - Status Code 204. The response is different, but there is no change of resources on the server-side.\nHowever, if you are attempting to delete the resource present, at last, every time you hit the API, such as the request DELETE /user/last which deletes the last user record, then calling the request N times would delete N resources on the server. This does not make DELETE idempotent. In such cases, as part of good practices, it is advisable to use POST requests. POST is not idempotent because POST APIs are usually used for creating a new resource on the server. While calling POST methods N times, there will be N new resources. This does not result in the same outcome at a time. Methods like GET, OPTIONS, TRACE, and HEAD are idempotent because they do not change the state of resources on the server. They are meant for resource retrieval whenever called. They do not result in write operations on the server thereby making it idempotent. PUT methods are generally used for updating the state of resources. If you call PUT methods N times, the first request updates the resource and the subsequent requests will be overwriting the same resource again and again without changing anything. Hence, PUT methods are idempotent. DELETE methods are said to be idempotent because when calling them for N times, the first request results in successful deletion (Status Code 200), and the next subsequent requests result in nothing - Status Code 204. The response is different, but there is no change of resources on the server-side.\nHowever, if you are attempting to delete the resource present, at last, every time you hit the API, such as the request DELETE /user/last which deletes the last user record, then calling the request N times would delete N resources on the server. This does not make DELETE idempotent. In such cases, as part of good practices, it is advisable to use POST requests. However, if you are attempting to delete the resource present, at last, every time you hit the API, such as the request DELETE /user/last which deletes the last user record, then calling the request N times would delete N resources on the server. This does not make DELETE idempotent. In such cases, as part of good practices, it is advisable to use POST requests. However, if you are attempting to delete the resource present, at last, every time you hit the API, such as the request DELETE /user/last which deletes the last user record, then calling the request N times would delete N resources on the server. This does not make DELETE idempotent. In such cases, as part of good practices, it is advisable to use POST requests. DELETE /user/last",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "5. What are the differences between REST and AJAX?",
        "answer": "REST AJAX\nREST- Representational State Transfer  AJAX - Asynchronous javascript and XML\nREST has a URI for accessing resources by means of a request-response pattern. AJAX uses XMLHttpRequest object to send requests to the server and the response is interpreted by the Javascript code dynamically.\nREST is an architectural pattern for developing client-server communication systems. AJAX is used for dynamic updation of UI without the need to reload the page.\nREST requires the interaction between client and server. AJAX supports asynchronous requests thereby eliminating the necessity of constant client-server interaction. REST AJAX\nREST- Representational State Transfer  AJAX - Asynchronous javascript and XML\nREST has a URI for accessing resources by means of a request-response pattern. AJAX uses XMLHttpRequest object to send requests to the server and the response is interpreted by the Javascript code dynamically.\nREST is an architectural pattern for developing client-server communication systems. AJAX is used for dynamic updation of UI without the need to reload the page.\nREST requires the interaction between client and server. AJAX supports asynchronous requests thereby eliminating the necessity of constant client-server interaction. REST AJAX REST AJAX REST AJAX REST- Representational State Transfer  AJAX - Asynchronous javascript and XML\nREST has a URI for accessing resources by means of a request-response pattern. AJAX uses XMLHttpRequest object to send requests to the server and the response is interpreted by the Javascript code dynamically.\nREST is an architectural pattern for developing client-server communication systems. AJAX is used for dynamic updation of UI without the need to reload the page.\nREST requires the interaction between client and server. AJAX supports asynchronous requests thereby eliminating the necessity of constant client-server interaction. REST- Representational State Transfer  AJAX - Asynchronous javascript and XML REST- Representational State Transfer AJAX - Asynchronous javascript and XML REST has a URI for accessing resources by means of a request-response pattern. AJAX uses XMLHttpRequest object to send requests to the server and the response is interpreted by the Javascript code dynamically. REST has a URI for accessing resources by means of a request-response pattern. AJAX uses XMLHttpRequest object to send requests to the server and the response is interpreted by the Javascript code dynamically. REST is an architectural pattern for developing client-server communication systems. AJAX is used for dynamic updation of UI without the need to reload the page. REST is an architectural pattern for developing client-server communication systems. AJAX is used for dynamic updation of UI without the need to reload the page. REST requires the interaction between client and server. AJAX supports asynchronous requests thereby eliminating the necessity of constant client-server interaction. REST requires the interaction between client and server. AJAX supports asynchronous requests thereby eliminating the necessity of constant client-server interaction.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "6. Can you tell what constitutes the core components of HTTP Request?",
        "answer": "In REST, any HTTP Request has 5 main components, they are: Method/Verb − This part tells what methods the request operation represents. Methods like GET, PUT, POST, DELETE, etc are some examples.\nURI − This part is used for uniquely identifying the resources on the server.\nHTTP Version − This part indicates what version of HTTP protocol you are using. An example can be HTTP v1.1.\nRequest Header − This part has the details of the request metadata such as client type, the content format supported, message format, cache settings, etc.\nRequest Body − This part represents the actual message content to be sent to the server. Method/Verb − This part tells what methods the request operation represents. Methods like GET, PUT, POST, DELETE, etc are some examples. URI − This part is used for uniquely identifying the resources on the server. HTTP Version − This part indicates what version of HTTP protocol you are using. An example can be HTTP v1.1. Request Header − This part has the details of the request metadata such as client type, the content format supported, message format, cache settings, etc. Request Body − This part represents the actual message content to be sent to the server.  ",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "7. What constitutes the core components of HTTP Response?",
        "answer": "HTTP Response has 4 components: Response Status Code − This represents the server response status code for the requested resource. Example- 400 represents a client-side error, 200 represents a successful response.\nHTTP Version − Indicates the HTTP protocol version.\nResponse Header − This part has the metadata of the response message. Data can describe what is the content length, content type, response date, what is server type, etc.\nResponse Body − This part contains what is the actual resource/message returned from the server. Response Status Code − This represents the server response status code for the requested resource. Example- 400 represents a client-side error, 200 represents a successful response. HTTP Version − Indicates the HTTP protocol version. Response Header − This part has the metadata of the response message. Data can describe what is the content length, content type, response date, what is server type, etc. Response Body − This part contains what is the actual resource/message returned from the server.  ",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "8. Define Addressing in terms of RESTful Web Services.",
        "answer": "Addressing is the process of locating a single/multiple resources that are present on the server. This task is accomplished by making use of URI (Uniform Resource Identifier). The general format of URI is <protocol>://<application-name>/<type-of-resource>/<id-of-resource> <protocol>://<application-name>/<type-of-resource>/<id-of-resource>",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "9. What are the differences between PUT and POST in REST?",
        "answer": "PUT POST\nPUT methods are used to request the server to store the enclosed entity in request. In case, the request does not exist, then new resource has to be created. If the resource exists, then the resource should get updated. POST method is used to request the server to store the enclosed entity in the request as a new resource.\nThe URI should have a resource identifier. Example: PUT /users/{user-id} The POST URI should indicate the collection of the resource. Example: POST /users\nPUT methods are idempotent. POST methods are not idempotent.\nPUT is used when the client wants to modify a single resource that is part of the collection. If a part of the resource has to be updated, then PATCH needs to be used. POST methods are used to add a new resource to the collection.\nThe responses are not cached here despite the idempotency. Responses are not cacheable unless the response explicitly specifies Cache-Control fields in the header.\nIn general, PUT is used for UPDATE operations. POST is used for CREATE operations. PUT POST\nPUT methods are used to request the server to store the enclosed entity in request. In case, the request does not exist, then new resource has to be created. If the resource exists, then the resource should get updated. POST method is used to request the server to store the enclosed entity in the request as a new resource.\nThe URI should have a resource identifier. Example: PUT /users/{user-id} The POST URI should indicate the collection of the resource. Example: POST /users\nPUT methods are idempotent. POST methods are not idempotent.\nPUT is used when the client wants to modify a single resource that is part of the collection. If a part of the resource has to be updated, then PATCH needs to be used. POST methods are used to add a new resource to the collection.\nThe responses are not cached here despite the idempotency. Responses are not cacheable unless the response explicitly specifies Cache-Control fields in the header.\nIn general, PUT is used for UPDATE operations. POST is used for CREATE operations. PUT POST PUT POST PUT POST PUT methods are used to request the server to store the enclosed entity in request. In case, the request does not exist, then new resource has to be created. If the resource exists, then the resource should get updated. POST method is used to request the server to store the enclosed entity in the request as a new resource.\nThe URI should have a resource identifier. Example: PUT /users/{user-id} The POST URI should indicate the collection of the resource. Example: POST /users\nPUT methods are idempotent. POST methods are not idempotent.\nPUT is used when the client wants to modify a single resource that is part of the collection. If a part of the resource has to be updated, then PATCH needs to be used. POST methods are used to add a new resource to the collection.\nThe responses are not cached here despite the idempotency. Responses are not cacheable unless the response explicitly specifies Cache-Control fields in the header.\nIn general, PUT is used for UPDATE operations. POST is used for CREATE operations. PUT methods are used to request the server to store the enclosed entity in request. In case, the request does not exist, then new resource has to be created. If the resource exists, then the resource should get updated. POST method is used to request the server to store the enclosed entity in the request as a new resource. PUT methods are used to request the server to store the enclosed entity in request. In case, the request does not exist, then new resource has to be created. If the resource exists, then the resource should get updated. POST method is used to request the server to store the enclosed entity in the request as a new resource. The URI should have a resource identifier. Example: PUT /users/{user-id} The POST URI should indicate the collection of the resource. Example: POST /users The URI should have a resource identifier. Example: PUT /users/{user-id} PUT /users/{user-id} The POST URI should indicate the collection of the resource. Example: POST /users POST /users PUT methods are idempotent. POST methods are not idempotent. PUT methods are idempotent. POST methods are not idempotent. PUT is used when the client wants to modify a single resource that is part of the collection. If a part of the resource has to be updated, then PATCH needs to be used. POST methods are used to add a new resource to the collection. PUT is used when the client wants to modify a single resource that is part of the collection. If a part of the resource has to be updated, then PATCH needs to be used. POST methods are used to add a new resource to the collection. The responses are not cached here despite the idempotency. Responses are not cacheable unless the response explicitly specifies Cache-Control fields in the header. The responses are not cached here despite the idempotency. Responses are not cacheable unless the response explicitly specifies Cache-Control fields in the header. In general, PUT is used for UPDATE operations. POST is used for CREATE operations. In general, PUT is used for UPDATE operations. POST is used for CREATE operations.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "10. What makes REST services to be easily scalable?",
        "answer": "REST services follow the concept of statelessness which essentially means no storing of any data across the requests on the server. This makes it easier to scale horizontally because the servers need not communicate much with each other while serving requests.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "11. Based on what factors, you can decide which type of web services you need to use - SOAP or REST?",
        "answer": "REST services have gained popularity due to the nature of simplicity, scalability, faster speed, improved performance, and multiple data format support. But, SOAP has its own advantages too. Developers use SOAP where the services require advanced security and reliability. Following are the questions you need to ask to help you decide which service can be used: Do you want to expose resource data or business logic?\nSOAP is commonly used for exposing business logic and REST for exposing data.\nDoes the client require a formal strict contract?\nIf yes, SOAP provides strict contracts by using WSDL. Hence, SOAP is preferred here.\nDoes your service require support for multiple formats of data?\nIf yes, REST supports multiple data formats which is why it is preferred in this case.\nDoes your service require AJAX call support?\nIf yes, REST can be used as it provides the XMLHttpRequest.\nDoes your service require both synchronous and asynchronous requests?\nSOAP has support for both sync/async operations.\nREST only supports synchronous calls.\nDoes your service require statelessness?\nIf yes, REST is suitable. If no, SOAP is preferred.\nDoes your service require a high-security level?\nIf yes, SOAP is preferred. REST inherits the security property based on the underlying implementation of the protocol. Hence, it can’t be preferred at all times.\nDoes your service require support for transactions?\nIf yes, SOAP is preferred as it is good in providing advanced support for transaction management.\nWhat is the bandwidth/resource required?\nSOAP involves a lot of overhead while sending and receiving XML data, hence it consumes a lot of bandwidth.\nREST makes use of less bandwidth for data transmission.\nDo you want services that are easy to develop, test, and maintain frequently?\nREST is known for simplicity, hence it is preferred. Do you want to expose resource data or business logic?\nSOAP is commonly used for exposing business logic and REST for exposing data. SOAP is commonly used for exposing business logic and REST for exposing data. SOAP is commonly used for exposing business logic and REST for exposing data. Does the client require a formal strict contract?\nIf yes, SOAP provides strict contracts by using WSDL. Hence, SOAP is preferred here. If yes, SOAP provides strict contracts by using WSDL. Hence, SOAP is preferred here. If yes, SOAP provides strict contracts by using WSDL. Hence, SOAP is preferred here. Does your service require support for multiple formats of data?\nIf yes, REST supports multiple data formats which is why it is preferred in this case. If yes, REST supports multiple data formats which is why it is preferred in this case. If yes, REST supports multiple data formats which is why it is preferred in this case. Does your service require AJAX call support?\nIf yes, REST can be used as it provides the XMLHttpRequest. If yes, REST can be used as it provides the XMLHttpRequest. If yes, REST can be used as it provides the XMLHttpRequest. Does your service require both synchronous and asynchronous requests?\nSOAP has support for both sync/async operations.\nREST only supports synchronous calls. SOAP has support for both sync/async operations.\nREST only supports synchronous calls. SOAP has support for both sync/async operations. REST only supports synchronous calls. Does your service require statelessness?\nIf yes, REST is suitable. If no, SOAP is preferred. If yes, REST is suitable. If no, SOAP is preferred. If yes, REST is suitable. If no, SOAP is preferred. Does your service require a high-security level?\nIf yes, SOAP is preferred. REST inherits the security property based on the underlying implementation of the protocol. Hence, it can’t be preferred at all times. If yes, SOAP is preferred. REST inherits the security property based on the underlying implementation of the protocol. Hence, it can’t be preferred at all times. If yes, SOAP is preferred. REST inherits the security property based on the underlying implementation of the protocol. Hence, it can’t be preferred at all times. Does your service require support for transactions?\nIf yes, SOAP is preferred as it is good in providing advanced support for transaction management. If yes, SOAP is preferred as it is good in providing advanced support for transaction management. If yes, SOAP is preferred as it is good in providing advanced support for transaction management. What is the bandwidth/resource required?\nSOAP involves a lot of overhead while sending and receiving XML data, hence it consumes a lot of bandwidth.\nREST makes use of less bandwidth for data transmission. SOAP involves a lot of overhead while sending and receiving XML data, hence it consumes a lot of bandwidth.\nREST makes use of less bandwidth for data transmission. SOAP involves a lot of overhead while sending and receiving XML data, hence it consumes a lot of bandwidth. REST makes use of less bandwidth for data transmission. Do you want services that are easy to develop, test, and maintain frequently?\nREST is known for simplicity, hence it is preferred. REST is known for simplicity, hence it is preferred. REST is known for simplicity, hence it is preferred.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "12. We can develop webservices using web sockets as well as REST. What are the differences between these two?",
        "answer": "REST Web Socket\nREST follows stateless architecture, meaning it won’t store any session-based data. Web Socket APIs follow the stateful protocol as it necessitates session-based data storage.\nThe mode of communication is uni-directional. At a time, only the server or the client will communicate. The communication is bi-directional, communication can be done by both client or server at a time.\nREST is based on the Request-Response Model. Web Socket follows the full-duplex model.\nEvery request will have sections like header, title, body, URL, etc. Web sockets do not have any overhead and hence suited for real-time communication.\nFor every HTTP request, a new TCP connection is set up. There will be only one TCP connection and then the client and server can start communicating.\nREST web services support both vertical and horizontal scaling. Web socket-based services only support vertical scaling.\nREST depends on HTTP methods to get the response. Web Sockets depend on the IP address and port number of the system to get a response.\nCommunication is slower here. Message transmission happens very faster than REST API.\nMemory/Buffers are not needed to store data here. Memory is required to store data. REST Web Socket\nREST follows stateless architecture, meaning it won’t store any session-based data. Web Socket APIs follow the stateful protocol as it necessitates session-based data storage.\nThe mode of communication is uni-directional. At a time, only the server or the client will communicate. The communication is bi-directional, communication can be done by both client or server at a time.\nREST is based on the Request-Response Model. Web Socket follows the full-duplex model.\nEvery request will have sections like header, title, body, URL, etc. Web sockets do not have any overhead and hence suited for real-time communication.\nFor every HTTP request, a new TCP connection is set up. There will be only one TCP connection and then the client and server can start communicating.\nREST web services support both vertical and horizontal scaling. Web socket-based services only support vertical scaling.\nREST depends on HTTP methods to get the response. Web Sockets depend on the IP address and port number of the system to get a response.\nCommunication is slower here. Message transmission happens very faster than REST API.\nMemory/Buffers are not needed to store data here. Memory is required to store data. REST Web Socket REST Web Socket REST Web Socket REST follows stateless architecture, meaning it won’t store any session-based data. Web Socket APIs follow the stateful protocol as it necessitates session-based data storage.\nThe mode of communication is uni-directional. At a time, only the server or the client will communicate. The communication is bi-directional, communication can be done by both client or server at a time.\nREST is based on the Request-Response Model. Web Socket follows the full-duplex model.\nEvery request will have sections like header, title, body, URL, etc. Web sockets do not have any overhead and hence suited for real-time communication.\nFor every HTTP request, a new TCP connection is set up. There will be only one TCP connection and then the client and server can start communicating.\nREST web services support both vertical and horizontal scaling. Web socket-based services only support vertical scaling.\nREST depends on HTTP methods to get the response. Web Sockets depend on the IP address and port number of the system to get a response.\nCommunication is slower here. Message transmission happens very faster than REST API.\nMemory/Buffers are not needed to store data here. Memory is required to store data. REST follows stateless architecture, meaning it won’t store any session-based data. Web Socket APIs follow the stateful protocol as it necessitates session-based data storage. REST follows stateless architecture, meaning it won’t store any session-based data. Web Socket APIs follow the stateful protocol as it necessitates session-based data storage. The mode of communication is uni-directional. At a time, only the server or the client will communicate. The communication is bi-directional, communication can be done by both client or server at a time. The mode of communication is uni-directional. At a time, only the server or the client will communicate. The communication is bi-directional, communication can be done by both client or server at a time. REST is based on the Request-Response Model. Web Socket follows the full-duplex model. REST is based on the Request-Response Model. Web Socket follows the full-duplex model. Every request will have sections like header, title, body, URL, etc. Web sockets do not have any overhead and hence suited for real-time communication. Every request will have sections like header, title, body, URL, etc. Web sockets do not have any overhead and hence suited for real-time communication. For every HTTP request, a new TCP connection is set up. There will be only one TCP connection and then the client and server can start communicating. For every HTTP request, a new TCP connection is set up. There will be only one TCP connection and then the client and server can start communicating. REST web services support both vertical and horizontal scaling. Web socket-based services only support vertical scaling. REST web services support both vertical and horizontal scaling. Web socket-based services only support vertical scaling. REST depends on HTTP methods to get the response. Web Sockets depend on the IP address and port number of the system to get a response. REST depends on HTTP methods to get the response. Web Sockets depend on the IP address and port number of the system to get a response. Communication is slower here. Message transmission happens very faster than REST API. Communication is slower here. Message transmission happens very faster than REST API. Memory/Buffers are not needed to store data here. Memory is required to store data. Memory/Buffers are not needed to store data here. Memory is required to store data. The request flow difference between the REST and Web Socket is shown below:  ",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "13. Can we implement transport layer security (TLS) in REST?",
        "answer": "Yes, we can. TLS does the task of encrypting the communication between the REST client and the server and provides the means to authenticate the server to the client. It is used for secure communication as it is the successor of the Secure Socket Layer (SSL). HTTPS works well with both TLS and SSL thereby making it effective while implementing RESTful web services. One point to mention here is, the REST inherits the property of the protocol it implements. So security measures are dependent on the protocol REST implements.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "14. Should we make the resources thread safe explicitly if they are made to share across multiple clients?",
        "answer": "There is no need to explicitly making the resources thread-safe because, upon every request, new resource instances are created which makes them thread-safe by default.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "15. What is Payload in terms of RESTful web services?",
        "answer": "Payload refers to the data passes in the request body. It is not the same as the request parameters. The payload can be sent only in POST methods as part of the request body.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "16. Is it possible to send payload in the GET and DELETE methods?",
        "answer": "No, the payload is not the same as the request parameters. Hence, it is not possible to send payload data in these methods.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "17. How can you test RESTful Web Services?",
        "answer": "RESTful web services can be tested using various tools like Postman, Swagger, etc. Postman provides a lot of features like sending requests to endpoints and show the response which can be converted to JSON or XML and also provides features to inspect request parameters like headers, query parameters, and also the response headers. Swagger also provides similar features like Postman and it provides the facility of documentation of the endpoints too. We can also use tools like Jmeter for performance and load testing of APIs.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "18. What is the maximum payload size that can be sent in POST methods?",
        "answer": "Theoretically, there is no restriction on the size of the payload that can be sent. But one must remember that the greater the size of the payload, the larger would be the bandwidth consumption and time taken to process the request that can impact the server performance.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "19. How does HTTP Basic Authentication work?",
        "answer": "While implementing Basic Authentication as part of APIs, the user must provide the username and password which is then concatenated by the browser in the form of “username: password” and then perform base64 encoding on it. The encoded value is then sent as the value for the “Authorization” header on every HTTP request from the browser. Since the credentials are only encoded, it is advised to use this form when requests are sent over HTTPS as they are not secure and can be intercepted by anyone if secure protocols are not used.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "20. What is the difference between idempotent and safe HTTP methods?",
        "answer": "Safe methods are those that do not change any resources internally. These methods can be cached and can be retrieved without any effects on the resource.\nIdempotent methods are those methods that do not change the responses to the resources externally. They can be called multiple times without any change in the responses. Safe methods are those that do not change any resources internally. These methods can be cached and can be retrieved without any effects on the resource. Idempotent methods are those methods that do not change the responses to the resources externally. They can be called multiple times without any change in the responses. According to restcookbook.com, the following is the table that describes what methods are idempotent and what is safe. restcookbook.com HTTP Methods Idempotent  Safe\nOPTIONS yes yes\nGET yes yes\nHEAD yes yes\nPUT yes no\nPOST no no\nDELETE yes no\nPATCH no no HTTP Methods Idempotent  Safe\nOPTIONS yes yes\nGET yes yes\nHEAD yes yes\nPUT yes no\nPOST no no\nDELETE yes no\nPATCH no no HTTP Methods Idempotent  Safe HTTP Methods Idempotent  Safe HTTP Methods Idempotent Safe OPTIONS yes yes\nGET yes yes\nHEAD yes yes\nPUT yes no\nPOST no no\nDELETE yes no\nPATCH no no OPTIONS yes yes OPTIONS yes yes GET yes yes GET yes yes HEAD yes yes HEAD yes yes PUT yes no PUT yes no POST no no POST no no DELETE yes no DELETE yes no PATCH no no PATCH no no",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "1. How can the JAX-RS applications be configured?",
        "answer": "JAX-RS applications have the root resource classes packaged in a war file. There are 2 means of configuring JAX-RS applications. Use @ApplicationPath annotation in a subclass of javax.ws.rs.core.Application that is packaged in the WAR file.\nUse the <servlet-mapping> tag inside the web.xml of the WAR. web.xml is the deployment descriptor of the application where the mappings to the servlets can be defined. Use @ApplicationPath annotation in a subclass of javax.ws.rs.core.Application that is packaged in the WAR file. javax.ws.rs.core.Application Use the <servlet-mapping> tag inside the web.xml of the WAR. web.xml is the deployment descriptor of the application where the mappings to the servlets can be defined.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "2. What do you understand by request method designator annotations?",
        "answer": "They are the runtime annotations in the JAX-RS library that are applied to Java methods. They correspond to the HTTP request methods that the clients want to make. They are @GET, @POST, @PUT, @DELETE, @HEAD. Usage Example: import javax.ws.rs.Path;\n/**\n* InterviewBitService is a root resource class that is exposed at 'resource_service' path\n*/\n@Path('resource_service')\npublic class InterviewBitService {\n    @GET\n    public String getRESTQuestions() {\n        // some operations\n    } \n} import javax.ws.rs.Path;\n/**\n* InterviewBitService is a root resource class that is exposed at 'resource_service' path\n*/\n@Path('resource_service')\npublic class InterviewBitService {\n    @GET\n    public String getRESTQuestions() {\n        // some operations\n    } \n} import /**\n* InterviewBitService is a root resource class that is exposed at 'resource_service' path\n*/ @Path('resource_service') public class InterviewBitService class InterviewBitService @GET public String getRESTQuestions() public getRESTQuestions () // some operations",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "3. Is it possible to make asynchronous requests in JAX-RS?",
        "answer": "Yes. the JAX-RS Client API provides a method called Invocation.Builder.async() that is used for constructing client requests that need to be executed asynchronously. Invoking a request asynchronously does the task of returning the control to the caller by returning with datatype java.util.concurrent.Future whose type is set to return the service call type. Future objects are used because they have the required methods to check whether the asynchronous calls have been completed and if yes, then retrieve the responses. They also provide the flexibility to cancel the request invocations and also check if the cancellation has been successful. Invocation.Builder.async() java.util.concurrent.Future Let us understand this with the help of a random example. We know that the Future interface from the java.util.concurrent has the below functions available: Future java.util.concurrent package java.util.concurrent;\npublic interface Future<V> {\n   // informs the executor to stop the thread execution\n   boolean cancel(boolean mayInterruptIfRunning);\n   \n   // indicates whether the Future was cancelled or not\n   boolean isCancelled();\n   \n   // indicates if the executor has completed the task\n   boolean isDone();\n   \n   // gets the actual result from the process. \n   // This blocks the program execution until the result is ready.\n   V get() throws InterruptedException, ExecutionException;\n   \n   // also gets actual result from the process but it throws \n   // the TimeoutException in case the result is not obtained before specified timeout\n   V get(long timeout, TimeUnit unit)\n       throws InterruptedException, ExecutionException, TimeoutException;\n} package java.util.concurrent;\npublic interface Future<V> {\n   // informs the executor to stop the thread execution\n   boolean cancel(boolean mayInterruptIfRunning);\n   \n   // indicates whether the Future was cancelled or not\n   boolean isCancelled();\n   \n   // indicates if the executor has completed the task\n   boolean isDone();\n   \n   // gets the actual result from the process. \n   // This blocks the program execution until the result is ready.\n   V get() throws InterruptedException, ExecutionException;\n   \n   // also gets actual result from the process but it throws \n   // the TimeoutException in case the result is not obtained before specified timeout\n   V get(long timeout, TimeUnit unit)\n       throws InterruptedException, ExecutionException, TimeoutException;\n} package public interface Future<V> interface Future V // informs the executor to stop the thread execution boolean cancel(boolean mayInterruptIfRunning) boolean cancel (boolean mayInterruptIfRunning) boolean // indicates whether the Future was cancelled or not boolean isCancelled() boolean isCancelled () // indicates if the executor has completed the task boolean isDone() boolean isDone () // gets the actual result from the process. // This blocks the program execution until the result is ready. V get() throws InterruptedException, ExecutionException get () throws // also gets actual result from the process but it throws // the TimeoutException in case the result is not obtained before specified timeout V get(long timeout, TimeUnit unit)\n       throws InterruptedException, ExecutionException, TimeoutException get (long timeout, TimeUnit unit) long throws Let us consider we have this function below which is used for processing 2 Ids parallelly. public void processIds(String userId1, String questionId){\n   Client client = ClientBuilder.newClient();\n   Future<Response> futureResponse1 = client.target(\"http://interviewbitserver.com/users/\"+userId).request().async().get();\n   Future<Order> futureResponse2 = client.target(\"http://interviewbitserver.com/questions/\"+questionId).request().async().get(Question.class);\n   \n   // block the process until complete\n   Response response1 = futureResponse1.get();\n   User userObject = response1.readEntity(User.class);\n   //Do processing of userObject\n   \n   // Wait for 2 seconds before fetching record\n   try {\n      Question question = futureResponse2.get(2, TimeUnit.SECONDS);\n      //Do Processing of question\n   } catch (TimeoutException timeoutException ) {\n       //handle exceptions\n   }\n   return;\n} public void processIds(String userId1, String questionId){\n   Client client = ClientBuilder.newClient();\n   Future<Response> futureResponse1 = client.target(\"http://interviewbitserver.com/users/\"+userId).request().async().get();\n   Future<Order> futureResponse2 = client.target(\"http://interviewbitserver.com/questions/\"+questionId).request().async().get(Question.class);\n   \n   // block the process until complete\n   Response response1 = futureResponse1.get();\n   User userObject = response1.readEntity(User.class);\n   //Do processing of userObject\n   \n   // Wait for 2 seconds before fetching record\n   try {\n      Question question = futureResponse2.get(2, TimeUnit.SECONDS);\n      //Do Processing of question\n   } catch (TimeoutException timeoutException ) {\n       //handle exceptions\n   }\n   return;\n} public void processIds(String userId1, String questionId) public void processIds (String userId1, String questionId) \"http://interviewbitserver.com/users/\" \"http://interviewbitserver.com/questions/\" // block the process until complete //Do processing of userObject // Wait for 2 seconds before fetching record try 2 //Do Processing of question catch //handle exceptions return In the above example, we see that there are 2 separate requests getting executed parallelly. For the first future object, we await the javax.ws.rs.core.Response indefinitely using the get() method until we get the response. For the second future object, we wait for the response only for 2 seconds and if we do not get within 2 seconds, then the get() method throws TimeoutException. We can also use the isDone() method or isCancelled() method to find out whether the executors have completed or cancelled. javax.ws.rs.core.Response",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "4. List the key annotations that are present in the JAX-RS API?",
        "answer": "@Path - This specifies the relative URI path to the REST resource.\n@GET - This is a request method designator which is corresponding to the HTTP GET requests. They process GET requests.\n@POST - This is a request method designator which is corresponding to the HTTP POST requests. They process POST requests.\n@PUT - This is a request method designator which is corresponding to the HTTP PUT requests. They process PUT requests.\n@DELETE - This is a request method designator which is corresponding to the HTTP DELETE requests. They process DELETE requests.\n@HEAD - This is a request method designator which is corresponding to the HTTP HEAD requests. They process HEAD requests.\n@PathParam - This is the URI path parameter that helps developers to extract the parameters from the URI and use them in the resource class/methods.\n@QueryParam - This is the URI query parameter that helps developers extract the query parameters from the URI and use them in the resource class/methods.\n@Produces - This specifies what MIME media types of the resource representations are produced and sent to the client as a response.\n@Consumes - This specifies which MIME media types of the resource representations are accepted or consumed by the server from the client. @Path - This specifies the relative URI path to the REST resource. @GET - This is a request method designator which is corresponding to the HTTP GET requests. They process GET requests. @POST - This is a request method designator which is corresponding to the HTTP POST requests. They process POST requests. @PUT - This is a request method designator which is corresponding to the HTTP PUT requests. They process PUT requests. @DELETE - This is a request method designator which is corresponding to the HTTP DELETE requests. They process DELETE requests. @HEAD - This is a request method designator which is corresponding to the HTTP HEAD requests. They process HEAD requests. @PathParam - This is the URI path parameter that helps developers to extract the parameters from the URI and use them in the resource class/methods. @QueryParam - This is the URI query parameter that helps developers extract the query parameters from the URI and use them in the resource class/methods. @Produces - This specifies what MIME media types of the resource representations are produced and sent to the client as a response. @Consumes - This specifies which MIME media types of the resource representations are accepted or consumed by the server from the client.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "5. Define RESTful Root Resource Classes in the JAX-RS API?",
        "answer": "A resource class is nothing but a Java class that uses JAX-RS provided annotations for implementing web resources.\nThey are the POJOs that are annotated either with @Path or have at least one method annotated with @Path, @GET, @POST, @DELETE, @PUT, etc. A resource class is nothing but a Java class that uses JAX-RS provided annotations for implementing web resources. They are the POJOs that are annotated either with @Path or have at least one method annotated with @Path, @GET, @POST, @DELETE, @PUT, etc. Example: import javax.ws.rs.Path;\n/**\n* InterviewBitService is a root resource class that is exposed at 'resource_service' path\n*/\n@Path('resource_service')\npublic class InterviewBitService {\n   // Defined methods\n} import javax.ws.rs.Path;\n/**\n* InterviewBitService is a root resource class that is exposed at 'resource_service' path\n*/\n@Path('resource_service')\npublic class InterviewBitService {\n   // Defined methods\n} import /**\n* InterviewBitService is a root resource class that is exposed at 'resource_service' path\n*/ @Path('resource_service') public class InterviewBitService class InterviewBitService // Defined methods",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "6. What are the key features provided by JAX-RS API in Java EE?",
        "answer": "JAX-RS stands for Java API for RESTful Web services. They are nothing but a set of Java-based APIs that are provided in the Java EE which is useful in the implementation and development of RESTful web services. Features of JAX-RS are: POJO-based: The APIs in the JAX-RS is based on a certain set of annotations, classes, and interfaces that are used with POJO (Plain Old Java Object) to expose the services as web services.\nHTTP-based: The JAX-RS APIs are designed using HTTP as their base protocol. They support the HTTP usage patterns and they provide the corresponding mapping between the HTTP actions and the API classes.\nFormat Independent: They can be used to work with a wide range of data types that are supported by the HTTP body content.\nContainer Independent: The APIs can be deployed in the Java EE container or a servlet container such as Tomcat or they can also be plugged into JAX-WS (Java API for XML-based web services) providers. POJO-based: The APIs in the JAX-RS is based on a certain set of annotations, classes, and interfaces that are used with POJO (Plain Old Java Object) to expose the services as web services. POJO-based HTTP-based: The JAX-RS APIs are designed using HTTP as their base protocol. They support the HTTP usage patterns and they provide the corresponding mapping between the HTTP actions and the API classes. HTTP-based: Format Independent: They can be used to work with a wide range of data types that are supported by the HTTP body content. Format Independent Container Independent: The APIs can be deployed in the Java EE container or a servlet container such as Tomcat or they can also be plugged into JAX-WS (Java API for XML-based web services) providers. Container Independent",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "1. Define RestTemplate in Spring.",
        "answer": "The RestTemplate is the main class meant for the client-side access for Spring-based RESTful services. The communication to the server is accomplished using the REST constraints. This is similar to other template classes such as JdbcTemplate, HibernateTemplate, etc provided by Spring. The RestTemplate provides high-level implementation details for the HTTP Methods like GET, POST, PUT, etc, and gives the methods to communicate using the URI template, URI path params, request/response types, request object, etc as part of arguments. Commonly used annotations like @GetMapping, @PostMapping, @PutMapping, etc are provided by this class from Spring 4.3. Prior to that, Spring provided (and still provides) @RequestMapping annotation to indicate what methods were being used. Commonly used annotations like @GetMapping, @PostMapping, @PutMapping, etc are provided by this class from Spring 4.3. Prior to that, Spring provided (and still provides) @RequestMapping annotation to indicate what methods were being used. @GetMapping @PostMapping @PutMapping @RequestMapping",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "2. What is the use of @RequestMapping?",
        "answer": "The annotation is used for mapping requests to specific handler classes or methods.\nIn spring, all the incoming web request routing is handled by Dispatcher Servlet. When it gets the request, it determines which controller is meant for processing the request by means of request handlers. The Dispatcher Servlet scans all the classes annotated with @Controller. The process of routing requests depends on @RequestMapping annotations that are declared inside the controller classes and their methods. The annotation is used for mapping requests to specific handler classes or methods. In spring, all the incoming web request routing is handled by Dispatcher Servlet. When it gets the request, it determines which controller is meant for processing the request by means of request handlers. The Dispatcher Servlet scans all the classes annotated with @Controller. The process of routing requests depends on @RequestMapping annotations that are declared inside the controller classes and their methods.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "3. What are the differences between the annotations @Controller and @RestController?",
        "answer": "@Controller  @RestController\nMostly used traditional Spring MVC service.  Represents RESTful web service in Spring.\nIt is mostly used in Spring MVC service where model data needs to rendered using view. It is used in case of RESTful web service that returns object values bound to response body.\nIf response values need to be converted through HttpMessageConverters and sent via response object, extra annotation @ResponseBody needs to be used on the class or the method handlers. The default behavior of the @RestController needs to be written on the response body because it is the combination of @Controller and @ResponseBody.\n@Controller provides control and flexibility over how the response needs to be sent. @RestController annotation has no such flexibility and writes all the results to the response body. @Controller  @RestController\nMostly used traditional Spring MVC service.  Represents RESTful web service in Spring.\nIt is mostly used in Spring MVC service where model data needs to rendered using view. It is used in case of RESTful web service that returns object values bound to response body.\nIf response values need to be converted through HttpMessageConverters and sent via response object, extra annotation @ResponseBody needs to be used on the class or the method handlers. The default behavior of the @RestController needs to be written on the response body because it is the combination of @Controller and @ResponseBody.\n@Controller provides control and flexibility over how the response needs to be sent. @RestController annotation has no such flexibility and writes all the results to the response body. @Controller  @RestController @Controller  @RestController @Controller @RestController Mostly used traditional Spring MVC service.  Represents RESTful web service in Spring.\nIt is mostly used in Spring MVC service where model data needs to rendered using view. It is used in case of RESTful web service that returns object values bound to response body.\nIf response values need to be converted through HttpMessageConverters and sent via response object, extra annotation @ResponseBody needs to be used on the class or the method handlers. The default behavior of the @RestController needs to be written on the response body because it is the combination of @Controller and @ResponseBody.\n@Controller provides control and flexibility over how the response needs to be sent. @RestController annotation has no such flexibility and writes all the results to the response body. Mostly used traditional Spring MVC service.  Represents RESTful web service in Spring. Mostly used traditional Spring MVC service. Represents RESTful web service in Spring. It is mostly used in Spring MVC service where model data needs to rendered using view. It is used in case of RESTful web service that returns object values bound to response body. It is mostly used in Spring MVC service where model data needs to rendered using view. It is used in case of RESTful web service that returns object values bound to response body. If response values need to be converted through HttpMessageConverters and sent via response object, extra annotation @ResponseBody needs to be used on the class or the method handlers. The default behavior of the @RestController needs to be written on the response body because it is the combination of @Controller and @ResponseBody. If response values need to be converted through HttpMessageConverters and sent via response object, extra annotation @ResponseBody needs to be used on the class or the method handlers. The default behavior of the @RestController needs to be written on the response body because it is the combination of @Controller and @ResponseBody. @Controller provides control and flexibility over how the response needs to be sent. @RestController annotation has no such flexibility and writes all the results to the response body. @Controller provides control and flexibility over how the response needs to be sent. @RestController annotation has no such flexibility and writes all the results to the response body.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "4. What does the annotation @PathVariable do?",
        "answer": "@PathVariable annotation is used for passing the parameter with the URL that is required to get the data. Spring MVC provides support for URL customization for data retrieval using @PathVariable annotation.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "5. Is it necessary to keep Spring MVC in the classpath for developing RESTful web services?",
        "answer": "Yes. Spring MVC needs to be on the classpath of the application while developing RESTful web services using Spring. This is because, the Spring MVC provides the necessary annotations like @RestController, @RequestBody, @PathVariable, etc. Hence the spring-mvc.jar needs to be on the classpath or the corresponding Maven entry in the pom.xml. Spring MVC Spring MVC",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "6. Define HttpMessageConverter in terms of Spring REST?",
        "answer": "HttpMessageConverter is a strategic interface that specified a converter for conversion between HTTP Requests and responses. Spring REST uses the HttpMessageConverter for converting responses to various data formats like JSON, XML, etc. Spring makes use of the “Accept” header for determining the type of content the client expects. Based on this, Spring would find the registered message converter interface that is capable of this conversion.",
        "reference": "interviewbit.com",
        "role": "rest-api"
    },
    {
        "question": "1. Conclusion",
        "answer": "We have seen what are the most commonly asked questions on RESTful web services during an interview. REST APIs have become a very important tool in the software industry. Developing RESTful web services that are scalable and easily maintainable is considered an art. As the industry trends increase, the REST architecture would become more concrete and the demand for developers who know the development of RESTful web services would increase steadily. References: References: To learn more about REST, you can refer to the below 2 links:\nhttps://restcookbook.com/\nhttps://www.restapitutorial.com/  https://restcookbook.com/  https://www.restapitutorial.com/",
        "reference": "interviewbit.com",
        "role": "rest-api"
    }
]