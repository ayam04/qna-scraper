[
    {
        "question": "1. What is Selenium testing?",
        "answer": "Selenium testing is a tool used for automating web applications to verify their functionality. It deals with browsers, clicks buttons, fills forms, and checks if the site works correctly.\nEnroll today in our Selenium Course to know more about Selenium!",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "2. Is Selenium 2.0 different from Selenium 3.0? If so, how?",
        "answer": "Selenium 3.0 represents an enhanced iteration of Selenium 2.0, introducing numerous enhancements and novel functionalities. A significant distinction lies in the inclusion of the WebDriver API as an integral part of Selenium 3.0, eliminating the need for separate downloads and installations as required in Selenium 2.0.\nMoreover, Selenium 3.0 exhibits various notable modifications, encompassing enhanced browser compatibility, improved management of browser plugins and extensions, and fortified security features. Furthermore, this version of Selenium demonstrates heightened compatibility with contemporary web browser editions and operating systems.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "3. Mention some of the popular tools used for Automation testing.",
        "answer": "There are several popular tools used for automation testing, including;\nSelenium\nAppium\nTestComplete\nKatalon Studio\nRanorex\nHP Unified Functional Testing (UFT)\nApache JMeter, and many more. \nThese tools help automate the testing process, improve efficiency, and reduce the risk of human error.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "4. What is a Locator? How can you find elements in Selenium?",
        "answer": "Selenium uses locators to find and match the elements of a web page that it needs to interact with. There are different types of Selenium locators to identify various web elements on a web page:\n\nID\nName\nClass\nPartial Link\nXPath\nCSS Selector\nLink Text",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "5. What are the test types supported by Selenium?",
        "answer": "For testing web-based applications, Selenium can be used.\nThe test types supported by Selenium are:\nFunctional testing: It verifies if each function of a software application performs in accordance with specific requirements. This testing primarily involves black-box testing, and it is not concerned with the source code of the application.\n\nRegression testing: It is nothing but a full or partial selection of the already executed test cases to be re-executed to ensure whether the existing functionalities work fine.\n\n\nGet 100% Hike!\nMaster Most in Demand Skills Now !\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "6. What is XPath?",
        "answer": "While DOM is the recognized standard way for navigating through an HTML element tree, XPath is the navigation tool used to locate a web element based on its XML path.\nXML stands for ‘Extensible Markup Language’ and is used to store, organize, and transport arbitrary data. It stores data in a key-value pair that is very much similar to HTML tags. Both being markup languages and falling under the same umbrella, XPath can be used to locate HTML elements.\nThe fundamental concept behind locating elements using XPath is traversing between various elements across the entire page and thus enabling a user to find an element with the reference of another element.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "7. Explain the difference between single slash and double slash in XPath.",
        "answer": "Single slash (/): Single slash is used to create an XPath with an absolute path. In this case, the XPath would start selection from the document’s start node.\nDouble slash (//): Double slash is used to create an XPath with a relative path. In this case, the XPath would start selection from anywhere within the document.\nAlso, check out the blog on Manual testing vs. Automation testing.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "8. Why should you use Selenium for test automation?",
        "answer": "Selenium should be used for test automation as it:\nIs a free and open-source tool\nHas a large user base and community support\nHas cross-browser compatibility (Firefox, Chrome, Internet Explorer, Safari, etc.)\nHas great platform compatibility (Windows, Mac OS, Linux, etc.)\nSupports multiple programming languages (Java, C#, Ruby, Python, Perl, etc.)\nHas fresh and regular repository developments\nSupports distributed testing",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "9. Does Selenium have any technical limitations? If so, what are those limitations?",
        "answer": "Yes, Selenium has a few limitations:\nTesting of only web applications is possible using Selenium.\nTesting of mobile applications or desktop applications is not possible.\nCaptcha and barcode readers cannot be tested using Selenium.\nA third-party tool like TestNG or JUnit should be used to generate reports.\nAs Selenium is a free tool, there is no ready vendor support through which users can find various helping communities.\nPrior programming language knowledge is expected from users.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "10. What is an object repository?",
        "answer": "An object repository allows testers to accumulate web elements of the application under test (AUT), along with their locator values, in one or more centralized locations as restricted to hard-coding them within the test scripts.\n\nWatch this video on Selenium Automation Testing Interview Questions and Answers:",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "11. What is Selenium?",
        "answer": "Selenium is a popular open-source software that is used to automate web-based applications. It is a set of multiple software tools, and each tool has a different approach to automated testing.\nSelenium has four major components, namely:\nSelenium Integrated Development Environment\nSelenium Remote Control\nSelenium WebDriver\nSelenium Grid",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "12. What is the difference between type keys and type commands?",
        "answer": "TypeKeys() will trigger JavaScript events, while type() won’t. TypesKeys collects different value attributes using JavaScript. Whereas, the type commands imitate an actual user typing.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "13. What are the advantages of Selenium?",
        "answer": "Selenium is a purely open-source and portable automation testing tool.\nIt supports different languages such as C#, PHP, Java, Perl, Python, JS, and Groovy.\nIt also supports different OS, including Windows, Linux, UNIX, and Mac OS.\nIt provides powerful methods such as Xpath, DOM, and CSS to locate elements.\nSince it is an open-source tool, developers can customize the code. Also, the developer community is supported by Google.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "14. Define automation testing, and list down its advantages.",
        "answer": "Automation testing, also known as test automation, involves using tools to automate the testing process, writing and executing test cases without human intervention. It empowers us to develop scripts that can be executed repeatedly and generate comprehensive test reports for the application.\nIts advantages are given below:\nIt helps with the performance and functional testing of an application.\nIt makes the execution of repeated test cases easy.\nIt facilitates the concurrent execution of multiple test cases.\nIt boosts the accuracy and efficiency of the application by cutting down the chances of human error.\nIt efficiently executes tests across an extensive test matrix.\nIt saves time and money by reducing the burden of arbitrary tasks.\nIf you want to become a professional Selenium with Python expert. Learn and master this technology by enrolling in Intellipaat’s Selenium with Python Online Training.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "15. What are the significant changes/upgrades made to various Selenium versions?",
        "answer": "Selenium’s first version included only three sets of tools: Selenium IDE, Selenium RC, and Selenium Grid. There was no WebDriver included in the first version. Later, Selenium WebDriver was introduced and hence included in Selenium V2. However, as WebDriver got included, the use of Selenium RC was discouraged with time and has not been much in use since. Selenium 3 is in use. There are some newly added Selenium features such as the IDE and WebDriver. Selenium 4 is the latest released version.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "16. What is an exception test in Selenium?",
        "answer": "An exception test is a test that looks forward to an exception being thrown inside a test class. It anticipates the @Test annotation followed by the expected exception name. For example, @Test(expectedException = NoSuchElementException.class) is an exception test for missing elements in Selenium.\nNote: Keep in mind the syntax, where the exception is suffixed with .class.\nCrack your interviews with ease. Check out Automation Testing Interview Questions in our blog.\nSelenium Testing Interview Questions for Experienced (2 to 5 Years)",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "17. What is TestNG in Selenium?",
        "answer": "TestNG is a popular testing framework that is widely used in Selenium. It is used to manage and run test cases in a more efficient and organized manner. TestNG provides features like grouping, parallel testing, and reporting.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "18. What is POM (Page Object Model)? What are its advantages?",
        "answer": "The page object model is a design pattern used to create object repositories for the web UI elements. Every web page of an application has a corresponding page class that is responsible for locating the web elements and performing actions on them.\nIts advantages are as follows:\nIt provides support to separate operations and flows on the UI from verification, hence improving code readability.\nAs the object repository is independent of test cases, multiple tests can use the same object repository.\nIt increases the reusability of the code\n\nSelenium 2 Years Experience Interview Questions",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "19. What are the different types of annotations used in Selenium? Explain the JUnit annotation linked to Selenium.",
        "answer": "In Java, a special form of syntactic metadata can be added to the Java source code, which is known as ‘annotations’. Variables, parameters, packages, methods, and classes are annotated. Some of the JUnit annotations are:\nTest\nBefore\nAfter\nIgnore\nBeforeClass\nAfterClass\nRunWith\nJUnit annotations linked to Selenium are:\nJUnit AnnotationsJUnit Annotations\n@Test: The @Test annotation finds a method to be a test method. When used before a test method, it is mentioned as ‘@Test’; it informs the JUnit framework that the following method is a test method.\n@Before: @Before annotation serves the purpose of identifying the method that should be executed prior to running the test method. Its intended use is to establish and configure the test environment before conducting the actual test.\n@After: The “@After” annotation is utilized as a post-execution method following the execution of the test method. This annotation performs teardown operations, such as deleting temporary data, restoring default values, cleaning up the test environment, and other relevant tasks.\n@BeforeClass: The @BeforeClass method is used only once before the start of all tests. Basically, this is used to perform cumbersome activities, like connecting to a database.\n@AfterClass: The @AfterClass method is used only once after executing all tests. This is used to carry out clean-up activities, like disconnecting from a database.\nDownload the Selenium Cheat Sheet and use it whenever required, especially during your interviews.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "20. Why do testers choose Selenium over QTP?",
        "answer": "Selenium is more widely used than QTP since:\nSelenium is an open-source tool, whereas QTP is a profitable tool.\nSelenium is used specifically for testing web-based applications, while QTP can be used for testing client–server applications too.\nSelenium supports multiple browsers like Firefox, IE, Opera, Safari, etc., and has multiple operating systems compatibility too. Selenium-supported OS platforms are Windows, Mac, Linux, etc. On the other hand, QTP is limited to Internet Explorer on Windows.\nSelenium supports multi-programming language compatibility. Languages supported by Selenium are Python, Ruby, Perl, etc. But, QTP supports only VBScript.\n\nYou can find more on Selenium by visiting our Selenium Community!",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "21. What are the four elements that you have to pass in Selenium?",
        "answer": "Four parameters that need to be passed in Selenium are:\nHost\nPort number\nBrowser\nURL\n\nSelenium Interview Questions for 3 Years Experience",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "22. What is the Same-origin Policy? How can we avoid it?",
        "answer": "The ‘Same-origin Policy’ is introduced for security reasons.\n\nIt ensures that the content of our site will never be accessible by a script from another site.\nAs per the policy, any code loaded within the browser can only operate within that website’s domain.\nTo avoid this same-origin policy, the proxy injection method is used. In the proxy injection mode, Selenium Server tricks the browser to be a real HTTP URL, i.e., it acts as a client-configured HTTP proxy, which sits between the browser and the application under test (AUT) and then masks the AUT under a fictional URL.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "23. What are data-driven frameworks and keyword-driven frameworks?",
        "answer": "A data-driven framework in Selenium is an approach to separating a ‘dataset’ from the actual ‘test case’ (code). This framework is completely dependent on the input test data. The test data is inserted from external sources, such as an Excel file, a CSV file, or any database. It also allows us to easily control how much data needs to be tested. We can easily increase the number of test parameters by adding more username and password fields to the Excel file (or other sources).\n\nA keyword-driven framework is an extension of the data-driven testing framework in the sense that it not only isolates the test data from the scripts but also keeps the particular section of the code belonging to the test script in an external data file. These sets of code are known as keywords, and hence the framework is so named. Keywords are self-guiding and work based on what actions need to be performed on the application.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "24. How will you use Selenium to upload a file?",
        "answer": "If the file is on the same machine or on a mapped network drive, it is really straightforward: We have to just type the ‘path’ of the file in the FileUpload control.\nExample:\ndriver = webdriver.Firefox()\nelement = driver.find_element_by_id(\"fileUpload\")\nelement.send_keys(\"C:myfile.txt\")\nLearn more about Selenium from this informative Selenium Tutorial!",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "25. What is the difference between getwindowhandles() and getwindowhandle()?",
        "answer": "getwindowhandles(): It is used to retrieve the addresses of all currently open browsers. The method returns a Set data type containing the addresses.\ngetwindowhandle(): It is used to obtain the current browser’s address and its return type is a string data type.\n\nSelenium Interview Questions for 5 Years Experience",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "26. What is a Selenium Maven project?",
        "answer": "In a Selenium Maven project, developers use Maven as a build tool and Selenium WebDriver to automate browser testing. Maven simplifies the process of managing dependencies and building Java projects, making it easier to configure Selenium WebDriver in the project.\nMaven empowers developers to establish a project structure encompassing source code, test code, and resource files while automating the build process. This simplifies project maintenance, distribution, and collaboration for Selenium.\nAlso, check out the blog on Maven in Selenium.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "27. What is a WebElement in Selenium, and how is it used?",
        "answer": "A WebElement is an interface in Selenium used to represent a web element on a web page. It is used to interact with the element, such as by clicking a button or entering text into a field.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "28. What is Selenese, and what are the three types of Selenese?",
        "answer": "Selenese is a set of commands in Selenium used for running a test.\nThree types of Selenese are as follows:\nActions: They are used for performing interactions and operations with the target elements.\nAccessors: They are used for storing values in a variable.\nAssertions: They are used as a checkpoint.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "29. If you want to insert a breakpoint in the Selenium IDE, how can you do that?",
        "answer": "To insert a breakpoint:\nFirst, select ‘Toggle Breakpoint’ by right-clicking on the command in Selenium IDE\nThen, press ‘B’ on the keyboard and select the command\nThe same step should be repeated for deselecting a breakpoint",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "30. How do you handle alerts in Selenium?",
        "answer": "Alerts are pop-up windows that are displayed on a web page. You can handle alerts in Selenium using the Alert interface. The Alert interface provides methods like accept(), dismiss(), and getText() to handle alerts.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "31. What is the difference between getText() and getAttribute() in Selenium?",
        "answer": "getText() returns the visible text of a web element, while getAttribute() returns the value of a specific attribute of the web element.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "32. List down some of the technical challenges with Selenium.",
        "answer": "Testing a Windows application: Selenium is just a web-based driver. It does not support Windows-based apps and only supports web apps.\nTesting mobile apps: With the help of Selenium, we can test web apps on any OS and browser that run on desktops. But, we cannot test mobile apps with Selenium because it does not work with OS such as Android and iOS. However, there is an alternative for this, i.e., Appium. It is an open-source automation testing tool that uses the WebDriver protocol to drive native, hybrid, and iOS and Android, which is built specifically for testing mobile apps.\nLimited reporting: It is one of the key challenges. In Selenium, we cannot generate efficient and accurate reports. Accurate reports help developers fix all bugs and errors. We can create reports using TestNG or ExtentReports.\nHandling dynamic elements: With the surge in the use of web apps, the management of dynamic elements should be as much efficient as possible. When a web page loads, the content present on the page changes depending on the user, location, and other factors. Most of today’s web apps are dynamic in nature for better user experience, e.g., e-commerce websites. In Selenium automation, the handling of dynamic web content is a major challenge. However, Selenium provides an explicit wait feature, where we can set a time interval for the automation testing process to hold the process for the new content to load. Also, another alternative is to utilize the implicit wait feature.\nHandling page load: Some of the web pages in a web app are user-specific. They load elements depending on the user. Also, some elements may be loaded depending on the user’s previous activities. During background processes, the Selenium script might not be able to identify a specific element. To overcome this, we can use explicit waits to provide sufficient time to load and discover the element.\nHandling pop-up windows: Whenever any simple, prompt, or confirmation alert pops up, it is difficult to automate it. Windows-based OS alerts are beyond Selenium’s capabilities as they are part of the OS instead of the browser. However, Selenium WebDriver can utilize multiple windows, and the web-based alerts can easily be handled with the help of the switchTo method. It manages the OS-based pop-ups while keeping the browser running in the background.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "33. What is the difference between setSpeed() and sleep() methods?",
        "answer": "Both setSpeed() and Sleep() in Selenium are used to delay the speed of execution.\nsetSpeed: Sets the execution speed with a delay of milliseconds, followed by the Selenium operation. By default, the delay is 0 milliseconds.\nsleep: Causes the suspension of execution of the current thread for a specified period.\n\nSelenium Advanced Interview Questions (6 to 10 Years)",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "34. How do you set the test case priority in TestNG?",
        "answer": "Setting Priority in TestNG:\nTest Execution Sequence:\nMethod1\nMethod2\nMethod3",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "35. What are the different types of frameworks?",
        "answer": "The various categories of frameworks are outlined as follows:\n\nModule-based testing framework: This framework divides the entire application under test (AUT) into a number of logical and isolated modules. For each module, we create a separate and independent test script. Thus, when these test scripts are taken together, it builds a larger test script representing more than one module.\nLibrary architecture testing framework: Instead of dividing AUT into test scripts, with this framework, we segregate the application into functions or rather common functions that can be used by the other parts of the application as well. Thus, we create a common library constituting common functions for AUT. Therefore, these libraries can be called from the test scripts whenever required.\nData-driven testing framework: The data-driven testing framework helps us segregate the test script logic and the test data from each other. It lets us store the test data into an external database. The data is conventionally stored in ‘key–value’ pairs. Keys can be used to access and populate the data within the test scripts.\nKeyword-driven testing framework: The keyword-driven testing framework is an extension to the data-driven testing framework in the sense that it not only segregates the test data from the scripts but also keeps a certain set of codes belonging to the test script in an external data file.\nHybrid testing framework: A hybrid testing framework is a combination of more than one of the above-mentioned frameworks. The best thing about such a setup is that it leverages the benefits of all kinds of associated frameworks.\nBehavior-driven development framework: The behavior-driven development framework allows the automation of functional validations in an easily readable and understandable format for Business Analysts, Developers, Testers, etc.\nGo through the Selenium Course in London to get a clear understanding of Selenium!\n\nSelenium Interview Questions for 6 to 7 Years Experience",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "36. Describe the difference between Selenium and QTP.",
        "answer": "Feature Selenium Quick Test Professional (QTP)\nBrowser compatibility It supports almost all popular browsers: Firefox, Chrome, Safari, Internet Explorer, Opera, etc. QTP supports Internet Explorer, Firefox, and Chrome. It only supports Windows operating system\nDistribution It is distributed as an open-source tool and is freely available It is distributed as a licensed tool and is commercialized\nApplication under test (AUT) It supports the testing of web-based applications only It supports the testing of both web-based and Windows-based applications\nObject repository Object repository needs to be created as a separate entity in Selenium QTP automatically creates and maintains the object repository\nLanguage support It supports multiple programming languages like Java, C#, Ruby, Python, Perl, etc. It supports only VBScript\nVendor support As Selenium is a free tool, users would not get the vendor’s support in troubleshooting issues Users can easily get the vendor’s support if they face any issues\nLearn more about Selenium in this Selenium Training in New York to get ahead in your career!",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "37. In Selenium, what are breakpoints and start points?",
        "answer": "Breakpoints: Breakpoints are used to stall the execution of the test. The execution will stop whenever a breakpoint is implemented, and this will help us check whether the code is working properly or not.\nStart points: Start points are the points from where the execution should begin. Start points can be used when we want to run the test script from the middle of the code or after a breakpoint.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "38. Mention the need for session handling while working with Selenium.",
        "answer": "While working with Selenium, we need session handling. This is because, during test execution, Selenium WebDriver has to interact with the browser all the time to execute the given commands. It is also possible that, before the current execution completes, someone else starts the execution of another script on the same machine and in the same type of browser. So, to avoid such a situation, we need session handling.\nAlso, check out the blog on how to use Selenium with Java.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "39. Mention the types of listeners in TestNG.",
        "answer": "The types of listeners in TestNG are:\nIAnnotationTransformer\nIConfigurable\nIConfigurationListener\nIExecutionListener\nIHookable\nIInvokedMethodListener\nIInvokedMethodListener2\nIMethodInterceptor\nIReporter\nISuiteListener\nITestListener",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "40. How can we handle Windows-based popups with Selenium?",
        "answer": "Selenium only supports web application testing. It does not support the testing of Windows-based applications or mobile applications. To handle Windows-based popups, third-party intervention is required. AutoIt and Robot Class are examples of third-party tools that we can use alongside Selenium to handle Windows-based popups.\nInterested in learning Selenium? Check out our Selenium Training in Sydney!",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "41. How can you take screenshots in Selenium?",
        "answer": "Selenium provides a method called getScreenshotAs() that can be used to capture a screenshot of the current browser window. We can then save the screenshot to a file or attach it to the test report.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "42. How can you identify an object in Selenium?",
        "answer": "We can use isElementPresent (string locator) to find an object in Selenium. It takes a locator as the argument and, if found, returns a Boolean.\nBecome a master of Selenium by taking this online Selenium Course in Toronto!",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "43. How do you implement data-driven testing in Selenium?",
        "answer": "Data-driven testing allows the same test script to be executed with multiple sets of data, making it easier to test different scenarios and edge cases. The candidate should know how to use external data sources, such as Excel or CSV files, to feed the test data into the script and how to handle the output results.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "44. Mention the use of XPath in Selenium testing.",
        "answer": "XPath is used to define web elements on a web page. The major advantage of XPath is that it helps us identify elements dynamically.\nThere are two types of XPath:\nAbsolute XPath\nRelative XPath",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "45. Explain how Selenium Grid works.",
        "answer": "Selenium Grid creates a test suite that works by forwarding test cases to the hub, and from there, the test cases are redirected to Selenium WebDriver. WebDriver will then execute them in the browser. The test suite allows for running tests in parallel.\nHope you find our comprehensive blog on Selenium testing interview questions useful. Do let us know in the comments section if you could make use of these Selenium topics for the interview.\nCheck out our blog to learn about Types of Software Testing!",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "46. Explain the difference between driver.close() and driver.quit() commands in Selenium.",
        "answer": "The following is the major difference between both commands:\nclose() command closes the currently active browser window, which is being used by the user or which is currently accessed by the web driver.\nquit() command closes all the windows opened by the program, unlike the driver.close () command.\nBoth commands do not take any value and also do not accept any parameter.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "47. Explain the difference between findElement() and findElements() in Selenium.",
        "answer": "The difference between findElement() and findElements() is as follows:\nfindElement(): It finds one particular element within the current page using the locating mechanism. It returns the first element located by the locator.\nfindElements(): It finds all the elements within the current page with the help of the locating mechanism. Hence, it returns a list of matching web elements found by the locator.\nGet ready for a Manual Testing job by going through these Top Manual Testing Interview Questions and Answers prepared by Industry Experts!",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "48. Mention the types of navigation commands.",
        "answer": "The following are the navigation commands provided by Selenium:\nnavigate().back(): It takes the user back to the previous or the last-used web page, according to the history.\nnavigate().forward(): It takes the user to the next web page, according to the browser history.\nnavigate().refresh(): It allows the user to refresh the current web page by reloading all the web elements.\nnavigate().to(): It takes the user to a new web page in a new window, depending on the URL specified.\n\nSelenium Interview Questions for 8 to 10 Years Experience",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "49. What is the use of the ‘ExpectedConditions’ class in Selenium?",
        "answer": "The ‘ExpectedConditions’ class in Selenium is a utility class that provides a set of predefined conditions that can be used to wait for a certain condition to be met before proceeding with the next step in a test. These conditions can be used in conjunction with the ‘WebDriverWait’ class to wait for elements to be visible, clickable, or to have a certain text, among other things.\nFor example,\n'ExpectedConditions.visibilityOfElementLocated(By.id(\"elementId\"))'\nthis can be used to wait for an element with a specific ID to be visible on the page. The ‘WebDriverWait’ class can then be used to wait for this condition to be met before interacting with the element. This helps to ensure that the element is present and visible before the test interacts with it, which can help prevent errors and improve the stability of the test.\nPreparing for a Software Testing Interview! Check out our Software Testing Interview Questions.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "50. Explain the significance of the @FindBy annotation in POM.",
        "answer": "@FindBy annotation is used to identify web elements in POM. The candidate should be able to explain its importance in improving code readability and maintainability.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "51. How can you perform mouse hover actions in Selenium?",
        "answer": "To perform a mouse hover action in Selenium, we can use the Actions class. We first need to create an object of the Actions class and then use the moveToElement() method to move the mouse to the element we want to hover over. We can then perform the required action on the element using click() or other similar methods.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "52. What is Cucumber?",
        "answer": "Cucumber is a BDD testing tool that enables developers to write test cases in a natural language format that can be understood by non-technical stakeholders. It supports multiple programming languages, including Java, Ruby, and Python, and can be integrated with various testing frameworks, including Selenium WebDriver.\nIt allows developers to write executable specifications in a readable format and automate the testing process. It enables developers to collaborate and communicate effectively with the team, including product owners, developers, and testers.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "53. How do you perform Cross browser testing using Selenium?",
        "answer": "Cross browser testing is a critical aspect of software testing that ensures the compatibility and functionality of a web application across different web browsers. Selenium, a popular open-source automation testing framework, provides a comprehensive solution for performing cross browser testing efficiently and effectively. \nThis process involves creating and executing test scripts using Selenium WebDriver to verify the consistency of the application’s behavior across multiple browsers.\nTo perform cross browser testing using Selenium, the following steps can be followed:\nTest Environment Setup: Start by setting up the necessary testing environment, including installing the required browsers (e.g., Chrome, Firefox, Safari, Internet Explorer) and the corresponding browser drivers (e.g., ChromeDriver, GeckoDriver).\nChoose the Browsers: Determine the target browsers based on the application’s target audience and market share. Consider both popular browsers and any specific browsers relevant to your user base.\nCreate Test Scripts: Develop test scripts using Selenium WebDriver and the programming language of your choice (e.g., Java, Python, C#). The test scripts should encompass a wide range of test cases, covering various features and functionalities of the application.\nImplement Cross Browser Testing: Within the test scripts, configure the desired browser capabilities and instantiate the WebDriver accordingly. This allows you to run the same tests across different browsers seamlessly.\nExecute the Test Scripts: Run the test scripts on each targeted browser individually, using the appropriate browser driver. Selenium WebDriver will launch the browsers, navigate to the application, and execute the defined test cases.\nValidate Results: Compare the expected results with the actual results obtained from each browser. Identify any inconsistencies, discrepancies, or browser-specific issues and address them accordingly.\nReporting and Analysis: Generate detailed test reports and analyze the results. This includes documenting any discrepancies or failures encountered during cross browser testing.\nBy performing cross browser testing using Selenium, you can identify and resolve any browser-specific issues, ensuring consistent functionality and a seamless user experience across different browsers. It is essential to regularly update the browser versions and drivers to stay compatible with the latest updates and changes in the browser landscape.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "54. Can you explain how to run Selenium tests in parallel?",
        "answer": "Running Selenium tests in parallel can improve the test execution time and reduce the overall test suite duration. The candidate should know how to set up a Selenium grid or use a cloud-based testing service to run tests in parallel on multiple machines or browsers.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "55. Can you explain how you would perform drag-and-drop operations in Selenium WebDriver?",
        "answer": "Performing drag-and-drop operations in Selenium WebDriver can be done using the ‘Actions’ class. The ‘Actions’ class provides several methods for simulating mouse and keyboard actions, including drag-and-drop.\nHere are the steps to perform drag-and-drop operations in Selenium WebDriver:\nFirst, you need to instantiate an instance of the ‘Actions’ class by passing in the ‘WebDriver’ instance as a parameter.\nNext, you need to locate the source and target elements on the page. These are the elements that you want to drag and drop.\nOnce you have located the source and target elements, you can use the ‘drag and drop (WebElement source, WebElement target)’ method of the ‘Actions’ class to simulate a drag-and-drop operation.\nYou can use the ‘build()’ method and ‘perform()’ method of the ‘Actions’ class to build the drag-and-drop action, and then perform it on the elements.\nHere’s an example of how you would perform a drag-and-drop operation using Selenium WebDriver:\nWebElement sourceElement = driver.findElement(By.id(\"source\"));\nWebElement targetElement = driver.findElement(By.id(\"target\"));\nActions actions = new Actions(driver);\nactions.dragAndDrop(sourceElement, targetElement).build().perform();",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "56. How do you handle dynamic web elements in Selenium?",
        "answer": "Dynamic web elements are those elements that change continuously on a web page. You can handle dynamic web elements using various methods such as:\nUsing regular expressions in locators\nUsing XPath functions like contains, starts-with, ends-with\nUsing CSS selectors",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "57. Can you explain how you would automate the login functionality of a web application using Selenium WebDriver?",
        "answer": "To automate the login functionality of a web application using Selenium WebDriver, we first need to identify the username and password fields on the login page using locators such as ID, name, or CSS selector.\nOnce we have located the elements, we can use the sendKeys() method to enter the username and password into the respective fields. We can then use the click() method to click the login button to submit the login form.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "58. How do you handle dynamic dropdowns in Selenium WebDriver?",
        "answer": "Dynamic dropdowns are those where the options change based on the selection made in another dropdown. To handle dynamic dropdowns in Selenium WebDriver, we first need to locate the parent dropdown and select an option from it. Then, we need to wait for the child dropdown to populate with new options before locating and selecting an option from it.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "59. Can you explain how you would automate the testing of a file upload functionality using Selenium WebDriver?",
        "answer": "In order to automate the testing of file upload functionality with Selenium WebDriver, the initial step involves locating the file upload button on the web page using locators such as ID, name, or CSS selector.\nOnce the upload button is successfully located, the sendKeys() method can be utilized to input the file path of the desired file that needs to be uploaded. Alternatively, the AutoIT tool can be employed to handle the file upload dialog box, as Selenium WebDriver lacks the inherent capability to interact with it.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "60. Can you explain how you would automate the testing of a responsive web application using Selenium WebDriver?",
        "answer": "The browser window resize function may be used to enlarge the browser window to various sizes in order to evaluate how the program works on various screen sizes during automated testing of a responsive web application using Selenium WebDriver. The browser development tools may also be used to simulate other devices and evaluate how the application operates on them.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "61. Can you explain how you would automate the testing of a pop-up window using Selenium WebDriver?",
        "answer": "Finding the element that causes the pop-up window using locators like ID, name, or CSS selector is the first step in automating the testing of a pop-up window using Selenium WebDriver.\nAfter that, the pop-up window may be opened by using the click() function. Using WebDriver’s switchTo() function, we can switch to the pop-up window and take the appropriate steps there. The same procedure may then be used to return to the main window.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "62. How would you automate a web application that uses a CAPTCHA to prevent automated access?",
        "answer": "CAPTCHA is a popular security mechanism that requires users to prove that they are humans. \nUse a CAPTCHA-solving service: There are many third-party services that offer CAPTCHA-solving solutions. These services use machine learning algorithms and human workers to solve CAPTCHAs. You can integrate these services into your automation script and use them to automatically solve the CAPTCHA.\nTrain a machine learning model: You can use machine learning to train a model to recognize and solve CAPTCHAs. This requires a large dataset of CAPTCHA images and corresponding solutions, as well as expertise in machine learning algorithms. However, once the model is trained, it can be used to automatically solve CAPTCHAs.\nUse OCR technology: Optical Character Recognition (OCR) technology can be used to automatically read and recognize the characters in a CAPTCHA image. This requires a high-quality image and accurate OCR software, but it can be a viable solution for some CAPTCHA types.\nUse human input: In some cases, it may be more efficient to use human input to solve CAPTCHAs. You can hire human workers or use crowdsourcing platforms to solve CAPTCHAs as part of your automation process.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "63. How would you test a web application that uses a single-page application (SPA) framework like Angular or React?",
        "answer": "To ensure the proper functioning, user-friendliness, and optimal experience of a web application developed using a single-page application (SPA) framework like Angular or React, a comprehensive testing approach is essential. The following explanation outlines the detailed methodology for testing a web application built with a SPA framework:\nUnderstand the SPA Architecture: Familiarize yourself with the underlying architecture and concepts of the SPA framework, such as Angular or React. Gain knowledge about components, routing, state management, and asynchronous data handling.\nIdentify Test Scenarios: Analyze the application’s functionality and identify key test scenarios. This includes testing navigation, form submissions, data fetching, dynamic rendering, and user interactions.\nUnit Testing: Begin with unit testing to test individual components, services, and utilities. Utilize testing frameworks specific to the SPA framework, such as Jasmine or Jest, to write and execute unit tests. Focus on testing component rendering, event handling, and data manipulation.\nIntegration Testing: Perform integration testing to ensure the correct collaboration between components, services, and modules within the application. Test interactions between components, API integrations, and third-party library integrations. Utilize testing frameworks like Karma or Enzyme to execute integration tests.\nEnd-to-End Testing: Conduct end-to-end (E2E) testing to simulate user interactions and test the entire application flow. Use tools like Selenium WebDriver or Cypress to write automated E2E tests. Test navigation, form submissions, user authentication, and other critical user flows.\nAccessibility Testing: Ensure the web application adheres to accessibility guidelines by performing accessibility testing. Verify that the application is accessible to users with disabilities and meets WCAG (Web Content Accessibility Guidelines) standards. Use tools like Axe or Lighthouse for automated accessibility testing.\nCompatibility Testing: Test the application across different browsers, devices, and operating systems. Verify that the SPA functions correctly and appears consistent across popular browsers like Chrome, Firefox, Safari, and Edge. Use browser testing tools or cloud-based testing platforms to perform cross-browser and cross-device testing.\nSecurity Testing: Assess the application for potential security vulnerabilities. Conduct security testing, including penetration testing, to identify and mitigate security risks. Validate inputs, test against common vulnerabilities, and ensure secure communication.\nContinuous Testing and Automation: Establish a resilient test automation framework to enable continuous testing practices. Automate repetitive tests, including unit tests, integration tests, and end-to-end (E2E) tests. Seamlessly integrate testing into the Continuous Integration/Continuous Deployment (CI/CD) pipeline to facilitate faster feedback loops and ensure the consistent delivery of high-quality software.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "64. How would you test a web application that uses WebSocket or real-time communication?",
        "answer": "Real-time communication and WebSocket are both becoming more and more common in online applications and testing them calls for a new strategy. You may monitor and examine the WebSocket traffic using tools like Fiddler or Wireshark to evaluate a web application that makes use of WebSockets or real-time communication. \nYou can also use testing frameworks like JMeter or Gatling to simulate high volumes of WebSocket traffic and test the application’s performance under load.\nAdditionally, manual testing can be done by emulating different scenarios and ensuring that the WebSocket connection is established and maintained properly. Testing the application’s error-handling capabilities and security measures is also important in ensuring the reliability and security of real-time communication.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "65. How would you handle a scenario where a web application requires user authentication before accessing certain pages?",
        "answer": "User authentication is a common requirement in web applications, and testing it requires a different approach. To handle a scenario where a web application requires user authentication before accessing certain pages, the application can implement a login system that verifies user credentials and grants access to authorized users. \nThis can involve using secure authentication methods like password hashing and using cookies or tokens to maintain user sessions. Testing should ensure that only authenticated users can access restricted pages and that access controls are properly implemented.\nAdditionally, testing should cover scenarios such as session timeouts, session hijacking, and other security risks associated with user authentication.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "66. How would you handle a scenario where a web application uses third-party APIs or services?",
        "answer": "Web applications often use third-party APIs or services, and testing them requires a different approach. A hybrid framework in Selenium combines both keyword-driven and data-driven approaches to test automation.\nTo implement it, you need to define a set of keywords that represent the actions and assertions you want to perform on the application. Then, you create test scripts that use these keywords to interact with the application and verify its behavior.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "67. How would you handle a scenario where a web application has dynamic URLs?",
        "answer": "Dynamic URLs can be challenging to test, as they change frequently. When dealing with a web application that has dynamic URLs, it is important to implement a consistent and logical URL structure that is easy for both users and search engines to understand. \nThis can be achieved by using descriptive keywords in the URL and implementing URL rewriting techniques to ensure that the URLs remain clean and user-friendly. Additionally, using canonical tags and setting up proper redirects can help avoid issues with duplicate content and broken links.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "68. What is BDD (Behavior Driven Development)?",
        "answer": "Behavior Driven Development (BDD) is an Agile software development approach that focuses on defining the behavior of a software application in a way that is understandable by all stakeholders, including developers, testers, and business analysts. \nIt is based on the principles of Test Driven Development (TDD), but it emphasizes collaboration and communication between team members. It uses natural language descriptions of features, scenarios, and acceptance criteria to define the expected behavior of the software.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "69. How would you handle a scenario where a web application uses complex data structures like trees or graphs?",
        "answer": "When working on web applications that rely on complex data structures like trees or graphs, it’s essential to grasp their fundamental data model fully and how it impacts application functionality. To reach optimal performance levels, efficient algorithms, and data structures for manipulating or traversing these structures must also be utilized in addition to rigorous testing procedures that protect data integrity while mitigating potential memory allocation or resource issues.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "70. How would you handle a scenario where a web application uses a lot of AJAX calls to update its UI?",
        "answer": "AJAX calls can make a website dynamic, but they can also pose unique problems in terms of automation. When using third-party APIs or services, it is imperative to test whether the application can effectively communicate with them while handling errors that arise – network outages, rate limiting and invalid responses should all be covered when testing these external services.\nAdditionally, an application must manage authentication and authorization to securely access external services. Error handling and logging should help diagnose issues with third-party APIs or services; while regular testing will help to ensure that its operation continues as designed should changes be made to those external APIs or services.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "71. How would you optimize your Selenium scripts for speed and performance?",
        "answer": "Optimizing Selenium scripts for speed and performance is key to decreasing execution time. There are various steps you can take to do so; one approach might be reducing page refreshes/waits in favor of conditional waits that trigger by specific page elements.\nHeadless browsers or cloud-based services can also help reduce test runtime by simultaneously running tests in parallel, shortening overall run times. Another technique to reduce data transfer between browser and server by employing efficient selectors and eliminating unnecessary requests can help limit data transfers between browser and server; additionally, optimizing test environments to reduce unnecessary logging can boost Selenium script performance as well.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "72. How would you handle a scenario where a web application has multiple languages and requires localization testing?",
        "answer": "Localization testing is essential when your web app serves users from multiple languages. To effectively conduct localization testing for multiple-lingual web apps, several steps should be taken.\nFirst and foremost, an application should support localization with language packs or resource files which can be tested to ensure accurate and consistent translations across languages. Furthermore, its user interface and layout should also be rigorously scrutinized against various character sets and formats of different languages to ensure compatibility.\nFurthermore, testing should cover scenarios like date/time formats, currency symbols, and regional variations.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "73. How would you handle a scenario where a web application uses browser-specific features like ActiveX or Java applets?",
        "answer": "Browser-specific features can create compatibility issues while automating web applications. To handle a scenario where a web application uses browser-specific features like ActiveX or Java applets, it is important to ensure that the application can properly communicate with the browser and handle any compatibility issues that may arise. \nTesting should cover scenarios like browser versions, operating systems, and browser security settings that may impact the use of these features. Additionally, ensuring that alternative solutions are available for users who cannot use these features can help maintain accessibility and functionality for all users.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "74. How would you handle a scenario where a web application uses security mechanisms like SSL or OAuth?",
        "answer": "Security mechanisms like SSL and OAuth are crucial in web applications. To handle a scenario where a web application uses security mechanisms like SSL or OAuth, it is important to ensure that the application properly implements these mechanisms and handles any security-related issues that may arise.\nTesting should cover scenarios like secure communication over HTTPS, token-based authentication using OAuth, and ensuring that user credentials are properly encrypted and stored.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "75. How would you handle a scenario where a web application uses third-party plugins like Adobe Flash or Microsoft Silverlight?",
        "answer": "Third-party plugins can create compatibility issues while automating web applications. To handle a scenario where a web application uses third-party plugins like Adobe Flash or Microsoft Silverlight, it is important to ensure that the application can properly communicate with the plugins and handle any compatibility issues that may arise. Testing should cover scenarios like browser versions, operating systems, and plugin security settings that may impact the use of these plugins.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "76. How do you ensure the stability and reliability of your Selenium tests?",
        "answer": "Selenium tests are susceptible to fragility and potential failure caused by factors like varying browser versions, network disruptions, or modifications in the application being tested. To guarantee the steadfastness and dependability of Selenium tests, it is essential to employ resilient and sustainable test code capable of accommodating dynamic changes in the application. This encompasses utilizing efficient selectors, modularizing the test code, and minimizing the reliance on hardcoded values. By adhering to these practices, the stability and reliability of Selenium tests can be enhanced, ensuring smoother test execution even in the face of evolving conditions or alterations in the application under examination.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "77. Can you explain how Selenium works under the hood?",
        "answer": "A proficient Selenium developer should possess a solid comprehension of the intricate interactions between Selenium and web browsers, along with the mechanisms involved in executing commands and retrieving outcomes using the WebDriver API.\nSelenium is a comprehensive suite of tools utilized for automating web browsers. Among these tools, Selenium WebDriver stands out as the most widely employed solution. It establishes communication with the browser through a set of commands and interfaces, thereby emulating user interactions with the web application.\nThese commands are dispatched to a browser-specific driver, which interprets them into actions that are specific to the particular browser. Selenium WebDriver also encompasses a diverse range of APIs that facilitate interaction with various elements on a web page. These APIs enable tasks such as element discovery, clicking on elements, and entering text into form fields.\nIn addition to functional and regression testing automation, Selenium can be effectively utilized for a myriad of web automation tasks. Possessing expertise in these aspects equips a Selenium developer with the necessary skills to leverage the full potential of Selenium and deliver robust and efficient test automation solutions.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "78. How do you implement a Hybrid Framework in Selenium?",
        "answer": "A Hybrid Framework is a combination of different design patterns and approaches, such as Data-Driven, Keyword-Driven, or Behavior-Driven Testing, to improve the modularity, reusability, and maintainability of Selenium tests.\nTo implement a Hybrid Framework in Selenium, you would first identify the different types of tests required, such as functional, regression, or performance testing.\nThen, you would create modular test scripts using a combination of data-driven and keyword-driven approaches. \nThese scripts can be managed through a test management tool and executed using a test runner. Additionally, implementing a reporting mechanism can provide valuable insights into the test results and aid in debugging and analysis.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "79. How do you handle security testing in Selenium?",
        "answer": "Security testing involves testing the web application’s vulnerabilities and threats, such as XSS, CSRF, or SQL injection, to ensure that it meets the security standards and regulations.\nWhen handling security testing in Selenium, it is important to test for vulnerabilities such as cross-site scripting (XSS), injection attacks, and broken authentication and session management. ]\nThis can be achieved by using security testing tools such as OWASP ZAP or Burp Suite in conjunction with Selenium. Additionally, implementing secure coding practices and ensuring that all inputs and outputs are properly validated can help prevent potential security breaches.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "80. How do you integrate Selenium with other testing tools, such as Jenkins or TestNG?",
        "answer": "Selenium can be integrated with other testing tools and frameworks to improve the automation workflow and generate useful reports and metrics. Integrating Selenium with other testing tools such as Jenkins or TestNG involves configuring the testing tools to work with Selenium. \nThis can be achieved by adding Selenium libraries to the project and setting up test configurations to run Selenium tests. Additionally, integrating with a continuous integration tool like Jenkins allows for automated testing and reporting, while TestNG provides advanced testing features such as grouping and parallel execution.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "81. How do you implement performance testing in Selenium?",
        "answer": "Performance testing involves measuring the web application’s response time, throughput, and scalability under different loads and stress levels. To implement performance testing in Selenium, you would use load testing tools such as JMeter or LoadRunner to simulate heavy user traffic and measure the performance of the web application. \nSelenium scripts can be integrated with these tools to simulate real user behavior and generate load on the application. Additionally, using performance profiling tools can help identify bottlenecks and areas for optimization in the application",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "82. Is it common to implement AI and ML techniques in Selenium? Give one example to explain why.",
        "answer": "AI and Machine Learning techniques can improve the efficiency, accuracy, and reliability of Selenium tests, such as using Natural Language Processing or Computer Vision to automate test cases and generate useful insights. It is not common to implement AI and Machine Learning techniques in Selenium, as it is primarily a testing tool. \nHowever, some AI and ML techniques can be used in conjunction with Selenium to enhance the testing process. For example, image recognition can be used to identify UI elements, and natural language processing can be used to generate test cases from user stories.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "83. Can you explain how to handle and automate complex web elements, such as iframes, pop-ups, or drag-and-drop elements?",
        "answer": "To handle and automate complex web elements such as iframes, pop-ups, or drag-and-drop elements in Selenium, first identify the element using appropriate locators such as ID or XPath.\nFor iframes, switch to the frame using the driver’s switchTo() method. For pop-ups, use the Alert class to handle the pop-up window. For drag-and-drop elements, make use of the Actions class to perform drag-and-drop operations.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "84. What is a DesiredCapabilities class in Selenium?",
        "answer": "The DesiredCapabilities class is a part of the Selenium WebDriver API and is used to configure the capabilities of a WebDriver instance. It is essentially a set of key-value pairs that specify the various properties of the browser or device that the WebDriver will use to run the tests.\nSome examples of the properties that can be set using DesiredCapabilities include; browser type, version, platform, proxy settings, and browser language.\nIt is particularly useful for cross-browser testing, where you may need to run the same tests on different browsers or platforms. By setting the capabilities using this class, you can ensure that the WebDriver will use the correct settings for each browser/platform, and your tests will run consistently across all environments.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "85. What is a WebDriverEventListener in Selenium and how is it used?",
        "answer": "A WebDriverEventListener is an interface in Selenium that allows you to listen to various events that occur during the execution of your tests. Some examples of events that can be listened to include beforeNavigateTo, afterNavigateTo, beforeClickOn, afterClickOn, beforeFindBy, and afterFindBy.\nBy implementing the WebDriverEventListener interface and defining methods for each of these events, you can perform custom actions or log during your tests.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "86. What is Gherkin?",
        "answer": "Gherkin is a simple, natural language syntax used to describe the behavior of a software application in a way that is understandable by non-technical stakeholders. It is used in conjunction with Cucumber to define the acceptance criteria and scenarios for a software feature.\nIt uses keywords, such as Given, When, and Then, to describe the steps of a scenario in a clear and concise manner. Gherkin allows developers to write executable specifications that can be easily understood and reviewed by the team.\n\nSelenium Coding Interview Questions and Answers",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "87. Write a Selenium WebDriver code to open a browser, navigate to a website, and print the page title in Java.",
        "answer": "WebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.intellipaat.com\");\nString pageTitle = driver.getTitle();\nSystem.out.println(\"Page Title: \" + pageTitle);\ndriver.quit();",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "88. Implement a function in Selenium WebDriver to find the total number of links on a webpage in Python.",
        "answer": "WebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.intellipaat.com\");\nAlert alert = driver.switchTo().alert();\nString alertText = alert.getText();\nSystem.out.println(\"Alert Text: \" + alertText);\nalert.accept();\ndriver.quit();",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "89. Write a Selenium script to perform a login operation using CSS selectors in Java.",
        "answer": "WebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.intellipaat.com\");\ndriver.findElement(By.cssSelector(\"input#username\")).sendKeys(\"your_username\");\ndriver.findElement(By.cssSelector(\"input#password\")).sendKeys(\"your_password\");\ndriver.findElement(By.cssSelector(\"button#loginButton\")).click();\ndriver.quit();",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "90. Implement a Selenium WebDriver script to capture a screenshot of a webpage in Python.",
        "answer": "from selenium import webdriver\ndriver = webdriver.Chrome()\ndriver.get(\"https://www.intellipaat.com\")\n# Take a screenshot and save it as \"screenshot.png\"\ndriver.save_screenshot(\"screenshot.png\")\ndriver.quit()",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "91. Create a Selenium script in Java to handle an alert on a webpage.",
        "answer": "WebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.intellipaat.com\");\nAlert alert = driver.switchTo().alert();\nString alertText = alert.getText();\nSystem.out.println(\"Alert Text: \" + alertText);\nalert.accept();\ndriver.quit();\n\nSelenium WebDriver Interview Questions",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "92. What is Selenium WebDriver?",
        "answer": "Selenium WebDriver is the most popular component of the Selenium framework. It is a powerful tool that allows you to automate web browsers. With Selenium WebDriver, you can write automation scripts in various programming languages and execute them on different browsers like Chrome, Firefox, Safari, and more.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "93. How many types of WebDriver APIs are available in Selenium?",
        "answer": "The following is a list of WebDriver APIs:\nAndroidDriver\nChromeDriver\nEventFiringWebDriver\nFirefoxDriver\nHTMLUnitDriver\nInternetExplorerDriver\niPhoneDriver\niPhoneSimulatorDriver\nRemoteWebDriver",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "94. How do you launch the web browser using WebDriver?",
        "answer": "The following syntax can be used to launch the browser corresponding to the system’s operating system:\nWebDriver driver = new FirefoxDriver();\nOr\nWebDriver driver = new InternetExplorerDriver();\nOr\nWebDriver driver = new ChromeDriver();",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "95. What are the different types of waits available in WebDriver?",
        "answer": "There are two types of waits available in WebDriver: Explicit and Implicit WaitExplicit and Implicit Wait\nImplicit wait: These waits are used to provide a default waiting time (say, 30 seconds) between the consecutive test steps across the entire test script. Hence, the subsequent test step would only be executed when the 30 seconds are over after executing the previous test step.\nExplicit wait: These waits are used to halt the execution until a particular condition is met or the maximum time has elapsed.\nExplicit waits are instantiated for a particular instance only, whereas implicit waits are not.\nWant to learn about Selenium with Python! Check out our blog on Selenium Python Tutorial for beginners.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "96. How do you handle a frame in WebDriver?",
        "answer": "An iframe (an acronym for ‘inline frame’) is used to insert another document within the current HTML document. Selecting iframe by ID:\ndriver.switchTo().frame(“ID of the frame“);\nLocating iframe using the tagName:\ndriver.switchTo().frame(driver.findElements(By.tagName(“iframe”).get(0));\nLocating iframe using index:\nframe(index)\ndriver.switchTo().frame(0);\nframe(“Name of the Frame”)\ndriver.switchTo().frame(“name of the frame”);\nframe(WebElement element)\nSelect Parent Window\ndriver.switchTo().defaultContent();",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "97. For the database testing in Selenium WebDriver, what API is required?",
        "answer": "For the database testing in Selenium WebDriver, we need the JDBC (Java Database Connectivity) API. It allows us to execute SQL statements.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "98. Can WebDriver test mobile applications?",
        "answer": "No, WebDriver is a testing tool used for web-based applications. So, we cannot test mobile applications with Selenium WebDriver.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "99. How do you handle synchronization issues in Selenium WebDriver?",
        "answer": "Synchronization issues can occur when the script moves too quickly, and the web page is not ready for the next step. To handle synchronization issues in Selenium WebDriver, we can use different types of waits like Implicit Wait, Explicit Wait, or Fluent Wait. We can also use the Thread.sleep() method to pause the execution of the script for a specified amount of time. However, this method should be used sparingly as it can make the script slower and less efficient.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "100. How do you find broken links in Selenium WebDriver?",
        "answer": "We can detect whether the given links are broken or not by using the following process:\nFirst, accumulate all the links present on a web page using the anchor tag. For each tag, use the attribute ‘href’ value to obtain the hyperlink.\nSend HTTP requests for each link and verify the HTTP response code\nBased on the HTTP response code, determine if the link is valid or broken. Then, use the driver.get() method to navigate to a URL, which will respond with a status of 200 – OK (200 – OK indicates that the link is working). If we get any other status, then it indicates that the link is broken\nRepeat the same process for all the links captured",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "101. How do you handle multiple windows in Selenium WebDriver?",
        "answer": "In Selenium WebDriver, you can handle multiple windows by actively switching between them using the ‘switchTo()’ method of the ‘WebDriver’ interface.\nHere are the steps to handle multiple windows in Selenium WebDriver:\nTo acquire the handle of the current window, one can employ the ‘getWindowHandle()’ method from the ‘WebDriver’ interface. This method enables access to the unique identifier of the current window.\nTo obtain all window handles in a formal manner, you can utilize the ‘getWindowHandles()’ method from the ‘WebDriver’ interface. This method retrieves a set of all currently open window handles.\nIterate through the window handles using a loop and check for the window handle of the desired window you want to switch to.\nAfter identifying the window handle of the desired window, utilize the ‘switchTo()’ method from the ‘WebDriver’ interface by passing the window handle as an argument. This operation allows for the web driver to shift its focus to the designated window.\nPerform any required actions in the new window.\nAfter completing the tasks in the new window, switch back to the original window by using the window handle of the original window that you stored earlier.\nNotably, Selenium WebDriver handles the transition to a new window. Upon switching to a new window, the WebDriver automatically adjusts the focus, enabling seamless interaction. Subsequently, when you have completed your tasks in the new window, you can effortlessly switch back to the original window and seamlessly proceed with your testing activities.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "102. How do you handle browser cookies in Selenium WebDriver?",
        "answer": "When performing web automation using Selenium WebDriver, it is essential to understand how to handle browser cookies effectively. Browser cookies are small data stored by websites on a user’s browser, used for various purposes like session management, personalization, and tracking. \nGetting Cookies: To retrieve cookies from the browser using Selenium WebDriver, we can use the get_cookies() method. This method returns a set of dictionaries, each representing a cookie. Each cookie dictionary typically contains attributes such as name, value, domain, path, expiry, and secure flag.\nAdding Cookies: To add cookies in Selenium WebDriver, we utilize the add_cookie() method. This method takes a dictionary containing the cookie attributes as its parameter. The most crucial attributes are the name and value, which must be provided. Other attributes like domain, path, expiry, and secure flag can also be set if required.\nDeleting Cookies: To remove cookies using Selenium WebDriver, we can use the delete_cookie() method, it takes the cookie’s name as a parameter. \nManaging Individual Cookies: Selenium WebDriver allows us to manipulate cookies individually. We can access a specific cookie using its name and modify its attributes using the get_cookie() and add_cookie() methods, respectively.\nWorking with Expiry: Cookies often have an expiry time. Selenium WebDriver enables us to handle this by setting a cookie’s expiry time using the expiry attribute in the cookie dictionary. We can provide an expiry value in Unix timestamp format to set the desired expiration.\nHandling browser cookies in Selenium WebDriver is crucial for scenarios like logging in as a specific user, maintaining a session state, or performing tests that rely on cookie-based functionalities. Utilizing the methods and techniques mentioned above, you can effectively manage and manipulate cookies during your web automation tasks with Selenium WebDriver, ensuring accurate and reliable test execution.\n\nSelenium MCQ Interview Questions",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "103. Which year was selenium created?",
        "answer": "2004\n2005\n2006\n2001\n2004",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "104. Who was the creator of selenium?",
        "answer": "Dan Cuellar\nJason Huggins\nRossmanith Gmbh\nJason Huggins",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "105. Which of the following browsers supports selenium?",
        "answer": "Google Chrome\nSafari\nMozilla Firefox\nInternet Explorer\nAll of the above\nAll of the above",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "106. What do you mean by open-source software?",
        "answer": "Open-source software is software that is circulated across the world with its source code which also means it is available for use, and modification.\nOpen-source software is software that is easy to use and where the code is stored in a public repository also it comes with a distributed license.\nAll of the aboveAll of the above",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "107. Which of the following is not the alternative to selenium?",
        "answer": "Cucumber\nCypress\nPuppeteer\nMocha\nMocha\n\nSelenium Tricky Interview Questions",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "108. How do you handle dynamic elements in Selenium, especially when traditional locators don't work?",
        "answer": "To handle the dynamic element in selenium especially when traditional locators fail, follow these approach: \nDynamic XPath or CSS Selectors:\nAnalyze the dynamic element, identifying consistent attributes or patterns.\nEmploy XPath or CSS selectors with functions like contains(), starts-with(), or ends-with() to encompass dynamic elements.\nExplicit Waits:\nImplement explicit waits to dynamically pause execution until the element stabilizes.\nUse conditions such as visibilityOf(), elementToBeClickable(), or presenceOfElementLocated() for precise timing.\nRetry Mechanism:\nEstablish a retry mechanism by catching exceptions and making multiple attempts to locate the element.\nThis adaptive approach accommodates scenarios where dynamic changes may momentarily hinder identification.\nJavaScriptExecutor:\nHarness JavaScriptExecutor to execute JavaScript code for direct interaction with dynamic elements.\nThis technique proves beneficial when conventional WebDriver methods encounter challenges posed by dynamic alterations.\nWait for Page to Stabilize:\nConfirm the full loading and stabilization of the page before initiating interactions with dynamic elements.\nImplement waits for complete page loads or AJAX requests to settle, ensuring a stable environment for automation.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "109. What is the purpose of the WebDriverWait class, and how do you use it effectively?",
        "answer": "The `WebDriverWait` class in Selenium plays a vital role in handling dynamic elements by enabling explicit waiting. This is crucial for effective synchronization during test automation. To use it optimally, create an instance with a specified timeout and polling interval. Define the expected conditions, such as visibility or clickability, and apply the wait using the `until` method. This approach enhances script reliability by synchronizing with dynamic web page behavior, ensuring a smooth and accurate execution.\nExample: \nWebDriverWait wait = new WebDriverWait(driver, 10);\nWebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(By.id(\"exampleId\")));",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "110. How would you handle a situation where a web page contains multiple frames, and you need to interact with an element within a specific frame?",
        "answer": "When dealing with multiple frames in Selenium, efficiently handle them by identifying the target frame using index, name, or WebElement. Utilize `switchTo().frame()` to navigate, perform actions within the frame, and then return to the default content using `switchTo().defaultContent()`. This ensures precise interaction, enhancing test reliability and effectiveness.\n\nSelenium Scenario-Based Interview Questions",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "111. You are testing an e-commerce website, and during checkout, the 'Place Order' button is not responding consistently. How would you approach debugging and resolving this issue using Selenium?",
        "answer": "There are several approach for debugging and resolving the issue using Selenium are: \nOptimize Element Identification: Ensure ‘Place Order’ button has a unique and SEO-friendly identifier, such as a relevant ID or class.\nEfficient Waiting: Implement precise waits with WebDriverWait to enhance user experience and optimize loading times.\nRobust Error Handling: Incorporate try-catch blocks with clear error messages for better SEO diagnostics.\nDetailed Logging for Analysis: Use detailed logging statements to aid developers in analyzing and improving the checkout process.\nSEO-friendly Naming: Name identifiers and variables descriptively, enhancing code readability and SEO friendliness.\nBrowser DevTools Insights: Leverage browser developer tools for a thorough analysis of the button element, ensuring a seamless user experience.\nStay Updated with Latest Technologies: Regularly update Selenium and browser drivers to align with the latest SEO-friendly practices and ensure compatibility.\nPrioritize User Focus: Confirm browser window focus for improved user interactions and SEO performance.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "112. The application you are testing involves uploading files. Explain how you would automate the testing of file uploads using Selenium WebDriver.",
        "answer": "We can automate the testing of file uploads using Selenium WebDriver by these mentions approach: \nOptimize File Input Element Identification: Choose SEO-friendly locators (like ID, XPath, or CSS) for the file input element.\nStreamlined Interaction with `send_keys()`: Utilize `send_keys()` method for a seamless and SEO-friendly simulation of file selection, providing the file path.\nEfficient Wait Strategies for Upload Completion: Implement explicit waits to optimize user experience and ensure timely file upload completion.\nSEO-friendly Verification of Upload Success: Verify upload success using SEO-friendly messages or elements indicating a successful upload.\nGraceful Handling of Popups (if any): Ensure a smooth transition by gracefully switching to and handling confirmation popups, if presented.\nDetailed Logging and SEO-friendly Reporting: Incorporate detailed logging statements for transparent progress tracking and integrate with SEO-friendly reporting tools for comprehensive logs.",
        "reference": "intellipaat.com",
        "role": "selenium"
    },
    {
        "question": "1. What is Selenium?",
        "answer": "Selenium is an open-source (free) automated testing framework for validating web applications across multiple browsers and platforms. Selenium Test Scripts can be written in a variety of programming languages, including Java, C#, Python, and others. Selenium Testing is the term for testing done using the Selenium testing tool. Selenium Software is a collection of tools, each of which caters to a specific organization's Selenium QA testing requirements. The following is a list of tools incorporated within Selenium: Selenium Integrated Development Environment (IDE).\nSelenium Remote Control (RC).\nSelenium WebDriver.\nSelenium Grid. Selenium Integrated Development Environment (IDE). Selenium Remote Control (RC). Selenium WebDriver. Selenium Grid. Learn Selenium with this Complete Roadmap. Learn Selenium",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "2. What are the Selenium suite components?",
        "answer": "Selenium is a package of several testing tools. It is therefore often referred to as a Selenium Suite with each of these tools designed to cater to a different testing requirement. The following are the different components of Selenium Suite: components of Selenium Suite   Selenium Integrated Development Environment (IDE): It is a Firefox/Chrome plug-in that is developed to speed up the creation of automation scripts by recording the user actions on the web browser and exporting them as a reusable script.\nSelenium Remote Control (RC): It is a server that enables users to generate test scripts in their preferred programming language. It accepts commands from the test scripts and sends them to the browser as Selenium core JavaScript commands, for the browser to behave accordingly.\nSelenium WebDriver: It is a programming interface that helps create and run test cases by directly communicating with the web browser and using its native compatibility to automate. Unlike RC, it doesn’t require an additional server to create and run test cases.\nSelenium Grid: It allows parallel execution of tests on different browsers and operating systems by distributing commands to other machines simultaneously. Selenium Integrated Development Environment (IDE): It is a Firefox/Chrome plug-in that is developed to speed up the creation of automation scripts by recording the user actions on the web browser and exporting them as a reusable script. Selenium Integrated Development Environment (IDE) Selenium Remote Control (RC): It is a server that enables users to generate test scripts in their preferred programming language. It accepts commands from the test scripts and sends them to the browser as Selenium core JavaScript commands, for the browser to behave accordingly. Selenium Remote Control (RC) Selenium WebDriver: It is a programming interface that helps create and run test cases by directly communicating with the web browser and using its native compatibility to automate. Unlike RC, it doesn’t require an additional server to create and run test cases. Selenium WebDriver: Selenium Grid: It allows parallel execution of tests on different browsers and operating systems by distributing commands to other machines simultaneously. Selenium Grid:",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "3. What are the advantages of using Selenium as an automation tool?",
        "answer": "The following are the advantages of using Selenium for automated testing : Selenium for automated testing Selenium for automated testing Open-Source: Selenium's greatest strength, as previously said, is that it is a freeware and portable tool. There are no out-of-pocket expenses. The utility can be downloaded for free, and community-based help is also accessible.\nLanguage assistance: Java, Perl, Python, C#, Ruby, Groovy, JavaScript, and other languages are supported by Selenium. It has its own script, yet it is not constrained by it. It can work with a variety of languages, depending on the developers' and testers' preferences.\nCompatible with a variety of operating systems: Selenium may run on a variety of operating systems, including Windows, Mac OS X, Linux, and UNIX. A customized testing suite can be constructed on any platform and then executed on another using the Selenium suite of products. For example, you may write test cases in Windows and run them on a Linux system with ease.\nBrowser compatibility: Selenium is compatible with a variety of web browsers, including Internet Explorer, Chrome, Firefox, Opera, and Safari. When running tests and testing them across multiple browsers at the same time, this becomes really useful.\nProgramming languages and framework support: Selenium works with a variety of programming languages and frameworks. For source code compilation, it can, for example, integrate with ANT or Maven frameworks. It may also be used to test apps and generate reports using the TestNG framework. Continuous Integration (CI), can integrate with Jenkins or Hudson, and it can also integrate with other open-source tools to offer other functionalities.\nTests on a variety of devices: On Android, iPhone, and Blackberry, Selenium Test Automation can be used to automate mobile web application testing. This can aid in the generation of necessary results and the ongoing resolution of bugs present in the application.\nRegular updates: Selenium support is based on a community, which allows for frequent updates and upgrades. These upgrades are simple to install and don't require any special training. Selenium is thus both resourceful and cost-effective.\nSelenium suites with a lot of content: Selenium is more than just a single tool or utility; it's a full set of numerous testing tools that's why it's called a Suite. Each tool is tailored to specific testing needs and test environment constraints. Selenium also includes features such as Selenium IDE, Selenium Grid, and Selenium Remote Control (RC).\nEase with which it can be implemented: Selenium has a user-friendly interface that makes it simple to develop and perform tests. Its open-source capabilities allow users to script their own extensions, making them simple to create, alter actions, and manipulate at a high level. Selenium's reporting features are also one of the reasons for its popularity, as it allows testers to extract results and take action based on them. Open-Source: Selenium's greatest strength, as previously said, is that it is a freeware and portable tool. There are no out-of-pocket expenses. The utility can be downloaded for free, and community-based help is also accessible. Open-Source: Language assistance: Java, Perl, Python, C#, Ruby, Groovy, JavaScript, and other languages are supported by Selenium. It has its own script, yet it is not constrained by it. It can work with a variety of languages, depending on the developers' and testers' preferences. Language assistance: Compatible with a variety of operating systems: Selenium may run on a variety of operating systems, including Windows, Mac OS X, Linux, and UNIX. A customized testing suite can be constructed on any platform and then executed on another using the Selenium suite of products. For example, you may write test cases in Windows and run them on a Linux system with ease. Compatible with a variety of operating systems: Browser compatibility: Selenium is compatible with a variety of web browsers, including Internet Explorer, Chrome, Firefox, Opera, and Safari. When running tests and testing them across multiple browsers at the same time, this becomes really useful. Browser compatibility: Programming languages and framework support: Selenium works with a variety of programming languages and frameworks. For source code compilation, it can, for example, integrate with ANT or Maven frameworks. It may also be used to test apps and generate reports using the TestNG framework. Continuous Integration (CI), can integrate with Jenkins or Hudson, and it can also integrate with other open-source tools to offer other functionalities. Programming languages and framework support: Tests on a variety of devices: On Android, iPhone, and Blackberry, Selenium Test Automation can be used to automate mobile web application testing. This can aid in the generation of necessary results and the ongoing resolution of bugs present in the application. Tests on a variety of devices: Regular updates: Selenium support is based on a community, which allows for frequent updates and upgrades. These upgrades are simple to install and don't require any special training. Selenium is thus both resourceful and cost-effective. Regular updates: Selenium suites with a lot of content: Selenium is more than just a single tool or utility; it's a full set of numerous testing tools that's why it's called a Suite. Each tool is tailored to specific testing needs and test environment constraints. Selenium also includes features such as Selenium IDE, Selenium Grid, and Selenium Remote Control (RC). Selenium suites with a lot of content: Ease with which it can be implemented: Selenium has a user-friendly interface that makes it simple to develop and perform tests. Its open-source capabilities allow users to script their own extensions, making them simple to create, alter actions, and manipulate at a high level. Selenium's reporting features are also one of the reasons for its popularity, as it allows testers to extract results and take action based on them. Ease with which it can be implemented:",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "4. What are the disadvantages of using Selenium as a testing tool?",
        "answer": "The following are the disadvantages of using Selenium as a testing tool: Tests web applications only: Selenium supports the testing of only web-based applications. Mobile applications, Captcha, and Barcode readers cannot be tested using Selenium unless integrated with third-party tools like Appium and TestNG.\nNo built-in reporting and test management facility: Selenium can generate reports only using third-party tools like TestNG or JUnit.\nUnavailability of reliable tech support: Since Selenium is an open-source tool, no dedicated support for user issues is available.\nMay require the knowledge of programming languages: Some prior programming knowledge is required to use Selenium. Tests web applications only: Selenium supports the testing of only web-based applications. Mobile applications, Captcha, and Barcode readers cannot be tested using Selenium unless integrated with third-party tools like Appium and TestNG. Tests web applications only No built-in reporting and test management facility: Selenium can generate reports only using third-party tools like TestNG or JUnit. No built-in reporting and test management facility Unavailability of reliable tech support: Since Selenium is an open-source tool, no dedicated support for user issues is available. Unavailability of reliable tech support May require the knowledge of programming languages: Some prior programming knowledge is required to use Selenium. May require the knowledge of programming languages",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "5. What is automation testing, and what are its advantages?",
        "answer": "Automation Testing or Test Automation is a process of automating the manual testing process of an application or a system by using testing tools that allow you to create scripts that can be executed repeatedly, generating detailed test reports of the application or system under test. Automation Testing   The advantages of Automated Testing are: It supports both the performance and functional testing of an application or system.\nIt facilitates the execution of repeated test cases.\nIt allows the parallel execution of the test cases.\nIt improves the accuracy and efficiency of the system by reducing the manual intervention of humans to generate test cases.\nIt helps in testing a large-scale test matrix.\nIt saves valuable time and money for the testing team involved in the project. It supports both the performance and functional testing of an application or system. It facilitates the execution of repeated test cases. It allows the parallel execution of the test cases. It improves the accuracy and efficiency of the system by reducing the manual intervention of humans to generate test cases. It helps in testing a large-scale test matrix. It saves valuable time and money for the testing team involved in the project.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "6. Why should Selenium be selected as a testing tool for web applications or systems?",
        "answer": "Selenium provides the following advantages, which make it an excellent automated testing framework: It is free and open-source software with a large user base and supports providing community.\nIt has cross-browser compatibility and supports multiple browsers like Google Chrome, Mozilla Firefox, Internet Explorer, Edge, Opera, Safari, etc.\nIt supports multiple operating systems such as Windows, Linux, macOS, etc.\nIt facilitates the usage of multiple programming languages including Scala, Ruby, Python, PHP, Perl, Java, Groovy, C#, etc.\nIt provides support for distributed testing as well. It is free and open-source software with a large user base and supports providing community. It has cross-browser compatibility and supports multiple browsers like Google Chrome, Mozilla Firefox, Internet Explorer, Edge, Opera, Safari, etc. It supports multiple operating systems such as Windows, Linux, macOS, etc. It facilitates the usage of multiple programming languages including Scala, Ruby, Python, PHP, Perl, Java, Groovy, C#, etc. It provides support for distributed testing as well.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "7. What is Selenese? Explain different types of Selenium commands.",
        "answer": "The language used for writing test scripts in Selenium IDE is called Selenese. It is a set of commands used to test your web application or system. Selenium commands could be divided into 3 major categories: Actions: These are the commands interacting directly with web applications.\nAccessors: These are the commands which allow users to store values in a user-defined variable.\nAssertions: They enable a comparison of the current state of the application with its expected state. Actions: These are the commands interacting directly with web applications. Actions: Accessors: These are the commands which allow users to store values in a user-defined variable. Accessors: Assertions: They enable a comparison of the current state of the application with its expected state. Assertions:  ",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "8. What is meant by a locator and name a few different types of locators present in Selenium.",
        "answer": "A locator is an address for uniquely identifying web elements within a web page. There are different types of locators present in Selenium to identify web elements uniquely and accurately like: ID\nClassName\nName\nTagName\nLinkText\nPartialLinkText\nXpath\nCSS Selector\nDOM. ID ClassName Name TagName LinkText PartialLinkText Xpath CSS Selector DOM.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "9. What is exception test in Selenium?",
        "answer": "An exception test is a test that expects an exception to be thrown inside a test class. It expects a @Test annotation followed by the expected exception name in the brackets. Eg: @Test(expectedException = NoSuchElementException.class) is an exception test for missing elements in Selenium. Eg: @Test(expectedException = NoSuchElementException.class)",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "10. What is XPath in Selenium? Explain XPath Absolute and XPath Relative.",
        "answer": "XPath, also defined as XML-Path (Extensible Markup Language Path), is a language used to query XML documents and provide functionalities like locating elements in Selenium by iterating through each element in a webpage. In XPath, data is stored in a key-value pair format similar to an HTML tag. It uses a single slash, i.e. ‘ / ’ for creating an absolute path, and a double slash, i.e. ‘ // ’ for creating a relative path for an element to be located on a webpage.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "11. In Xpath, what is the difference between \"/\" and \"//\"?",
        "answer": "Single Slash \"/\" - A single slash is used to create an Xpath with an absolute path, i.e., the XPath will begin with the document node/start node. For example, Single Slash \"/\" - A single slash is used to create an Xpath with an absolute path, i.e., the XPath will begin with the document node/start node. For example, Single Slash \"/\" Absolute XPath: /html/body/div/div/form/input Absolute XPath: /html/body/div/div/form/input Here, /html is the root html node. Double Slash \"//\" - The double slash is used to construct an Xpath with a relative path, which means the XPath can start selection from anywhere on the page. For example, Double Slash \"//\" - The double slash is used to construct an Xpath with a relative path, which means the XPath can start selection from anywhere on the page. For example, Double Slash \"//\" Relative XPath: //input[@id = 'email'] Relative XPath: //input[@id = 'email'] Here, we can locate an input having id = ‘email’ present anywhere in the document object model (DOM).",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "12. What is the difference between the commands \"type\" and \"typeAndWait\" in the context of Selenium?",
        "answer": "The \"type\" command is used to enter keyboard key values into a software web application's text box. It can also be used to choose values from a combo box, whereas the \"typeAndWait\" command is used when you finish typing and the software web page begins to reload. This command will wait for the page of the software program to reload before proceeding. You must use a basic \"type\" command if there is no page reload event when typing.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "13. Differentiate between findElement() and findElements() in the context of Selenium with proper examples.",
        "answer": "Following table lists the differences between findElement() and findElements() in Selenium: findElement() findElements()\nThe first web element that matches the locator is returned. It gives you a list of all the web items that match the locator.\nIf there are no matching web elements, a NoSuchElementException is produced. If there are no matching elements, an empty list is returned.\nSyntax − WebElement button = webdriver.findElement(By.name(\"<<Name value>>\")); Syntax − List<WebElement> buttons = webdriver.findElements(By.name(\"<<Name value>>\")); findElement() findElements()\nThe first web element that matches the locator is returned. It gives you a list of all the web items that match the locator.\nIf there are no matching web elements, a NoSuchElementException is produced. If there are no matching elements, an empty list is returned.\nSyntax − WebElement button = webdriver.findElement(By.name(\"<<Name value>>\")); Syntax − List<WebElement> buttons = webdriver.findElements(By.name(\"<<Name value>>\")); findElement() findElements() findElement() findElements() findElement() findElements() The first web element that matches the locator is returned. It gives you a list of all the web items that match the locator.\nIf there are no matching web elements, a NoSuchElementException is produced. If there are no matching elements, an empty list is returned.\nSyntax − WebElement button = webdriver.findElement(By.name(\"<<Name value>>\")); Syntax − List<WebElement> buttons = webdriver.findElements(By.name(\"<<Name value>>\")); The first web element that matches the locator is returned. It gives you a list of all the web items that match the locator. The first web element that matches the locator is returned. It gives you a list of all the web items that match the locator. If there are no matching web elements, a NoSuchElementException is produced. If there are no matching elements, an empty list is returned. If there are no matching web elements, a NoSuchElementException is produced. If there are no matching elements, an empty list is returned. Syntax − WebElement button = webdriver.findElement(By.name(\"<<Name value>>\")); Syntax − List<WebElement> buttons = webdriver.findElements(By.name(\"<<Name value>>\")); Syntax − WebElement button = webdriver.findElement(By.name(\"<<Name value>>\")); WebElement button = webdriver.findElement(By.name(\"<<Name value>>\")); Syntax − List<WebElement> buttons = webdriver.findElements(By.name(\"<<Name value>>\")); List<WebElement> buttons = webdriver.findElements(By.name(\"<<Name value>>\")); Using findElements():- Using findElements():- findElements() // JAVA\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.util.concurrent.TimeUnit;\npublic class findElements {\n  public static void main(String[] args) {\n     System.setProperty(\"webdriver.chrome.driver\", \"C:\\\\Users\\\\vaibhav\\\\Desktop\\\\Java\\\\chromedriver.exe\");\n     WebDriver driver = new ChromeDriver();\n     String url = \"https://www.exampleurl.com/example.htm\";\n     driver.get(url);\n     driver.manage().window().maximize();\n     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n     \n     List<WebElement> rows = driver.findElements(By.xpath(\"//table/tbody/tr[2]/td\")); // xpath with index appended to get the values from the row 1of table using findElements(), which returns a list\n     System.out.println(\"The number of values in row 2 is \"+ rows.size());\n     driver.close();\n  }\n} // JAVA\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.util.concurrent.TimeUnit;\npublic class findElements {\n  public static void main(String[] args) {\n     System.setProperty(\"webdriver.chrome.driver\", \"C:\\\\Users\\\\vaibhav\\\\Desktop\\\\Java\\\\chromedriver.exe\");\n     WebDriver driver = new ChromeDriver();\n     String url = \"https://www.exampleurl.com/example.htm\";\n     driver.get(url);\n     driver.manage().window().maximize();\n     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n     \n     List<WebElement> rows = driver.findElements(By.xpath(\"//table/tbody/tr[2]/td\")); // xpath with index appended to get the values from the row 1of table using findElements(), which returns a list\n     System.out.println(\"The number of values in row 2 is \"+ rows.size());\n     driver.close();\n  }\n} // JAVA import import import import import import public class findElements class findElements public static void main(String[] args) public static void main (String[] args) \"webdriver.chrome.driver\" \"C:\\\\Users\\\\vaibhav\\\\Desktop\\\\Java\\\\chromedriver.exe\" new \"https://www.exampleurl.com/example.htm\" 10 \"//table/tbody/tr[2]/td\" // xpath with index appended to get the values from the row 1of table using findElements(), which returns a list \"The number of values in row 2 is \" Explanation - In the above code, first of all, we import all the necessary headers and then set up the driver for the chrome browser. We use the findElements() method to find all the values present in the 2nd row of a table in the given URL web page using the XPath of the element. Explanation - findElements() Using findElement() :- Using findElement() :- findElement() import org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.util.concurrent.TimeUnit;\npublic class findTagname {\n  public static void main(String[] args) {\n     System.setProperty(\"webdriver.chrome.driver\",    \"C:\\\\Users\\\\vaibhav\\\\Desktop\\\\Java\\\\chromedriver.exe\");\n     WebDriver driver = new ChromeDriver();\n     String url = \"https://www.exampleurl.com/example.htm\";\n     driver.get(url);\n     driver.manage().timeouts().implicitlyWait(12, TimeUnit.SECONDS);\n     driver.findElement(By.cssSelector(\"input[id='search']\")).sendKeys(\"Selenium\"); //Using id tagname attribute combination for css expression and get the element from findElement()\n     driver.close();\n  }\n} import org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport java.util.concurrent.TimeUnit;\npublic class findTagname {\n  public static void main(String[] args) {\n     System.setProperty(\"webdriver.chrome.driver\",    \"C:\\\\Users\\\\vaibhav\\\\Desktop\\\\Java\\\\chromedriver.exe\");\n     WebDriver driver = new ChromeDriver();\n     String url = \"https://www.exampleurl.com/example.htm\";\n     driver.get(url);\n     driver.manage().timeouts().implicitlyWait(12, TimeUnit.SECONDS);\n     driver.findElement(By.cssSelector(\"input[id='search']\")).sendKeys(\"Selenium\"); //Using id tagname attribute combination for css expression and get the element from findElement()\n     driver.close();\n  }\n} import import import import import import public class findTagname class findTagname public static void main(String[] args) public static void main (String[] args) \"webdriver.chrome.driver\" \"C:\\\\Users\\\\vaibhav\\\\Desktop\\\\Java\\\\chromedriver.exe\" new \"https://www.exampleurl.com/example.htm\" 12 \"input[id='search']\" \"Selenium\" //Using id tagname attribute combination for css expression and get the element from findElement() Explanation - In the above code, first of all, we import all the necessary headers and then set up the driver for the chrome browser. We use the findElement() method to find an input element having an id attribute set as search. Explanation",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "14. In Selenium, how will you wait until a web page has been loaded completely?",
        "answer": "There are two methods of making sure that the web page has been loaded completely in Selenium. They are as follows: 1. Immediately after creating the webdriver instance, set an implicit wait: temp = driver.Manage().Timeouts().ImplicitWait; temp = driver.Manage().Timeouts().ImplicitWait; On every page navigation or reload, this will try to wait until the page is fully loaded. 2. Call JavaScript return document.readyState till \"complete\" is returned after page navigation. As a JavaScript executor, the web driver instance can be used. Code example: new WebDriverWait(firefoxDriver, pageLoadTimeout).until(\n     webDriver -> ((JavascriptExecutor) webDriver).executeScript(\"return document.readyState\").equals(\"complete\")); new WebDriverWait(firefoxDriver, pageLoadTimeout).until(\n     webDriver -> ((JavascriptExecutor) webDriver).executeScript(\"return document.readyState\").equals(\"complete\"));",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "15. What is Selenium WebDriver?",
        "answer": "Selenium WebDriver, also known as Selenium 2, is a browser automation framework that accepts and sends commands to a browser to implement it. It has direct control over the browser because it communicates with it directly. Java, C#, PHP, Python, Perl, and Ruby are all supported by Selenium WebDriver.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "16. Is Selenium WebDriver a library?",
        "answer": "Selenium WebDriver is a prominent free open-source library for automating browsers and testing web applications.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "17. Is Selenium WebDriver an interface or a class?",
        "answer": "Selenium WebDriver is usually a set of methods defined by an interface. The browser-specific classes, on the other hand, provide an implementation of it by extending a class. AndroidDriver, ChromeDriver, FirefoxDriver, InternetExplorerDriver, SafariDriver, and others are some of the implementation classes.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "18. What are the different types of WebDriver Application Programming Interfaces in Selenium?",
        "answer": "The Various Types of WebDriver APIs in Selenium are as follows: Types of WebDriver APIs Opera Driver\nInternetExplorer Driver\nChrome Driver\nSafari Driver\nAndroid Driver\nFirefox Driver\nGecko Driver\niPhone Driver\nEventFiringWebDriver\nHTMLUnit Driver. Opera Driver InternetExplorer Driver Chrome Driver Safari Driver Android Driver Firefox Driver Gecko Driver iPhone Driver EventFiringWebDriver HTMLUnit Driver.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "19. What programming languages does Selenium WebDiver support?",
        "answer": "The various programming languages that Selenium WebDriver supports are as follows: Java\nC#\nPython\nRuby\nPerl\nPHP Java C# Python Ruby Perl PHP",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "20. What open-source frameworks does Selenium WebDriver support?",
        "answer": "The following are the open-source frameworks supported by the Selenium WebDriver: TestNG:\nCédric Beust designed TestNG, a testing framework for the Java programming language that was influenced by JUnit and NUnit.\nTestNG was created with the purpose of covering a wider range of test categories, including unit, functional, end-to-end, integration, and so on, with more robust and user-friendly functions.\nJUnit:\nIt is used for Unit Testing of various types of applications. TestNG:\nCédric Beust designed TestNG, a testing framework for the Java programming language that was influenced by JUnit and NUnit.\nTestNG was created with the purpose of covering a wider range of test categories, including unit, functional, end-to-end, integration, and so on, with more robust and user-friendly functions. TestNG: Cédric Beust designed TestNG, a testing framework for the Java programming language that was influenced by JUnit and NUnit.\nTestNG was created with the purpose of covering a wider range of test categories, including unit, functional, end-to-end, integration, and so on, with more robust and user-friendly functions. Cédric Beust designed TestNG, a testing framework for the Java programming language that was influenced by JUnit and NUnit. TestNG was created with the purpose of covering a wider range of test categories, including unit, functional, end-to-end, integration, and so on, with more robust and user-friendly functions. JUnit:\nIt is used for Unit Testing of various types of applications. JUnit: It is used for Unit Testing of various types of applications. It is used for Unit Testing of various types of applications.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "21. What is WebDriver's super interface?",
        "answer": "SearchContext is the Super Interface of the WebDriver. SearchContext",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "22. Explain the following line of code.",
        "answer": "Webdriver driver = new FirefoxDriver(); Webdriver driver = new FirefoxDriver(); 'WebDriver' is an interface, and we are generating a WebDriver object by instantiating a FirefoxDriver object (This object uses Firefox Driver to link the test cases with the Firefox browser).",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "23. Is it necessary to use Selenium Server to run Selenium WebDriver scripts?",
        "answer": "Selenium Server is required when distributing Selenium WebDriver scripts for execution with Selenium Grid. Selenium Grid is a Selenium functionality that allows you to execute test cases on multiple machines on various platforms. You wish to execute your test cases on a remote machine because your local machine is running numerous applications. You will need to set up the remote server so that the test cases can run on it.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "24. What will happen if I execute this command? driver.get(“www.interviewbit.com”) ;",
        "answer": "An exception is triggered if the URL does not begin with http or https. As a result, the HTTP protocol must be sent to the driver.get() method. driver.get()",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "25. What is an alternative option to driver.get() method to open an URL in Selenium Web Driver?",
        "answer": "driver.navigate() can be used instead. It is used for navigating forwards and backwards in a browser. driver.navigate()",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "26. What is the difference between driver.get() and driver.navigate.to(“url”)?",
        "answer": "The difference between the two is as follows: driver.get(): To open a URL and have it wait for the entire page to load.\ndriver.navigate.to(): To navigate to a URL without having to wait for the entire page to load. driver.get(): To open a URL and have it wait for the entire page to load. driver.get() driver.navigate.to(): To navigate to a URL without having to wait for the entire page to load. driver.navigate.to()",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "27. What are the differences between the methods driver.close() and driver.quit()?",
        "answer": "The functions of these two methods (driver.close and driver.quit) are nearly identical. Although both allow us to close a browser, there is a distinction. driver.close driver.quit To close the current WebDriver instance, use driver.close().\nTo close all open WebDriver instances, use driver.quit(). To close the current WebDriver instance, use driver.close(). driver.close() To close all open WebDriver instances, use driver.quit(). driver.quit()",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "28. What are some cases that Selenium WebDriver cannot automate?",
        "answer": "Some of the scenarios which we cannot automate are as follows: Selenium WebDriver does not support bitmap comparison.\nUsing Selenium WebDriver to automate Captcha is not possible.\nUsing Selenium WebDriver, we are unable to read bar codes.\nVideo streaming scenarios: Selenium will almost never be able to recognise video controllers. To some extent, JavaScript Executor and flex UI selenium will work, although they are not completely dependable.\nPerformance testing can be automated, however, it's preferable to avoid using Selenium for performance testing. Selenium WebDriver does not support bitmap comparison. Using Selenium WebDriver to automate Captcha is not possible. Using Selenium WebDriver, we are unable to read bar codes. Video streaming scenarios: Selenium will almost never be able to recognise video controllers. To some extent, JavaScript Executor and flex UI selenium will work, although they are not completely dependable. Performance testing can be automated, however, it's preferable to avoid using Selenium for performance testing.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "29. In Selenium WebDriver, what is an Object Repository?",
        "answer": "Instead of hard-coding element locator data in the scripts, the Object Repository is used to store the element locator data in a centralized location. To store all of the element locators, we create a property file (.properties), which acts as an object repository in Selenium WebDriver.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "1. State the major difference between “assert” and “verify” commands in Selenium.",
        "answer": "Both “assert” and “verify” commands check whether the given condition is true or false and the only difference between them is that: Assert: Assert condition stops the execution of the testing if the given condition is false else would continue with the further tests.\nVerify: Verify the condition doesn’t stop the flow of execution irrespective of the condition being true or false. Assert: Assert condition stops the execution of the testing if the given condition is false else would continue with the further tests. Assert: Verify: Verify the condition doesn’t stop the flow of execution irrespective of the condition being true or false. Verify:",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "2. Explain the same-origin policy and how Selenium handles it?",
        "answer": "The same Origin policy is a feature adopted for security purposes that allows a web browser to run scripts from one webpage to access the contents of another webpage provided both pages have the same origin. The URL scheme, hostname, and port number combo are referred to as the origin. This policy was introduced to prevent access to sensitive data on one webpage by another for ill purposes. Consider a Java program used by scaler.com, the program can access domain pages like scaler.com/mentors, scaler.com/courses but none from different domains like facebook.com.   The Selenium Server (Selenium RC) acts as a client-configured HTTP proxy and \"tricks\" the browser into believing that Selenium Core and the web application being tested come from the same origin.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "3. Explain the pause feature in Selenium IDE.",
        "answer": "The pause feature is built to handle exceptions in the test script by allowing the user to pause at the statement causing the exception and enter the debug mode by clicking on the pause icon on the top right corner of the IDE. This feature prevents the entire test case's failure and gives the user a chance to correct the error instantly.  ",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "4. With the help of code snippets, explain how we can create right-click and mouse hover actions in Selenium.",
        "answer": "The following code can replicate right-click action: actions action = newActions(driver);\nWebElement element = driver.findElement(By.id(\"elementId\")); \naction.contextClick(element).perform(); actions action = newActions(driver);\nWebElement element = driver.findElement(By.id(\"elementId\")); \naction.contextClick(element).perform(); The following code can replicate the mouse hover action: actions action = newActions(driver);\nWebElement element = driver.findElement(By.id(\"elementId\"));\naction.moveToElement(element).perform(); actions action = newActions(driver);\nWebElement element = driver.findElement(By.id(\"elementId\"));\naction.moveToElement(element).perform();",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "5. Can we handle a windows-based pop-up in Selenium, and if not, then what are the alternatives?",
        "answer": "No, Selenium doesn’t support windows-based pop-ups as it’s an automated testing tool built for web application-based testing. However, with the support of third-party tools like AutoIT, Robot class, etc., windows-based pop-ups can be handled in selenium.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "6. Can you capture a screenshot using Selenium? If yes, write a simple code to illustrate the same.",
        "answer": "Yes, using a web driver in Selenium, we can capture the screenshot. Following is the code to do the same: import org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.File;\nimport java.io.IOException;\nimport org.apache.commons.io.FileUtils;\nimport org.openqa.selenium.OutputType;\nimport org.openqa.selenium.TakesScreenshot;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.firefox.FirefoxDriver;\npublic class TakeScreenshot {\nWebDriver drv;\n   @ Before\n   public void setUp() throws Exception {\n   driver = new FirefoxDriver();\n   drv.get(\"https://google.com\");\n}\n   @ After\n   public void tearDown() throws Exception {\n   drv.quit();\n   }\n   @ Test\n   public void test() throws IOException {\n   // Capture the screenshot\n   File scrFile = ((TakeScreenshot)drv).getScreenshotAs(OutputType.FILE);\n   // Code for pasting screenshot to a user-specified location\n   FileUtils.copyFile(scrFile, new File(\"C:\\\\Screenshot\\\\Scr.jpg\"))\n   }\n} import org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport java.io.File;\nimport java.io.IOException;\nimport org.apache.commons.io.FileUtils;\nimport org.openqa.selenium.OutputType;\nimport org.openqa.selenium.TakesScreenshot;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.firefox.FirefoxDriver;\npublic class TakeScreenshot {\nWebDriver drv;\n   @ Before\n   public void setUp() throws Exception {\n   driver = new FirefoxDriver();\n   drv.get(\"https://google.com\");\n}\n   @ After\n   public void tearDown() throws Exception {\n   drv.quit();\n   }\n   @ Test\n   public void test() throws IOException {\n   // Capture the screenshot\n   File scrFile = ((TakeScreenshot)drv).getScreenshotAs(OutputType.FILE);\n   // Code for pasting screenshot to a user-specified location\n   FileUtils.copyFile(scrFile, new File(\"C:\\\\Screenshot\\\\Scr.jpg\"))\n   }\n}",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "7. Explain different types of framework and connection of Selenium with Robot Framework.",
        "answer": "The following are the different types of frameworks: Behavior-Driven Development Framework: This type of framework provides a readable and easily understandable format to Business Analysts, Developers, Testers, etc.\nData-Driven Testing Framework: This type of framework helps separate test data from the test-script logic by storing test data in some external database in the form of key-value pairs. These keys can be used for accessing as well as populating data into the test scripts.\nKeyword-Driven Testing Framework: This type of framework is an extension of the data-driven testing framework. In addition to separating test data and the test-script logic, it also separates a part of the test script code by storing it in an external data file.\nLibrary Architecture Testing Framework: This type of framework groups common steps into functions under a library and calls these functions as and when required.\nModule-Based Testing Framework: This type of framework divides each test application into several isolated and logical modules, with each module having its distinct test script.\nHybrid Testing Framework: This type of framework is a combination of the above-mentioned frameworks leveraging all their good features. Behavior-Driven Development Framework: This type of framework provides a readable and easily understandable format to Business Analysts, Developers, Testers, etc. Behavior-Driven Development Framework: Data-Driven Testing Framework: This type of framework helps separate test data from the test-script logic by storing test data in some external database in the form of key-value pairs. These keys can be used for accessing as well as populating data into the test scripts. Data-Driven Testing Framework: Keyword-Driven Testing Framework: This type of framework is an extension of the data-driven testing framework. In addition to separating test data and the test-script logic, it also separates a part of the test script code by storing it in an external data file. Keyword-Driven Testing Framework: Library Architecture Testing Framework: This type of framework groups common steps into functions under a library and calls these functions as and when required. Library Architecture Testing Framework: Module-Based Testing Framework: This type of framework divides each test application into several isolated and logical modules, with each module having its distinct test script. Module-Based Testing Framework: Hybrid Testing Framework: This type of framework is a combination of the above-mentioned frameworks leveraging all their good features. Hybrid Testing Framework: Robot Framework is a modular open-source automation framework that can interact with 3rd party libraries and functions. To execute a web testing library such as Selenium, a test automation runner or an automation wrapper is required, which is provided to it in the form of Robot Framework. Other popular test runners to serve the same purpose are MSTest, TestNG, Nunit, Junit, etc. Robot Framework Robot Framework The below diagram shows the connection of the Robot framework to the Selenium library:  ",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "8. Demonstrate usage of Selenium through a test application.",
        "answer": "You need the following prerequisites to run a demo Selenium test script: Java SDK in your respective Operating System.\nA Java-based IDE such as Eclipse or IntelliJ.\nA Selenium WebDriver is to be added as a dependency to Java IDE. Java SDK in your respective Operating System. Java SDK A Java-based IDE such as Eclipse or IntelliJ. Java-based IDE A Selenium WebDriver is to be added as a dependency to Java IDE. Selenium WebDriver package scalerAcademy;\nimport org.openqa.selenium.firefox.FirefoxDriver;\nimport org.openqa.selenium.WebDriver;\npublic class MyFirstTestClass {\npublic static void main(String[] args) throws InterruptedException {\n//It sets the system property to the given value.\nSystem.setProperty(\"webdriver.gecko.driver\",\"D:\\\\Softwares\\\\geckodriver.exe”);        \nWebDriver driver = new FirefoxDriver();\n         driver.get(\"https://www.google.com/\");\n         //Launch website in the browser \n         driver.manage().window().maximize();\n //The sleep pauses the execution of the thread for 5000 ms.\n         Thread.sleep(5000);\n         driver.quit();\n }\n} package scalerAcademy;\nimport org.openqa.selenium.firefox.FirefoxDriver;\nimport org.openqa.selenium.WebDriver;\npublic class MyFirstTestClass {\npublic static void main(String[] args) throws InterruptedException {\n//It sets the system property to the given value.\nSystem.setProperty(\"webdriver.gecko.driver\",\"D:\\\\Softwares\\\\geckodriver.exe”);        \nWebDriver driver = new FirefoxDriver();\n         driver.get(\"https://www.google.com/\");\n         //Launch website in the browser \n         driver.manage().window().maximize();\n //The sleep pauses the execution of the thread for 5000 ms.\n         Thread.sleep(5000);\n         driver.quit();\n }\n} package import import public class MyFirstTestClass class MyFirstTestClass public static void main(String[] args) throws InterruptedException public static void main (String[] args) throws //It sets the system property to the given value. \"webdriver.gecko.driver\" \"D:\\\\Softwares\\\\geckodriver.exe”);        \nWebDriver driver = new FirefoxDriver();\n         driver.get(\" //www.google.com/\"); //Launch website in the browser //The sleep pauses the execution of the thread for 5000 ms. 5000 Once you run the above script in a Java IDE, you’ll get the following execution logs displayed in your IDE window.  ",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "9. Explain basic steps of Selenium testing and its widely used commands via a practical application.",
        "answer": "Selenium testing can be divided into the following seven basic elements: 1. Creating an instance of a Webdriver: This is the first step for all the usages of a Selenium webdriver API. An instance of a webdriver interface is created using a constructor of a particular browser. This webdriver instance is used to invoke methods and access other interfaces. The following are the most commonly used commands for initializing a web driver: 1. Creating an instance of a Webdriver Firefox:\nWebDriver driver = new FirefoxDriver();\nChrome:\nWebDriver driver = new ChromeDriver();\nSafari Driver:\nWebDriver driver = new SafariDriver();\nInternet Explorer:\nWebDriver driver = new InternetExplorerDriver(); Firefox:\nWebDriver driver = new FirefoxDriver();\nChrome:\nWebDriver driver = new ChromeDriver();\nSafari Driver:\nWebDriver driver = new SafariDriver();\nInternet Explorer:\nWebDriver driver = new InternetExplorerDriver(); 2. Navigating to a webpage: The second step after initializing an instance of a webdriver, is to navigate to a particular webpage you want to test. The following are the most commonly used commands for webpage navigation: 2. Navigating to a webpage: Navigate to URL: \ndriver.get(“https://www.interviewbit.com”) \ndriver.navigateo.to(“https://www.interviewbit.com”)\nRefresh page:\ndriver.navigate().refresh()\nNavigate forward in browser history:\ndriver.navigate().forward()\nNavigate backward in browser history:\ndriver.navigate().backward() Navigate to URL: \ndriver.get(“https://www.interviewbit.com”) \ndriver.navigateo.to(“https://www.interviewbit.com”)\nRefresh page:\ndriver.navigate().refresh()\nNavigate forward in browser history:\ndriver.navigate().forward()\nNavigate backward in browser history:\ndriver.navigate().backward() 3. Locating an HTML element on the webpage: To interact with a web element and perform actions on it like clicking a button or entering text, we first need to locate the desired elements such as the button or the textbox on the web page. The following are the most commonly used commands for web element navigation: 3. Locating an HTML element on the webpage: Locating by ID:\ndriver.findElement(By.id(\"q\")).sendKeys(\"Selenium 3\");\nLocation by Name:\ndriver.findElement(By.name(\"q\")).sendKeys (\"Selenium 3\");\nLocation by Xpath:\ndriver.findElement(By.xpath(\"//input[@id==’q’])).sendKeys(\"Selenium 3\");\nLocating Hyperlinks by Link Text:\ndriver.FindElement(By.LinkText(\"edit this page\")).Click();\nLocating by ClassName\ndriver.findElement(By.className(\"profileheader\"));\nLocating by TagName\ndriver.findElement(By.tagName(\"select')).click();\nLocating by LinkText\ndriver.findElement(By.linkText(\"NextPage\")).click();\nLocating by PartialLinkText\ndriverlindElement(By.partialLinkText(\" NextP\")).click(); Locating by ID:\ndriver.findElement(By.id(\"q\")).sendKeys(\"Selenium 3\");\nLocation by Name:\ndriver.findElement(By.name(\"q\")).sendKeys (\"Selenium 3\");\nLocation by Xpath:\ndriver.findElement(By.xpath(\"//input[@id==’q’])).sendKeys(\"Selenium 3\");\nLocating Hyperlinks by Link Text:\ndriver.FindElement(By.LinkText(\"edit this page\")).Click();\nLocating by ClassName\ndriver.findElement(By.className(\"profileheader\"));\nLocating by TagName\ndriver.findElement(By.tagName(\"select')).click();\nLocating by LinkText\ndriver.findElement(By.linkText(\"NextPage\")).click();\nLocating by PartialLinkText\ndriverlindElement(By.partialLinkText(\" NextP\")).click(); 4. Performing actions on an HTML element: Once we have located the HTML element, the next step is interacting with it. The following are the most commonly used commands for performing actions on an HTML elements: 4. Performing actions on an HTML element: Entering a username\nusernameElement.sendKeys(\"InterviewBit\");\nEntering a password\npasswordElement.sendKeys(\"Raw\");\nSubmitting a text input element\npasswordElement.submit();\nSubmitting a form element:\nformElement.submit(); Entering a username\nusernameElement.sendKeys(\"InterviewBit\");\nEntering a password\npasswordElement.sendKeys(\"Raw\");\nSubmitting a text input element\npasswordElement.submit();\nSubmitting a form element:\nformElement.submit(); 5. Anticipating browser response from the action: Once an action is performed, anticipating a response from the browser to test comes under this step. It takes a second or two for the action to reach the browser, and hence wait is often required for this step. There are two main types of wait conditions: 5. Anticipating browser response from the action: Implicit Wait: It sets a fixed, definite time for all the webdriver interactions. It’s slightly unreliable as web driver response times are usually unpredictable. Eg: Implicit Wait: driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); Explicit Wait: This type of wait condition sets an expected condition to occur on the web page or a maximum wait time for all the webdriver interactions. Eg: Explicit Wait: WebElement messageElement = wait.until(      ExpectedConditions.presenceOfElementLocated(By.id(\"loginResponse\")) ); WebElement messageElement = wait.until(      ExpectedConditions.presenceOfElementLocated(By.id(\"loginResponse\")) ); 6. Running tests and recording their results using a test framework: in this step, we run tests in an automated test script to evaluate an application's function and performance. Various test frameworks are used for this step, such as: 6. Running tests and recording their results using a test framework: JUnit for Java\nNUnit for C#\nUnittest or Pyunit for Python\nRUnit for Ruby JUnit for Java NUnit for C# Unittest or Pyunit for Python RUnit for Ruby Most frameworks use some sort of asset statement to verify their test results from the expected results. Eg: assertEquals (expectedMessage, actualMessage); assertEquals (expectedMessage, actualMessage); 7. Concluding a test: In this step, we conclude a test by invoking a quit method on the driver variable. This step closes all the webpages, quits the WebDriver server, and releases the driver. Eg: 7. Concluding a test: driver.quit(); driver.quit(); The following is an example of an app that covers all the steps mentioned above: import org.openqa.selenium.By,\nimport org.openqa.selenium.WebElement,\nimport org.openqa.selenium.support.ni.ExpectedConditiof, import org.openqa.selenium.support.ni.WebOriverWait,\nimport org.junit.Assert;\npublic class Example {\npublic static void main(String[] args) {\n// Creating a driver instance\nWebDriver driver = new FirefoxDriver(),\n// Navigate to a web page\n­driver.get(\"http://www.foo.com\");\n// Enter text to submit the form\nWebElement usernameElement = driver.findElement( By.name(\"username\"));\nWebElement passwordElement = driver.findElement(By.name(”password\"));\nWebElement formElement = driver.findElement(By.id(”loginForm\"));\nusernameElement.sendKeys(\"Scaler Academy\");\npasswordElement.sendKeys(\"Raw\");\nformElement.submit();      // submit by form element\n\n//Putting an explicit wait\nWebDriverWait wait = new WebDriverWait(driver, 10);\nWebElement messageElement = wait.until(\n      ExpectedConditions.presenceofElementLocated(By.id(”loginResponse\")) \n      ) ;\n// Run a test\nString message              = messageElement.getrept();\nString successMsg      = \"Welcome to foo. You logged in successfully.”;\nAssert.assertEquals (message, successMsg);\n// Conclude a test\ndriver.quit();\n}\n} import org.openqa.selenium.By,\nimport org.openqa.selenium.WebElement,\nimport org.openqa.selenium.support.ni.ExpectedConditiof, import org.openqa.selenium.support.ni.WebOriverWait,\nimport org.junit.Assert;\npublic class Example {\npublic static void main(String[] args) {\n// Creating a driver instance\nWebDriver driver = new FirefoxDriver(),\n// Navigate to a web page\n­driver.get(\"http://www.foo.com\");\n// Enter text to submit the form\nWebElement usernameElement = driver.findElement( By.name(\"username\"));\nWebElement passwordElement = driver.findElement(By.name(”password\"));\nWebElement formElement = driver.findElement(By.id(”loginForm\"));\nusernameElement.sendKeys(\"Scaler Academy\");\npasswordElement.sendKeys(\"Raw\");\nformElement.submit();      // submit by form element\n\n//Putting an explicit wait\nWebDriverWait wait = new WebDriverWait(driver, 10);\nWebElement messageElement = wait.until(\n      ExpectedConditions.presenceofElementLocated(By.id(”loginResponse\")) \n      ) ;\n// Run a test\nString message              = messageElement.getrept();\nString successMsg      = \"Welcome to foo. You logged in successfully.”;\nAssert.assertEquals (message, successMsg);\n// Conclude a test\ndriver.quit();\n}\n}",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "10. What do you understand about the Page Object Model in the context of Selenium? What are its advantages?",
        "answer": "Page Object Model (POM) is a design pattern that generates an Object Repository for web UI elements and is widely used in test automation. The paradigm has the advantage of reducing code duplication and improving test maintenance. According to this paradigm, each web page in the application should have its own Page Class. This Page class will identify the web page's WebElements and also has Page methods that operate on those WebElements. The names of these methods should correspond to the tasks they perform, for example, if a loader is waiting for the payment gateway to appear, the POM method name could be waitForPaymentScreenDisplay(). waitForPaymentScreenDisplay() The following are the advantages of the Page Object Model (POM) : According to the Page Object Design Pattern, user interface activities and flows should be separated from verification. Our code is clearer and easier to understand as a result of this notion.\nThe second advantage is that the object repository is independent of test cases, allowing us to reuse the same object repository with different tools. For example, we can use Selenium to combine Page Object Model with TestNG/JUnit for functional testing and JBehave/Cucumber for acceptability testing.\nBecause of the reusable page methods in the POM classes, code gets less and more efficient.\nMethods are given more realistic names that can be easily associated with the UI operation. If we land on the home page after clicking the button, the function name will be 'gotoHomePage()'. According to the Page Object Design Pattern, user interface activities and flows should be separated from verification. Our code is clearer and easier to understand as a result of this notion. The second advantage is that the object repository is independent of test cases, allowing us to reuse the same object repository with different tools. For example, we can use Selenium to combine Page Object Model with TestNG/JUnit for functional testing and JBehave/Cucumber for acceptability testing. Because of the reusable page methods in the POM classes, code gets less and more efficient. Methods are given more realistic names that can be easily associated with the UI operation. If we land on the home page after clicking the button, the function name will be 'gotoHomePage()'.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "11. What is Jenkins and what are the benefits of using it with Selenium?",
        "answer": "Hudson Lab's Jenkins is the most popular open-source continuous integration technology. It's cross-platform, meaning it can run on Windows, Linux, Mac OS, and Solaris. Jenkins is a Java application. Jenkin's main purpose is to keep track of any job, such as SVN (Apache Subversion) checkouts, cron jobs, or application states. When a specific event in an application occurs, it triggers pre-configured actions. Learn More. Learn More Learn More   The following are the features of Jenkins: features of Jenkins Jenkins generates a list of all changes made in SVN repositories, for example.\nJenkins gives permanent links to the most recent build or failed build, which can be utilized for convenient communication.\nJenkins is simple to install using either a direct installation file (exe) or a war file for deployment via the application server.\nJenkins can be set up to send the content of the build status to an email address.\nSimple Configuration: Jenkins makes it simple to set up multiple tasks.\nJenkins can be configured to run the automated test build on TestNg following every SVN build.\nJenkins documents the details of the jar, its version, and the mapping of build and jar numbers.\nPlugins: Jenkins can be set to utilize features and additional functionality provided by third-party plugins. Jenkins generates a list of all changes made in SVN repositories, for example. Jenkins gives permanent links to the most recent build or failed build, which can be utilized for convenient communication. Jenkins is simple to install using either a direct installation file (exe) or a war file for deployment via the application server. Jenkins can be set up to send the content of the build status to an email address. Simple Configuration: Jenkins makes it simple to set up multiple tasks. Jenkins can be configured to run the automated test build on TestNg following every SVN build. Jenkins documents the details of the jar, its version, and the mapping of build and jar numbers. Plugins: Jenkins can be set to utilize features and additional functionality provided by third-party plugins. Following are the reasons we use Jenkins with Selenium: use Jenkins with Selenium When you run Selenium tests in Jenkins, you can run them every time your program changes, and when the tests pass, you may deploy the software to a new environment.\nJenkins may execute your tests at a predetermined time.\nThe execution history as well as the Test Reports can be saved.\nJenkins allows you to develop and test a project in continuous integration using Maven. When you run Selenium tests in Jenkins, you can run them every time your program changes, and when the tests pass, you may deploy the software to a new environment. Jenkins may execute your tests at a predetermined time. The execution history as well as the Test Reports can be saved. Jenkins allows you to develop and test a project in continuous integration using Maven.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "12. How will you select a date from a datepicker in a webpage using Selenium for automated testing? Explain with a proper code.",
        "answer": "In such types of questions, the interviewer wants to assess how clear your understanding is of the framework. It is a good practice to explain the code while you write it so that the interviewer is engaged at all points and does not feel left out. We will be considering an example on MakeMyTrip.   Here, we will be using the chrome browser and so we will be implementing the code for the chrome browser only. You can implement similar code for firefox and other browsers as well. First of all, we create a package named browserSelection which contains a class defined for handling different types of browsers such as chrome, firefox that we may want to use. package browserSelection;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\npublic class SelectBrowser \n{\n  static WebDriver driver;\n  public static WebDriver useChrome()\n  {\n     System.setProperty(\"webdriver.chrome.driver\", \"E:\\\\SeleniumLibs\\\\\\\\chromedriver_win32\\\\chromedriver.exe\"); \n     driver = new ChromeDriver(); \n     driver.manage().window().maximize();\n     return driver;\n  } \n} package browserSelection;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\npublic class SelectBrowser \n{\n  static WebDriver driver;\n  public static WebDriver useChrome()\n  {\n     System.setProperty(\"webdriver.chrome.driver\", \"E:\\\\SeleniumLibs\\\\\\\\chromedriver_win32\\\\chromedriver.exe\"); \n     driver = new ChromeDriver(); \n     driver.manage().window().maximize();\n     return driver;\n  } \n} Next, we create a package named datepicker which will contain a class containing methods defined for selecting a specific date on the website of MakeMyTrip. We need to import this package into our driver class and call the respective methods. package datepicker;\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.KeyEvent;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebDriverException;\nimport org.openqa.selenium.WebElement;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\nimport browserSelection.SelectBrowser;\npublic class DatePick \n{\n  WebDriver driver;\n  @BeforeMethod\n  public void startBrowser()\n  { \n     driver = SelectBrowser.useChrome(); \n  }\n  @Test\n  public void selectDateUtil() throws InterruptedException, AWTException\n  {\n     //Modify Wait time as per the Network Ability in the Thread Sleep method\n     driver.get(\"https://www.makemytrip.com/\"); \n     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n     Thread.sleep(5000);\n     try\n     {\n        driver.findElement(By.xpath(\"//input[@id='hp-widget__depart']\")).click();\n        Thread.sleep(2000);\n        Date sampleDate = new Date(); // initialising the date object with the current date \n        SimpleDateFormat formatter = new SimpleDateFormat(\"dd-MMM yyyy\");\n        String date = formatter.format(sampleDate); // formatting the date object in dd-MMM yyyy format\n        String splitter[] = date.split(\"-\");\n        String monthYear = splitter[1]; // storing the month and year concatenated string excluding the day number\n        String day = splitter[0]; // storing the day number in the current date\n        System.out.println(monthYear);\n        System.out.println(day);\n\n        selectDate(monthYear,day); // function invocation\n        Thread.sleep(3000);\n\n        public void selectDate(String monthYear, String select_day) throws InterruptedException\n        { \n           List<WebElement> elements = driver.findElements(By.xpath(\"//div[@class='ui-datepicker-title']/span[1]\"));\n           for (int i=0; i<elements.size();i++)\n           {\n              System.out.println(elements.get(i).getText());\n              //Selecting the month\n              if(elements.get(i).getText().equals(monthYear))\n              {\n                 //Selecting the date \n                 List<WebElement> days = driver.findElements(By.xpath(\"//div[@class='ui-datepicker-inline ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all ui-datepicker-multi ui-datepicker-multi-2']/div[2]/table/tbody/tr/td/a\"));\n                 for (WebElement d:days)\n                 { \n                    System.out.println(d.getText());\n                    if(d.getText().equals(select_day))\n                    {\n                       d.click();\n                       Thread.sleep(10000);\n                       return;\n                    }\n                 }\n              }\n           }\n           // if we do not find the matching month and year, we click on the arrow button to load new months.\n           driver.findElement(By.xpath(\"//div[@class='ui-datepicker-inline ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all ui-datepicker-multi ui-datepicker-multi-2']/div[2]/div/a/span\")).click();\n           selectDate(monthYear,select_day); // function invocation\n        }\n        @AfterMethod\n        public void endBrowser()\n        {\n           driver.quit();\n        }\n     }\n  }\n} package datepicker;\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.KeyEvent;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebDriverException;\nimport org.openqa.selenium.WebElement;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\nimport browserSelection.SelectBrowser;\npublic class DatePick \n{\n  WebDriver driver;\n  @BeforeMethod\n  public void startBrowser()\n  { \n     driver = SelectBrowser.useChrome(); \n  }\n  @Test\n  public void selectDateUtil() throws InterruptedException, AWTException\n  {\n     //Modify Wait time as per the Network Ability in the Thread Sleep method\n     driver.get(\"https://www.makemytrip.com/\"); \n     driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n     Thread.sleep(5000);\n     try\n     {\n        driver.findElement(By.xpath(\"//input[@id='hp-widget__depart']\")).click();\n        Thread.sleep(2000);\n        Date sampleDate = new Date(); // initialising the date object with the current date \n        SimpleDateFormat formatter = new SimpleDateFormat(\"dd-MMM yyyy\");\n        String date = formatter.format(sampleDate); // formatting the date object in dd-MMM yyyy format\n        String splitter[] = date.split(\"-\");\n        String monthYear = splitter[1]; // storing the month and year concatenated string excluding the day number\n        String day = splitter[0]; // storing the day number in the current date\n        System.out.println(monthYear);\n        System.out.println(day);\n\n        selectDate(monthYear,day); // function invocation\n        Thread.sleep(3000);\n\n        public void selectDate(String monthYear, String select_day) throws InterruptedException\n        { \n           List<WebElement> elements = driver.findElements(By.xpath(\"//div[@class='ui-datepicker-title']/span[1]\"));\n           for (int i=0; i<elements.size();i++)\n           {\n              System.out.println(elements.get(i).getText());\n              //Selecting the month\n              if(elements.get(i).getText().equals(monthYear))\n              {\n                 //Selecting the date \n                 List<WebElement> days = driver.findElements(By.xpath(\"//div[@class='ui-datepicker-inline ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all ui-datepicker-multi ui-datepicker-multi-2']/div[2]/table/tbody/tr/td/a\"));\n                 for (WebElement d:days)\n                 { \n                    System.out.println(d.getText());\n                    if(d.getText().equals(select_day))\n                    {\n                       d.click();\n                       Thread.sleep(10000);\n                       return;\n                    }\n                 }\n              }\n           }\n           // if we do not find the matching month and year, we click on the arrow button to load new months.\n           driver.findElement(By.xpath(\"//div[@class='ui-datepicker-inline ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all ui-datepicker-multi ui-datepicker-multi-2']/div[2]/div/a/span\")).click();\n           selectDate(monthYear,select_day); // function invocation\n        }\n        @AfterMethod\n        public void endBrowser()\n        {\n           driver.quit();\n        }\n     }\n  }\n} In the above code, the function startBrowser() is used to invoke the useChrome() method from the imported package browserSelection. The function selectDateUtil() is used to select the current date from the date picker of the sample web page. The endBrowser() function is used to close the driver connections by invoking the quit() method. startBrowser() useChrome() selectDateUtil() endBrowser() quit()",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "13. What do you understand about broken links? How can you detect broken links in Selenium? Explain properly with code.",
        "answer": "Links or URLs that are not reachable are known as broken links. They may be unavailable or inoperable due to a server issue. A URL's status will always be 2xx, indicating that it is legitimate. There are a variety of HTTP status codes, each with its own set of functions. HTTP status 4xx and 5xx indicate an invalid request. The 4xx class of status codes is used for client-side errors, while the 5xx class is used for server response errors.   You should always check for broken links on your site to ensure that the user does not end up on an error page. If the rules aren't updated appropriately, or the requested resources aren't available on the server, the error will occur. Manual link checking is a time-consuming task because each web page may have a huge number of links, and the process must be performed for each page. To find broken links in Selenium, follow the instructions below. Using the <a> (anchor) tag, collect all of the links on a web page.\nFor each link, send an HTTP request.\nMake that the HTTP response code is correct.\nBased on the HTTP response code, determine whether the link is genuine or not.\nRepeat the procedure for all of the links that were captured in the first step. Using the <a> (anchor) tag, collect all of the links on a web page. For each link, send an HTTP request. Make that the HTTP response code is correct. Based on the HTTP response code, determine whether the link is genuine or not. Repeat the procedure for all of the links that were captured in the first step. package SeleniumPackage;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.chrome.ChromeOptions;\npublic class BrokenLinks {\n   \n   public static void main(String[] args) {\n       \n       String pageURL = \"http://www.interviewbit.com\";\n       String url = \"\";\n       HttpURLConnection huc = null;\n       int responseCode = 200;\n       System.setProperty(\"webdriver.chrome.driver\", \"C:\\\\Users\\\\user\\\\Downloads\\\\selenium\\\\chromedriver_win32\\\\chromedriver.exe\");\n       ChromeOptions options = new ChromeOptions();\n       options.addArguments(\"--headless\", \"--disable-gpu\", \"--window-size=1920,1200\",\"--ignore-certificate-errors\", \"--silent\");\n       WebDriver driver = new ChromeDriver(options);//Creating an instance of the WebDriver class\n       \n       driver.manage().window().maximize();\n       \n       driver.get(pageURL);\n       \n       List<WebElement> links = driver.findElements(By.tagName(\"a\")); // getting hold of all the elements having the anchor tag\n       \n       Iterator<WebElement> it = links.iterator();\n       // Iterating over the obtained list of elements and checking them one by one\n       while(it.hasNext()){\n           \n           url = it.next().getAttribute(\"href\");\n           \n           System.out.println(url);\n       \n           if(url == null || url.isEmpty()){\n               System.out.println(\"The linked element has invalid href url.\");\n               continue;\n           }\n           \n           if(!url.startsWith(pageURL)){\n               System.out.println(\"URL belongs to another domain, skipping it.\");\n               continue;\n           }\n           \n           try {\n               huc = (HttpURLConnection)(new URL(url).openConnection());\n               \n               huc.setRequestMethod(\"HEAD\");\n               \n               huc.connect(); // connecting to the url\n               \n               responseCode = huc.getResponseCode(); // reading the response code on firing the url\n               \n               if(responseCode >= 400){\n                   System.out.println(url+\" is a broken link\");\n               }\n               else{\n                   System.out.println(url+\" is a valid link\");\n               }\n                   \n           } catch (MalformedURLException e) {\n               e.printStackTrace();\n           } catch (IOException e) {\n               e.printStackTrace();\n           }\n       }\n       \n       driver.quit();\n   }\n} package SeleniumPackage;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.chrome.ChromeOptions;\npublic class BrokenLinks {\n   \n   public static void main(String[] args) {\n       \n       String pageURL = \"http://www.interviewbit.com\";\n       String url = \"\";\n       HttpURLConnection huc = null;\n       int responseCode = 200;\n       System.setProperty(\"webdriver.chrome.driver\", \"C:\\\\Users\\\\user\\\\Downloads\\\\selenium\\\\chromedriver_win32\\\\chromedriver.exe\");\n       ChromeOptions options = new ChromeOptions();\n       options.addArguments(\"--headless\", \"--disable-gpu\", \"--window-size=1920,1200\",\"--ignore-certificate-errors\", \"--silent\");\n       WebDriver driver = new ChromeDriver(options);//Creating an instance of the WebDriver class\n       \n       driver.manage().window().maximize();\n       \n       driver.get(pageURL);\n       \n       List<WebElement> links = driver.findElements(By.tagName(\"a\")); // getting hold of all the elements having the anchor tag\n       \n       Iterator<WebElement> it = links.iterator();\n       // Iterating over the obtained list of elements and checking them one by one\n       while(it.hasNext()){\n           \n           url = it.next().getAttribute(\"href\");\n           \n           System.out.println(url);\n       \n           if(url == null || url.isEmpty()){\n               System.out.println(\"The linked element has invalid href url.\");\n               continue;\n           }\n           \n           if(!url.startsWith(pageURL)){\n               System.out.println(\"URL belongs to another domain, skipping it.\");\n               continue;\n           }\n           \n           try {\n               huc = (HttpURLConnection)(new URL(url).openConnection());\n               \n               huc.setRequestMethod(\"HEAD\");\n               \n               huc.connect(); // connecting to the url\n               \n               responseCode = huc.getResponseCode(); // reading the response code on firing the url\n               \n               if(responseCode >= 400){\n                   System.out.println(url+\" is a broken link\");\n               }\n               else{\n                   System.out.println(url+\" is a valid link\");\n               }\n                   \n           } catch (MalformedURLException e) {\n               e.printStackTrace();\n           } catch (IOException e) {\n               e.printStackTrace();\n           }\n       }\n       \n       driver.quit();\n   }\n} Explanation - In the above code, we first set up the system properties and then initialize a webdriver object. We find all the elements in the web page having the anchor tag with the help of the findElements() method. Then, we iterate over the list obtained one by one and fire up the URL and read the response code received to check if it is a broken link or not. Explanation findElements()",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "14. What do you understand about window handle in the context of automated testing? How can you handle multiple windows in Selenium?",
        "answer": "The window handle is a one-of-a-kind identifier that contains the addresses of all of the windows. Consider it a window pointer that returns the string value. Each browser will presumably have its own window handle. This window handle function aids in the retrieval of all window handles.\nSyntax:  get.windowhandle(): This function is used to retrieve the current window's handle.\nget.windowhandles(): This function is useful for retrieving the handles of all the windows that have been opened.\nset: This method allows you to set the window handles as a string. \nset<string> set= driver.get.windowhandles()\nswitch to: This method aids in the switching of windows.\naction: This method aids in the execution of specific window actions. get.windowhandle(): This function is used to retrieve the current window's handle. get.windowhandle() get.windowhandles(): This function is useful for retrieving the handles of all the windows that have been opened. get.windowhandles() set: This method allows you to set the window handles as a string. \nset<string> set= driver.get.windowhandles()  set<string> set= driver.get.windowhandles() switch to: This method aids in the switching of windows. action: This method aids in the execution of specific window actions. Let us consider an example code to understand better. We will open the website of InterviewBit and then click on all the links available on the web page. Then, we will switch from the parent window to multiple different child windows and then switch back to the parent window at last. package SeleniumPackage;\nimport java.util.Iterator; \nimport java.util.Set; \nimport org.openqa.selenium.By; \nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\npublic class WindowHandle_Demo { \n  public static void main(String[] args) throws Exception {\n\n     System.setProperty(\"webdriver.chrome.driver\", \"C:\\\\Users\\\\user\\\\Downloads\\\\selenium\\\\chromedriver_win32\\\\chromedriver.exe\");\n     WebDriver driver = new ChromeDriver();\n     driver.manage().window().maximize();\n     // Loading the website\n     driver.get(\"http://www.interviewbit.com/\");\n     String parent=driver.getWindowHandle(); // storing the parent window name as a string \n     List<WebElement> links = driver.findElements(By.tagName(\"a\")); // storing the list of all the elements having an anchor tag\n     Iterator<WebElement> it = links.iterator();\n     // Iterating over the list elements one by one and clicking all the links to open new child windows\n     while(it.hasNext()){\n        it.next().click();\n     }\n     Set<String> s = driver.getWindowHandles(); // Storing the list of all the child windows\n     Iterator<String> I1= s.iterator();\n     // Iterating over the list of child windows \n     while(I1.hasNext())\n     {\n        String child_window=I1.next();\n        if(!parent.equals(child_window))\n        {\n           driver.switchTo().window(child_window);\n           System.out.println(driver.switchTo().window(child_window).getTitle());\n           driver.close();\n        }\n     }\n     //switch to the parent window\n     driver.switchTo().window(parent);\n  }\n} package SeleniumPackage;\nimport java.util.Iterator; \nimport java.util.Set; \nimport org.openqa.selenium.By; \nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\npublic class WindowHandle_Demo { \n  public static void main(String[] args) throws Exception {\n\n     System.setProperty(\"webdriver.chrome.driver\", \"C:\\\\Users\\\\user\\\\Downloads\\\\selenium\\\\chromedriver_win32\\\\chromedriver.exe\");\n     WebDriver driver = new ChromeDriver();\n     driver.manage().window().maximize();\n     // Loading the website\n     driver.get(\"http://www.interviewbit.com/\");\n     String parent=driver.getWindowHandle(); // storing the parent window name as a string \n     List<WebElement> links = driver.findElements(By.tagName(\"a\")); // storing the list of all the elements having an anchor tag\n     Iterator<WebElement> it = links.iterator();\n     // Iterating over the list elements one by one and clicking all the links to open new child windows\n     while(it.hasNext()){\n        it.next().click();\n     }\n     Set<String> s = driver.getWindowHandles(); // Storing the list of all the child windows\n     Iterator<String> I1= s.iterator();\n     // Iterating over the list of child windows \n     while(I1.hasNext())\n     {\n        String child_window=I1.next();\n        if(!parent.equals(child_window))\n        {\n           driver.switchTo().window(child_window);\n           System.out.println(driver.switchTo().window(child_window).getTitle());\n           driver.close();\n        }\n     }\n     //switch to the parent window\n     driver.switchTo().window(parent);\n  }\n} In the above code, we open the landing page of interviewbit and then find all the elements having the anchor tag and click them to open multiple child windows. Then, we iterate over each of the child windows and print them as a string. Finally, having traversed over the entire list, we break from the loop and switch back to the parent window.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "1. In Selenium WebDriver, how do you handle Ajax calls?",
        "answer": "When using Selenium WebDriver, one of the most prevalent challenges is handling AJAX calls. We would have no way of knowing when the AJAX call would complete, and the page would be refreshed. In this tutorial, we'll look at how to use Selenium to handle AJAX calls. AJAX (Asynchronous JavaScript and XML) is an acronym for Asynchronous JavaScript and XML. AJAX allows a web page to obtain little quantities of data from the server without having to completely reload the page. Without reloading the page, AJAX sends HTTP requests from the client to the server and then processes the server's answer. Wait commands may not work with AJAX controls. It's only that the page itself is not going to refresh. The essential information may show on the web page without refreshing the browser when you click on a submit button. It may load in a fraction of a second, or it may take longer. We have no control over how long it takes for pages to load. In Selenium, the easiest way to deal with circumstances like this is to employ dynamic waits (i.e., WebDriverWait in combination with ExpectedCondition)\nThe following are some of the approaches that are available:  1. titleIs() – The anticipated condition looks for a specific title on a page. titleIs() wait.until(ExpectedConditions.titleIs(\"Big Sale of the Year\")); wait.until(ExpectedConditions.titleIs(\"Big Sale of the Year\")); 2. elementToBeClickable() – The desired condition requires that an element be clickable, which means that it must be present/displayed/visible on the screen and enabled. elementToBeClickable() wait.until(ExpectedConditions.elementToBeClickable(By.xpath(\"xpath\"))); wait.until(ExpectedConditions.elementToBeClickable(By.xpath(\"xpath\"))); 3. alertIsPresent() – The expected condition anticipates the appearance of an alert box. alertIsPresent() wait.until(ExpectedConditions.alertIsPresent())!=null); wait.until(ExpectedConditions.alertIsPresent())!=null); 4. textToBePresentInElement() – The anticipated condition looks for a string pattern in an element. textToBePresentInElement() wait.until(ExpectedConditions.textToBePresentInElement(By.id(\"text\"),\"text to be found\"); wait.until(ExpectedConditions.textToBePresentInElement(By.id(\"text\"),\"text to be found\");",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "2. How to create an Object Repository in your project?",
        "answer": "There is an Object Repository notion in QTP (Quick Test Professional). By default, when a user records a test, the objects and their properties are saved in an Object Repository. This Object Repository is used by QTP to playback scripts. There is no default Object Repository concept in Selenium. This isn't to say that Selenium doesn't have an Object Repository. Even if there isn't one by default, we could make our own. Quick Test Professional Objects are referred to as locators in Selenium (such as ID, Name, Class Name, Tag Name, Link Text, Partial Link Text, XPath, and CSS). A collection of objects is referred to as an object repository. Placing all the locators in a separate file is one technique to construct an Object Repository (i.e., properties file). The ideal method, however, is to use Page Object Model. Each web page is represented as a class in the Page Object Model Design Pattern. A class contains all of the items associated with a specific page of a web application.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "3. What are the different types of waits that WebDriver supports?",
        "answer": "  1. Implicit Wait: Implicit wait instructs Selenium to wait a specified amount of time before throwing a \"No such element\" exception (One of the WebDriver Exceptions is NoSuchElementException, which occurs when the locators indicated in the Selenium Program code is unable to locate the web element on the web page). 1. Implicit Wait: Before throwing an exception, the Selenium WebDriver is told to wait for a particular amount of time. WebDriver will wait for the element after this time has been set before throwing an exception. Implicit Wait is activated and remains active for the duration of the browser's open state. Its default setting is 0, and the following protocol must be used to define the specific wait duration. Its Syntax is as follows: driver.manage().timeouts().implicitlyWait(TimeOut, TimeUnit.SECONDS); driver.manage().timeouts().implicitlyWait(TimeOut, TimeUnit.SECONDS); 2. Explicit Wait:  Explicit wait tells the WebDriver to wait for specific conditions before throwing an \"ElementNotVisibleException\" exception. The Explicit Wait command tells the WebDriver to wait until a certain condition occurs before continuing to execute the code. Setting Explicit Wait is crucial in circumstances when certain items take longer to load than others. 2. Explicit Wait: If an implicit wait command is specified, the browser will wait the same amount of time before loading each web element. This adds to the time it takes to run the test script. Explicit waiting is smarter, but it can only be used for specific parts. It is, nonetheless preferable to implicit wait since it allows the programme to stop for dynamically loaded Ajax items. Its Syntax is as follows: WebDriverWait wait = new WebDriverWait(WebDriver Reference, TimeOut); WebDriverWait wait = new WebDriverWait(WebDriver Reference, TimeOut); 3. Fluent Wait: It is used to inform the WebDriver how long to wait for a condition and how often we want to check it before throwing an \"ElementNotVisibleException\" exception. In Selenium, Fluent Wait refers to the maximum amount of time that a Selenium WebDriver will wait for a condition (web element) to become visible. 3. Fluent Wait: It also specifies how often WebDriver will check for the presence of the condition before throwing the \"ElementNotVisibleException.\" To put it another way, Fluent Wait searches for a web element at regular intervals until it timeouts or the object is found. When engaging with site items that take longer to load, Fluent Wait instructions come in handy. This is a common occurrence with Ajax apps. It is possible to establish a default polling period while using Fluent Wait. During the polling time, the user can configure the wait to ignore any exceptions. Because they don't wait out the complete duration defined in the code, fluent waits are also known as Smart Waits. Its Syntax is as follows: Wait wait = new FluentWait(WebDriver reference).withTimeout(timeout, SECONDS).pollingEvery(timeout, SECONDS).ignoring(Exception.class); Wait wait = new FluentWait(WebDriver reference).withTimeout(timeout, SECONDS).pollingEvery(timeout, SECONDS).ignoring(Exception.class);",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "4. Mention the several types of navigation commands that can be used?",
        "answer": "The several types of navigation commands that can be used are as follows: navigate().to() - It is used for going to the specified URL.\ndriver.navigate().refresh() - The current page is refreshed using the driver.navigate().refresh() command.\ndriver.navigate().forward() - This command does the same function as clicking the browser's Forward Button. Nothing is accepted or returned by it.\ndriver.navigate()back() - This command does the same function as clicking the browser's Back Button. Nothing is accepted or returned by it. navigate().to() - It is used for going to the specified URL. navigate().to() driver.navigate().refresh() - The current page is refreshed using the driver.navigate().refresh() command. driver.navigate().refresh() driver.navigate().forward() - This command does the same function as clicking the browser's Forward Button. Nothing is accepted or returned by it. driver.navigate().forward() driver.navigate()back() - This command does the same function as clicking the browser's Back Button. Nothing is accepted or returned by it. driver.navigate()back()",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "5. How does a Selenium WebDriver interact with the browser?",
        "answer": "  On a high level, the Selenium webdriver communicates with the browser and does not transform commands into JavaScript. Our Java or Python code will be transmitted as an API get and post request in the JSON wire protocol. The browser webdriver interacts with the real browser as an HTTP Request, as mentioned in the previous answer. To receive HTTP requests, each Browser Driver utilizes an HTTP server. When the URL reaches the Browser Driver, it will send the request via HTTP to the real browser. The commands in your Selenium script will be executed on the browser after this is completed.\nIf the request is a POST request, the browser will perform an action. If the request is a GET request, the browser will generate the corresponding response. The request will then be delivered to the browser driver through HTTP, and the browser driver will send it to the user interface via JSON Wire Protocol. Learn More.  Learn More The JSON wire protocol converts test commands into HTTP requests.\nEvery browser has its own driver that initializes the server before executing any test cases.\nThe browser's driver then begins to receive the request. The JSON wire protocol converts test commands into HTTP requests. Every browser has its own driver that initializes the server before executing any test cases. The browser's driver then begins to receive the request.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "6. What are Selenium WebDriver Listeners?",
        "answer": "Selenium WebDriver Listeners, as the name implies, \"listen\" to any event that the Selenium code specifies. Listeners are useful when you want to know what happens before you click any element, before and after you navigate to an element, or when an exception is thrown and the test fails. Listeners can be used in Selenium Automation Testing to log the order of activities and to capture a screenshot whenever an Exception is thrown. This makes debugging easier in the later stages of Test Execution. Some examples of Listeners are Web Driver Event Listeners and TestNG.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "7. What is the implementation of WebDriver Listeners?",
        "answer": "The Webdriver Event Listeners can be implemented in one of two ways: WebDriverEventListener is an interface with several built-in methods for tracking Webdriver events. It necessitates the implementation of ALL of the methods described in the Interface.\nThe AbstractWebDriverEventListener class gives us the ability to implement only the methods that we're interested in. WebDriverEventListener is an interface with several built-in methods for tracking Webdriver events. It necessitates the implementation of ALL of the methods described in the Interface. WebDriverEventListener The AbstractWebDriverEventListener class gives us the ability to implement only the methods that we're interested in. AbstractWebDriverEventListener",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "8. What kinds of Selenium WebDriver exceptions have you run into?",
        "answer": "In the following project the exceptions we've run into are as follows: Element Not Visible Exception: This error is produced when you try to discover a certain element on a webpage that is not currently accessible, despite the fact that it exists in the DOM. Also, if you're trying to find an element with an XPath that connects two or more elements, it can be difficult.\nStale Element Reference Exception: This is thrown in one of two scenarios, the first of which is more prevalent:\nThe element has been completely removed.\nThe element has been detached from the DOM. Element Not Visible Exception: This error is produced when you try to discover a certain element on a webpage that is not currently accessible, despite the fact that it exists in the DOM. Also, if you're trying to find an element with an XPath that connects two or more elements, it can be difficult. Element Not Visible Exception Stale Element Reference Exception: This is thrown in one of two scenarios, the first of which is more prevalent:\nThe element has been completely removed.\nThe element has been detached from the DOM. Stale Element Reference Exception The element has been completely removed.\nThe element has been detached from the DOM. The element has been completely removed. The element has been detached from the DOM. On the elements, with which we are interacting, destruction and then restoration, we get a stale element reference exception. When this happens, the element's DOM reference becomes invalid. Because of this, we are unable to obtain the element's reference. The following are some more common exceptions: WebDriverException\nTimeoutException\nNoAlertPresentException\nNoSuchWindowException\nIllegalStateException\nNoSuchElementException. WebDriverException WebDriverException TimeoutException TimeoutException NoAlertPresentException NoAlertPresentException NoSuchWindowException NoSuchWindowException IllegalStateException IllegalStateException NoSuchElementException. NoSuchElementException.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "9. Which implementation of WebDriver promises to be the fastest?",
        "answer": "HTMLUnitDriver is the quickest WebDriver implementation because the HTMLUnitDriver does not run tests in the browser, this is the case. When compared to running the scripts without a browser, starting a browser and performing test cases took longer. For test case execution, HTMLUnitDriver used a simple HTTP request-response method.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "10. At a bare minimum, how many parameters do selenium commands have?",
        "answer": "The following four parameters need to be passed in Selenium: 1. Host: This is the parameter that binds Selenium to a particular IP address. Because we usually perform Selenium tests on our local system, the value will be 'localhost.' Instead of localhost, you can specify an IP address. 1. Host: The Syntax is as follows: java -jar <selenium server standalone jar name> -host <Your IP Address> java -jar <selenium server standalone jar name> -host <Your IP Address> 2. Port number: TCP/IP port for connecting Selenium tests to the Selenium Grid Hub. 4444 is the default port hub. 2. Port number: The Syntax is as follows: java -jar <selenium server standalone jar name> -role hub -port 4444 java -jar <selenium server standalone jar name> -role hub -port 4444 Assure this port isn't being used by any other software on your machine. An exception like Exception in thread \"main\" java.net may occur. Selenium is already running on port 4444. BindException: Selenium is already running on port 4444. Alternatively, some other service is available. If this happens, you may either kill the other process using port 4444 or tell Selenium-Grid to use a new port for its hub. If you want to change the hub's port, the -port option can be used. 3. Browser: For the execution of the selenium scripts I required a browser to be passed. 3. Browser: 4. Url: The URL of the application needs to be passed. 4. Url:",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "11. As seen below, we establish a WebDriver reference variable called 'driver.' What exactly is the purpose of proceeding in this manner?",
        "answer": "WebDriver driver = new FirefoxDriver(); WebDriver driver = new FirefoxDriver(); instead of creating instead of creating FirefoxDriver driver = new FirefoxDriver(); FirefoxDriver driver = new FirefoxDriver(); We may use the same driver variable to work with any browser we want, such as IEDriver, SafariDriver, and so on if we construct a reference variable of type WebDriver.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "12. What is the Selenium WebDriver Architecture?",
        "answer": "Selenium WebDriver is a web framework for performing cross-browser testing (Cross-browser testing is comparing and assessing your website's behaviour in various browser contexts. It ensures that your website provides the best possible user experience regardless of the browser used to access it). This program is used to test web-based applications to ensure that they work as expected. Selenium WebDriver allows us to write test scripts in the programming language of our choice. As previously stated, it is an improvement to Selenium RC in that it overcomes a few shortcomings. Although Selenium WebDriver is unable to handle window components, this limitation can be bypassed by using tools such as Sikuli, Auto IT, and others. The Selenium WebDriver Architecture consists of: Selenium WebDriver Architecture Selenium WebDriver Architecture   Selenium Client library.\nJSON wire protocol over HTTP.\nBrowser Drivers.\nBrowsers. Selenium Client library. JSON wire protocol over HTTP. Browser Drivers. Browsers.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "13. In Selenium WebDriver, how do you use the Recovery Scenario?",
        "answer": "Within Selenium WebDriver Java tests, by using \"Try Catch Block.\" try {\n    driver.get(\"www.interviewbit.com\");\n}catch(Exception e){\n    System.out.println(e.getMessage());\n} try {\n    driver.get(\"www.interviewbit.com\");\n}catch(Exception e){\n    System.out.println(e.getMessage());\n}",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "14. How can I use WebDriver to mouse hover over a web element?",
        "answer": "We can use the Actions class to mouse hover over a web element as shown below in the code snippet: WebElement ele = driver.findElement(By.xpath(\"xpath\"));\n//Create object 'action' of an Actions class\nActions action = new Actions(driver);\n//Mouseover on an element\naction.moveToElement(ele).perform(); WebElement ele = driver.findElement(By.xpath(\"xpath\"));\n//Create object 'action' of an Actions class\nActions action = new Actions(driver);\n//Mouseover on an element\naction.moveToElement(ele).perform();",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "15. In Selenium WebDriver, how do I push the ENTER key on a text box?",
        "answer": "To utilize Selenium WebDriver to hit the ENTER key, we must use Selenium Enum Keys with the constant ENTER. driver.findElement(By.xpath(\"xpath\")).sendKeys(Keys.ENTER); driver.findElement(By.xpath(\"xpath\")).sendKeys(Keys.ENTER);",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "16. How do I use Selenium WebDriver for submitting a form?",
        "answer": "For submitting a form in Selenium WebDriver, we use the \"submit\" method on the element. driver.findElement(By.id(\"form\")).submit(); driver.findElement(By.id(\"form\")).submit();",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "17. How can I use Selenium WebDriver for clicking on a hyperlink?",
        "answer": "In Selenium, we use the click() method for clicking on a hyperlink. driver.findElement(By.linkText(\"Interview Bit Website\")).click(); driver.findElement(By.linkText(\"Interview Bit Website\")).click();",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "18. How do I retrieve the value of an attribute in Selenium WebDriver?",
        "answer": "Using the getAttribute(value) method. It returns the value of the parameterized attribute. HTML: HTML: <input name=\"nameSeleniumWebDriver\" value=\"valueSeleniumWebDriver\">Interview Bit</input> <input name=\"nameSeleniumWebDriver\" value=\"valueSeleniumWebDriver\">Interview Bit</input> Selenium Program: Selenium Program String attributeValue = driver.findElement(By.name(\"nameSeleniumWebDriver\")).getAttribute(\"value\");\nSystem.out.println(\"Available attribute value is :\"+attributeValue); String attributeValue = driver.findElement(By.name(\"nameSeleniumWebDriver\")).getAttribute(\"value\");\nSystem.out.println(\"Available attribute value is :\"+attributeValue); Output: Output: valueSeleniumWebDriver valueSeleniumWebDriver",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "19. What is the best way to acquire the textual matter of a web element?",
        "answer": "The best way to acquire the textual matter of a web element is by employing the getText() method as shown below: getText() package interviewBit;\n// package name\nimport org.openqa.selenium.By;\nimport org.testng.annotations.Test;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.WebDriver;\n// importing the necessary libraries\n// Test class\npublic class Test {\n@Test\npublic void testmethod(){\n// sets the property as required\nSystem.setProperty(\"webdriver.chrome.driver\",\"C:\\\\Selenium  Environment\\\\Drivers\\\\chromedriver.exe\");\n//Creates a new Chrome Web Driver\nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.youtube.com\");\nString textAvailable=driver.findElement(By.xpath(\"//*[@id='gbw']/div/div/div[1]/div[1]/a\")).getText();\n  System.out.println(\"Textual Matter which is Present is :\" + textAvailable);\n}\n} package interviewBit;\n// package name\nimport org.openqa.selenium.By;\nimport org.testng.annotations.Test;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.WebDriver;\n// importing the necessary libraries\n// Test class\npublic class Test {\n@Test\npublic void testmethod(){\n// sets the property as required\nSystem.setProperty(\"webdriver.chrome.driver\",\"C:\\\\Selenium  Environment\\\\Drivers\\\\chromedriver.exe\");\n//Creates a new Chrome Web Driver\nWebDriver driver = new ChromeDriver();\ndriver.get(\"https://www.youtube.com\");\nString textAvailable=driver.findElement(By.xpath(\"//*[@id='gbw']/div/div/div[1]/div[1]/a\")).getText();\n  System.out.println(\"Textual Matter which is Present is :\" + textAvailable);\n}\n} package // package name import import import import // importing the necessary libraries // Test class public class Test class Test @Test public void testmethod() public void testmethod () // sets the property as required \"webdriver.chrome.driver\" \"C:\\\\Selenium  Environment\\\\Drivers\\\\chromedriver.exe\" //Creates a new Chrome Web Driver new \"https://www.youtube.com\" \"//*[@id='gbw']/div/div/div[1]/div[1]/a\" \"Textual Matter which is Present is :\"",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "20. How can I use Selenium WebDriver to clear the text in a text box?",
        "answer": "The above task can be done using the clear() function as shown below: clear() WebDriver driver = new FirefoxDriver();\ndriver.get(\"https://www.youtube.com\");\ndriver.findElement(By.xpath(\"xpath_of_element1\")).sendKeys(\"Interview Bit\");\ndriver.findElement(By.xpath(\"xpath_of_element1\")).clear(); WebDriver driver = new FirefoxDriver();\ndriver.get(\"https://www.youtube.com\");\ndriver.findElement(By.xpath(\"xpath_of_element1\")).sendKeys(\"Interview Bit\");\ndriver.findElement(By.xpath(\"xpath_of_element1\")).clear();",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "21. How do I use Selenium WebDriver to enter text into a text box?",
        "answer": "Using the method sendKeys() sendKeys() WebDriver driver = new FirefoxDriver();\ndriver.get(\"https://www.youtube.com\");\ndriver.findElement(By.xpath(\"xpath\")).sendKeys(\"Interview Bit\"); WebDriver driver = new FirefoxDriver();\ndriver.get(\"https://www.youtube.com\");\ndriver.findElement(By.xpath(\"xpath\")).sendKeys(\"Interview Bit\");",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "22. In Selenium WebDriver, how do you take a screenshot?",
        "answer": "During the execution of the test scripts, test cases may fail. We just capture a screenshot and save it in a result repository while manually executing the test cases. Selenium WebDriver can be used to accomplish the same thing. Some of the instances in which we might need to use Selenium WebDriver to capture a screenshot are as follows: Problems with applications\nAssertion Defect\nFinding Web Elements on the web page is difficult.\nTake a break to look for Webelements on the page. Problems with applications Assertion Defect Finding Web Elements on the web page is difficult. Take a break to look for Webelements on the page. TakesScreenshot is a Selenium interface that has a function getScreenShotAs that may be used to take a screenshot of the programme under test. When capturing screenshots with Selenium 3, we may run into a few difficulties. We utilize the aShot() function to get around this.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "23. What is the best way to deal with StaleElementReferenceException?",
        "answer": "Before we look at how to manage a StaleElementReferenceException using the Page Object Model, let's have a look at how to handle a StaleElementReferenceException. First, let's define Stale Element Reference Exception. Stale refers to something that is old, deteriorated, and no longer fresh. An old or no longer available element is referred to as a stale element. Assume there is a WebElement in WebDriver that is discovered on a web page. The WebElement becomes stale when the DOM changes. The StaleElementReferenceException is thrown when we try to interact with a stale element.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "1. Why is it important to use TestNG when working with Selenium RC?",
        "answer": "TestNG is a testing framework that provides more powerful and flexible test configuration and execution than JUnit, the default testing framework used with Selenium RC. TestNG allows for the annotation of test methods, support for data-driven testing, and the ability to run tests in parallel, which can lead to faster test execution and better test organization. Additionally, TestNG provides more advanced reporting and logging capabilities than JUnit. Using TestNG with Selenium RC can help improve the efficiency and effectiveness of automating web application testing.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "2. Can Selenium be used to test responsive web design?",
        "answer": "Yes, Selenium can be used to test responsive web design. Selenium is a web automation tool that allows for the automation of browser interactions, and as such, it can be used to test the responsiveness of a web page by simulating interactions on different screen sizes and resolutions. This can include testing how the page layout adjusts to different viewport sizes, testing how the page elements are displayed on different devices, and testing how the page behaves when a user switches between landscape and portrait orientations. One way to test responsive web design with Selenium is by using the Selenium WebDriver API to set the browser's viewport size and then test the page's layout and functionality. Another way is to use a third-party library such as Selenium-Responsive-Testing which allows you to test how the page behaves on different devices and screen sizes. It is worth noting that Selenium alone is not enough for responsive web design testing, it should be combined with other methods such as manual testing, visual testing, and using responsive design testing tools to get complete coverage.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "3. What API should be used to test databases when using Selenium WebDriver for database testing?",
        "answer": "Selenium WebDriver is a tool for automating web browsers, it's not designed for database testing. To test databases, you need a database testing tool that can connect to the database and perform various operations like running SQL queries and asserting the results. Some examples of database testing tools are DBUnit, jOOQ, and JDBC. These tools provide an API that can be used to connect to the database, perform operations and assert the results.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "4. What are assertions in Selenium?",
        "answer": "In the context of Selenium, assertions are used to check if the actual outcome of a test matches the expected outcome. Assertions are used to validate that a certain condition is true and if it's not true, the test execution will be stopped and an assertion error will be thrown. Assertions can be used to verify that a specific element is present on the page, to check the text of an element, to check the value of an input field, and many other things. Selenium WebDriver provides assertion methods through the org.junit.Assert and org.testng.Assert classes for JUnit and TestNG respectively.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "5. What is the Silk Test Tool?",
        "answer": "Silk Testing (formerly known as Segue Silk Test) is a commercial, functional, and regression testing tool used for automating the testing of software applications. It is developed and maintained by Micro Focus and it is used for automating GUI-based tests for a variety of applications, including web, mobile, and desktop applications. The tool can be used to test applications on different platforms such as Windows, iOS, and Android. Silk Testing uses a proprietary scripting language called 4Test, which allows users to automate the testing process by writing test scripts that simulate user interactions with the application under test. The tool also has a visual text editor that allows users to record and edit test scripts using a GUI.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "6. What is the purpose of the testing.xml file ?",
        "answer": "The testing.xml file, also known as testng.xml is an XML configuration file used in the TestNG framework. It is used to configure and execute test suites and test cases. It provides a way to define and organize test methods, classes, and packages into test suites. It also allows setting up test execution order, parallel execution, test data, test listeners, test reporting, and more. With the testing.xml file, users can specify which test methods or classes should be included or excluded in a test run, what test listeners should be used, and what test configuration should be used, among other things. It is used to organize and execute test methods, classes, and packages in a logical and organized way.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "7. What are the areas where Selenium can improve its features?",
        "answer": "Selenium has a wide range of capabilities, but some areas where it could see the benefit in extending its features include: Mobile testing: Selenium has limited support for mobile testing. It can automate web applications on mobile browsers, but it does not support automating native mobile applications.\nVisual testing: Selenium is mainly used for functional testing, but it does not have built-in support for visual testing. Visual testing compares the look and feel of the application to a pre-approved design and helps in identifying issues related to layout, alignment, and font.\nCross-browser testing: Selenium supports a wide range of browsers, but there are still some browsers that are not fully supported or have limited support.\nTest reports and analysis: Selenium's test reporting capabilities are basic and it does not provide advanced test analytics features like test coverage, flaky test detection, and root cause analysis.\nPerformance testing: Selenium is mainly used for functional testing, but it does not have built-in support for performance testing. Performance testing can help to measure the responsiveness, stability, and scalability of the application under test.\nContinuous Integration: Selenium does not provide out-of-the-box support for continuous integration (CI) and continuous delivery (CD) pipeline, it needs to be integrated with other tools to automate the test execution in CI/CD pipeline. Mobile testing: Selenium has limited support for mobile testing. It can automate web applications on mobile browsers, but it does not support automating native mobile applications. Mobile testing: Visual testing: Selenium is mainly used for functional testing, but it does not have built-in support for visual testing. Visual testing compares the look and feel of the application to a pre-approved design and helps in identifying issues related to layout, alignment, and font. Visual testing: Cross-browser testing: Selenium supports a wide range of browsers, but there are still some browsers that are not fully supported or have limited support. Cross-browser testing: Test reports and analysis: Selenium's test reporting capabilities are basic and it does not provide advanced test analytics features like test coverage, flaky test detection, and root cause analysis. Test reports and analysis: Performance testing: Selenium is mainly used for functional testing, but it does not have built-in support for performance testing. Performance testing can help to measure the responsiveness, stability, and scalability of the application under test. Performance testing: Continuous Integration: Selenium does not provide out-of-the-box support for continuous integration (CI) and continuous delivery (CD) pipeline, it needs to be integrated with other tools to automate the test execution in CI/CD pipeline. Continuous Integration: It's worth noting that Selenium is widely used and has a large community of developers who are constantly working to improve and extend its capabilities. There are also many other test automation tools that can be used in combination with Selenium to address these limitations.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "8. Can you explain what Page Factory is?",
        "answer": "Page Factory is a design pattern used to create an object repository for web elements in Selenium WebDriver. It's an extension of the Page Object Model design pattern, which is used to create a centralized repository for web elements. It uses annotations to identify and initialize web elements at runtime and make the code more readable and maintainable by separating the test code from the technical details of locating web elements. In order to use Page Factory, you need to create a class for each web page and define web elements in that class using the @FindBy annotation it also contains methods for interacting with the web elements.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "9. What is the Actions class?",
        "answer": "The Actions class is a part of the Selenium Python bindings for automating web browsers. It allows you to perform actions on web elements, such as moving the mouse over an element, clicking on it, and sending keys to it. The Actions class is typically used in conjunction with the WebDriver class, which is the main class for interacting with a web browser.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "10. What are the steps for troubleshooting tests using Selenium IDE?",
        "answer": "Troubleshooting tests using Selenium IDE can be a multi-step process, but here are some general steps that you can follow: Verify that the test is correctly recorded: Make sure that the test is recorded correctly and that all the elements and commands are in the correct order.\nCheck the test for syntax errors: Selenium IDE will alert you if there are any syntax errors in the test, so make sure to check for and fix any errors.\nCheck the test for compatibility issues: Make sure that the test is compatible with the browser and version that you are using to run the test.\nCheck the test for missing elements: Make sure that all the elements used in the test are present on the web page.\nRun the test in debug mode: Selenium IDE provides a debug mode that allows you to step through the test and check the values of variables and the state of the web page at each step.\nCheck the browser's developer tools: The browser's developer tools can be used to inspect the web page and check for any issues.\nCheck the log messages: Selenium IDE provides a log panel where you can view log messages generated by the test. This can be useful for troubleshooting issues.\nCheck the Selenium documentation: The Selenium documentation provides information on the different commands and options available in Selenium IDE, which can be helpful for troubleshooting.\nFinally, you can also seek help from the Selenium community and forums, where you can ask questions and get help from other Selenium users. Verify that the test is correctly recorded: Make sure that the test is recorded correctly and that all the elements and commands are in the correct order. Check the test for syntax errors: Selenium IDE will alert you if there are any syntax errors in the test, so make sure to check for and fix any errors. Check the test for compatibility issues: Make sure that the test is compatible with the browser and version that you are using to run the test. Check the test for missing elements: Make sure that all the elements used in the test are present on the web page. Run the test in debug mode: Selenium IDE provides a debug mode that allows you to step through the test and check the values of variables and the state of the web page at each step. Check the browser's developer tools: The browser's developer tools can be used to inspect the web page and check for any issues. Check the log messages: Selenium IDE provides a log panel where you can view log messages generated by the test. This can be useful for troubleshooting issues. Check the Selenium documentation: The Selenium documentation provides information on the different commands and options available in Selenium IDE, which can be helpful for troubleshooting. Finally, you can also seek help from the Selenium community and forums, where you can ask questions and get help from other Selenium users.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "11. What steps can be taken to resolve an issue where a Selenium script only works properly on Google Chrome but not Internet Explorer?",
        "answer": "Here are some possible steps that can be taken to resolve an issue where a Selenium script only works properly on Google Chrome but not Internet Explorer: Verify that the correct version of Internet Explorer is being used: Selenium supports different versions of Internet Explorer, so make sure that you are using a version that is compatible with your Selenium script.\nCheck the Internet Explorer settings: Make sure that Internet Explorer's security settings are configured correctly and that the browser is not running in compatibility mode.\nCheck the Selenium WebDriver version: Make sure that you are using the latest version of the Selenium WebDriver for Internet Explorer.\nCheck the browser's developer tools: Use the browser's developer tools to inspect the web page and check for any issues.\nCheck the log messages: Selenium provides log messages that can be helpful for troubleshooting issues.\nCheck the Internet Explorer documentation: The Internet Explorer documentation provides information on the different options and settings available in Internet Explorer, which can be helpful for troubleshooting.\nUse a different browser: If the above steps do not resolve the issue, you may want to consider using a different browser that is supported by Selenium, like Firefox or Microsoft Edge.\nYou can also try to seek help from the Selenium community and forums, where you can ask questions and get help from other Selenium users. Verify that the correct version of Internet Explorer is being used: Selenium supports different versions of Internet Explorer, so make sure that you are using a version that is compatible with your Selenium script. Check the Internet Explorer settings: Make sure that Internet Explorer's security settings are configured correctly and that the browser is not running in compatibility mode. Check the Selenium WebDriver version: Make sure that you are using the latest version of the Selenium WebDriver for Internet Explorer. Check the browser's developer tools: Use the browser's developer tools to inspect the web page and check for any issues. Check the log messages: Selenium provides log messages that can be helpful for troubleshooting issues. Check the Internet Explorer documentation: The Internet Explorer documentation provides information on the different options and settings available in Internet Explorer, which can be helpful for troubleshooting. Use a different browser: If the above steps do not resolve the issue, you may want to consider using a different browser that is supported by Selenium, like Firefox or Microsoft Edge. You can also try to seek help from the Selenium community and forums, where you can ask questions and get help from other Selenium users.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "12. Is it possible to open pop-up windows with Selenium?",
        "answer": "Yes, it is possible to open pop-up windows with Selenium. Selenium WebDriver provides methods to interact with browser windows, so you can use Selenium to open new windows, switch between windows, and close windows. You can open a new window using the window_handles method, and switch to the new window using the switch_to.window() method. Once you have switched to the new window, you can interact with the elements on the pop-up window just like you would interact with elements on the main window. You can also use the Alert class of Selenium WebDriver to handle JavaScript alerts and confirmations. It's worth noting that, while some browsers may block pop-ups by default, you need to configure the browser settings to allow pop-ups for the testing website. It's also important to use explicit waits to handle the dynamic nature of the web pages and pop-ups, as the time taken for a pop-up window to load may vary depending on the browser, internet connection, and other factors.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "13. Can selenium be used to launch web browsers?",
        "answer": "Yes, Selenium provides good support to launch web browsers like Google Chrome, Mozilla Firefox, Internet Explorer, etc. The following commands can be used to launch web browsers using Selenium: WebDriver driver = new FirefoxDriver();\nWebDriver driver = new ChromeDriver();\nWebDriver driver = new InternetExplorerDriver(); WebDriver driver = new FirefoxDriver(); WebDriver driver = new FirefoxDriver(); WebDriver driver = new ChromeDriver(); WebDriver driver = new ChromeDriver(); WebDriver driver = new InternetExplorerDriver(); WebDriver driver = new InternetExplorerDriver();",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "14. Is it possible to use only perform() without build()?",
        "answer": "Yes, it is possible to use the perform() method without calling the build() method. The build() method is used to construct and return an instance of the ActionChains class, which is a container for a series of actions. However, if you don't call build(), the actions will be performed immediately when you call perform(). actions.move_to_element(element).click().perform() actions.move_to_element(element).click().perform() The above line of code is an example of using perform() without calling build(). The move_to_element(), click() methods are chained together and the perform() method is used to execute all the chained actions. However, it is important to note that, perform() method is used to execute all the chained actions only after calling build() when you are chaining multiple actions together and want to execute them together.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "15. What is StaleElementReferenceException? When does this occur? And how to overcome such exceptions?",
        "answer": "StaleElementReferenceException is an exception that is thrown in Selenium WebDriver when a web element that was previously found on a web page is no longer available or has been deleted from the DOM (Document Object Model). This can happen if the web page has been refreshed, the element has been removed or replaced, or the element's parent element has been removed or replaced. This exception occurs when the element is no longer attached to the DOM, which means that the element can no longer be interacted with using the WebDriver. There are a few ways to overcome this exception: Re-find the element: You can re-find the element by using the WebDriver's find_element or find_elements methods again. Re-find the element: You can re-find the element by using the WebDriver's find_element or find_elements methods again. Re-find the element: try:\n    element.click()\nexcept StaleElementReferenceException:\n    element = driver.find_element_by_id('element_id')\n    element.click() try:\n    element.click()\nexcept StaleElementReferenceException:\n    element = driver.find_element_by_id('element_id')\n    element.click() Wait for the element to be available: You can use explicit waits such as WebDriverWait and ExpectedConditions to wait for the element to be available before interacting with it. Wait for the element to be available: You can use explicit waits such as WebDriverWait and ExpectedConditions to wait for the element to be available before interacting with it. Wait for the element to be available: from selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\n\ntry:\n    element.click()\nexcept StaleElementReferenceException:\n    wait = WebDriverWait(driver, 10)\n    element = wait.until(EC.presence_of_element_located((By.ID, 'element_id')))\n    element.click() from selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\n\ntry:\n    element.click()\nexcept StaleElementReferenceException:\n    wait = WebDriverWait(driver, 10)\n    element = wait.until(EC.presence_of_element_located((By.ID, 'element_id')))\n    element.click() Refresh the page: You can refresh the page using the refresh() method of the WebDriver instance and then re-find the element. Refresh the page: You can refresh the page using the refresh() method of the WebDriver instance and then re-find the element. Refresh the page: try:\n    element.click()\nexcept StaleElementReferenceException:\n    driver.refresh()\n    element = driver.find_element_by_id('element_id')\n    element.click() try:\n    element.click()\nexcept StaleElementReferenceException:\n    driver.refresh()\n    element = driver.find_element_by_id('element_id')\n    element.click() It is important to note that this exception is a run-time exception, so it's best to catch it and handle it in the code, rather than letting the script crash.",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "16. In a Selenium script, what happens if you use both implicit and explicit wait?",
        "answer": "According to the official Selenium manual, mixing Implicit and Explicit Waits is not recommended. Combining the two can result in unpredictable wait times. Only one time in the code is implicit wait specified. Throughout the driver object instance, it will remain the same. Explicit wait is used in the code whenever it is required. At the time of execution, this wait will be called. It's a conditional waiting period. Wherever explicit wait is applied, it will supersede the implicit wait. As a result, Explicit Wait takes precedence over Implicit Wait. Explicit Wait takes precedence over Implicit Wait",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "17. In a Selenium Script, what happens if you use both Thread.Sleep and WebDriver Waits?",
        "answer": "The Thread.sleep() method allows you to suspend the execution for a specified amount of time in milliseconds. If we use WebDriver waits in conjunction with the Thread.sleep() method, the webdriver will pause the execution for the provided amount of time in the parameter of the Thread.sleep() function before proceeding to the next wait. If we combine both waits, the test execution time will increase. Thread.sleep() Thread.sleep() Thread.sleep()",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "18. How can I type text into the text box without using the sendKeys() function?",
        "answer": "We can use the following piece of code to type text into the text box without using the sendKeys() function: sendKeys() // To initialize js object\nJavascriptExecutor JS = (JavascriptExecutor)webdriver;\n// To enter username\nJS.executeScript(\"document.getElementById('User').value='InterviewBit.com'\");\n// To enter password\nJS.executeScript(\"document.getElementById('Pass').value='tester value'\"); // To initialize js object\nJavascriptExecutor JS = (JavascriptExecutor)webdriver;\n// To enter username\nJS.executeScript(\"document.getElementById('User').value='InterviewBit.com'\");\n// To enter password\nJS.executeScript(\"document.getElementById('Pass').value='tester value'\");",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "19. How does Selenium WebDriver handle hidden elements?",
        "answer": "Using the JavaScript executor, we can deal with hidden items. (JavascriptExecutor(driver)).executeScript(\"document.getElementsByClassName(ElementLocator).click(); (JavascriptExecutor(driver)).executeScript(\"document.getElementsByClassName(ElementLocator).click();",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "20. What are test design techniques? Explain BVA and ECP with some examples.",
        "answer": "Test design techniques are the methods or strategies used to design and create test cases for a software application. Some common test design techniques include: Black Box Testing: Testing the functionality of the software without looking into the internal structure or code.\nWhite Box Testing: Testing the internal structure or code of the software.\nGrey Box Testing: Combining both Black Box and White Box testing methods.\nBoundary Value Analysis (BVA): This technique is used to test the software's behaviour at its input and output boundaries. It involves testing the software with input values that are just above and just below the valid range, as well as testing the software with the maximum and minimum valid input values.\nEquivalence Class Partitioning (ECP): This technique is used to divide the input domain of the software into a finite number of classes or partitions, where each class represents a group of input values that are expected to behave in the same way. The goal of ECP is to test the software with a representative sample of input values from each partition. Black Box Testing: Testing the functionality of the software without looking into the internal structure or code. Black Box Testing: White Box Testing: Testing the internal structure or code of the software. White Box Testing: Grey Box Testing: Combining both Black Box and White Box testing methods. Grey Box Testing: Boundary Value Analysis (BVA): This technique is used to test the software's behaviour at its input and output boundaries. It involves testing the software with input values that are just above and just below the valid range, as well as testing the software with the maximum and minimum valid input values. Boundary Value Analysis (BVA): Equivalence Class Partitioning (ECP): This technique is used to divide the input domain of the software into a finite number of classes or partitions, where each class represents a group of input values that are expected to behave in the same way. The goal of ECP is to test the software with a representative sample of input values from each partition. Equivalence Class Partitioning (ECP): Examples: Examples: BVA: BVA: In a login form, test the minimum and maximum length of the password field.\nFor a form field that accepts a date, testing the software with a date that is just before and just after the valid range of dates. In a login form, test the minimum and maximum length of the password field. For a form field that accepts a date, testing the software with a date that is just before and just after the valid range of dates. ECP: ECP: In a form field that accepts a phone number, divide the input domain into three classes: valid phone numbers, phone numbers that are too short, and phone numbers that are too long.\nIn a form field that accepts a price, divide the input domain into two classes: valid prices and invalid prices (e.g., negative prices). In a form field that accepts a phone number, divide the input domain into three classes: valid phone numbers, phone numbers that are too short, and phone numbers that are too long. In a form field that accepts a price, divide the input domain into two classes: valid prices and invalid prices (e.g., negative prices). It is important to note that these techniques are helpful in creating a comprehensive set of test cases that can help ensure that the software is functioning correctly. However, it's not enough to just use one technique, a combination of different techniques are used to test the software in different ways and identify all the possible defects. Recommended Resources RPA Interview Questions and Answers\nJava Interview Questions and Answers\nAutomation Testing Interview Questions and Answers\nSelenium Interview Questions for 5years Experience\nCucumber Interview Questions and Answers\nAppium Interview Questions and Answers\nDatabase Testing Interview Questions\nTechnical Interview Guide\nPrinciples of Software Testing\nDifference Between Alpha and Beta Testing\nFree Software Testing Course RPA Interview Questions and Answers RPA Interview Questions and Answers Java Interview Questions and Answers Java Interview Questions and Answers Automation Testing Interview Questions and Answers Automation Testing Interview Questions and Answers Selenium Interview Questions for 5years Experience Selenium Interview Questions for 5years Experience Cucumber Interview Questions and Answers Cucumber Interview Questions and Answers Appium Interview Questions and Answers Appium Interview Questions and Answers Database Testing Interview Questions Database Testing Interview Questions Technical Interview Guide Technical Interview Guide Principles of Software Testing Principles of Software Testing Difference Between Alpha and Beta Testing Difference Between Alpha and Beta Testing Free Software Testing Course Free Software Testing Course",
        "reference": "interviewbit.com",
        "role": "selenium"
    },
    {
        "question": "Basic Level - Selenium Interview Questions",
        "answer": "1) What is test automation or automation testing?\nAutomation testing uses automation tools to write and execute test cases, no manual involvement is necessary for executing an automated test suite. Testers prefer automation tools to write test scripts and test cases and then group into test suites.\nADVERTISEMENT\nAutomation testing enables the use of specialized tools to automate the execution of manually designed test cases without any human intervention. Automation testing tools can access the test data, controls the execution of tests and compares the actual result against the expected result. Consequently, generating detailed test reports of the system under test.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "1) What is test automation or automation testing?",
        "answer": "Automation testing uses automation tools to write and execute test cases, no manual involvement is necessary for executing an automated test suite. Testers prefer automation tools to write test scripts and test cases and then group into test suites.\nADVERTISEMENT\nAutomation testing enables the use of specialized tools to automate the execution of manually designed test cases without any human intervention. Automation testing tools can access the test data, controls the execution of tests and compares the actual result against the expected result. Consequently, generating detailed test reports of the system under test.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "2) What are the advantages of automation testing?",
        "answer": "Some basic Advantages of automation testing are as follows.\nADVERTISEMENT\nAutomation testing supports both functional and performance test on an application.\nIt supports the execution of repeated test cases.\nIt facilitates parallel execution.\nIt aids in testing a large test matrix.\nIt improves accuracy because there are no chances of human errors.\nIt saves time and money.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "Lists of top 10 used automation testing tools for Functional Automation are as follows.\nTeleric Test Studio, Developed by Teleric.\nTestingWhiz\nHPE Unified Functional Testing (HP - UFT formerly QTP)\nTosca Testsuite\nWatir\nQuick Test Professional, provided by HP.\nRational Robot, provided by IBM.\nCoded UI, provided by Microsoft.\nSelenium, open source.\nAuto It, Open Source.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "Lists of some commonly used Automation Testing tools for Non-Functional Automation are as follows.\nLoad Runner, provided by Hp.\nJMeter, provided by Apache.\nBurp Suite, provided by PortSwigger.\nAcunetix, provided by Acunetix.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "5) What is Selenium?",
        "answer": "Selenium is a portable framework for software testing. Selenium tool facilitates with a playback tool for authoring functional tests without the need to learn a test scripting language.\nSelenium is one of the most widely used open source Web UI (User Interface) automation testing suite. Jason Huggins developed Selenium in 2004 as an internal tool at Thought Works. Selenium supports automation across different browsers, platforms, and programming languages.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "6) What are the different components of Selenium?",
        "answer": "Selenium is not just a single tool but a suite of software's, each having a different approach to support automation testing. It comprises of four major components which include:\nSelenium Integrated Development Environment (IDE)\nSelenium Remote Control (Now Deprecated)\nWebDriver\nSelenium Grid",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "Selenium supports various operating systems, browsers and programming languages. Following is the list:\nProgramming Languages: C#, Java, Python, PHP, Ruby, Perl, JavaScript.\nOperating Systems: Android, iOS, Windows, Linux, Mac, Solaris.\nBrowsers: Google Chrome, Mozilla Firefox, Internet Explorer, Edge, Opera, Safari, etc.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "8) What are the significant changes/upgrades in various Selenium versions?",
        "answer": "Selenium v1.0:\nVersion 1.0 was the initial release of Selenium.\nIt included three tools: Selenium IDE, Selenium RC, and Selenium Grid.\nSelenium v2.0:\nSelenium WebDriver was introduced replacing Selenium RC in version \"2.0\".\nWith the onset of WebDriver, RC got deprecated and moved to the legacy package.\nSelenium v3:\nThe latest release Selenium 3 has new added features and functionalities.\nIt includes Selenium IDE, Selenium WebDriver, and Selenium Grid.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "Different types of testing's that we can achieve through Selenium are.\nFunctional Testing\nRegression Testing\nSanity Testing\nSmoke Testing\nResponsive Testing\nCross Browser Testing\nUI testing (black box)\nIntegration Testing",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "10) What is Selenium IDE?",
        "answer": "Selenium IDE is implemented as Firefox extension which provides record and playback functionality on test scripts. It allows testers to export recorded scripts in many languages like HTML, Java, Ruby, RSpec, Python, C#, JUnit and TestNG.\nSelenium IDE has limited scope, and the generated test scripts are not very robust, and portable.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "11) What do you mean by Selenese?",
        "answer": "Selenium commands, also known as \"Selenese\" are the set of commands used in Selenium that run your tests. For example, command - open (URL); launches the desired URL in the specified browser and it accept both relative and absolute URLs.\nA sequence of Selenium commands (Selenese) together is known as a test script.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "12) What are the different ways of locating a web element in Selenium?",
        "answer": "In Selenium, web elements are identified and located with the help of Locators. Locators specify a target location which uniquely defines the web element in the context of a web application. Thus, to identify web elements accurately and precisely we have different types of locators in Selenium:\nID\nClassName\nName\nTagName\nLinkText\nPartialLinkText\nXpath\nCSS Selector\nDOM",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "13) How many types of WebDriver API's are available in Selenium?",
        "answer": "The list of WebDriver API's which are used to automate browser include:\nAndroidDriver\nChromeDriver\nEventFiringWebDriver\nFirefoxDriver\nHtmlUnitDriver\nInternetExplorerDriver\niPhoneDriver\niPhoneSimulatorDriver\nRemoteWebDriver",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "Selenium can be used to automate functional tests and can be integrated with automation test tools such as Maven, Jenkins, &Docker to achieve continuous testing. It can also be integrated with tools such as TestNG, &JUnit for managing test cases and generating reports.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "15) What do you mean by the assertion in Selenium?",
        "answer": "The assertion is used as a verification point. It verifies that the state of the application conforms to what is expected. The types of assertion are \"assert\", \"verify\" and \"waitFor\".",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "16) Explain the difference between assert and verify commands?",
        "answer": "Assert: Assert command checks if the given condition is true or false. If the condition is true, the program control will execute the next phase of testing, and if the condition is false, execution will stop, and nothing will be executed.\nVerify: Verify command also checks if the given condition is true or false. It doesn't halt program execution, i.e., any failure during verification would not stop the execution, and all the test phases would be executed.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "17) What do you mean by XPath?",
        "answer": "XPath is also defined as XML Path. It is a language used to query XML documents. It is an important approach to locate elements in Selenium. XPath consists of a path expression along with some conditions. Here, we can easily write XPath script/query to locate any element in the webpage. It is developed to allow the navigation of XML documents. The key factors that it considered while navigating are selecting individual elements, attributes, or some other part of an XML document for specific processing. It also produces reliable locators. Some other points about XPath are as follows.\nXPath is a language used for locating nodes in XML documents.\nXPath can be used as a substitute when you don't have a suitable id or name attribute for the element you want to locate.\nXPath provides locating strategies like:\nXPath Absolute\nXPath Attributes",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "XPath Absolute:\nXPath Absolute enables users to mention the complete XPath location from the root HTML tag to the specific elements.\nSyntax: //html/body/tag1[index]/tag2[index]/.../tagN[index]\nExample: //html/body/div[2]/div/div[2]/div/div/div/fieldset/form/div[1]/input[1]\n\nXPath Attributes:\nXPath Attributes is always recommended when you don't have a suitable id or name attribute for the element you want to locate.\nSyntax: //htmltag[@attribute1='value1' and @attribute2='value2']\nExample: //input[@id='passwd' and @placeholder='password']",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "19) What is the difference between \"/\" and \"//\" in XPath?",
        "answer": "Single Slash \"/\": Single slash is used to create XPath with absolute path.\nDouble Slash \"//\": Double slash is used to create XPath with the relative path.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "20) What are the different types of annotations which are used in Selenium?",
        "answer": "JUnit annotations which can be used are:\nTest\nBefore\nAfter\nIgnore\nBeforeClass\nAfterClass\nRunWith",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "21) What are the WebDriver supported Mobile Testing Drivers?",
        "answer": "WebDriver supported \"mobile testing drivers\" are:\nAndroidDriver\nIphoneDriver\nOperaMobileDriver",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "22) What are the popular programming languages supported by Selenium WebDriver to write Test Cases?",
        "answer": "Selenium WebDriver supports the below languages to write Test Cases.\nJAVA\nPHP\nPython\nC#\nRuby\nPerl",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "23) What is the difference between type keys and type commands?",
        "answer": "TypeKeys() will trigger JavaScript event in most of the cases whereas .type() won't.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "24) What is the difference between \"type\" and \"typeAndWait\" command?",
        "answer": "\"type\" command is used to type keyboard key values into the text box of software web application. It can also be used for selecting values of combo box whereas \"typeAndWait\" command is used when your typing is completed and software web page start reloading. This command will wait for software application page to reload. If there is no page reload event on typing, you have to use a simple \"type\" command.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "25) What is the difference between findElement() and findElements()?",
        "answer": "findElement(): It is used to find the first element within the current page using the given \"locating mechanism\". It returns a single WebElement.\nfindElements(): It uses the given \"locating mechanism\" to find all the elements within the current page. It returns a list of web elements.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "26) What is the wait? How many types of waits in selenium?",
        "answer": "Selenium Webdriver introduces the concept of waits for the AJAX-based application. There are two types of waits:\nImplicit Wait\nExplicit Wait",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "27) What is the main disadvantage of implicit wait?",
        "answer": "The main disadvantage of implicit wait is that it slows down test performance.\nAnother disadvantage of implicit wait is:\nSuppose, you set the waiting limit to be 10 seconds, and the elements appear in the DOM in 11 seconds, your tests will be failed because you told it to wait a maximum of 10 seconds.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "28) What is Selenium Grid?",
        "answer": "Selenium Grid facilitates you to distribute your tests on multiple machines and all of them at the same time. So, you can execute tests on Internet Explorer on Windows and Safari on Mac machine using the same text script. It reduces the time of test execution and provides quick feedback.\nAdvance Level - Selenium Interview Questions\n29) How can we launch different browsers in Selenium WebDriver?\nWe have to create an instance of a driver of that particular browser.\nWebDriver driver =newFirefoxDriver();  \nHere, \"WebDriver\" is an interface, and we are creating a reference variable \"driver\" of type WebDriver, instantiated using \"FireFoxDriver\" class.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "Advance Level - Selenium Interview Questions",
        "answer": "29) How can we launch different browsers in Selenium WebDriver?\nWe have to create an instance of a driver of that particular browser.\nWebDriver driver =newFirefoxDriver();  \nHere, \"WebDriver\" is an interface, and we are creating a reference variable \"driver\" of type WebDriver, instantiated using \"FireFoxDriver\" class.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "29) How can we launch different browsers in Selenium WebDriver?",
        "answer": "We have to create an instance of a driver of that particular browser.\nWebDriver driver =newFirefoxDriver();  \nHere, \"WebDriver\" is an interface, and we are creating a reference variable \"driver\" of type WebDriver, instantiated using \"FireFoxDriver\" class.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "public class FirefoxBrowserLaunchDemo {  \n  public static void main(String[] args) {  \n  //Creating a driver object referencing WebDriver interface  \nWebDriver driver;  \n  //Setting webdriver.gecko.driver property  \nSystem.setProperty(\"webdriver.gecko.driver\", pathToGeckoDriver + \"\\\\geckodriver.exe\");  \n  //Instantiating driver object and launching browser  \ndriver = newFirefoxDriver();  \n  //Using get() method to open a webpage  \ndriver.get(\"http://javatpoint.com\");  \n  //Closing the browser  \ndriver.quit();  \n      }  \n  }",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "public class ChromeBrowserLaunchDemo {  \n  public static void main(String[] args) {  \n  //Creating a driver object referencing WebDriver interface  \nWebDriver driver;  \n  //Setting the webdriver.chrome.driver property to its executable's location  \nSystem.setProperty(\"webdriver.chrome.driver\", \"/lib/chromeDriver/chromedriver.exe\");  \n      //Instantiating driver object  \ndriver = newChromeDriver();  \n  //Using get() method to open a webpage  \ndriver.get(\"http://javatpoint.com\");  \n  //Closing the browser  \ndriver.quit();  \n      }  \n  }",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "public class IEBrowserLaunchDemo {  \n  public static void main(String[] args) {  \n  //Creating a driver object referencing WebDriver interface  \nWebDriver driver;  \n  //Setting the webdriver.ie.driver property to its executable's location  \nSystem.setProperty(\"webdriver.ie.driver\", \"/lib/IEDriverServer/IEDriverServer.exe\");  \n      //Instantiating driver object  \ndriver = newInternetExplorerDriver();  \n  //Using get() method to open a webpage  \ndriver.get(\"http://javatpoint.com\");  \n  //Closing the browser  \ndriver.quit();  \n      }  \n  }",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "We will use Action class to generate user event like right-click an element in WebDriver.\nActions action = newActions(driver);  \nWebElement element = driver.findElement(By.id(\"elementId\"));  \naction.contextClick(element).perform();",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "Actions action = newActions(driver);  \nWebElement element = driver.findElement(By.id(\"elementId\"));  \naction.moveToElement(element).perform();",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "35) How do you perform drag and drop operation in WebDriver?",
        "answer": "Code snippet to perform drag and drop operation:\n//WebElement on which drag and drop operation needs to be performed  \nWebElementfromWebElement = driver.findElement(By Locator of fromWebElement);  \n  //WebElement to which the above object is dropped  \nWebElementtoWebElement = driver.findElement(By Locator of toWebElement);  \n  //Creating object of Actions class to build composite actions  \nActions builder = newActions(driver);  \n  //Building a drag and drop action  \nAction dragAndDrop = builder.clickAndHold(fromWebElement)  \n             .moveToElement(toWebElement)  \n             .release(toWebElement)  \n         .build();  \n  //Performing the drag and drop action  \ndragAndDrop.perform();",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "36) What are the different methods to refresh a web page in WebDriver?",
        "answer": "There are multiple ways of refreshing a page in Webdriver.\n1. Using driver.navigate command -\ndriver.navigate().refresh();  \n2. Using driver.getCurrentUrl() with driver.get() command -\ndriver.get(driver.getCurrentUrl());  \n3. Using driver.getCurrentUrl() with driver.navigate() command -\ndriver.navigate().to(driver.getCurrentUrl());  \n4. Pressing an F5 key on any textbox using the sendKeys command -\ndriver.findElement(By textboxLocator).sendKeys(Keys.F5);  \n5. Passing ascii value of the F5 key, i.e., \"\\uE035\" using the sendKeys command -\ndriver.findElement(By textboxLocator).sendKeys(\"\\uE035\");",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "37) Write a code snippet to navigate back and forward in browser history?",
        "answer": "Navigate back in browser history:\ndriver.navigate().back();  \nNavigate forward in browser history:\ndriver.navigate().forward();",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "38) How to invoke an application in WebDriver?",
        "answer": "driver.get(\"url\"); or  \ndriver.navigate().to(\"url\");  \nMisc. Questions - Selenium Interview Question.\n39) What are the benefits of Automation Testing?\nBenefits of Automation testing are as follows.\nIt allows execution of repeated test cases\nIt enables parallel execution\nAutomation Testing encourages unattended execution\nIt improves accuracy. Thus, it reduces human-generated errors\nIt saves time and money.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "",
        "answer": "39) What are the benefits of Automation Testing?\nBenefits of Automation testing are as follows.\nIt allows execution of repeated test cases\nIt enables parallel execution\nAutomation Testing encourages unattended execution\nIt improves accuracy. Thus, it reduces human-generated errors\nIt saves time and money.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "39) What are the benefits of Automation Testing?",
        "answer": "Benefits of Automation testing are as follows.\nIt allows execution of repeated test cases\nIt enables parallel execution\nAutomation Testing encourages unattended execution\nIt improves accuracy. Thus, it reduces human-generated errors\nIt saves time and money.",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "40) How can we get a text of a web element?",
        "answer": "Get command is used to get the inner text of the specified web element. The get command doesn't require any parameter, but it returns a string type value. It is also one of the widely used commands for verification of messages, labels, and errors,etc.,from web pages.\nSyntax\nString Text = driver.findElement(By.id(\"Text\")).getText();",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "41) How to select value in a dropdown?",
        "answer": "We use the WebDriver's Select class to select the value in the dropdown.\nSyntax:\nselectByValue:\nSelect selectByValue = new Select(driver.findElement(By.id(\"SelectID_One\")));  \nselectByValue.selectByValue(\"greenvalue\");  \nselectByVisibleText:\nSelect selectByVisibleText = new Select (driver.findElement(By.id(\"SelectID_Two\")));  \nselectByVisibleText.selectByVisibleText(\"Lime\");  \n\nSelect selectByIndex = new Select(driver.findElement(By.id(\"SelectID_Three\")));  \nselectByIndex.selectByIndex(2);",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "42) What are the different types of navigation commands?",
        "answer": "The navigation commands are as follows.\nnavigate().back()\nThe above command needs no parameters and takes back the user to the previous webpage.\nExample\ndriver.navigate().back();  \nnavigate().forward()\nThe above command allows the user to navigate to the next web page with reference to the browser's history.\nExample\ndriver.navigate().forward();  \nnavigate().refresh()\nThe navigate().refresh() command allows the user to refresh the current web page by reloading all the web elements.\n\nExample\ndriver.navigate().refresh();  \nnavigate().to()\nThe navigate().to() command allows the user to launch a new web browser window and navigate to the specified URL.\nExample\ndriver.navigate().to(\"https://google.com\");",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "43) How to deal with frame in WebDriver?",
        "answer": "An inline frame abbreviates as an iframe. It is used to insert another document within the current document. These document can be HTML document or simply web page and nested web page.\nSelect iframe by id\ndriver.switchTo().frame(\"ID of the frame\");  \nLocating iframe using tagName\ndriver.switchTo().frame(driver.findElements(By.tagName(\"iframe\").get(0));  \nLocating iframe using index\nframe(index)\ndriver.switchTo().frame(0);  \nframe(Name of Frame)\ndriver.switchTo().frame(\"name of the frame\");  \nframe(WebElement element)\nSelect Parent Window\ndriver.switchTo().defaultContent();",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "NET?",
        "answer": "To use HtmlUnit first use the RemoteWebDriver and pass it in the desired capabilities.\nIWebDriver driver  \n= new RemoteWebDriver(DesiredCapabilities.HtmlUnit())  \nFor the Firefox implementation to run, use\nIWebDriver driver  \n= new RemoteWebDriver(DesiredCapabilities.HtmlUnitWithJavaScript())",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "45) How can you redirect browsing from a browser through some proxy?",
        "answer": "Selenium facilitates with a PROXY class to redirect browsing from a proxy. Look at the example below.\nExample\nString PROXY = \"199.201.125.147:8080\";  \norg.openqa.selenium.Proxy proxy = new.org.openqa.selenium.Proxy();  \nproxy.setHTTPProxy(Proxy)  \n .setFtpProxy(Proxy)  \n .setSslProxy(Proxy)  \nDesiredCapabilities cap = new DesiredCapabilities();  \ncap.setCapability(CapabilityType.PROXY, proxy);  \nWebDriver driver = new FirefoxDriver(cap);",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "46) What is POM (Page Object Model)? What are its advantages?",
        "answer": "Page Object Model is a design pattern for creating an Object directory for web UI elements. Each web page is required to have its page class. The page class is responsible for finding the WebElements in web pages and then perform operations on WebElements.\nThe benefits of using POM are as follows.\nIt facilitates with separate operations and flows in the UI from Verification - improves code readability\nMultiple tests can use the same Object Repository because the Object Repository is independent of Test Cases.\nReusability of code",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "47) How to capture screenshot in WebDriver?",
        "answer": "Below is the program to capture screenshot in WebDriver.\nimport org.junit.After;  \nimport org.junit.Before;  \nimport org.junit.Test;  \nimport java.io.File;  \nimport java.io.IOException;  \nimport org.apache.commons.io.FileUtils;  \nimport org.openqa.selenium.OutputType;  \nimport org.openqa.selenium.TakesScreenshot;  \nimport org.openqa.selenium.WebDriver;  \nimport org.openqa.selenium.firefox.FirefoxDriver;  \n  public class TakeScreenshot {  \nWebDriver drv;  \n@Before  \npublic void setUp() throws Exception {  \ndriver = new FirefoxDriver();  \ndrv.get(\"https://google.com\");  \n}  \n@After  \npublic void tearDown() throws Exception {  \ndrv.quit();  \n}  \n  @Test  \npublic void test() throws IOException {  \n//capture the screenshot  \nFile scrFile = ((TakeScreenshot)drv).getScreenshotAs(OutputType.FILE);  \n// paste the screenshot in the desired location  \nFileUtils.copyFile(scrFile, new File(\"C:\\\\Screenshot\\\\Scr.jpg\"))  \n}  \n}",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "48) How to type text in a textbox using Selenium?",
        "answer": "The sendKeys(\"String to be entered\") is used to enter the string in a textbox.\nSyntax\nWebElement username = drv.findElement(By.id(\"Email\"));  \n// entering username  \nusername.sendKeys(\"sth\");",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "49) How can you find if an element is displayed on the screen?",
        "answer": "WebDriver allows user to check the visibility of the web elements. These web elements can be buttons, radio buttons, drop, checkboxes, boxes, labels etc. which are used with the following methods.\nisDisplayed()\nisSelected()\nisEnabled()\nSyntax:\nisDisplayed():  \nboolean buttonPresence = driver.findElement(By.id(\"gbqfba\")).isDisplayed();  \nisSelected():  \nboolean buttonSelected = driver.findElement(By.id(\"gbqfba\")).isSelected();  \nisEnabled():  \nboolean searchIconEnabled = driver.findElement(By.id(\"gbqfb\")).isEnabled();",
        "reference": "javatpoint.com",
        "role": "selenium"
    },
    {
        "question": "50) How to click on a hyper link using linkText?",
        "answer": "driver.findElement(By.linkText(\"Google\")).click();  \nThe above command search the element using a link text, then click on that element and thus the user will be re-directed to the corresponding page.\nThe following command can access the link mentioned earlier.\ndriver.findElement(By.partialLinkText(\"Goo\")).click();  \nThe above-given command searches the element based on the substring of the link provided in the parenthesis. And after that partialLinkText() finds the web element with the specified substring and then clicks on it.",
        "reference": "javatpoint.com",
        "role": "selenium"
    }
]