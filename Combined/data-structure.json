[
    {
        "question": "1. What are Data Structures?",
        "answer": "A data structure is a mechanical or logical way that data is organized within a program. The organization of data is what determines how a program performs. There are many types of data structures, each with its own uses. When designing code, we need to pay particular attention to the way data is structured. If data isn't stored efficiently or correctly structured, then the overall performance of the code will be reduced.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "2. Why Create Data Structures?",
        "answer": "Data structures serve a number of important functions in a program. They ensure that each line of code performs its function correctly and efficiently, they help the programmer identify and fix problems with his/her code, and they help to create a clear and organized code base.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "3. What are some applications of Data structures?",
        "answer": "Following are some real-time applications of data structures:   Decision Making\nGenetics\nImage Processing\nBlockchain\nNumerical and Statistical Analysis\nCompiler Design\nDatabase Design and many more Decision Making Genetics Image Processing Blockchain Numerical and Statistical Analysis Compiler Design Database Design and many more",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "4. Explain the process behind storing a variable in memory.",
        "answer": "A variable is stored in memory based on the amount of memory that is needed. Following are the steps followed to store a variable:\nThe required amount of memory is assigned first.\nThen, it is stored based on the data structure being used.\nUsing concepts like dynamic allocation ensures high efficiency and that the storage units can be accessed based on requirements in real-time. A variable is stored in memory based on the amount of memory that is needed. Following are the steps followed to store a variable:\nThe required amount of memory is assigned first.\nThen, it is stored based on the data structure being used. The required amount of memory is assigned first.\nThen, it is stored based on the data structure being used. The required amount of memory is assigned first. Then, it is stored based on the data structure being used. Using concepts like dynamic allocation ensures high efficiency and that the storage units can be accessed based on requirements in real-time.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "5. Can you explain the difference between file structure and storage structure?",
        "answer": "File Structure: Representation of data into secondary or auxiliary memory say any device such as a hard disk or pen drives that stores data which remains intact until manually deleted is known as a file structure representation.\nStorage Structure: In this type, data is stored in the main memory i.e RAM, and is deleted once the function that uses this data gets completely executed. File Structure: Representation of data into secondary or auxiliary memory say any device such as a hard disk or pen drives that stores data which remains intact until manually deleted is known as a file structure representation. File Structure: Storage Structure: In this type, data is stored in the main memory i.e RAM, and is deleted once the function that uses this data gets completely executed. Storage Structure The difference is that the storage structure has data stored in the memory of the computer system, whereas the file structure has the data stored in the auxiliary memory.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "6. Describe the types of Data Structures?",
        "answer": "  Linear Data Structure: A data structure that includes data elements arranged sequentially or linearly, where each element is connected to its previous and next nearest elements, is referred to as a linear data structure. Arrays and linked lists are two examples of linear data structures.\nNon-Linear Data Structure: Non-linear data structures are data structures in which data elements are not arranged linearly or sequentially. We cannot walk through all elements in one pass in a non-linear data structure, as in a linear data structure. Trees and graphs are two examples of non-linear data structures. Linear Data Structure: A data structure that includes data elements arranged sequentially or linearly, where each element is connected to its previous and next nearest elements, is referred to as a linear data structure. Arrays and linked lists are two examples of linear data structures. Linear Data Structure: Non-Linear Data Structure: Non-linear data structures are data structures in which data elements are not arranged linearly or sequentially. We cannot walk through all elements in one pass in a non-linear data structure, as in a linear data structure. Trees and graphs are two examples of non-linear data structures. Non-Linear Data Structure:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "7. What is a stack data structure? What are the applications of stack?",
        "answer": "A stack is a data structure that is used to represent the state of an application at a particular point in time. The stack consists of a series of items that are added to the top of the stack and then removed from the top. It is a linear data structure that follows a particular order in which operations are performed. LIFO (Last In First Out) or FILO (First In Last Out) are two possible orders. A stack consists of a sequence of items. The element that's added last will come out first, a real-life example might be a stack of clothes on top of each other. When we remove the cloth that was previously on top, we can say that the cloth that was added last comes out first.   Following are some applications for stack data structure: It acts as temporary storage during recursive operations\nRedo and Undo operations in doc editors\nReversing a string\nParenthesis matching\nPostfix to Infix Expressions\nFunction calls order It acts as temporary storage during recursive operations Redo and Undo operations in doc editors Reversing a string Parenthesis matching Postfix to Infix Expressions Function calls order",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "8. What are different operations available in stack data structure?",
        "answer": "Some of the main operations provided in the stack data structure are: push: This adds an item to the top of the stack. The overflow condition occurs if the stack is full.\npop: This removes the top item of the stack. Underflow condition occurs if the stack is empty.\ntop: This returns the top item from the stack.\nisEmpty: This returns true if the stack is empty else false.\nsize:  This returns the size of the stack. push: This adds an item to the top of the stack. The overflow condition occurs if the stack is full. push: pop: This removes the top item of the stack. Underflow condition occurs if the stack is empty. pop: top: This returns the top item from the stack. top: isEmpty: This returns true if the stack is empty else false. isEmpty: size:  This returns the size of the stack. size:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "9. What is a queue data structure? What are the applications of queue?",
        "answer": "A queue is a linear data structure that allows users to store items in a list in a systematic manner. The items are added to the queue at the rear end until they are full, at which point they are removed from the queue from the front. Queues are commonly used in situations where the users want to hold items for a long period of time, such as during a checkout process. A good example of a queue is any queue of customers for a resource where the first consumer is served first.   Following are some applications of queue data structure: Breadth-first search algorithm in graphs\nOperating system: job scheduling operations, Disk scheduling, CPU scheduling etc.\nCall management in call centres Breadth-first search algorithm in graphs Operating system: job scheduling operations, Disk scheduling, CPU scheduling etc. Call management in call centres",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "10. What are different operations available in queue data structure?",
        "answer": "enqueue: This adds an element to the rear end of the queue.  Overflow conditions occur if the queue is full.\ndequeue: This removes an element from the front end of the queue. Underflow conditions occur if the queue is empty.\nisEmpty: This returns true if the queue is empty or else false.\nrear: This returns the rear end element without removing it.\nfront: This returns the front-end element without removing it.\nsize: This returns the size of the queue. enqueue: This adds an element to the rear end of the queue.  Overflow conditions occur if the queue is full. enqueue: dequeue: This removes an element from the front end of the queue. Underflow conditions occur if the queue is empty. dequeue: isEmpty: This returns true if the queue is empty or else false. isEmpty: rear: This returns the rear end element without removing it. rear: front: This returns the front-end element without removing it. front: size: This returns the size of the queue. size:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "11. Differentiate between stack and queue data structure.",
        "answer": "  Stack Queue\nStack is a linear data structure where data is added and removed from the top. Queue is a linear data structure where data is ended at the rear end and removed from the front.\nStack is based on LIFO(Last In First Out) principle Queue is based on FIFO(First In First Out) principle\nInsertion operation in Stack is known as push. Insertion operation in Queue is known as eneque.\nDelete operation in Stack is known as pop. Delete operation in Queue is known as dequeue.\nOnly one pointer is available for both addition and deletion: top() Two pointers are available for addition and deletion: front() and rear()\nUsed in solving recursion problems Used in solving sequential processing problems Stack Queue\nStack is a linear data structure where data is added and removed from the top. Queue is a linear data structure where data is ended at the rear end and removed from the front.\nStack is based on LIFO(Last In First Out) principle Queue is based on FIFO(First In First Out) principle\nInsertion operation in Stack is known as push. Insertion operation in Queue is known as eneque.\nDelete operation in Stack is known as pop. Delete operation in Queue is known as dequeue.\nOnly one pointer is available for both addition and deletion: top() Two pointers are available for addition and deletion: front() and rear()\nUsed in solving recursion problems Used in solving sequential processing problems Stack Queue Stack Queue Stack Queue Stack is a linear data structure where data is added and removed from the top. Queue is a linear data structure where data is ended at the rear end and removed from the front.\nStack is based on LIFO(Last In First Out) principle Queue is based on FIFO(First In First Out) principle\nInsertion operation in Stack is known as push. Insertion operation in Queue is known as eneque.\nDelete operation in Stack is known as pop. Delete operation in Queue is known as dequeue.\nOnly one pointer is available for both addition and deletion: top() Two pointers are available for addition and deletion: front() and rear()\nUsed in solving recursion problems Used in solving sequential processing problems Stack is a linear data structure where data is added and removed from the top. Queue is a linear data structure where data is ended at the rear end and removed from the front. Stack is a linear data structure where data is added and removed from the top. Queue is a linear data structure where data is ended at the rear end and removed from the front. Stack is based on LIFO(Last In First Out) principle Queue is based on FIFO(First In First Out) principle Stack is based on LIFO(Last In First Out) principle Queue is based on FIFO(First In First Out) principle Insertion operation in Stack is known as push. Insertion operation in Queue is known as eneque. Insertion operation in Stack is known as push. Insertion operation in Queue is known as eneque. Delete operation in Stack is known as pop. Delete operation in Queue is known as dequeue. Delete operation in Stack is known as pop. Delete operation in Queue is known as dequeue. Only one pointer is available for both addition and deletion: top() Two pointers are available for addition and deletion: front() and rear() Only one pointer is available for both addition and deletion: top() Two pointers are available for addition and deletion: front() and rear() Used in solving recursion problems Used in solving sequential processing problems Used in solving recursion problems Used in solving sequential processing problems",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "12. How to implement a queue using stack?",
        "answer": "A queue can be implemented using two stacks. Let q be the queue andstack1 and stack2 be the 2 stacks for implementing q. We know that stack supports push, pop, and peek operations and using these operations, we need to emulate the operations of the queue - enqueue and dequeue. Hence, queue q can be implemented in two methods (Both the methods use auxillary space complexity of O(n)): two stacks q stack1 stack2 q q 1. By making enqueue operation costly: 1. By making enqueue operation costly: Here, the oldest element is always at the top of stack1 which ensures dequeue operation occurs in O(1) time complexity.\nTo place the element at top of stack1, stack2 is used.\nPseudocode:\nEnqueue: Here time complexity will be O(n) Here, the oldest element is always at the top of stack1 which ensures dequeue operation occurs in O(1) time complexity. stack1 To place the element at top of stack1, stack2 is used. Pseudocode:\nEnqueue: Here time complexity will be O(n) Pseudocode: Enqueue: Here time complexity will be O(n) Enqueue: Here time complexity will be O(n) Enqueue: enqueue(q, data):  \nWhile stack1 is not empty:\n     Push everything from stack1 to stack2.\n      Push data to stack1\n      Push everything back to stack1. enqueue(q, data):  \nWhile stack1 is not empty:\n     Push everything from stack1 to stack2.\n      Push data to stack1\n      Push everything back to stack1. Dequeue: Here time complexity will be O(1) Dequeue: Here time complexity will be O(1) Dequeue: deQueue(q):\n If stack1 is empty then error  else\n Pop an item from stack1 and return it deQueue(q):\n If stack1 is empty then error  else\n Pop an item from stack1 and return it 2. By making the dequeue operation costly: 2. By making the dequeue operation costly: Here, for enqueue operation, the new element is pushed at the top of stack1. Here, the enqueue operation time complexity is O(1).\nIn dequeue, if stack2 is empty, all elements from stack1 are moved to stack2 and top of stack2 is the result. Basically, reversing the list by pushing to a stack and returning the first enqueued element. This operation of pushing all elements to a new stack takes O(n) complexity.\nPseudocode:\nEnqueue: Time complexity: O(1) Here, for enqueue operation, the new element is pushed at the top of stack1. Here, the enqueue operation time complexity is O(1). stack1 In dequeue, if stack2 is empty, all elements from stack1 are moved to stack2 and top of stack2 is the result. Basically, reversing the list by pushing to a stack and returning the first enqueued element. This operation of pushing all elements to a new stack takes O(n) complexity. stack2 stack1 stack2 stack2 Pseudocode:\nEnqueue: Time complexity: O(1) Pseudocode: Enqueue: Time complexity: O(1) Enqueue: Time complexity: O(1) Enqueue: enqueue(q, data):    \nPush data to stack1 enqueue(q, data):    \nPush data to stack1 Dequeue: Time complexity: O(n) Dequeue: Time complexity: O(n) Dequeue: dequeue(q): \nIf both stacks are empty then raise error.\nIf stack2 is empty:  \nWhile stack1 is not empty:\n push everything from stack1 to stack2. \n  Pop the element from stack2 and return it. dequeue(q): \nIf both stacks are empty then raise error.\nIf stack2 is empty:  \nWhile stack1 is not empty:\n push everything from stack1 to stack2. \n  Pop the element from stack2 and return it.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "13. How do you implement stack using queues?",
        "answer": "A stack can be implemented using two queues. We know that a queue supports enqueue and dequeue operations. Using these operations, we need to develop push, pop operations.\nLet stack be ‘s’ and queues used to implement be ‘q1’ and ‘q2’. Then, stack ‘s’ can be implemented in two ways: A stack can be implemented using two queues. We know that a queue supports enqueue and dequeue operations. Using these operations, we need to develop push, pop operations. Let stack be ‘s’ and queues used to implement be ‘q1’ and ‘q2’. Then, stack ‘s’ can be implemented in two ways: 1. By making push operation costly: 1. By making push operation costly: This method ensures that the newly entered element is always at the front of ‘q1’ so that pop operation just dequeues from ‘q1’.\n‘q2’ is used as auxillary queue to put every new element in front of ‘q1’ while ensuring pop happens in O(1) complexity.\nPseudocode:\nPush element to stack s: Here push takes O(n) time complexity. This method ensures that the newly entered element is always at the front of ‘q1’ so that pop operation just dequeues from ‘q1’. ‘q2’ is used as auxillary queue to put every new element in front of ‘q1’ while ensuring pop happens in O(1) complexity. Pseudocode:\nPush element to stack s: Here push takes O(n) time complexity. Pseudocode: Push element to stack s: Here push takes O(n) time complexity. Push element to stack s: Here push takes O(n) time complexity. push(s, data):\n    Enqueue data to q2\n    Dequeue elements one by one from q1 and enqueue to q2.\n    Swap the names of q1 and q2 push(s, data):\n    Enqueue data to q2\n    Dequeue elements one by one from q1 and enqueue to q2.\n    Swap the names of q1 and q2 Pop element from stack s: Takes O(1) time complexity. Pop element from stack s: Takes O(1) time complexity. pop(s):\ndequeue from q1 and return it. pop(s):\ndequeue from q1 and return it. 2. By making pop operation costly: 2. By making pop operation costly: In push operation, the element is enqueued to q1.\nIn pop operation, all the elements from q1 except the last remaining element, are pushed to q2 if it is empty. That last element remaining of q1 is dequeued and returned.\nPseudocode:\nPush element to stack s: Here push takes O(1) time complexity. In push operation, the element is enqueued to q1. In pop operation, all the elements from q1 except the last remaining element, are pushed to q2 if it is empty. That last element remaining of q1 is dequeued and returned. Pseudocode:\nPush element to stack s: Here push takes O(1) time complexity. Pseudocode: Push element to stack s: Here push takes O(1) time complexity. Push element to stack s: Here push takes O(1) time complexity. push(s,data):\nEnqueue data to q1 push(s,data):\nEnqueue data to q1 Pop element from stack s: Takes O(n) time complexity. Pop element from stack s: Takes O(n) time complexity. pop(s): \n Step1: Dequeue every elements except the last element from q1 and enqueue to q2.\n Step2: Dequeue the last item of q1, the dequeued item is stored in result variable.\n  Step3: Swap the names of q1 and q2 (for getting updated data after dequeue) \n  Step4: Return the result. pop(s): \n Step1: Dequeue every elements except the last element from q1 and enqueue to q2.\n Step2: Dequeue the last item of q1, the dequeued item is stored in result variable.\n  Step3: Swap the names of q1 and q2 (for getting updated data after dequeue) \n  Step4: Return the result.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "14. What is array data structure? What are the applications of arrays?",
        "answer": "An array data structure is a data structure that is used to store data in a way that is efficient and easy to access. It is similar to a list in that it stores data in a sequence. However, an array data structure differs from a list in that it can hold much more data than a list can. An array data structure is created by combining several arrays together. Each array is then given a unique identifier, and each array’s data is stored in the order in which they are created.   Array data structures are commonly used in databases and other computer systems to store large amounts of data efficiently. They are also useful for storing information that is frequently accessed, such as large amounts of text or images.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "15. Elaborate on different types of array data structure",
        "answer": "There are several different types of arrays: One-dimensional array: A one-dimensional array stores its elements in contiguous memory locations, accessing them using a single index value. It is a linear data structure holding all the elements in a sequence. One-dimensional array: A one-dimensional array stores its elements in contiguous memory locations, accessing them using a single index value. It is a linear data structure holding all the elements in a sequence. One-dimensional array:   Two-dimensional array: A two-dimensional array is a tabular array that includes rows and columns and stores data. An M × N two-dimensional array is created by grouping M rows and N columns into N columns and rows. Two-dimensional array: A two-dimensional array is a tabular array that includes rows and columns and stores data. An M × N two-dimensional array is created by grouping M rows and N columns into N columns and rows. Two-dimensional array:   Three-dimensional array: A three-dimensional array is a grid that has rows, columns, and depth as a third dimension. It comprises a cube with rows, columns, and depth as a third dimension. The three-dimensional array has three subscripts for a position in a particular row, column, and depth. Depth (dimension or layer) is the first index, row index is the second index, and column index is the third index. Three-dimensional array: A three-dimensional array is a grid that has rows, columns, and depth as a third dimension. It comprises a cube with rows, columns, and depth as a third dimension. The three-dimensional array has three subscripts for a position in a particular row, column, and depth. Depth (dimension or layer) is the first index, row index is the second index, and column index is the third index. Three-dimensional array:  ",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "16. What is a linked list data structure? What are the applications for the Linked list?",
        "answer": "A linked list can be thought of as a series of linked nodes (or items) that are connected by links (or paths). Each link represents an entry into the linked list, and each entry points to the next node in the sequence. The order in which nodes are added to the list is determined by the order in which they are created.   Following are some applications of linked list data structure: Stack, Queue, binary trees, and graphs are implemented using linked lists.\nDynamic management for Operating System memory.\nRound robin scheduling for operating system tasks.\nForward and backward operation in the browser. Stack, Queue, binary trees, and graphs are implemented using linked lists. Dynamic management for Operating System memory. Round robin scheduling for operating system tasks. Forward and backward operation in the browser.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "17. Elaborate on different types of Linked List data structures?",
        "answer": "Following are different types of linked lists: 1. Singly Linked List: A singly linked list is a data structure that is used to store multiple items. The items are linked together using the key. The key is used to identify the item and is usually a unique identifier. In a singly linked list, each item is stored in a separate node. The node can be a single object or it can be a collection of objects. When an item is added to the list, the node is updated and the new item is added to the end of the list. When an item is removed from the list, the node that contains the removed item is deleted and its place is taken by another node. The key of a singly linked list can be any type of data structure that can be used to identify an object. For example, it could be an integer, a string, or even another singly linked list. Singly-linked lists are useful for storing many different types of data. For example, they are commonly used to store lists of items such as grocery lists or patient records. They are also useful for storing data that is time sensitive such as stock market prices or flight schedules. 1. Singly Linked List:   2. Doubly Linked List: A doubly linked list is a data structure that allows for two-way data access such that each node in the list points to the next node in the list and also points back to its previous node. In a doubly linked list, each node can be accessed by its address, and the contents of the node can be accessed by its index. It's ideal for applications that need to access large amounts of data in a fast manner. A disadvantage of a doubly linked list is that it is more difficult to maintain than a single-linked list. In addition, it is more difficult to add and remove nodes than in a single-linked list. 2. Doubly Linked List:   3. Circular Linked List: A circular linked list is a unidirectional linked list where each node points to its next node and the last node points back to the first node, which makes it circular. 3. Circular Linked List:   4. Doubly Circular Linked List: A doubly circular linked list is a linked list where each node points to its next node and its previous node and the last node points back to the first node and first node’s previous points to the last node. 4. Doubly Circular Linked List:   5. Header List: A list that contains the header node at the beginning of the list, is called the header-linked list. This is helpful in calculating some repetitive operations like the number of elements in the list etc. 5. Header List:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "18. Difference between Array and Linked List.",
        "answer": "  Arrays Linked Lists\nAn array is a collection of data elements of the same type. A linked list is a collection of entities known as nodes. The node is divided into two sections: data and address.\nIt keeps the data elements in a single memory. It stores elements at random, or anywhere in the memory.\nThe memory size of an array is fixed and cannot be changed during runtime. The memory size of a linked list is allocated during runtime.\nAn array's elements are not dependent on one another. Linked List elements are dependent on one another.\nIt is easier and faster to access an element in an array. In the linked list, it takes time to access an element.\nMemory utilization is ineffective in the case of an array. Memory utilization is effective in the case of linked lists.\nOperations like insertion and deletion take longer time in an array. Operations like insertion and deletion are faster in the linked list. Arrays Linked Lists\nAn array is a collection of data elements of the same type. A linked list is a collection of entities known as nodes. The node is divided into two sections: data and address.\nIt keeps the data elements in a single memory. It stores elements at random, or anywhere in the memory.\nThe memory size of an array is fixed and cannot be changed during runtime. The memory size of a linked list is allocated during runtime.\nAn array's elements are not dependent on one another. Linked List elements are dependent on one another.\nIt is easier and faster to access an element in an array. In the linked list, it takes time to access an element.\nMemory utilization is ineffective in the case of an array. Memory utilization is effective in the case of linked lists.\nOperations like insertion and deletion take longer time in an array. Operations like insertion and deletion are faster in the linked list. Arrays Linked Lists Arrays Linked Lists Arrays Linked Lists An array is a collection of data elements of the same type. A linked list is a collection of entities known as nodes. The node is divided into two sections: data and address.\nIt keeps the data elements in a single memory. It stores elements at random, or anywhere in the memory.\nThe memory size of an array is fixed and cannot be changed during runtime. The memory size of a linked list is allocated during runtime.\nAn array's elements are not dependent on one another. Linked List elements are dependent on one another.\nIt is easier and faster to access an element in an array. In the linked list, it takes time to access an element.\nMemory utilization is ineffective in the case of an array. Memory utilization is effective in the case of linked lists.\nOperations like insertion and deletion take longer time in an array. Operations like insertion and deletion are faster in the linked list. An array is a collection of data elements of the same type. A linked list is a collection of entities known as nodes. The node is divided into two sections: data and address. An array is a collection of data elements of the same type. A linked list is a collection of entities known as nodes. The node is divided into two sections: data and address. It keeps the data elements in a single memory. It stores elements at random, or anywhere in the memory. It keeps the data elements in a single memory. It stores elements at random, or anywhere in the memory. The memory size of an array is fixed and cannot be changed during runtime. The memory size of a linked list is allocated during runtime. The memory size of an array is fixed and cannot be changed during runtime. The memory size of a linked list is allocated during runtime. An array's elements are not dependent on one another. Linked List elements are dependent on one another. An array's elements are not dependent on one another. Linked List elements are dependent on one another. It is easier and faster to access an element in an array. In the linked list, it takes time to access an element. It is easier and faster to access an element in an array. In the linked list, it takes time to access an element. Memory utilization is ineffective in the case of an array. Memory utilization is effective in the case of linked lists. Memory utilization is ineffective in the case of an array. Memory utilization is effective in the case of linked lists. Operations like insertion and deletion take longer time in an array. Operations like insertion and deletion are faster in the linked list. Operations like insertion and deletion take longer time in an array. Operations like insertion and deletion are faster in the linked list.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "19. What is an asymptotic analysis of an algorithm?",
        "answer": "Asymptotic analysis of an algorithm defines the run-time performance as per its mathematical boundations. Asymptotic analysis helps us articulate the best case(Omega Notation, Ω), average case(Theta Notation, θ), and worst case(Big Oh Notation, Ο) performance of an algorithm.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "20. What is hashmap in data structure?",
        "answer": "Hashmap is a data structure that uses an implementation of a hash table data structure which allows access to data in constant time (O(1)) complexity if you have the key.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "21. What is the requirement for an object to be used as key or value in HashMap?",
        "answer": "The key or value object that gets used in the hashmap must implement equals() and hashcode() method.\nThe hash code is used when inserting the key object into the map and the equals method is used when trying to retrieve a value from the map. The key or value object that gets used in the hashmap must implement equals() and hashcode() method. equals() hashcode() The hash code is used when inserting the key object into the map and the equals method is used when trying to retrieve a value from the map.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "22. How does HashMap handle collisions in Java?",
        "answer": "The java.util.HashMap class in Java uses the approach of chaining to handle collisions. In chaining, if the new values with the same key are attempted to be pushed, then these values are stored in a linked list stored in a bucket of the key as a chain along with the existing value.\nIn the worst-case scenario, it can happen that all keys might have the same hashcode, which will result in the hash table turning into a linked list. In this case, searching a value will take O(n) complexity as opposed to O(1) time due to the nature of the linked list. Hence, care has to be taken while selecting hashing algorithm. The java.util.HashMap class in Java uses the approach of chaining to handle collisions. In chaining, if the new values with the same key are attempted to be pushed, then these values are stored in a linked list stored in a bucket of the key as a chain along with the existing value. java.util.HashMap In the worst-case scenario, it can happen that all keys might have the same hashcode, which will result in the hash table turning into a linked list. In this case, searching a value will take O(n) complexity as opposed to O(1) time due to the nature of the linked list. Hence, care has to be taken while selecting hashing algorithm.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "23. What is the time complexity of basic operations get() and put() in HashMap class?",
        "answer": "The time complexity is O(1) assuming that the hash function used in the hash map distributes elements uniformly among the buckets. assuming",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "1. What is binary tree data structure? What are the applications for binary trees?",
        "answer": "A binary tree is a data structure that is used to organize data in a way that allows for efficient retrieval and manipulation. It is a data structure that uses two nodes, called leaves and nodes, to represent the data. The leaves represent the data and the nodes represent the relationships between the leaves. Each node has two children, called siblings, and each child has one parent. The parent is the node that is closest to the root of the tree. When a node is deleted from the tree, it is deleted from both its child and its parent. Following are some applications for binary tree data structure:   It's widely used in computer networks for storing routing table information.\nDecision Trees.\nExpression Evaluation.\nDatabase indices. It's widely used in computer networks for storing routing table information. Decision Trees. Expression Evaluation. Database indices.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "2. What is binary search tree data structure? What are the applications for binary search trees?",
        "answer": "A binary search tree is a data structure that stores items in sorted order. In a binary search tree, each node stores a key and a value. The key is used to access the item and the value is used to determine whether the item is present or not. The key can be any type of value such as an integer, floating point number, character string, or even a combination of these types. The value can be any type of items such as an integer, floating point number, character string, or even a combination of these types. When a node is added to the tree, its key is used to access the item stored at that node. When a node is removed from the tree, its key is used to access the item stored at that node. A binary search tree is a special type of binary tree that has a specific order of elements in it. It has three basic qualities: All elements in the left subtree of a node should have a value less than or equal to the parent node's value, and\nAll elements in the right subtree of a node should have a value greater than or equal to the parent node's value.\nBoth the left and right subtrees must be binary search trees too. All elements in the left subtree of a node should have a value less than or equal to the parent node's value, and All elements in the right subtree of a node should have a value greater than or equal to the parent node's value. Both the left and right subtrees must be binary search trees too.   Following are some applications for binary tree data structure: It is used for indexing and multi-level indexing.\nIt is used for implementing various search algorithms.\nIt is helpful in organizing a sorted stream of data. It is used for indexing and multi-level indexing. It is used for implementing various search algorithms. It is helpful in organizing a sorted stream of data.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "3. What are tree traversals?",
        "answer": "Tree traversal is the process of visiting all the nodes of a tree. Since the root (head) is the first node and all nodes are connected via edges (or links) we always start with that node. There are three ways which we use to traverse a tree − 1. Inorder Traversal: 1. Inorder Traversal: Algorithm:\nStep 1. Traverse the left subtree, i.e., call Inorder(root.left)\nStep 2. Visit the root.\nStep 3. Traverse the right subtree, i.e., call Inorder(root.right)\nInorder traversal in Java: Algorithm:\nStep 1. Traverse the left subtree, i.e., call Inorder(root.left)\nStep 2. Visit the root.\nStep 3. Traverse the right subtree, i.e., call Inorder(root.right) Step 1. Traverse the left subtree, i.e., call Inorder(root.left)\nStep 2. Visit the root.\nStep 3. Traverse the right subtree, i.e., call Inorder(root.right) Step 1. Traverse the left subtree, i.e., call Inorder(root.left) Step 2. Visit the root. Step 3. Traverse the right subtree, i.e., call Inorder(root.right) Inorder traversal in Java: // Print inorder traversal of given tree.\n     void printInorderTraversal(Node root) \n     { \n         if (root == null) \n             return;\n         //first traverse to the left subtree\n         printInorderTraversal(root.left);\n         //then print the data of node\n         System.out.print(root.data + \" \");\n         //then traverse to the right subtree\n         printInorderTraversal(root.right); \n     } // Print inorder traversal of given tree.\n     void printInorderTraversal(Node root) \n     { \n         if (root == null) \n             return;\n         //first traverse to the left subtree\n         printInorderTraversal(root.left);\n         //then print the data of node\n         System.out.print(root.data + \" \");\n         //then traverse to the right subtree\n         printInorderTraversal(root.right); \n     } Uses: In binary search trees (BST), inorder traversal gives nodes in ascending order. Uses: In binary search trees (BST), inorder traversal gives nodes in ascending order. 2. Preorder Traversal: 2. Preorder Traversal: Algorithm:\nStep 1. Visit the root.\nStep 2. Traverse the left subtree, i.e., call Preorder(root.left)\nStep 3. Traverse the right subtree, i.e., call Preorder(root.right)\nPreorder traversal in Java: Algorithm:\nStep 1. Visit the root.\nStep 2. Traverse the left subtree, i.e., call Preorder(root.left)\nStep 3. Traverse the right subtree, i.e., call Preorder(root.right) Step 1. Visit the root.\nStep 2. Traverse the left subtree, i.e., call Preorder(root.left)\nStep 3. Traverse the right subtree, i.e., call Preorder(root.right) Step 1. Visit the root. Step 2. Traverse the left subtree, i.e., call Preorder(root.left) Step 3. Traverse the right subtree, i.e., call Preorder(root.right) Preorder traversal in Java: // Print preorder traversal of given tree.\n    void printPreorderTraversal(Node root) \n    { \n        if (root == null) \n            return; \n        //first print the data of node\n        System.out.print(root.data + \" \");\n        //then traverse to the left subtree\n        printPreorderTraversal(root.left);                    \n        //then traverse to the right subtree\n        printPreorderTraversal(root.right); \n    } // Print preorder traversal of given tree.\n    void printPreorderTraversal(Node root) \n    { \n        if (root == null) \n            return; \n        //first print the data of node\n        System.out.print(root.data + \" \");\n        //then traverse to the left subtree\n        printPreorderTraversal(root.left);                    \n        //then traverse to the right subtree\n        printPreorderTraversal(root.right); \n    } Uses:\nPreorder traversal is commonly used to create a copy of the tree.\nIt is also used to get prefix expression of an expression tree. Uses:\nPreorder traversal is commonly used to create a copy of the tree.\nIt is also used to get prefix expression of an expression tree. Preorder traversal is commonly used to create a copy of the tree.\nIt is also used to get prefix expression of an expression tree. Preorder traversal is commonly used to create a copy of the tree. It is also used to get prefix expression of an expression tree. 3. Postorder Traversal: 3. Postorder Traversal: Algorithm:\nStep 1. Traverse the left subtree, i.e., call Postorder(root.left)\nStep 2. Traverse the right subtree, i.e., call Postorder(root.right)\nStep 3. Visit the root.\nPostorder traversal in Java: Algorithm:\nStep 1. Traverse the left subtree, i.e., call Postorder(root.left)\nStep 2. Traverse the right subtree, i.e., call Postorder(root.right)\nStep 3. Visit the root. Step 1. Traverse the left subtree, i.e., call Postorder(root.left)\nStep 2. Traverse the right subtree, i.e., call Postorder(root.right)\nStep 3. Visit the root. Step 1. Traverse the left subtree, i.e., call Postorder(root.left) Step 2. Traverse the right subtree, i.e., call Postorder(root.right) Step 3. Visit the root. Postorder traversal in Java: // Print postorder traversal of given tree.\nvoid printPostorderTraversal(Node root) \n{ \n if (root == null) \n     return;\n //first traverse to the left subtree\n printPostorderTraversal(root.left);                    \n //then traverse to the right subtree\n printPostorderTraversal(root.right);\n //then print the data of node\n System.out.print(root.data + \" \");\n} // Print postorder traversal of given tree.\nvoid printPostorderTraversal(Node root) \n{ \n if (root == null) \n     return;\n //first traverse to the left subtree\n printPostorderTraversal(root.left);                    \n //then traverse to the right subtree\n printPostorderTraversal(root.right);\n //then print the data of node\n System.out.print(root.data + \" \");\n} Uses:\nPostorder traversal is commonly used to delete the tree.\nIt is also useful to get the postfix expression of an expression tree. Uses:\nPostorder traversal is commonly used to delete the tree.\nIt is also useful to get the postfix expression of an expression tree. Postorder traversal is commonly used to delete the tree.\nIt is also useful to get the postfix expression of an expression tree. Postorder traversal is commonly used to delete the tree. It is also useful to get the postfix expression of an expression tree. Consider the following tree as an example, then:   Inorder Traversal => Left, Root, Right : [4, 2, 5, 1, 3]\nPreorder Traversal => Root, Left, Right : [1, 2, 4, 5, 3]\nPostorder Traversal => Left, Right, Root : [4, 5, 2, 3, 1] Inorder Traversal => Left, Root, Right : [4, 2, 5, 1, 3] Preorder Traversal => Root, Left, Right : [1, 2, 4, 5, 3] Postorder Traversal => Left, Right, Root : [4, 5, 2, 3, 1]",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "4. What is a deque data structure and its types? What are the applications for deque?",
        "answer": "A deque can be thought of as an array of items, but with one important difference: Instead of pushing and popping items off the end to make room, deques are designed to allow items to be inserted at either end. This property makes deques well-suited for performing tasks such as keeping track of inventory, scheduling tasks, or handling large amounts of data.   There are two types of deque: Input Restricted Deque: Insertion operations are performed at only one end while deletion is performed at both ends in the input restricted queue. Input Restricted Deque: Insertion operations are performed at only one end while deletion is performed at both ends in the input restricted queue. Input Restricted Deque:   Output Restricted Deque: Deletion operations are performed at only one end while insertion is performed at both ends in the output restricted queue. Output Restricted Deque: Deletion operations are performed at only one end while insertion is performed at both ends in the output restricted queue. Output Restricted Deque:   Following are some real-time applications for deque data structure: It can be used as both stack and queue, as it supports all the operations for both data structures.\nWeb browser’s history can be stored in a deque.\nOperating systems job scheduling algorithm. It can be used as both stack and queue, as it supports all the operations for both data structures. Web browser’s history can be stored in a deque. Operating systems job scheduling algorithm.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "5. What are some key operations performed on the Deque data structure?",
        "answer": "Following are the key operations available deque: insertFront(): This adds an element to the front of the Deque.\ninsertLast(): This adds an element to the rear of the Deque.\ndeleteFront(): This deletes an element from the front of the Deque.\ndeleteLast():This deletes an element from the front of the Deque.\ngetFront(): This gets an element from the front of the Deque. \ngetRear(): This gets an element from the rear of the Deque. \nisEmpty(): This checks whether Deque is empty or not.\nisFull(): This checks whether Deque is full or not. insertFront(): This adds an element to the front of the Deque. insertFront() insertLast(): This adds an element to the rear of the Deque. insertLast() deleteFront(): This deletes an element from the front of the Deque. deleteFront() deleteLast():This deletes an element from the front of the Deque. deleteLast() getFront(): This gets an element from the front of the Deque. getFront() getRear(): This gets an element from the rear of the Deque. getRear() isEmpty(): This checks whether Deque is empty or not. isEmpty() isFull(): This checks whether Deque is full or not. isFull()",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "6. What is a priority queue? What are the applications for priority queue?",
        "answer": "Priority Queue is an abstract data type that is similar to a queue in that each element is assigned a priority value. The order in which elements in a priority queue are served is determined by their priority (i.e., the order in which they are removed). If the elements have the same priority, they are served in the order they appear in the queue.   Following are some real-time applications for priority queue: Used in graph algorithms like Dijkstra, Prim’s Minimum spanning tree etc.\nHuffman code for data compression\nFinding Kth Largest/Smallest element Used in graph algorithms like Dijkstra, Prim’s Minimum spanning tree etc. Huffman code for data compression Finding Kth Largest/Smallest element",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "7. Compare different implementations of priority queue",
        "answer": "The following table contains an asymptotic analysis of different implementations of a priority queue: Operations peek insert delete\nLinked List O(1) O(n) O(1)\nBinary Heap O(1) O(log n) O(log n)\nBinary Search Tree O(1) O(log n) O(log n) Operations peek insert delete\nLinked List O(1) O(n) O(1)\nBinary Heap O(1) O(log n) O(log n)\nBinary Search Tree O(1) O(log n) O(log n) Operations peek insert delete Operations peek insert delete Operations peek insert delete Linked List O(1) O(n) O(1)\nBinary Heap O(1) O(log n) O(log n)\nBinary Search Tree O(1) O(log n) O(log n) Linked List O(1) O(n) O(1) Linked List O(1) O(n) O(1) Binary Heap O(1) O(log n) O(log n) Binary Heap O(1) O(log n) O(log n) Binary Search Tree O(1) O(log n) O(log n) Binary Search Tree O(1) O(log n) O(log n)",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "8. What is graph data structure and its representations? What are the applications for graphs?",
        "answer": "A graph is a type of non-linear data structure made up of nodes and edges. The nodes are also known as vertices, and edges are lines or arcs that connect any two nodes in the graph.   The following are the two most common graph representations: 1. Adjacency Matrix: Adjacency Matrix is a two-dimensional array with the dimensions V x V, where V is the number of vertices in a graph. Representation is simpler to implement and adhere to. It takes O(1) time to remove an edge. Queries such as whether there is an edge from vertex 'u' to vertex 'v' are efficient and can be completed in O(1). 1. Adjacency Matrix   One of the cons of this representation is that even if the graph is sparse (has fewer edges), it takes up the same amount of space. Adding a vertex takes O(V^2). It also takes O(V) time to compute all of a vertex's neighbours, which is not very efficient. 2. Adjacency List: In this method, each Node holds a list of Nodes that are directly connected to that vertex. Each node at the end of the list is connected with null values to indicate that it is the last node in the list. This saves space O(|V|+|E|). In the worst-case scenario, a graph can have C(V, 2) edges, consuming O(V^2) space. It is simpler to add a vertex. It takes the least amount of time to compute all of a vertex's neighbours. 2. Adjacency List:   One of the cons of this representation is that queries such as \"is there an edge from vertex u to vertex v?\" are inefficient and take O (V) in the worst case.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "9. What is the difference between the Breadth First Search (BFS) and Depth First Search (DFS)?",
        "answer": "  Breadth First Search (BFS) Depth First Search (DFS)\nIt stands for “Breadth First Search” It stands for “Depth First Search”\nBFS (Breadth First Search) finds the shortest path using the Queue data structure. DFS (Depth First Search) finds the shortest path using the Stack data structure.\nWe walk through all nodes on the same level before passing to the next level in BFS. DFS begins at the root node and proceeds as far as possible through the nodes until we reach the node with no unvisited nearby nodes.\nWhen compared to DFS, BFS is slower. When compared to BFS, DFS is faster.\nBFS performs better when the target is close to the source. DFS performs better when the target is far from the source.\nBFS necessitates more memory. DFS necessitates less memory.\nNodes that have been traversed multiple times are removed from the queue. When there are no more nodes to visit, the visited nodes are added to the stack and then removed.\nBacktracking is not an option in BFS. The DFS algorithm is a recursive algorithm that employs the concept of backtracking.\nIt is based on the FIFO principle (First In First Out). It is based on the LIFO principle (Last In First Out). Breadth First Search (BFS) Depth First Search (DFS)\nIt stands for “Breadth First Search” It stands for “Depth First Search”\nBFS (Breadth First Search) finds the shortest path using the Queue data structure. DFS (Depth First Search) finds the shortest path using the Stack data structure.\nWe walk through all nodes on the same level before passing to the next level in BFS. DFS begins at the root node and proceeds as far as possible through the nodes until we reach the node with no unvisited nearby nodes.\nWhen compared to DFS, BFS is slower. When compared to BFS, DFS is faster.\nBFS performs better when the target is close to the source. DFS performs better when the target is far from the source.\nBFS necessitates more memory. DFS necessitates less memory.\nNodes that have been traversed multiple times are removed from the queue. When there are no more nodes to visit, the visited nodes are added to the stack and then removed.\nBacktracking is not an option in BFS. The DFS algorithm is a recursive algorithm that employs the concept of backtracking.\nIt is based on the FIFO principle (First In First Out). It is based on the LIFO principle (Last In First Out). Breadth First Search (BFS) Depth First Search (DFS) Breadth First Search (BFS) Depth First Search (DFS) Breadth First Search (BFS) Depth First Search (DFS) It stands for “Breadth First Search” It stands for “Depth First Search”\nBFS (Breadth First Search) finds the shortest path using the Queue data structure. DFS (Depth First Search) finds the shortest path using the Stack data structure.\nWe walk through all nodes on the same level before passing to the next level in BFS. DFS begins at the root node and proceeds as far as possible through the nodes until we reach the node with no unvisited nearby nodes.\nWhen compared to DFS, BFS is slower. When compared to BFS, DFS is faster.\nBFS performs better when the target is close to the source. DFS performs better when the target is far from the source.\nBFS necessitates more memory. DFS necessitates less memory.\nNodes that have been traversed multiple times are removed from the queue. When there are no more nodes to visit, the visited nodes are added to the stack and then removed.\nBacktracking is not an option in BFS. The DFS algorithm is a recursive algorithm that employs the concept of backtracking.\nIt is based on the FIFO principle (First In First Out). It is based on the LIFO principle (Last In First Out). It stands for “Breadth First Search” It stands for “Depth First Search” It stands for “Breadth First Search” It stands for “Depth First Search” BFS (Breadth First Search) finds the shortest path using the Queue data structure. DFS (Depth First Search) finds the shortest path using the Stack data structure. BFS (Breadth First Search) finds the shortest path using the Queue data structure. DFS (Depth First Search) finds the shortest path using the Stack data structure. We walk through all nodes on the same level before passing to the next level in BFS. DFS begins at the root node and proceeds as far as possible through the nodes until we reach the node with no unvisited nearby nodes. We walk through all nodes on the same level before passing to the next level in BFS. DFS begins at the root node and proceeds as far as possible through the nodes until we reach the node with no unvisited nearby nodes. When compared to DFS, BFS is slower. When compared to BFS, DFS is faster. When compared to DFS, BFS is slower. When compared to BFS, DFS is faster. BFS performs better when the target is close to the source. DFS performs better when the target is far from the source. BFS performs better when the target is close to the source. DFS performs better when the target is far from the source. BFS necessitates more memory. DFS necessitates less memory. BFS necessitates more memory. DFS necessitates less memory. Nodes that have been traversed multiple times are removed from the queue. When there are no more nodes to visit, the visited nodes are added to the stack and then removed. Nodes that have been traversed multiple times are removed from the queue. When there are no more nodes to visit, the visited nodes are added to the stack and then removed. Backtracking is not an option in BFS. The DFS algorithm is a recursive algorithm that employs the concept of backtracking. Backtracking is not an option in BFS. The DFS algorithm is a recursive algorithm that employs the concept of backtracking. It is based on the FIFO principle (First In First Out). It is based on the LIFO principle (Last In First Out). It is based on the FIFO principle (First In First Out). It is based on the LIFO principle (Last In First Out).",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "10. What is AVL tree data structure, its operations, and its rotations? What are the applications for AVL trees?",
        "answer": "AVL trees are height balancing binary search trees named after their inventors Adelson, Velski, and Landis. The AVL tree compares the heights of the left and right subtrees and ensures that the difference is less than one. This distinction is known as the Balance Factor. BalanceFactor = height(left-subtree) − height(right-subtree) BalanceFactor = height(left-subtree) − height(right-subtree) BalanceFactor = height(left-subtree) − height(right-subtree)   We can perform the following two operations on AVL tree: Insertion: Insertion in an AVL tree is done in the same way that it is done in a binary search tree. However, it may cause a violation in the AVL tree property, requiring the tree to be balanced. Rotations can be used to balance the tree.\nDeletion: Deletion can also be performed in the same manner as in a binary search tree. Because deletion can disrupt the tree's balance, various types of rotations are used to rebalance it. Insertion: Insertion in an AVL tree is done in the same way that it is done in a binary search tree. However, it may cause a violation in the AVL tree property, requiring the tree to be balanced. Rotations can be used to balance the tree. Insertion: Deletion: Deletion can also be performed in the same manner as in a binary search tree. Because deletion can disrupt the tree's balance, various types of rotations are used to rebalance it. Deletion: An AVL tree can balance itself by performing the four rotations listed below: Left rotation: When a node is inserted into the right subtree of the right subtree and the tree becomes unbalanced, we perform a single left rotation.\nRight rotation: If a node is inserted in the left subtree of the left subtree, the AVL tree may become unbalanced. The tree then requires right rotation.\nLeft-Right rotation: The RR rotation is performed first on the subtree, followed by the LL rotation on the entire tree.\nRight-Left rotation: The LL rotation is performed first on the subtree, followed by the RR rotation on the entire tree. Left rotation: When a node is inserted into the right subtree of the right subtree and the tree becomes unbalanced, we perform a single left rotation. Left rotation: Right rotation: If a node is inserted in the left subtree of the left subtree, the AVL tree may become unbalanced. The tree then requires right rotation. Right rotation: Left-Right rotation: The RR rotation is performed first on the subtree, followed by the LL rotation on the entire tree. Left-Right rotation: Right-Left rotation: The LL rotation is performed first on the subtree, followed by the RR rotation on the entire tree. Right-Left rotation: Following are some real-time applications for AVL tree data structure: AVL trees are typically used for in-memory sets and dictionaries.\nAVL trees are also widely used in database applications where there are fewer insertions and deletions but frequent data lookups are required.\nApart from database applications, it is used in applications that require improved searching. AVL trees are typically used for in-memory sets and dictionaries. AVL trees are also widely used in database applications where there are fewer insertions and deletions but frequent data lookups are required. Apart from database applications, it is used in applications that require improved searching.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "11. What is a B-tree data structure? What are the applications for B-trees?",
        "answer": "The B Tree is a type of m-way tree that is commonly used for disc access. A B-Tree with order m can only have m-1 keys and m children. One of the primary reasons for using a B tree is its ability to store a large number of keys in a single node as well as large key values while keeping the tree's height relatively small. A B-tree of order 4 is shown below in the image:   Following are the key properties of a B-tree data structure: All of the leaves are at the same height.\nThe term minimum degree 't' describes a B-Tree. The value of t is determined by the size of the disc block.\nExcept for root, every node must have at least t-1 keys. The root must contain at least one key.\nAll nodes (including root) can have no more than 2*t - 1 keys.\nThe number of children of a node is equal to its key count plus one.\nA node's keys are sorted in ascending order. The child of two keys k1 and k2 contains all keys between k1 and k2.\nIn contrast to Binary Search Tree, B-Tree grows and shrinks from the root. All of the leaves are at the same height. The term minimum degree 't' describes a B-Tree. The value of t is determined by the size of the disc block. Except for root, every node must have at least t-1 keys. The root must contain at least one key. All nodes (including root) can have no more than 2*t - 1 keys. The number of children of a node is equal to its key count plus one. A node's keys are sorted in ascending order. The child of two keys k1 and k2 contains all keys between k1 and k2. In contrast to Binary Search Tree, B-Tree grows and shrinks from the root. Following are real-time applications of a B-Tree data structure: It is used to access data stored on discs in large databases.\nUsing a B tree, you can search for data in a data set in significantly less time.\nThe indexing feature allows for multilevel indexing.\nThe B-tree approach is also used by the majority of servers. It is used to access data stored on discs in large databases. Using a B tree, you can search for data in a data set in significantly less time. The indexing feature allows for multilevel indexing. The B-tree approach is also used by the majority of servers.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "12. Define Segment Tree data structure and its applications.",
        "answer": "A segment Tree is a binary tree that is used to store intervals or segments. The Segment Tree is made up of nodes that represent intervals. Segment Tree is used when there are multiple range queries on an array and changes to array elements. The segment tree of array A[7] will look like this:   Following are key operations performed on the Segment tree data structure: Building Tree: In this step, we create the structure and initialize the segment tree variable.\nUpdating the Tree: In this step, we change the tree by updating the array value at a point or over an interval.\nQuerying Tree: This operation can be used to run a range query on the array. Building Tree: In this step, we create the structure and initialize the segment tree variable. Updating the Tree: In this step, we change the tree by updating the array value at a point or over an interval. Querying Tree: This operation can be used to run a range query on the array. Following are real-time applications for Segment Tree: Used to efficiently list all pairs of intersecting rectangles from a list of rectangles in the plane.\nThe segment tree has become popular for use in pattern recognition and image processing.\nFinding range sum/product, range max/min, prefix sum/product, etc\nComputational geometry\nGeographic information systems\nStatic and Dynamic RMQ (Range Minimum Query)\nStoring segments in an arbitrary manner Used to efficiently list all pairs of intersecting rectangles from a list of rectangles in the plane. The segment tree has become popular for use in pattern recognition and image processing. Finding range sum/product, range max/min, prefix sum/product, etc Computational geometry Geographic information systems Static and Dynamic RMQ (Range Minimum Query) Storing segments in an arbitrary manner",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "13. Define Trie data structure and its applications",
        "answer": "The word \"Trie\" is an abbreviation for \"retrieval.\" Trie is a data structure that stores a set of strings as a sorted tree. Each node has the same number of pointers as the number of alphabet characters. It can look up a word in the dictionary by using its prefix. Assuming that all strings are formed from the letters 'a' to 'z' in the English alphabet, each trie node can have a maximum of 26 points. Trie is also referred to as the digital tree or the prefix tree. The key to which a node is connected is determined by its position in the Trie. Trie allows us to insert and find strings in O(L) time, where L is the length of a single word. This is clearly faster than BST. Because of how it is implemented, this is also faster than Hashing. There is no need to compute a hash function. There is no need to handle collisions (like we do in open addressing and separate chaining) Another benefit of Trie is that we can easily print all words in alphabetical order, which is not easy with hashing. Trie can also perform prefix search (or auto-complete) efficiently.   The main disadvantage of tries is that they require a large amount of memory to store the strings. We have an excessive number of node pointers for each node Following are some real-time applications for Trie data structure: Auto-Complete and Search for Search Engines\nGenome Analysis\nData Analytics\nBrowser History\nSpell Checker Auto-Complete and Search for Search Engines Genome Analysis Data Analytics Browser History Spell Checker",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "14. Define Red-Black Tree and its applications",
        "answer": "Red Black Trees are a type of self-balancing binary search tree. Rudolf Bayer invented it in 1972 and dubbed it \"symmetric binary B-trees.\" A red-black tree is a Binary tree in which each node has a colour attribute, either red or black. By comparing the node colours on any simple path from the root to a leaf, red-black trees ensure that no path is more than twice as long as any other, ensuring that the tree is generally balanced. Red-black trees are similar to binary trees in that they both store their data in two's complementary binary formats. However, red-black trees have one important advantage over binary trees: they are faster to access. Because red-black trees are so fast to access, they are often used to store large amounts of data. Red-black trees can be used to store any type of data that can be represented as a set of values.   Every Red-Black Tree Obeys the Following Rules: Every node is either red or black.\nThe tree's root is always black.\nThere are no two red nodes that are adjacent.\nThere is the same number of black nodes on every path from a node to any of its descendant's NULL nodes.\nAll of the leaf nodes are black. Every node is either red or black. The tree's root is always black. There are no two red nodes that are adjacent. There is the same number of black nodes on every path from a node to any of its descendant's NULL nodes. All of the leaf nodes are black. Following are some real-time applications for the Red-Black Tree data structure: The majority of self-balancing BST library functions in C++ or Java use Red-Black Trees.\nIt is used to implement Linux CPU Scheduling.\nIt is also used to reduce time complexity in the K-mean clustering algorithm in machine learning.\nMySQL also employs the Red-Black tree for table indexes in order to reduce searching and insertion time. The majority of self-balancing BST library functions in C++ or Java use Red-Black Trees. It is used to implement Linux CPU Scheduling. It is also used to reduce time complexity in the K-mean clustering algorithm in machine learning. MySQL also employs the Red-Black tree for table indexes in order to reduce searching and insertion time.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "15. Which data structures are used for implementing LRU cache?",
        "answer": "LRU cache or Least Recently Used cache allows quick identification of an element that hasn’t been put to use for the longest time by organizing items in order of use. In order to achieve this, two data structures are used: Queue – This is implemented using a doubly-linked list. The maximum size of the queue is determined by the cache size, i.e by the total number of available frames. The least recently used pages will be near the front end of the queue whereas the most recently used pages will be towards the rear end of the queue.\nHashmap – Hashmap stores the page number as the key along with the address of the corresponding queue node as the value. Queue – This is implemented using a doubly-linked list. The maximum size of the queue is determined by the cache size, i.e by the total number of available frames. The least recently used pages will be near the front end of the queue whereas the most recently used pages will be towards the rear end of the queue. Queue Hashmap – Hashmap stores the page number as the key along with the address of the corresponding queue node as the value. Hashmap  ",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "16. What is a heap data structure?",
        "answer": "Heap is a special tree-based non-linear data structure in which the tree is a complete binary tree. A binary tree is said to be complete if all levels are completely filled except possibly the last level and the last level has all elements as left as possible. Heaps are of two types: Max-Heap:\nIn a Max-Heap the data element present at the root node must be the greatest among all the data elements present in the tree.\nThis property should be recursively true for all sub-trees of that binary tree.\nMin-Heap:\nIn a Min-Heap the data element present at the root node must be the smallest (or minimum) among all the data elements present in the tree.\nThis property should be recursively true for all sub-trees of that binary tree. Max-Heap:\nIn a Max-Heap the data element present at the root node must be the greatest among all the data elements present in the tree.\nThis property should be recursively true for all sub-trees of that binary tree. Max-Heap: In a Max-Heap the data element present at the root node must be the greatest among all the data elements present in the tree.\nThis property should be recursively true for all sub-trees of that binary tree. In a Max-Heap the data element present at the root node must be the greatest among all the data elements present in the tree. This property should be recursively true for all sub-trees of that binary tree. Min-Heap:\nIn a Min-Heap the data element present at the root node must be the smallest (or minimum) among all the data elements present in the tree.\nThis property should be recursively true for all sub-trees of that binary tree. Min-Heap: In a Min-Heap the data element present at the root node must be the smallest (or minimum) among all the data elements present in the tree.\nThis property should be recursively true for all sub-trees of that binary tree. In a Min-Heap the data element present at the root node must be the smallest (or minimum) among all the data elements present in the tree. This property should be recursively true for all sub-trees of that binary tree.",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "1. Write a program to remove duplicates from a sorted array in place?",
        "answer": "Input: {1, 1, 1, 2, 3, 3, 6, 6, 7}\nOutput: {1, 2, 3, 6, 7}\nExplanation: The given input has only 1,2,3,6, and 7 as unique elements, hence the output only lists them out. Input: {1, 1, 1, 2, 3, 3, 6, 6, 7} Input Output: {1, 2, 3, 6, 7} Output Explanation: The given input has only 1,2,3,6, and 7 as unique elements, hence the output only lists them out. Explanation #include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution{\npublic:\n    //function that takes an array and its size as arguments\n    int removeDuplicates(int a[],int n){\n        int index=0;\n        for(int i=1;i<n;i++) {\n        \n            if(a[i]!=a[index]) { //change index\n                index++; //swap next line\n                a[index]=a[i]; \n            } \n          }\n          return index+1;\n    }\n};\n\nint main()\n{\n    int T;\n    //taking the number of test cases from user\n    cin>>T;\n    //running the loop for all test cases\n    while(T--)\n    {\n        int N;\n        //taking size input from user\n        cin>>N;\n        int a[N];\n        //taking array input from user\n        for(int i=0;i<N;i++)\n        {\n            cin>>a[i];\n        }\n        Solution ob;\n        //calling the removeDuplicates in the Solution class\n        int n = ob.removeDuplicates(a,N);\n        //printing the array after removing duplicates\n        for(int i=0;i<n;i++)\n            cout<<a[i]<<\" \";\n            cout<<endl;\n        }\n} #include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution{\npublic:\n    //function that takes an array and its size as arguments\n    int removeDuplicates(int a[],int n){\n        int index=0;\n        for(int i=1;i<n;i++) {\n        \n            if(a[i]!=a[index]) { //change index\n                index++; //swap next line\n                a[index]=a[i]; \n            } \n          }\n          return index+1;\n    }\n};\n\nint main()\n{\n    int T;\n    //taking the number of test cases from user\n    cin>>T;\n    //running the loop for all test cases\n    while(T--)\n    {\n        int N;\n        //taking size input from user\n        cin>>N;\n        int a[N];\n        //taking array input from user\n        for(int i=0;i<N;i++)\n        {\n            cin>>a[i];\n        }\n        Solution ob;\n        //calling the removeDuplicates in the Solution class\n        int n = ob.removeDuplicates(a,N);\n        //printing the array after removing duplicates\n        for(int i=0;i<n;i++)\n            cout<<a[i]<<\" \";\n            cout<<endl;\n        }\n} #include <bits/stdc++.h> include <bits/stdc++.h> using namespace class Solution{ class Solution public //function that takes an array and its size as arguments int removeDuplicates(int a[],int n) int removeDuplicates (int a[],int n) int int int 0 for int 1 if //change index //swap next line return 1 int main() int main () int //taking the number of test cases from user //running the loop for all test cases while int //taking size input from user int //taking array input from user for int 0 //calling the removeDuplicates in the Solution class int removeDuplicates //printing the array after removing duplicates for int 0 \" \" Time Complexity: O(n)\nSpace Complexity: O(1) Time Complexity: O(n) Time Complexity Space Complexity: O(1) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "2. Write a function for zigzag traversal in a binary tree",
        "answer": "Input: \nOutput: [1, 3, 2, 4, 5, 6, 8, 7]\nExplanation: Zigzag Traversal first iterates the given level of the tree from left to right and then the next level as the right to the level. Input: Input: Output: [1, 3, 2, 4, 5, 6, 8, 7] Output: Explanation: Zigzag Traversal first iterates the given level of the tree from left to right and then the next level as the right to the level. Explanation: // Tree Node\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n};\n\n//Function to store the zigzag order traversal of a tree in a list.\n    vector <int> zigZagTraversal(Node* root)\n    {\n     //creating two stacks for level traversals in both order\n     stack<Node*> st1;\n     stack<Node*> st2;\n     //vector to store the zigzag traversal\n     vector<int> result;\n     \n     //Initialize the first stack with the root element\n     st1.push(root);\n     \n     //Iterate until either of the stack is not empty\n     while(!st1.empty() || !st2.empty()){\n        //iterate until the first stack is not empty\n         while(!st1.empty()){\n             Node* temp=st1.top();\n             st1.pop();\n             result.push_back(temp->data);\n             \n             if(temp->left)\n                 st2.push(temp->left);\n             if(temp->right)\n                 st2.push(temp->right);\n         }\n         //Iterate until the second stack is not empty\n         while(!st2.empty()){\n             Node* temp=st2.top();\n             st2.pop();\n             result.push_back(temp->data);\n             \n             if(temp->right)\n                 st1.push(temp->right);\n             if(temp->left)\n                 st1.push(temp->left);\n             \n         }\n     }\n     return result;\n    } // Tree Node\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n};\n\n//Function to store the zigzag order traversal of a tree in a list.\n    vector <int> zigZagTraversal(Node* root)\n    {\n     //creating two stacks for level traversals in both order\n     stack<Node*> st1;\n     stack<Node*> st2;\n     //vector to store the zigzag traversal\n     vector<int> result;\n     \n     //Initialize the first stack with the root element\n     st1.push(root);\n     \n     //Iterate until either of the stack is not empty\n     while(!st1.empty() || !st2.empty()){\n        //iterate until the first stack is not empty\n         while(!st1.empty()){\n             Node* temp=st1.top();\n             st1.pop();\n             result.push_back(temp->data);\n             \n             if(temp->left)\n                 st2.push(temp->left);\n             if(temp->right)\n                 st2.push(temp->right);\n         }\n         //Iterate until the second stack is not empty\n         while(!st2.empty()){\n             Node* temp=st2.top();\n             st2.pop();\n             result.push_back(temp->data);\n             \n             if(temp->right)\n                 st1.push(temp->right);\n             if(temp->left)\n                 st1.push(temp->left);\n             \n         }\n     }\n     return result;\n    } Time Complexity: O(n)\nSpace Complexity: O(n) Time Complexity: O(n) Time Complexity Space Complexity: O(n) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "3. Write a function to sort a linked list of 0s, 1s and 2s",
        "answer": "Input: 0->1->0->2->1->0->2->1\nOutput: 0->0->0->1->1->1->2->2\nExplanation: All 0’s will come first then 1s and then 2s. This can be done in O(n) time by counting the occurrences of all three and rearranging them in the linked list. Input: 0->1->0->2->1->0->2->1 Input: Output: 0->0->0->1->1->1->2->2 Output: Explanation: All 0’s will come first then 1s and then 2s. This can be done in O(n) time by counting the occurrences of all three and rearranging them in the linked list. Explanation //structure of the linked list\nstruct Node {\n   int data;\n   Node *left;\n   Node *right;\n}\n//function take the head of the linked list as a parameter\nvoid sortList(Node *head)\n{\n   //if linked list is empty then return back \n   if(head==NULL)\n       return;\n   else\n   {\n       Node *temp=head;\n       Node *temp1=head;\n       //to store count of 0s, 1s, and 2s\n       int count0=0,count1=0,count2=0;\n       //calculating the count of 0s, 1s, and 2s\n       while(temp!=NULL)\n       {\n           if(temp->data==0)\n               count0++;\n           else if(temp->data==1)\n               count1++;\n           else\n               count2++;\n           temp=temp->next;\n       }\n       //iterating over count of 0s and filling the linked list\n       while(count0!=0)\n       {\n           temp1->data=0;\n           temp1=temp1->next;\n           count0--;\n       }\n     //iterating over count of 1s and filling the linked list\n       while(count1!=0)\n       {\n           temp1->data=1;\n           temp1=temp1->next;\n           count1--;\n       }   \n     //iterating over count of 2s and filling the linked list\n       while(count2!=0)\n       {\n           temp1->data=2;\n           temp1=temp1->next;\n           count2--;\n       }\n   }\n} //structure of the linked list\nstruct Node {\n   int data;\n   Node *left;\n   Node *right;\n}\n//function take the head of the linked list as a parameter\nvoid sortList(Node *head)\n{\n   //if linked list is empty then return back \n   if(head==NULL)\n       return;\n   else\n   {\n       Node *temp=head;\n       Node *temp1=head;\n       //to store count of 0s, 1s, and 2s\n       int count0=0,count1=0,count2=0;\n       //calculating the count of 0s, 1s, and 2s\n       while(temp!=NULL)\n       {\n           if(temp->data==0)\n               count0++;\n           else if(temp->data==1)\n               count1++;\n           else\n               count2++;\n           temp=temp->next;\n       }\n       //iterating over count of 0s and filling the linked list\n       while(count0!=0)\n       {\n           temp1->data=0;\n           temp1=temp1->next;\n           count0--;\n       }\n     //iterating over count of 1s and filling the linked list\n       while(count1!=0)\n       {\n           temp1->data=1;\n           temp1=temp1->next;\n           count1--;\n       }   \n     //iterating over count of 2s and filling the linked list\n       while(count2!=0)\n       {\n           temp1->data=2;\n           temp1=temp1->next;\n           count2--;\n       }\n   }\n} Time Complexity: O(n)\nSpace Complexity: O(1) Time Complexity: O(n) Time Complexity Space Complexity: O(1) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "4. Write a function to detect cycle in an undirected graph",
        "answer": "Input: n = 4, e = 4 , 0 1, 1 2, 2 3, 3 1\nOutput: Yes\nExplanation: The graph is represented as follows in adjacency list representation:\n0->1\n1->2\n2->3\n3->1 Input: n = 4, e = 4 , 0 1, 1 2, 2 3, 3 1 Input: Input: Output: Yes Output: Output: Explanation: The graph is represented as follows in adjacency list representation:\n0->1\n1->2\n2->3\n3->1 Explanation     From the above representation, we can see that there exists a cycle: 1→2→3→1 //function to run dfs for a given node in the graph\n  int dfs(int v,vector<int> adj[],vector<int> &visited,vector<int> &rec,int i,int parent){\n        int ans=0;\n        visited[i]=1;\n        rec[i]=1;\n        for(auto x : adj[i]){ \n            if(x!=parent) {\n                if(rec[x]) \n                    return 1;\n                ans=dfs(v,adj,visited,rec,x,i);\n                if(ans) \n                   return 1;\n            }\n        }\n        rec[i]=0;\n        return 0;\n    }\n    // Function to detect cycle in an undirected graph.\n    // it takes adjacency list representation as an argument\n    bool isCycle(int v, vector<int> adj[]) {\n        vector<int> visited(v,0),rec(v,0);\n        int ans=0;\n        for(int i=0;i<v;i++){\n            if(visited[i]==0) \n                ans=dfs(v,adj,visited,rec,i,-1);\n            if(ans) \n                return 1;\n        }\n        return 0;\n    } //function to run dfs for a given node in the graph\n  int dfs(int v,vector<int> adj[],vector<int> &visited,vector<int> &rec,int i,int parent){\n        int ans=0;\n        visited[i]=1;\n        rec[i]=1;\n        for(auto x : adj[i]){ \n            if(x!=parent) {\n                if(rec[x]) \n                    return 1;\n                ans=dfs(v,adj,visited,rec,x,i);\n                if(ans) \n                   return 1;\n            }\n        }\n        rec[i]=0;\n        return 0;\n    }\n    // Function to detect cycle in an undirected graph.\n    // it takes adjacency list representation as an argument\n    bool isCycle(int v, vector<int> adj[]) {\n        vector<int> visited(v,0),rec(v,0);\n        int ans=0;\n        for(int i=0;i<v;i++){\n            if(visited[i]==0) \n                ans=dfs(v,adj,visited,rec,i,-1);\n            if(ans) \n                return 1;\n        }\n        return 0;\n    } Time Complexity: O(V+E)\nSpace Complexity: O(V) Time Complexity: O(V+E) Time Complexity: Space Complexity: O(V) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "5. Write a function to convert an infix expression to postfix expression",
        "answer": "Input: a+b*(c^d)\nOutput: abcd^*+ Input: a+b*(c^d) Input: Output: abcd^*+ Output: int prec(char c)\n{\n    if (c == '^')\n        return 3;\n    else if (c == '/' || c == '*')\n        return 2;\n    else if (c == '+' || c == '-')\n        return 1;\n    else\n        return -1;\n}\n  public:\n    // Function to convert an infix expression to a postfix expression.\n    string infixToPostfix(string s) {\n        stack<char> st; // For stack operations, we are using C++ built in stack\n        string result;\n \n        for (int i = 0; i < s.length(); i++) {\n            char c = s[i];\n \n            // If the scanned character is\n            // an operand, add it to the output string.\n            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n            || (c >= '0' && c <= '9'))\n                result += c;\n \n            // If the scanned character is an\n            // '(', push it to the stack.\n            else if (c == '(')\n                st.push('(');\n \n            // If the scanned character is an ')',\n            // pop and to output string from the stack\n            // until an '(' is encountered.\n            else if (c == ')') {\n                while (st.top() != '(') {\n                    result += st.top();\n                    st.pop();\n                }\n                st.pop();\n            }\n \n            // If an operator is scanned\n            else {\n                while (!st.empty()\n                   && prec(s[i]) <= prec(st.top())) {\n                    if (c == '^' && st.top() == '^')\n                        break;\n                    else {\n                        result += st.top();\n                        st.pop();\n                    }\n                }\n                st.push(c);\n            }\n        }\n \n        // Pop all the remaining elements from the stack\n        while (!st.empty()) {\n            result += st.top();\n            st.pop();\n        }\n \n        return result;\n    } int prec(char c)\n{\n    if (c == '^')\n        return 3;\n    else if (c == '/' || c == '*')\n        return 2;\n    else if (c == '+' || c == '-')\n        return 1;\n    else\n        return -1;\n}\n  public:\n    // Function to convert an infix expression to a postfix expression.\n    string infixToPostfix(string s) {\n        stack<char> st; // For stack operations, we are using C++ built in stack\n        string result;\n \n        for (int i = 0; i < s.length(); i++) {\n            char c = s[i];\n \n            // If the scanned character is\n            // an operand, add it to the output string.\n            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n            || (c >= '0' && c <= '9'))\n                result += c;\n \n            // If the scanned character is an\n            // '(', push it to the stack.\n            else if (c == '(')\n                st.push('(');\n \n            // If the scanned character is an ')',\n            // pop and to output string from the stack\n            // until an '(' is encountered.\n            else if (c == ')') {\n                while (st.top() != '(') {\n                    result += st.top();\n                    st.pop();\n                }\n                st.pop();\n            }\n \n            // If an operator is scanned\n            else {\n                while (!st.empty()\n                   && prec(s[i]) <= prec(st.top())) {\n                    if (c == '^' && st.top() == '^')\n                        break;\n                    else {\n                        result += st.top();\n                        st.pop();\n                    }\n                }\n                st.push(c);\n            }\n        }\n \n        // Pop all the remaining elements from the stack\n        while (!st.empty()) {\n            result += st.top();\n            st.pop();\n        }\n \n        return result;\n    } Time Complexity: O(n)\nSpace Complexity: O(n) Time Complexity: O(n) Time Complexity: Space Complexity: O(n) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "6. Write a function to find the maximum for each and every contiguous subarray of size k.",
        "answer": "Input: N = 9, K = 3 arr[] = {1, 2, 3, 1, 4, 5, 2, 3, 6}\nOutput: {3, 3, 4, 5, 5, 5, 6}\nExplanation: In the first subarray of size 3: {1,2,3}, the value 3 is maximum, similarly for all such subarrays for size 3. Input: N = 9, K = 3 arr[] = {1, 2, 3, 1, 4, 5, 2, 3, 6} Input: Output: {3, 3, 4, 5, 5, 5, 6} Output: Explanation: In the first subarray of size 3: {1,2,3}, the value 3 is maximum, similarly for all such subarrays for size 3. Explanation //function to find maximum in each subarray using sliding window approach\nvector<int> max_of_subarrays(vector<int> arr, int n, int k){\n        int i=0,j=0;\n        deque<int> dq;\n        dq.push_front(i++);\n        while(i<k)\n        {\n            while(!dq.empty()&&arr[dq.back()]<=arr[i])\n            dq.pop_back();\n            dq.push_back(i++);\n        }\n        vector<int> ans;\n        while(i<n)\n        {\n            ans.push_back(arr[dq.front()]);\n            while(!dq.empty()&&j>=dq.front())\n            {\n                dq.pop_front();\n                \n            }\n            j++;\n             while(!dq.empty()&&arr[dq.back()]<=arr[i])\n            dq.pop_back();\n            dq.push_back(i++);\n        }\n        ans.push_back(arr[dq.front()]);\n        return ans;\n    \n    } //function to find maximum in each subarray using sliding window approach\nvector<int> max_of_subarrays(vector<int> arr, int n, int k){\n        int i=0,j=0;\n        deque<int> dq;\n        dq.push_front(i++);\n        while(i<k)\n        {\n            while(!dq.empty()&&arr[dq.back()]<=arr[i])\n            dq.pop_back();\n            dq.push_back(i++);\n        }\n        vector<int> ans;\n        while(i<n)\n        {\n            ans.push_back(arr[dq.front()]);\n            while(!dq.empty()&&j>=dq.front())\n            {\n                dq.pop_front();\n                \n            }\n            j++;\n             while(!dq.empty()&&arr[dq.back()]<=arr[i])\n            dq.pop_back();\n            dq.push_back(i++);\n        }\n        ans.push_back(arr[dq.front()]);\n        return ans;\n    \n    } Time Complexity: O(n)\nSpace Complexity: O(k) Time Complexity: O(n) Time Complexity: Space Complexity: O(k) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "7. Write a function to merge two sorted binary search tree",
        "answer": "Input: Input: First BST 7 /     \\ 5       9 Second BST 4 /   \\ 3       12 Output: 3 4 5 6 7 9 12 Output: //Function to return a list of integers denoting the node \n//values of both the BST in a sorted order.\n    void inorder(Node*root,vector<int>&v){\n        if(root==NULL)\n            return;\n        inorder(root->left,v);\n        v.push_back(root->data);\n        inorder(root->right,v);\n    }\n    vector<int> merge(vector<int>v1,vector<int>v2){\n        vector<int>v;\n        int n1=v1.size(),n2=v2.size(),i=0,j=0;\n        while(i<n1&&j<n2){\n            if(v1[i]>v2[j]){\n                v.push_back(v2[j]);\n                j++;\n            }\n            else{\n                v.push_back(v1[i]);\n                i++;\n            }\n        }\n        while(i<n1){\n            v.push_back(v1[i]);\n            i++;\n        }\n        while(j<n2){\n            v.push_back(v2[j]);\n            j++;\n        }\n        return v;\n    }\n    vector<int> merge(Node *root1, Node *root2)\n    {\n       vector<int>v1,v2;\n       inorder(root1,v1);\n       inorder(root2,v2);\n       return merge(v1,v2);\n    } //Function to return a list of integers denoting the node \n//values of both the BST in a sorted order.\n    void inorder(Node*root,vector<int>&v){\n        if(root==NULL)\n            return;\n        inorder(root->left,v);\n        v.push_back(root->data);\n        inorder(root->right,v);\n    }\n    vector<int> merge(vector<int>v1,vector<int>v2){\n        vector<int>v;\n        int n1=v1.size(),n2=v2.size(),i=0,j=0;\n        while(i<n1&&j<n2){\n            if(v1[i]>v2[j]){\n                v.push_back(v2[j]);\n                j++;\n            }\n            else{\n                v.push_back(v1[i]);\n                i++;\n            }\n        }\n        while(i<n1){\n            v.push_back(v1[i]);\n            i++;\n        }\n        while(j<n2){\n            v.push_back(v2[j]);\n            j++;\n        }\n        return v;\n    }\n    vector<int> merge(Node *root1, Node *root2)\n    {\n       vector<int>v1,v2;\n       inorder(root1,v1);\n       inorder(root2,v2);\n       return merge(v1,v2);\n    } Time Complexity: O(m+n) \nSpace Complexity: O(height of the first tree + height of the second tree) Time Complexity: O(m+n) Time Complexity: O(m+n)  Space Complexity: O(height of the first tree + height of the second tree) Space Complexity: O(height of the first tree + height of the second tree)",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "8. Write a function to print all unique rows of the given matrix.",
        "answer": "Input: Input: {{1, 1, 1, 0, 0},  {0, 1, 0, 0, 1}, {1, 0, 1, 1, 0}, {0, 1, 0, 0, 1}, {1, 1, 1, 0, 0}} Output:  Output: {{1, 1, 1, 0, 0}, {0, 1, 0, 0, 1}, {1, 0, 1, 1, 0}} vector<vector<int>> uniqueRow(int M[MAX][MAX],int row,int col)\n{\nset<vector<int>> st;\nvector<vector<int>> v;\n\nfor(int i=0; i<row; i++) {\n    vector<int> v1;\n    for(int j=0; j<col; j++) {\n        v1.push_back(M[i][j]);\n    }\n    if(st.count(v1) == 0) {\n         v.push_back(v1);\n         st.insert(v1);\n    }\n}\n\nreturn v;\n} vector<vector<int>> uniqueRow(int M[MAX][MAX],int row,int col)\n{\nset<vector<int>> st;\nvector<vector<int>> v;\n\nfor(int i=0; i<row; i++) {\n    vector<int> v1;\n    for(int j=0; j<col; j++) {\n        v1.push_back(M[i][j]);\n    }\n    if(st.count(v1) == 0) {\n         v.push_back(v1);\n         st.insert(v1);\n    }\n}\n\nreturn v;\n} Time Complexity: O( ROW x COL )\nSpace Complexity: O( ROW ) Time Complexity: O( ROW x COL ) Time Complexity: Space Complexity: O( ROW ) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "9. Write a function to find number of subarrays with product less than K",
        "answer": "Input: arr = [1, 6, 2, 3, 2, 1], k = 12\nOutput: 11 Input: arr = [1, 6, 2, 3, 2, 1], k = 12 Input: Output: 11 Output: int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        int ans=0;\n        int pdt=1;\n        int left=0,right=0;\n        while(right<=nums.size()-1){\n            \n            pdt*=nums[right];\n            while(pdt>=k and left<nums.size()){\n                pdt/=nums[left];\n                left++;\n                \n            }\n            if(right-left>=0)\n            ans+=right-left+1;//since on adding a new element new subarrays formed is r-i+1;\n            right++;\n            \n        }\n        return ans;\n    } int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        int ans=0;\n        int pdt=1;\n        int left=0,right=0;\n        while(right<=nums.size()-1){\n            \n            pdt*=nums[right];\n            while(pdt>=k and left<nums.size()){\n                pdt/=nums[left];\n                left++;\n                \n            }\n            if(right-left>=0)\n            ans+=right-left+1;//since on adding a new element new subarrays formed is r-i+1;\n            right++;\n            \n        }\n        return ans;\n    } Time Complexity: O(n)\nSpace Complexity: O(1) Time Complexity: O(n) Time Complexity: Space Complexity: O(1) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "10. Find the subsequence of length 3 with the highest product from a sequence of non-negative integers, with the elements in increasing order.",
        "answer": "Input: n = 8 arr[ ] = {6, 7, 10, 1, 2, 3, 11, 12}\nOutput: {10, 11, 12} Input: n = 8 arr[ ] = {6, 7, 10, 1, 2, 3, 11, 12} Input: Output: {10, 11, 12} Output: The three increasing elements of the given arrays are 10, 11, and 12, which form a three-size subsequence with the highest product. vector<int> maxProductSubsequence(int *a , int n) \n    { \n        set<int> s;\n        long long largestOnLeft[n];\n        for(int i=0;i<n;i++)\n        {   \n            s.insert(a[i]);\n            auto it=s.lower_bound(a[i]);\n            if(it==s.begin())\n            {\n                largestOnLeft[i]=-1;\n                continue;\n            }\n            it--;\n            largestOnLeft[i]=*it;\n        }\n        int m=0;\n        long long p=INT_MIN;\n        vector<int> result(3);\n        result[0]=-1;\n        for(int i=n-1;i>=0;i--)\n        {   \n          if(a[i]>=m){\n          m=a[i];}\n          else\n          {\n              if(largestOnLeft[i] !=-1)\n              {\n                  if(largestOnLeft[i]*a[i]*m >p)\n                  {\n                      p=largestOnLeft[i]*a[i]*m;\n                      result[0]=largestOnLeft[i];\n                      result[1]=a[i];\n                      result[2]=m;\n                  }\n              }\n          }\n        }\n        return v;\n    } vector<int> maxProductSubsequence(int *a , int n) \n    { \n        set<int> s;\n        long long largestOnLeft[n];\n        for(int i=0;i<n;i++)\n        {   \n            s.insert(a[i]);\n            auto it=s.lower_bound(a[i]);\n            if(it==s.begin())\n            {\n                largestOnLeft[i]=-1;\n                continue;\n            }\n            it--;\n            largestOnLeft[i]=*it;\n        }\n        int m=0;\n        long long p=INT_MIN;\n        vector<int> result(3);\n        result[0]=-1;\n        for(int i=n-1;i>=0;i--)\n        {   \n          if(a[i]>=m){\n          m=a[i];}\n          else\n          {\n              if(largestOnLeft[i] !=-1)\n              {\n                  if(largestOnLeft[i]*a[i]*m >p)\n                  {\n                      p=largestOnLeft[i]*a[i]*m;\n                      result[0]=largestOnLeft[i];\n                      result[1]=a[i];\n                      result[2]=m;\n                  }\n              }\n          }\n        }\n        return v;\n    } Time Complexity: O(nlog(n))\nSpace Complexity: O(n) Time Complexity: O(nlog(n)) Time Complexity: Space Complexity: O(n) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "11. Write a function to implement Quicksort on Doubly Linked List",
        "answer": "Input: 8<->10<->1<->7<->6\nOutput: 1<->6<->7<->8<->10 Input: 8<->10<->1<->7<->6 Input: Output: 1<->6<->7<->8<->10 Output: class Solution{\npublic:\n    Node* partition(Node *l, Node *h){\n        //Your code goes here\n        Node*temp = h;\n        Node*tt = l;\n        Node*first = l;\n        \n        while(tt != h){\n              if(tt->data <= temp->data){\n                  swap(first->data, tt->data);\n                  first = first->next;\n              }\n              tt = tt -> next;\n        }\n        swap(first-> data, h->data);\n        return first;\n    \n    }\n};\n\nvoid _quickSort(struct Node* l, struct Node *h)\n{\n    if (h != NULL && l != h && l != h->next)\n    {\n        Solution ob;\n        struct Node *p = ob.partition(l, h);\n        _quickSort(l, p->prev);\n        _quickSort(p->next, h);\n    }\n}\n \nvoid quickSort(struct Node *head)\n{\n    struct Node *h = lastNode(head);\n    _quickSort(head, h);\n} class Solution{\npublic:\n    Node* partition(Node *l, Node *h){\n        //Your code goes here\n        Node*temp = h;\n        Node*tt = l;\n        Node*first = l;\n        \n        while(tt != h){\n              if(tt->data <= temp->data){\n                  swap(first->data, tt->data);\n                  first = first->next;\n              }\n              tt = tt -> next;\n        }\n        swap(first-> data, h->data);\n        return first;\n    \n    }\n};\n\nvoid _quickSort(struct Node* l, struct Node *h)\n{\n    if (h != NULL && l != h && l != h->next)\n    {\n        Solution ob;\n        struct Node *p = ob.partition(l, h);\n        _quickSort(l, p->prev);\n        _quickSort(p->next, h);\n    }\n}\n \nvoid quickSort(struct Node *head)\n{\n    struct Node *h = lastNode(head);\n    _quickSort(head, h);\n} Time Complexity: O(n^2) in the worst case when the list is already sorted. O(nlog(n)) in the best and average case.\nSpace Complexity: O(n) Time Complexity: O(n^2) in the worst case when the list is already sorted. O(nlog(n)) in the best and average case. Time Complexity: Space Complexity: O(n) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "12. Write a function to connect nodes at the same level of a binary tree",
        "answer": "Input:              100 Input: /     \\ 13      15 /  \\         \\ 14    1        20   Output:          100-> NULL Output: /      \\ 13   ->  15   -> NULL /      \\           \\ 14  ->  1   -> 20 -> NULL class Solution\n{\n    public:\n    //Function to connect nodes at the same level.\n    void connect(Node *p)\n    {\n       map<int,vector<Node *> > m;\n       queue<Node *> q;\n       queue<int> l;\n       q.push(p);\n       l.push(0);\n       while(!q.empty())\n       {\n           Node *temp=q.front();\n           int level=l.front();\n           q.pop();\n           l.pop();\n           m[level].push_back(temp);\n           if(temp->left!=NULL)\n           {\n               q.push(temp->left);\n               l.push(level+1);\n           }\n           if(temp->right!=NULL)\n           {\n               q.push(temp->right);\n               l.push(level+1);\n           }\n       }\n       for(map<int,vector<Node *> > ::iterator it=m.begin();it!=m.end();it++)\n       {\n           vector<Node *> temp1=it->second;\n           for(int i=0;i<temp1.size()-1;i++)\n           {\n               temp1[i]->nextRight=temp1[i+1];\n           }\n           temp1[temp1.size()-1]->nextRight=NULL;\n       }\n    }\n}; class Solution\n{\n    public:\n    //Function to connect nodes at the same level.\n    void connect(Node *p)\n    {\n       map<int,vector<Node *> > m;\n       queue<Node *> q;\n       queue<int> l;\n       q.push(p);\n       l.push(0);\n       while(!q.empty())\n       {\n           Node *temp=q.front();\n           int level=l.front();\n           q.pop();\n           l.pop();\n           m[level].push_back(temp);\n           if(temp->left!=NULL)\n           {\n               q.push(temp->left);\n               l.push(level+1);\n           }\n           if(temp->right!=NULL)\n           {\n               q.push(temp->right);\n               l.push(level+1);\n           }\n       }\n       for(map<int,vector<Node *> > ::iterator it=m.begin();it!=m.end();it++)\n       {\n           vector<Node *> temp1=it->second;\n           for(int i=0;i<temp1.size()-1;i++)\n           {\n               temp1[i]->nextRight=temp1[i+1];\n           }\n           temp1[temp1.size()-1]->nextRight=NULL;\n       }\n    }\n}; Time Complexity: O(n)\nSpace Complexity: O(n) Time Complexity: O(n) Time Complexity: Space Complexity: O(n) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "13. Write a function to find number of structurally unique binary trees are possible",
        "answer": "Input: N = 3 Input: Output: 5 for N = 3, there are 5 possible BSTs: Output: 1           3      3        2 1 \\         /      /          /  \\   \\ 3     2      1      1    3     2 /      /          \\                     \\ 2      1         2                       3 class Solution\n{\n    public:\n     //function to calculate binomial coefficient C(n,k)\n    long long int binomialCoefficient(long long int n, long long int k)\n    {\n        long long int res = 1;\n        if (k > n - k)\n            k = n - k;\n    \n        for (long long int i = 0; i < k; ++i)\n        {\n            res *= (n - i);\n            res /= (i + 1);\n        }\n     \n        return res;\n    }\n     \n   //function to calculate Nth Catalan Number  \n    long long int catalanNumber(long long in n)\n    {\n        // Calculate value of 2nCn\n        long long int C = binomialCoefficient(2*n, n);\n    \n        // return 2nCn/(n+1)\n        return C/(n+1);\n    }\n    \n    //Function to return the total number of possible unique BST. \n    long long int numOfUniqueBinarySearchTrees(int n) \n    {\n         // find nth catalan number\n        long long int countOfUniqueBinarySearchTrees = catalanNumber(n);\n     \n        // return nth catalan number\n        return countOfUniqueBinarySearchTrees;\n    }\n}; class Solution\n{\n    public:\n     //function to calculate binomial coefficient C(n,k)\n    long long int binomialCoefficient(long long int n, long long int k)\n    {\n        long long int res = 1;\n        if (k > n - k)\n            k = n - k;\n    \n        for (long long int i = 0; i < k; ++i)\n        {\n            res *= (n - i);\n            res /= (i + 1);\n        }\n     \n        return res;\n    }\n     \n   //function to calculate Nth Catalan Number  \n    long long int catalanNumber(long long in n)\n    {\n        // Calculate value of 2nCn\n        long long int C = binomialCoefficient(2*n, n);\n    \n        // return 2nCn/(n+1)\n        return C/(n+1);\n    }\n    \n    //Function to return the total number of possible unique BST. \n    long long int numOfUniqueBinarySearchTrees(int n) \n    {\n         // find nth catalan number\n        long long int countOfUniqueBinarySearchTrees = catalanNumber(n);\n     \n        // return nth catalan number\n        return countOfUniqueBinarySearchTrees;\n    }\n}; Time Complexity: O(n) \nSpace Complexity: O(1) Time Complexity: O(n) Time Complexity: Space Complexity: O(1) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "14. Implement LRU(Least Recently Used) Cache",
        "answer": "class LRUCache\n{\n    private:\n    class node_t {\n        public:\n        int key;\n        int value;\n        node_t * next;\n        node_t * prev;\n    };\n    \n    int cap;\n    node_t head;\n    unordered_map<int, node_t*> tbl;\n    \n    void remove_node(node_t * node) {\n        node->next->prev = node->prev;\n        node->prev->next = node->next;\n    }\n    void add_node(node_t * node) {\n        node->next = head.next;\n        node->prev = &head;\n        head.next = node;\n        node->next->prev = node;\n    }\n    public:\n    //Constructor for initializing the cache capacity with the given value.\n    LRUCache(int cap): cap(cap)\n    {\n        // code here\n        head.prev = &head;\n        head.next = &head;\n    }\n    \n    //Function to return value corresponding to the key.\n    int get(int key)\n    {\n        // your code here\n        unordered_map<int, node_t*>::iterator it = tbl.find(key);\n        if(it==tbl.end())\n            return -1;\n        remove_node(it->second);\n        add_node(it->second);\n        return it->second->value;\n    }\n    \n    //Function for storing key-value pair.\n    void set(int key, int value)\n    {\n        // your code here   \n        unordered_map<int, node_t*>::iterator it = tbl.find(key);\n        if(it!=tbl.end())\n        {\n            remove_node(it->second);\n            add_node(it->second);\n            it->second->value = value;\n        }\n        else {\n            node_t * node = new node_t;\n            node->key = key;\n            node->value = value;\n            add_node(node);\n            tbl[key] = node;\n            if(tbl.size()>cap) {\n                auto * old_node = head.prev;\n                tbl.erase(old_node->key);\n                remove_node(old_node);\n                delete old_node;\n            }\n        }\n    }\n}; class LRUCache\n{\n    private:\n    class node_t {\n        public:\n        int key;\n        int value;\n        node_t * next;\n        node_t * prev;\n    };\n    \n    int cap;\n    node_t head;\n    unordered_map<int, node_t*> tbl;\n    \n    void remove_node(node_t * node) {\n        node->next->prev = node->prev;\n        node->prev->next = node->next;\n    }\n    void add_node(node_t * node) {\n        node->next = head.next;\n        node->prev = &head;\n        head.next = node;\n        node->next->prev = node;\n    }\n    public:\n    //Constructor for initializing the cache capacity with the given value.\n    LRUCache(int cap): cap(cap)\n    {\n        // code here\n        head.prev = &head;\n        head.next = &head;\n    }\n    \n    //Function to return value corresponding to the key.\n    int get(int key)\n    {\n        // your code here\n        unordered_map<int, node_t*>::iterator it = tbl.find(key);\n        if(it==tbl.end())\n            return -1;\n        remove_node(it->second);\n        add_node(it->second);\n        return it->second->value;\n    }\n    \n    //Function for storing key-value pair.\n    void set(int key, int value)\n    {\n        // your code here   \n        unordered_map<int, node_t*>::iterator it = tbl.find(key);\n        if(it!=tbl.end())\n        {\n            remove_node(it->second);\n            add_node(it->second);\n            it->second->value = value;\n        }\n        else {\n            node_t * node = new node_t;\n            node->key = key;\n            node->value = value;\n            add_node(node);\n            tbl[key] = node;\n            if(tbl.size()>cap) {\n                auto * old_node = head.prev;\n                tbl.erase(old_node->key);\n                remove_node(old_node);\n                delete old_node;\n            }\n        }\n    }\n}; Time Complexity: O(1) to get an element\nSpace Complexity: O(n) Time Complexity: O(1) to get an element Time Complexity: Space Complexity: O(n) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "15. Write a function to determine whether duplicate elements in a given array are within a given distance of each other.",
        "answer": "Input: arr[] = {1, 2, 3, 4, 2, 1, 2} range=3\nOutput: True Input: arr[] = {1, 2, 3, 4, 2, 1, 2} range=3 Input: Output: True Output: class Solution {\n    public:\n    \n    bool checkDuplicatesWithinRange(vector<int> arr, int range)\n    {\n        // Creating an empty hashset\n        unordered_set<int> myset;\n     \n        // Traversing the input array\n        for (int i = 0; i < arr.size(); i++)\n        {\n            // If already present in hashset, then we found a duplicate within range distance\n            if (myset.find(arr[i]) != myset.end())\n                return true;\n     \n            // Add this item to hashset\n            myset.insert(arr[i]);\n     \n            // Remove the range+1 distant item from the hashset\n            if (i >= range)\n                myset.erase(arr[i-range]);\n        }\n        return false;\n    }\n}; class Solution {\n    public:\n    \n    bool checkDuplicatesWithinRange(vector<int> arr, int range)\n    {\n        // Creating an empty hashset\n        unordered_set<int> myset;\n     \n        // Traversing the input array\n        for (int i = 0; i < arr.size(); i++)\n        {\n            // If already present in hashset, then we found a duplicate within range distance\n            if (myset.find(arr[i]) != myset.end())\n                return true;\n     \n            // Add this item to hashset\n            myset.insert(arr[i]);\n     \n            // Remove the range+1 distant item from the hashset\n            if (i >= range)\n                myset.erase(arr[i-range]);\n        }\n        return false;\n    }\n}; Time Complexity: O(n)\nSpace Complexity: O(n) Time Complexity: O(n) Time Complexity: Space Complexity: O(n) Space Complexity:",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "16. Write a recursive function to calculate the height of a binary tree in Java.",
        "answer": "Consider that every node of a tree represents a class called Node as given below: Consider that every node of a tree represents a class called Node as given below: public class Node{\n     int data;\n     Node left;\n     Node right;\n } public class Node{\n     int data;\n     Node left;\n     Node right;\n } Then the height of the binary tree can be found as follows: Then the height of the binary tree can be found as follows: int heightOfBinaryTree(Node node)  \n     { \n         if (node == null) \n             return 0; // If node is null then height is 0 for that node.\n         else \n         { \n             // compute the height of each subtree\n             int leftHeight = heightOfBinaryTree(node.left); \n             int rightHeight = heightOfBinaryTree(node.right);     \n             //use the larger among the left and right height and plus 1 (for the root)\n             return Math.max(leftHeight, rightHeight) + 1; \n         } \n     } int heightOfBinaryTree(Node node)  \n     { \n         if (node == null) \n             return 0; // If node is null then height is 0 for that node.\n         else \n         { \n             // compute the height of each subtree\n             int leftHeight = heightOfBinaryTree(node.left); \n             int rightHeight = heightOfBinaryTree(node.right);     \n             //use the larger among the left and right height and plus 1 (for the root)\n             return Math.max(leftHeight, rightHeight) + 1; \n         } \n     }",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "17. Write Java code to count number of nodes in a binary tree",
        "answer": "int countNodes(Node root)\n{\n    int count =  1;             //Root itself should be counted\n    if (root ==null)\n        return 0;\n    else\n    {\n        count += countNodes(root.left);\n        count += countNodes(root.right);\n        return count;\n    }\n} int countNodes(Node root)\n{\n    int count =  1;             //Root itself should be counted\n    if (root ==null)\n        return 0;\n    else\n    {\n        count += countNodes(root.left);\n        count += countNodes(root.right);\n        return count;\n    }\n} int countNodes(Node root) int countNodes (Node root) int 1 //Root itself should be counted if null return 0 else return",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "18. Print Left view of any binary trees.",
        "answer": "The main idea to solve this problem is to traverse the tree in pre order manner and pass the level information along with it. If the level is visited for the first time, then we store the information of the current node and the current level in the hashmap. Basically, we are getting the left view by noting the first node of every level.\nAt the end of traversal, we can get the solution by just traversing the map.\nConsider the following tree as example for finding the left view:\nLeft view of a binary tree in Java: The main idea to solve this problem is to traverse the tree in pre order manner and pass the level information along with it. If the level is visited for the first time, then we store the information of the current node and the current level in the hashmap. Basically, we are getting the left view by noting the first node of every level. At the end of traversal, we can get the solution by just traversing the map. Consider the following tree as example for finding the left view: Left view of a binary tree in Java: import java.util.HashMap;\n\n  //to store a Binary Tree node\n  class Node\n  {\n      int data;\n      Node left = null, right = null;\n\n      Node(int data) {\n          this.data = data;\n      }\n  }\n  public class InterviewBit\n  {\n      // traverse nodes in pre-order way\n      public static void leftViewUtil(Node root, int level, HashMap<Integer, Integer> map)\n      {\n          if (root == null) {\n              return;\n          }\n\n          // if you are visiting the level for the first time\n          // insert the current node and level info to the map\n          if (!map.containsKey(level)) {\n              map.put(level, root.data);\n          }\n\n          leftViewUtil(root.left, level + 1, map);\n          leftViewUtil(root.right, level + 1, map);\n      }\n\n      // to print left view of binary tree\n      public static void leftView(Node root)\n      {\n          // create an empty HashMap to store first node of each level\n          HashMap<Integer, Integer> map = new HashMap<>();\n\n          // traverse the tree and find out the first nodes of each level\n          leftViewUtil(root, 1, map);\n\n          // iterate through the HashMap and print the left view\n          for (int i = 0; i <map.size(); i++) {\n              System.out.print(map.get(i) + \" \");\n          }\n      }\n\n      public static void main(String[] args)\n      {\n          Node root = new Node(4);\n          root.left = new Node(2);\n          root.right = new Node(6);\n          root.left.left = new Node(1);\n          root.left.left = new Node(3);\n          root.right.left = new Node(5);\n          root.right.right = new Node(7);\n          root.right.left.left = new Node(9);\n\n          leftView(root);\n      }\n  } import java.util.HashMap;\n\n  //to store a Binary Tree node\n  class Node\n  {\n      int data;\n      Node left = null, right = null;\n\n      Node(int data) {\n          this.data = data;\n      }\n  }\n  public class InterviewBit\n  {\n      // traverse nodes in pre-order way\n      public static void leftViewUtil(Node root, int level, HashMap<Integer, Integer> map)\n      {\n          if (root == null) {\n              return;\n          }\n\n          // if you are visiting the level for the first time\n          // insert the current node and level info to the map\n          if (!map.containsKey(level)) {\n              map.put(level, root.data);\n          }\n\n          leftViewUtil(root.left, level + 1, map);\n          leftViewUtil(root.right, level + 1, map);\n      }\n\n      // to print left view of binary tree\n      public static void leftView(Node root)\n      {\n          // create an empty HashMap to store first node of each level\n          HashMap<Integer, Integer> map = new HashMap<>();\n\n          // traverse the tree and find out the first nodes of each level\n          leftViewUtil(root, 1, map);\n\n          // iterate through the HashMap and print the left view\n          for (int i = 0; i <map.size(); i++) {\n              System.out.print(map.get(i) + \" \");\n          }\n      }\n\n      public static void main(String[] args)\n      {\n          Node root = new Node(4);\n          root.left = new Node(2);\n          root.right = new Node(6);\n          root.left.left = new Node(1);\n          root.left.left = new Node(3);\n          root.right.left = new Node(5);\n          root.right.right = new Node(7);\n          root.right.left.left = new Node(9);\n\n          leftView(root);\n      }\n  }",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "19. Given an m x n 2D grid map of '1’s which represents land and '0’s that represents water return the number of islands (surrounded by water and formed by connecting adjacent lands in 2 directions - vertically or horizontally).",
        "answer": "Assume that the boundary cases - which are all four edges of the grid are surrounded by water. Assume that the boundary cases - which are all four edges of the grid are surrounded by water. Constraints are: m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\ngrid[i][j] can only be ‘0’ or ‘1’.    Example: Input: grid = [\n[“1” , “1” , “1” , “0” , “0”],\n[“1” , “1” , “0” , “0” , “0”],\n[“0” , “0” , “1” , “0” , “1”],\n[“0” , “0” , “0” , “1” , “1”]\n]      Output: 3 class InterviewBit {\n    public int numberOfIslands(char[][] grid) {\n        if(grid==null || grid.length==0||grid[0].length==0)\n            return 0;\n\n        int m = grid.length;\n        int n = grid[0].length;\n\n        int count=0;\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(grid[i][j]=='1'){\n                    count++;\n                    mergeIslands(grid, i, j);\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public void mergeIslands(char[][] grid, int i, int j){\n        int m=grid.length;\n        int n=grid[0].length;\n\n        if(i<0||i>=m||j<0||j>=n||grid[i][j]!='1')\n            return;\n\n        grid[i][j]='X';\n\n        mergeIslands(grid, i-1, j);\n        mergeIslands(grid, i+1, j);\n        mergeIslands(grid, i, j-1);\n        mergeIslands(grid, i, j+1);\n    }\n} class InterviewBit {\n    public int numberOfIslands(char[][] grid) {\n        if(grid==null || grid.length==0||grid[0].length==0)\n            return 0;\n\n        int m = grid.length;\n        int n = grid[0].length;\n\n        int count=0;\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(grid[i][j]=='1'){\n                    count++;\n                    mergeIslands(grid, i, j);\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public void mergeIslands(char[][] grid, int i, int j){\n        int m=grid.length;\n        int n=grid[0].length;\n\n        if(i<0||i>=m||j<0||j>=n||grid[i][j]!='1')\n            return;\n\n        grid[i][j]='X';\n\n        mergeIslands(grid, i-1, j);\n        mergeIslands(grid, i+1, j);\n        mergeIslands(grid, i, j-1);\n        mergeIslands(grid, i, j+1);\n    }\n}",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "20. What is topological sorting in a graph?",
        "answer": "Topological sorting is a linear ordering of vertices such that for every directed edge ij, vertex i comes before j in the ordering.\nTopological sorting is only possible for Directed Acyclic Graph (DAG).\nApplications:\njobs scheduling from the given dependencies among jobs.\nordering of formula cell evaluation in spreadsheets\nordering of compilation tasks to be performed in make files,\ndata serialization\nresolving symbol dependencies in linkers.\nTopological Sort Code in Java: Topological sorting is a linear ordering of vertices such that for every directed edge ij, vertex i comes before j in the ordering. Topological sorting is only possible for Directed Acyclic Graph (DAG). Applications:\njobs scheduling from the given dependencies among jobs.\nordering of formula cell evaluation in spreadsheets\nordering of compilation tasks to be performed in make files,\ndata serialization\nresolving symbol dependencies in linkers. jobs scheduling from the given dependencies among jobs.\nordering of formula cell evaluation in spreadsheets\nordering of compilation tasks to be performed in make files,\ndata serialization\nresolving symbol dependencies in linkers. jobs scheduling from the given dependencies among jobs. ordering of formula cell evaluation in spreadsheets ordering of compilation tasks to be performed in make files, data serialization resolving symbol dependencies in linkers. Topological Sort Code in Java: // V - total vertices\n     // visited - boolean array to keep track of visited nodes\n     // graph - adjacency list.\n    // Main Topological Sort Function. \n    void topologicalSort() \n    { \n        Stack<Integer> stack = new Stack<Integer>(); \n  \n        // Mark all the vertices as not visited \n        boolean visited[] = new boolean[V]; \n        for (int j = 0; j < V; j++){ \n            visited[j] = false; \n        }\n        // Call the util function starting from all vertices one by one \n        for (int i = 0; i < V; i++) \n            if (visited[i] == false) \n                topologicalSortUtil(i, visited, stack); \n  \n        // Print contents of stack -> result of topological sort\n        while (stack.empty() == false) \n            System.out.print(stack.pop() + \" \"); \n    } \n    \n    // A helper function used by topologicalSort\n    void topologicalSortUtil(int v, boolean visited[], \n                             Stack<Integer> stack) \n    { \n        // Mark the current node as visited. \n        visited[v] = true; \n        Integer i; \n  \n        // Recur for all the vertices adjacent to the current vertex \n        Iterator<Integer> it = graph.get(v).iterator(); \n        while (it.hasNext()) { \n            i = it.next(); \n            if (!visited[i]) \n                topologicalSortUtil(i, visited, stack); \n        } \n  \n        // Push current vertex to stack that saves result \n        stack.push(new Integer(v)); \n    } // V - total vertices\n     // visited - boolean array to keep track of visited nodes\n     // graph - adjacency list.\n    // Main Topological Sort Function. \n    void topologicalSort() \n    { \n        Stack<Integer> stack = new Stack<Integer>(); \n  \n        // Mark all the vertices as not visited \n        boolean visited[] = new boolean[V]; \n        for (int j = 0; j < V; j++){ \n            visited[j] = false; \n        }\n        // Call the util function starting from all vertices one by one \n        for (int i = 0; i < V; i++) \n            if (visited[i] == false) \n                topologicalSortUtil(i, visited, stack); \n  \n        // Print contents of stack -> result of topological sort\n        while (stack.empty() == false) \n            System.out.print(stack.pop() + \" \"); \n    } \n    \n    // A helper function used by topologicalSort\n    void topologicalSortUtil(int v, boolean visited[], \n                             Stack<Integer> stack) \n    { \n        // Mark the current node as visited. \n        visited[v] = true; \n        Integer i; \n  \n        // Recur for all the vertices adjacent to the current vertex \n        Iterator<Integer> it = graph.get(v).iterator(); \n        while (it.hasNext()) { \n            i = it.next(); \n            if (!visited[i]) \n                topologicalSortUtil(i, visited, stack); \n        } \n  \n        // Push current vertex to stack that saves result \n        stack.push(new Integer(v)); \n    } Conclusion In this post, we covered the most important and frequently asked Data Structures interview questions. We've also included some pointers and tricks to help you prepare for the interview. When preparing for the product-based companies interview, keep in mind that the Data Structures interview is a critical component of the process. It is critical that you are well prepared for the interview because it will determine whether or not you are hired. As a result, it is critical to begin planning as soon as possible. Additional Interview Resources Programming: DSA - https://www.interviewbit.com/courses/programming/\nData Structure MCQ - https://www.interviewbit.com/data-structure-mcq/\nBest Books for Data Structures and Algorithms - https://www.interviewbit.com/blog/data-structures-and-algorithms-books/\nBest Data Structures and Algorithms Course - https://www.interviewbit.com/blog/best-courses-for-data-structures-and-algorithms/\nFree Java DSA Certification Course - https://www.scaler.com/topics/course/dsa-beginners-java/\nAlgorithm Interview Questions - https://www.interviewbit.com/algorithm-interview-questions/\nMaster Data Structures and Algorithms With the Scaler Academy Program - https://www.scaler.com/courses/data-structures-and-algorithms/\nDifference Between Array and Linked List - https://www.scaler.com/topics/difference-between-array-and-linked-list/ Programming: DSA - https://www.interviewbit.com/courses/programming/ https://www.interviewbit.com/courses/programming/ Data Structure MCQ - https://www.interviewbit.com/data-structure-mcq/ https://www.interviewbit.com/data-structure-mcq/ Best Books for Data Structures and Algorithms - https://www.interviewbit.com/blog/data-structures-and-algorithms-books/ https://www.interviewbit.com/blog/data-structures-and-algorithms-books/ Best Data Structures and Algorithms Course - https://www.interviewbit.com/blog/best-courses-for-data-structures-and-algorithms/ https://www.interviewbit.com/blog/best-courses-for-data-structures-and-algorithms/ Free Java DSA Certification Course - https://www.scaler.com/topics/course/dsa-beginners-java/ https://www.scaler.com/topics/course/dsa-beginners-java/ https://www.scaler.com/topics/course/dsa-beginners-java/ Algorithm Interview Questions - https://www.interviewbit.com/algorithm-interview-questions/ https://www.interviewbit.com/algorithm-interview-questions/ Master Data Structures and Algorithms With the Scaler Academy Program - https://www.scaler.com/courses/data-structures-and-algorithms/ https://www.scaler.com/courses/data-structures-and-algorithms/ Difference Between Array and Linked List - https://www.scaler.com/topics/difference-between-array-and-linked-list/",
        "reference": "interviewbit.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "The data structure is a way that specifies how to organize and manipulate the data. It also defines the relationship between them. Some examples of Data Structures are arrays, Linked List, Stack, Queue, etc. Data Structures are the central part of many computer science algorithms as they enable the programmers to handle the data in an efficient way",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "2) Describe the types of Data Structures?",
        "answer": "Data Structures are mainly classified into two types:\nLinear Data Structure: A data structure is called linear if all of its elements are arranged in the sequential order. In linear data structures, the elements are stored in a non-hierarchical way where each item has the successors and predecessors except the first and last element.\nNon-Linear Data Structure: The Non-linear data structure does not form a sequence i.e. each item or element is connected with two or more other items in a non-linear arrangement. The data elements are not arranged in the sequential structure.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "Data structures are applied extensively in the following areas of computer science:\nADVERTISEMENT\nCompiler Design,\nOperating System,\nDatabase Management System,\nStatistical analysis package,\nNumerical Analysis,\nGraphics,\nArtificial Intelligence,\nSimulation",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "4) What is the difference between file structure and storage structure?",
        "answer": "Difference between file structure and storage structure:\n\nThe main difference between file structure and storage structure is based on memory area that is being accessed.\nStorage structure: It is the representation of the data structure in the computer memory.\nFile structure: It is the representation of the storage structure in the auxiliary memory.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "RDBMS uses Array data structure\nNetwork data model uses Graph\nHierarchal data model uses Trees",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "6) Which data structure is used to perform recursion?",
        "answer": "Stack data structure is used in recursion due to its last in first out nature. Operating system maintains the stack in order to save the iteration variables at each function call",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "7) What is a Stack?",
        "answer": "Stack is an ordered list in which, insertion and deletion can be performed only at one end that is called the top. It is a recursive data structure having pointer to its top element. The stack is sometimes called as Last-In-First-Out (LIFO) list i.e. the element which is inserted first in the stack will be deleted last from the stack.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "8) List the area of applications where stack data structure can be used?",
        "answer": "Expression evaluation\nBacktracking\nMemory Management\nFunction calling and return",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "9) What are the operations that can be performed on a stack?",
        "answer": "Push Operations\nPop Operations\nPeek Operations",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "Overflow occurs when top = Maxsize -1",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "11) What is the difference between PUSH and POP?",
        "answer": "PUSH and POP operations specify how data is stored and retrieved in a stack.\nPUSH: PUSH specifies that data is being \"inserted\" into the stack.\n\nPOP: POP specifies data retrieval. It means that data is being deleted from the stack.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "Push:\nIncrement the variable top so that it can refer to the next memory allocation\nCopy the item to the at the array index value equal to the top\nRepeat step 1 and 2 until stack overflows\nPop:\nStore the topmost element into the an another variable\nDecrement the value of the top\nReturn the topmost element",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "13) What is a postfix expression?",
        "answer": "An expression in which operators follow the operands is known as postfix expression. The main benefit of this form is that there is no need to group sub-expressions in parentheses or to consider operator precedence.\nThe expression \"a + b\" will be represented as \"ab+\" in postfix notation.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "14)Write the postfix form of the expression: (A + B) * (C - D)",
        "answer": "AB+CD-*",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": ")15) Which notations are used in Evaluation of Arithmetic Expressions using prefix and postfix forms?",
        "answer": "Polish and Reverse Polish notations.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "16)What is an array?",
        "answer": "Arrays are defined as the collection of similar types of data items stored at contiguous memory locations. It is the simplest data structure in which each data element can be randomly accessed by using its index number.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "17) How to reference all the elements in a one-dimension array?",
        "answer": "It can be done by using an indexed loop such that the counter runs from 0 to the array size minus one. In this manner, you can reference all the elements in sequence by using the loop counter as the array subscript.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "18) What is a multidimensional array?",
        "answer": "The multidimensional array can be defined as the array of arrays in which, the data is stored in tabular form consists of rows and columns. 2D arrays are created to implement a relational database lookalike data structure. It provides ease of holding the bulk of data at once which can be passed to any number of functions wherever required.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "19) How are the elements of a 2D array are stored in the memory?",
        "answer": "There are two techniques by using which, the elements of a 2D array can be stored in the memory.\nRow-Major Order: In row-major ordering, all the rows of the 2D array are stored into the memory contiguously. First, the 1st row of the array is stored into the memory completely, then the 2nd row of the array is stored into the memory completely and so on till the last row.\nColumn-Major Order: In column-major ordering, all the columns of the 2D array are stored into the memory contiguously. first, the 1st column of the array is stored into the memory completely, then the 2nd row of the array is stored into the memory completely and so on till the last column of the array.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "Row-Major Order: If array is declared as a[m][n] where m is the number of rows while n is the number of columns, then address of an element a[i][j] of the array stored in row major order is calculated as,\n\n\nAddress(a[i][j]) = B. A. + (i * n + j) * size\nColumn-Major Order: If array is declared as a[m][n] where m is the number of rows while n is the number of columns, then address of an element a[i][j] of the array stored in column major order is calculated as\nAddress(a[i][j]) = ((j*m)+i)*Size + BA.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "Linked List is the collection of randomly stored data objects called nodes. In Linked List, each node is linked to its adjacent node through a pointer. A node contains two fields, i.e. Data Field and Link Field.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "22) Are linked lists considered linear or non-linear data structures?",
        "answer": "A linked list is considered both linear and non-linear data structure depending upon the situation.\nOn the basis of data storage, it is considered as a non-linear data structure.\nOn the basis of the access strategy, it is considered as a linear data-structure.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "23) What are the advantages of Linked List over an array?",
        "answer": "The size of a linked list can be incremented at runtime which is impossible in the case of the array.\nThe List is not required to be contiguously present in the main memory, if the contiguous space is not available, the nodes can be stored anywhere in the memory connected through the links.\nThe List is dynamically stored in the main memory and grows as per the program demand while the array is statically stored in the main memory, size of which must be declared at compile time.\nThe number of elements in the linked list are limited to the available memory space while the number of elements in the array is limited to the size of an array.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "struct node   \n{  \n    int data;   \n    struct node *next;  \n};  \nstruct node *head, *ptr;   \nptr = (struct node *)malloc(sizeof(struct node));",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "25) If you are using C language to implement the heterogeneous linked list, what pointer type should be used?",
        "answer": "The heterogeneous linked list contains different data types, so it is not possible to use ordinary pointers for this. For this purpose, you have to use a generic pointer type like void pointer because the void pointer is capable of storing a pointer to any type.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "26) What is doubly linked list?",
        "answer": "The doubly linked list is a complex type of linked list in which a node contains a pointer to the previous as well as the next node in the sequence. In a doubly linked list, a node consists of three parts:\nnode data\npointer to the next node in sequence (next pointer)\npointer to the previous node (previous pointer).",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "#include<stdio.h>  \n#include<stdlib.h>  \nvoid beg_insert(int);  \nstruct node  \n{  \n    int data;  \n    struct node *next;  \n};  \nstruct node *head;  \nvoid main ()  \n{  \n    int choice,item;  \n    do   \n    {  \n        printf(\"\\nEnter the item which you want to insert?\\n\");  \n        scanf(\"%d\",&item);  \n        beg_insert(item);  \n        printf(\"\\nPress 0 to insert more ?\\n\");  \n        scanf(\"%d\",&choice);  \n    }while(choice == 0);  \n}  \nvoid beg_insert(int item)    \n{    \n            struct node *ptr = (struct node *)malloc(sizeof(struct node));    \n    struct node *temp;  \n    if(ptr == NULL)    \n    {    \n        printf(\"\\nOVERFLOW\");    \n    }    \n    else     \n    {    \n        ptr -> data = item;    \n        if(head == NULL)    \n        {    \n            head = ptr;    \n            ptr -> next = head;    \n        }    \n        else     \n        {       \n            temp = head;    \n            while(temp->next != head)    \n                temp = temp->next;    \n            ptr->next = head;     \n            temp -> next = ptr;     \n            head = ptr;    \n        }     \n    printf(\"\\nNode Inserted\\n\");  \n    }    \n                }",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "A queue can be defined as an ordered list which enables insert operations to be performed at one end called REAR and delete operations to be performed at another end called FRONT.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "The Applications of the queue is given as follows:\nQueues are widely used as waiting lists for a single shared resource like a printer, disk, CPU.\nQueues are used in the asynchronous transfer of data (where data is not being transferred at the same rate between two processes) for eg. pipes, file IO, sockets.\nQueues are used as buffers in most of the applications like MP3 media player, CD player, etc.\nQueues are used to maintain the playlist in media players to add and remove the songs from the play-list.\nQueues are used in operating systems for handling interrupts.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "30) What are the drawbacks of array implementation of Queue?",
        "answer": "Memory Wastage: The space of the array, which is used to store queue elements, can never be reused to store the elements of that queue because the elements can only be inserted at front end and the value of front might be so high so that, all the space before that, can never be filled.\nArray Size: There might be situations in which, we may need to extend the queue to insert more elements if we use an array to implement queue, It will almost be impossible to extend the array size, therefore deciding the correct array size is always a problem in array implementation of queue.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "31) What are the scenarios in which an element can be inserted into the circular queue?",
        "answer": "If (rear + 1)%maxsize = front, the queue is full. In that case, overflow occurs and therefore, insertion can not be performed in the queue.\nIf rear != max - 1, the rear will be incremented to the mod(maxsize) and the new value will be inserted at the rear end of the queue.\nIf front != 0 and rear = max - 1, it means that queue is not full therefore, set the value of rear to 0 and insert the new element there.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "32) What is a dequeue?",
        "answer": "Dequeue (also known as double-ended queue) can be defined as an ordered set of elements in which the insertion and deletion can be performed at both the ends, i.e. front and rear.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "33) What is the minimum number of queues that can be used to implement a priority queue?",
        "answer": "Two queues are needed. One queue is used to store the data elements, and another is used for storing priorities.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "The Tree is a recursive data structure containing the set of one or more data nodes where one node is designated as the root of the tree while the remaining nodes are called as the children of the root. The nodes other than the root node are partitioned into the nonempty sets where each one of them is to be called sub-tree.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "There are six types of tree given as follows.\nGeneral Tree\nForests\nBinary Tree\nBinary Search Tree\nExpression Tree\nTournament Tree",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "36) What are Binary trees?",
        "answer": "A binary Tree is a special type of generic tree in which, each node can have at most two children. Binary tree is generally partitioned into three disjoint subsets, i.e. the root of the node, left sub-tree and Right binary sub-tree.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "void in-order(struct treenode *tree)  \n    {  \n        if(tree != NULL)  \n        {  \n            in-order(tree→ left);  \n            printf(\"%d\",tree→ root);  \n            in-order(tree→ right);  \n        }  \n    }",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "38) What is the maximum number of nodes in a binary tree of height k?",
        "answer": "2k+1-1 where k >= 1",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "39) Which data structure suits the most in the tree construction?",
        "answer": "Queue data structure",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "40) Which data structure suits the most in the tree construction?",
        "answer": "Queue data structure",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "int count (struct node* t)  \n{  \n    if(t)  \n    {  \n        int l, r;  \n        l = count(t->left);  \n        r=count(t->right);  \n        return (1+l+r);  \n    }  \n    else   \n    {  \n        return 0;  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "int countHeight(struct node* t)  \n{  \n    int l,r;  \n    if(!t)  \n        return 0;  \n    if((!(t->left)) && (!(t->right)))  \n        return 0;  \n    l=countHeight(t->left);  \n    r=countHeight(t->right);  \n    return (1+((l>r)?l:r));  \n}",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "43) How can AVL Tree be useful in all the operations as compared to Binary search tree?",
        "answer": "AVL tree controls the height of the binary search tree by not letting it be skewed. The time taken for all operations in a binary search tree of height h is O(h). However, it can be extended to O(n) if the BST becomes skewed (i.e. worst case). By limiting this height to log n, AVL tree imposes an upper bound on each operation to be O(log n) where n is the number of nodes.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "A B tree of order m contains all the properties of an M way tree. In addition, it contains the following properties.\nEvery node in a B-Tree contains at most m children.\nEvery node in a B-Tree except the root node and the leaf node contain at least m/2 children.\nThe root nodes must have at least 2 nodes.\nAll leaf nodes must be at the same level.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "45) What are the differences between B tree and B+ tree?",
        "answer": "SN B Tree B+ Tree\n1 Search keys cannot repeatedly be stored. Redundant search keys can be present.\n2 Data can be stored in leaf nodes as well as internal nodes Data can only be stored on the leaf nodes.\n3 Searching for some data is a slower process since data can be found on internal nodes as well as on the leaf nodes. Searching is comparatively faster as data can only be found on the leaf nodes.\n4 Deletion of internal nodes is so complicated and time-consuming. Deletion will never be a complexed process since element will always be deleted from the leaf nodes.\n5 Leaf nodes cannot be linked together. Leaf nodes are linked together to make the search operations more efficient.\n46) List some applications of Tree-data structure?\nApplications of Tree- data structure:\nThe manipulation of Arithmetic expression,\nSymbol Table construction,\nSyntax analysis\nHierarchal data model",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "46) List some applications of Tree-data structure?",
        "answer": "Applications of Tree- data structure:\nThe manipulation of Arithmetic expression,\nSymbol Table construction,\nSyntax analysis\nHierarchal data model",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "47) Define the graph data structure?",
        "answer": "A graph G can be defined as an ordered set G(V, E) where V(G) represents the set of vertices and E(G) represents the set of edges which are used to connect these vertices. A graph can be seen as a cyclic tree, where the vertices (Nodes) maintain any complex relationship among them instead of having parent-child relations.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "48) Differentiate among cycle, path, and circuit?",
        "answer": "Path: A Path is the sequence of adjacent vertices connected by the edges with no restrictions.\nCycle: A Cycle can be defined as the closed path where the initial vertex is identical to the end vertex. Any vertex in the path can not be visited twice\nCircuit: A Circuit can be defined as the closed path where the intial vertex is identical to the end vertex. Any vertex may be repeated.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "",
        "answer": "For the graph implementation, following data structures are used.\nIn sequential representation, Adjacency matrix is used.\nIn Linked representation, Adjacency list is used.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "50) Which data structures are used in BFS and DFS algorithm?",
        "answer": "In BFS algorithm, Queue data structure is used.\nIn DFS algorithm, Stack data structure is used.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "51) What are the applications of Graph data structure?",
        "answer": "The graph has the following applications:\nGraphs are used in circuit networks where points of connection are drawn as vertices and component wires become the edges of the graph.\nGraphs are used in transport networks where stations are drawn as vertices and routes become the edges of the graph.\nGraphs are used in maps that draw cities/states/regions as vertices and adjacency relations as edges.\nGraphs are used in program flow analysis where procedures or modules are treated as vertices and calls to these procedures are drawn as edges of the graph.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "54) In what scenario, Binary Search can be used?",
        "answer": "Binary Search algorithm is used to search an already sorted list. The algorithm follows divide and conqer approach\nExample:",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "52) What are the advantages of Binary search over linear search?",
        "answer": "There are relatively less number of comparisons in binary search than that in linear search. In average case, linear search takes O(n) time to search a list of n elements while Binary search takes O(log n) time to search a list of n elements.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "53) What are the advantages of Selecetion Sort?",
        "answer": "It is simple and easy to implement.\nIt can be used for small data sets.\nIt is 60 per cent more efficient than bubble sort.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "55) List Some Applications of Multilinked Structures?",
        "answer": "Sparse matrix,\nIndex generation.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    },
    {
        "question": "56) What is the difference between NULL and VOID?",
        "answer": "Null is actually a value, whereas Void is a data type identifier.\nA null variable simply indicates an empty value, whereas void is used to identify pointers as having no initial size.",
        "reference": "javatpoint.com",
        "role": "data-structure"
    }
]