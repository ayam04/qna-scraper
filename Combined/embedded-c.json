[
    {
        "question": "1. What do you understand by segmentation fault?",
        "answer": "A segmentation fault occurs most commonly and often leads to crashes in the programs. It occurs when a program instruction tries to access a memory address that is prohibited from getting accessed.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "2. What do you understand by startup code?",
        "answer": "A startup code is that piece of code that is called before the execution of the main function. This is used for creating a basic platform for the application and it is written in assembly language.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "3. What is ISR?",
        "answer": "ISR expands to Interrupt Service Routines. These are the procedures stored at a particular memory location and are called when certain interrupts occur. Interrupt refers to the signal sent to the processor that indicates there is a high-priority event that requires immediate attention. The processor suspends the normal flow of the program, executes the instructions in ISR to cater for the high priority event. Post execution of the ISR, the normal flow of the program resumes. The following diagrams represent the flow of ISR.  ",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "4. What is Void Pointer in Embedded C and why is it used?",
        "answer": "Void pointers are those pointers that point to a variable of any type. It is a generic pointer as it is not dependent on any of the inbuilt or user-defined data types while referencing. During dereferencing of the pointer, we require the correct data type to which the data needs to be dereferenced. For Example: int num1 = 20;    //variable of int datatype \nvoid *ptr;        //Void Pointer\n*ptr = &num1;    //Point the pointer to int data\nprint(\"%d\",(*(int*)ptr));    //Dereferencing requires specific data type \n\nchar c = 'a';\n*ptr = &c;    //Same void pointer can be used to point to data of different type -> reusability\nprint(\"%c\",(*(char*)ptr)); int num1 = 20;    //variable of int datatype \nvoid *ptr;        //Void Pointer\n*ptr = &num1;    //Point the pointer to int data\nprint(\"%d\",(*(int*)ptr));    //Dereferencing requires specific data type \n\nchar c = 'a';\n*ptr = &c;    //Same void pointer can be used to point to data of different type -> reusability\nprint(\"%c\",(*(char*)ptr)); Void pointers are used mainly because of their nature of re-usability. It is reusable because any type of data can be stored.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "5. Why do we use the volatile keyword?",
        "answer": "The volatile keyword is mainly used for preventing a compiler from optimizing a variable that might change its behaviour unexpectedly post the optimization. Consider a scenario where we have a variable where there is a possibility of its value getting updated by some event or a signal, then we need to tell the compiler not to optimize it and load that variable every time it is called. To inform the compiler, we use the keyword volatile at the time of variable declaration. volatile // Declaring volatile variable - SYNTAX\n// volatile datatype variable_name;\nvolatile int x; // Declaring volatile variable - SYNTAX\n// volatile datatype variable_name;\nvolatile int x; Here, x is an integer variable that is defined as a volatile variable.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "6. What are the differences between the const and volatile qualifiers in embedded C?",
        "answer": "const volatile\nThe keyword “const” is enforced by the compiler and tells it that no changes can be made to the value of that object/variable during program execution. The keyword “volatile” tells the compiler to not perform any optimization on the variables and not to assume anything about the variables against which it is declared.\nExample: const int x=20;, here if the program attempts to modify the value of x, then there would be a compiler error as there is const keyword assigned which makes the variable x non-modifiable. Example: volatile int x;, here the compiler is told to not assume anything regarding the variable x and avoid performing optimizations on it. Every time the compiler encounters the variable, fetch it from the memory it is assigned to. const volatile\nThe keyword “const” is enforced by the compiler and tells it that no changes can be made to the value of that object/variable during program execution. The keyword “volatile” tells the compiler to not perform any optimization on the variables and not to assume anything about the variables against which it is declared.\nExample: const int x=20;, here if the program attempts to modify the value of x, then there would be a compiler error as there is const keyword assigned which makes the variable x non-modifiable. Example: volatile int x;, here the compiler is told to not assume anything regarding the variable x and avoid performing optimizations on it. Every time the compiler encounters the variable, fetch it from the memory it is assigned to. const volatile const volatile const volatile The keyword “const” is enforced by the compiler and tells it that no changes can be made to the value of that object/variable during program execution. The keyword “volatile” tells the compiler to not perform any optimization on the variables and not to assume anything about the variables against which it is declared.\nExample: const int x=20;, here if the program attempts to modify the value of x, then there would be a compiler error as there is const keyword assigned which makes the variable x non-modifiable. Example: volatile int x;, here the compiler is told to not assume anything regarding the variable x and avoid performing optimizations on it. Every time the compiler encounters the variable, fetch it from the memory it is assigned to. The keyword “const” is enforced by the compiler and tells it that no changes can be made to the value of that object/variable during program execution. The keyword “volatile” tells the compiler to not perform any optimization on the variables and not to assume anything about the variables against which it is declared. The keyword “const” is enforced by the compiler and tells it that no changes can be made to the value of that object/variable during program execution. The keyword “volatile” tells the compiler to not perform any optimization on the variables and not to assume anything about the variables against which it is declared. Example: const int x=20;, here if the program attempts to modify the value of x, then there would be a compiler error as there is const keyword assigned which makes the variable x non-modifiable. Example: volatile int x;, here the compiler is told to not assume anything regarding the variable x and avoid performing optimizations on it. Every time the compiler encounters the variable, fetch it from the memory it is assigned to. Example: const int x=20;, here if the program attempts to modify the value of x, then there would be a compiler error as there is const keyword assigned which makes the variable x non-modifiable. const int x=20; Example: volatile int x;, here the compiler is told to not assume anything regarding the variable x and avoid performing optimizations on it. Every time the compiler encounters the variable, fetch it from the memory it is assigned to. volatile int x;",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "7. What Is Concatenation Operator in Embedded C?",
        "answer": "The Concatenation operator is indicated by the usage of ##. It is used in macros to perform concatenation of the arguments in the macro. We need to keep note that only the arguments are concatenated, not the values of those arguments. ## For example, if we have the following piece of code: #define CUSTOM_MACRO(x, y) x##y\n\nmain(){\n\n  int xValue = 20;\n  printf(“%d”, CUSTOM_MACRO(x, Value));    //Prints 20\n\n} #define CUSTOM_MACRO(x, y) x##y\n\nmain(){\n\n  int xValue = 20;\n  printf(“%d”, CUSTOM_MACRO(x, Value));    //Prints 20\n\n} We can think of it like this if arguments x and y are passed, then the macro just returns xy -> The concatenation of x and y. x y xy x y",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "8. What do you understand by Interrupt Latency?",
        "answer": "Interrupt latency refers to the time taken by ISR to respond to the interrupt. The lesser the latency faster is the response to the interrupt event.  ",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "9. How will you use a variable defined in source file1 inside source file2?",
        "answer": "We can achieve this by making use of the “extern” keyboard. It allows the variable to be accessible from one file to another. This can be handled more cleanly by creating a header file that just consists of extern variable declarations. This header file is then included in the source files which uses the extern variables. Consider an example where we have a header file named variables.h and a source file named sc_file.c. variables.h sc_file.c /* variables.h*/\nextern int global_variable_x; /* variables.h*/\nextern int global_variable_x; /* sc_file.c*/\n#include \"variables.h\"  /* Header variables included */\n#include <stdio.h>\nvoid demoFunction(void)\n{\n   printf(\"Value of Global Variable X: %d\\n\", global_variable_x++);\n} /* sc_file.c*/\n#include \"variables.h\"  /* Header variables included */\n#include <stdio.h>\nvoid demoFunction(void)\n{\n   printf(\"Value of Global Variable X: %d\\n\", global_variable_x++);\n}",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "10. What is Embedded C Programming? How is Embedded C different from C language?",
        "answer": "Embedded C is a programming language that is an extension of C programming. It uses the same syntax as C and it is called “embedded” because it is used widely in embedded systems. Embedded C supports I/O hardware operations and addressing, fixed-point arithmetic operations, memory/address space access, and various other features that are required to develop fool-proof embedded systems. C programming Following are the differences between traditional C language and Embedded C: C Language Embedded C Language\nIt is of native development nature It is used for cross-development purposes\nC is independent of hardware and its underlying architecture Embedded C is dependent on the hardware architecture.\nC is mainly used for developing desktop applications. Embedded C is used in embedded systems that have limited resources like ROM, RAM, etc. C Language Embedded C Language\nIt is of native development nature It is used for cross-development purposes\nC is independent of hardware and its underlying architecture Embedded C is dependent on the hardware architecture.\nC is mainly used for developing desktop applications. Embedded C is used in embedded systems that have limited resources like ROM, RAM, etc. C Language Embedded C Language C Language Embedded C Language C Language Embedded C Language It is of native development nature It is used for cross-development purposes\nC is independent of hardware and its underlying architecture Embedded C is dependent on the hardware architecture.\nC is mainly used for developing desktop applications. Embedded C is used in embedded systems that have limited resources like ROM, RAM, etc. It is of native development nature It is used for cross-development purposes It is of native development nature It is used for cross-development purposes C is independent of hardware and its underlying architecture Embedded C is dependent on the hardware architecture. C is independent of hardware and its underlying architecture Embedded C is dependent on the hardware architecture. C is mainly used for developing desktop applications. Embedded C is used in embedded systems that have limited resources like ROM, RAM, etc. C is mainly used for developing desktop applications. Embedded C is used in embedded systems that have limited resources like ROM, RAM, etc.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "11. What are the differences between Inline and Macro Function?",
        "answer": "Category Macro Function Inline Function\nCompile-time expansion Macro functions are expanded by the preprocessor at the compile time. Inline functions are expanded by the compiler.\nArgument Evaluation Expressions passed to the Macro functions might get evaluated more than once. Expressions passed to Inline functions get evaluated once.\nParameter Checking Macro functions do not follow strict parameter data type checking. Inline functions follow strict data type checking of the parameters.\nEase of debugging Macro functions are hard to debug because it is replaced by the pre-processor as a textual representation which is not visible in the source code. Easier to debug inline functions which is why it is recommended to be used over macro functions.\nExample #define SQUARENUM(A) A * A -> The macro functions are expanded at compile time. Hence, if we pass, the output will be evaluated to 3+2*3+2 which gets evaluated to 11. This might not be as per our expectations. inline squareNum(int A){return A * A;} -> If we have printf(squareNum(3+2));, the arguments to the function are evaluated first to 5 and passed to the function, which returns a square of 5 = 25. Category Macro Function Inline Function\nCompile-time expansion Macro functions are expanded by the preprocessor at the compile time. Inline functions are expanded by the compiler.\nArgument Evaluation Expressions passed to the Macro functions might get evaluated more than once. Expressions passed to Inline functions get evaluated once.\nParameter Checking Macro functions do not follow strict parameter data type checking. Inline functions follow strict data type checking of the parameters.\nEase of debugging Macro functions are hard to debug because it is replaced by the pre-processor as a textual representation which is not visible in the source code. Easier to debug inline functions which is why it is recommended to be used over macro functions.\nExample #define SQUARENUM(A) A * A -> The macro functions are expanded at compile time. Hence, if we pass, the output will be evaluated to 3+2*3+2 which gets evaluated to 11. This might not be as per our expectations. inline squareNum(int A){return A * A;} -> If we have printf(squareNum(3+2));, the arguments to the function are evaluated first to 5 and passed to the function, which returns a square of 5 = 25. Category Macro Function Inline Function Category Macro Function Inline Function Category Macro Function Inline Function Compile-time expansion Macro functions are expanded by the preprocessor at the compile time. Inline functions are expanded by the compiler.\nArgument Evaluation Expressions passed to the Macro functions might get evaluated more than once. Expressions passed to Inline functions get evaluated once.\nParameter Checking Macro functions do not follow strict parameter data type checking. Inline functions follow strict data type checking of the parameters.\nEase of debugging Macro functions are hard to debug because it is replaced by the pre-processor as a textual representation which is not visible in the source code. Easier to debug inline functions which is why it is recommended to be used over macro functions.\nExample #define SQUARENUM(A) A * A -> The macro functions are expanded at compile time. Hence, if we pass, the output will be evaluated to 3+2*3+2 which gets evaluated to 11. This might not be as per our expectations. inline squareNum(int A){return A * A;} -> If we have printf(squareNum(3+2));, the arguments to the function are evaluated first to 5 and passed to the function, which returns a square of 5 = 25. Compile-time expansion Macro functions are expanded by the preprocessor at the compile time. Inline functions are expanded by the compiler. Compile-time expansion Macro functions are expanded by the preprocessor at the compile time. Inline functions are expanded by the compiler. Argument Evaluation Expressions passed to the Macro functions might get evaluated more than once. Expressions passed to Inline functions get evaluated once. Argument Evaluation Expressions passed to the Macro functions might get evaluated more than once. Expressions passed to Inline functions get evaluated once. Parameter Checking Macro functions do not follow strict parameter data type checking. Inline functions follow strict data type checking of the parameters. Parameter Checking Macro functions do not follow strict parameter data type checking. Inline functions follow strict data type checking of the parameters. Ease of debugging Macro functions are hard to debug because it is replaced by the pre-processor as a textual representation which is not visible in the source code. Easier to debug inline functions which is why it is recommended to be used over macro functions. Ease of debugging Macro functions are hard to debug because it is replaced by the pre-processor as a textual representation which is not visible in the source code. Easier to debug inline functions which is why it is recommended to be used over macro functions. Example #define SQUARENUM(A) A * A -> The macro functions are expanded at compile time. Hence, if we pass, the output will be evaluated to 3+2*3+2 which gets evaluated to 11. This might not be as per our expectations. inline squareNum(int A){return A * A;} -> If we have printf(squareNum(3+2));, the arguments to the function are evaluated first to 5 and passed to the function, which returns a square of 5 = 25. Example #define SQUARENUM(A) A * A -> The macro functions are expanded at compile time. Hence, if we pass, the output will be evaluated to 3+2*3+2 which gets evaluated to 11. This might not be as per our expectations. #define SQUARENUM(A) A * A 3+2*3+2 inline squareNum(int A){return A * A;} -> If we have printf(squareNum(3+2));, the arguments to the function are evaluated first to 5 and passed to the function, which returns a square of 5 = 25. inline squareNum(int A){return A * A;} printf(squareNum(3+2));",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "12. Is it possible for a variable to be both volatile and const?",
        "answer": "The const keyword is used when we want to ensure that the variable value should not be changed. However, the value can still be changed due to external interrupts or events. So, we can use const with volatile keywords and it won’t cause any problem.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "13. Is it possible to declare a static variable in a header file?",
        "answer": "Variables defined with static are initialized once and persists until the end of the program and are local only to the block it is defined. A static variables declaration requires definition. It can be defined in a header file. But if we do so, a private copy of the variable of the header file will be present in each source file the header is included. This is not preferred and hence it is not recommended to use static variables in a header file.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "14. What do you understand by the pre-decrement and post-decrement operators?",
        "answer": "The Pre-decrement operator (--operand) is used for decrementing the value of the variable by 1 before assigning the variable value. --operand #include < stdio.h >  \nint main(){  \n    int x = 100, y;  \n  \n    y = --x;   //pre-decrememt operators  -- first decrements the value and then it is assigned \n\n    printf(\"y = %d\\n\", y);  // Prints 99\n    printf(\"x = %d\\n\", x);  // Prints 99\n    return 0;  \n} #include < stdio.h >  \nint main(){  \n    int x = 100, y;  \n  \n    y = --x;   //pre-decrememt operators  -- first decrements the value and then it is assigned \n\n    printf(\"y = %d\\n\", y);  // Prints 99\n    printf(\"x = %d\\n\", x);  // Prints 99\n    return 0;  \n} The Post-decrement operator (operand--) is used for decrementing the value of a variable by 1 after assigning the variable value. operand-- #include < stdio.h >  \nint main(){  \n    int x = 100, y;  \n  \n    y = x--;   //post-decrememt operators  -- first assigns the value and then it is decremented \n\n    printf(\"y = %d\\n\", y);  // Prints 100\n    printf(\"x = %d\\n\", x);  // Prints 99\n    return 0;  \n} #include < stdio.h >  \nint main(){  \n    int x = 100, y;  \n  \n    y = x--;   //post-decrememt operators  -- first assigns the value and then it is decremented \n\n    printf(\"y = %d\\n\", y);  // Prints 100\n    printf(\"x = %d\\n\", x);  // Prints 99\n    return 0;  \n}",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "15. What is a reentrant function?",
        "answer": "A function is called reentrant if the function can be interrupted in the middle of the execution and be safely called again (re-entered) to complete the execution. The interruption can be in the form of external events or signals or internal signals like call or jump. The reentrant function resumes at the point where the execution was left off and proceeds to completion.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "1. Is it possible to protect a character pointer from accidentally pointing it to a different address?",
        "answer": "It can be done by defining it as a constant character pointer. const protects it from modifications.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "2. What are the reasons for segmentation fault in Embedded C? How do you avoid these errors?",
        "answer": "Following are the reasons for the segmentation fault to occur: While trying to dereference NULL pointers.\nWhile trying to write or update the read-only memory or non-existent memory not accessible by the program such as code segment, kernel structures, etc.\nWhile trying to dereference an uninitialized pointer that might have been pointing to invalid memory.\nWhile trying to dereference a pointer that was recently freed using the free function.\nWhile accessing the array beyond the boundary. While trying to dereference NULL pointers. While trying to write or update the read-only memory or non-existent memory not accessible by the program such as code segment, kernel structures, etc. While trying to dereference an uninitialized pointer that might have been pointing to invalid memory. While trying to dereference a pointer that was recently freed using the free function. While accessing the array beyond the boundary. Some of the ways where we can avoid Segmentation fault are: Initializing Pointer Properly: Assign addresses to the pointers properly. For instance:\nWe can also assign the address of the matrix, vectors or using functions like calloc, malloc etc.\nOnly important thing is to assign value to the pointer before accessing it. Initializing Pointer Properly: Assign addresses to the pointers properly. For instance:\nWe can also assign the address of the matrix, vectors or using functions like calloc, malloc etc.\nOnly important thing is to assign value to the pointer before accessing it. Initializing Pointer Properly: We can also assign the address of the matrix, vectors or using functions like calloc, malloc etc.\nOnly important thing is to assign value to the pointer before accessing it. We can also assign the address of the matrix, vectors or using functions like calloc, malloc etc. Only important thing is to assign value to the pointer before accessing it. int varName;\nint *p = &varName; int varName;\nint *p = &varName; Minimize using pointers: Most of the functions in Embedded C such as scanf, require that address should be sent as a parameter to them. In cases like these, as best practices, we declare a variable and send the address of that variable to that function as shown below: Minimize using pointers: Most of the functions in Embedded C such as scanf, require that address should be sent as a parameter to them. In cases like these, as best practices, we declare a variable and send the address of that variable to that function as shown below: Minimize using pointers: int x;       \nscanf(\"%d\",&x); int x;       \nscanf(\"%d\",&x); In the same way, while sending the address of variables to custom-defined functions, we can use the & parameter instead of using pointer variables to access the address. int x = 1; \nx = customFunction(&x); int x = 1; \nx = customFunction(&x); Troubleshooting: Make sure that every component of the program like pointers, array subscripts, & operator, * operator, array accessing, etc as they can be likely candidates for segmentation error. Debug the statements line by line to identify the line that causes the error and investigate them. Troubleshooting: Make sure that every component of the program like pointers, array subscripts, & operator, * operator, array accessing, etc as they can be likely candidates for segmentation error. Debug the statements line by line to identify the line that causes the error and investigate them. Troubleshooting:",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "3. Is it recommended to use printf() inside ISR?",
        "answer": "printf() is a non-reentrant and thread-safe function which is why it is not recommended to call inside the ISR.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "4. Is it possible to pass a parameter to ISR or return a value from it?",
        "answer": "An ISR by nature does not allow anything to pass nor does it return anything. This is because ISR is a routine called whenever hardware or software events occur and is not in control of the code.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "5. What Is a Virtual Memory in Embedded C and how can it be implemented?",
        "answer": "Virtual memory is a means of allocating memory to the processes if there is a shortage of physical memory by using an automatic allocation of storage. The main advantage of using virtual memory is that it is possible to have larger virtual memory than physical memory. It can be implemented by using the technique of paging. Paging works as follows: Whenever a process needs to be executed, it would be swapped into the memory by using a lazy swapper called a pager.\nThe pager tries to guess which page needs to get access to the memory based on a predefined algorithm and swaps that process. This ensures that the whole process is not swapped into the memory, but only the necessary parts of the process are swapped utilizing pages.\nThis decreases the time taken to swap and unnecessary reading of memory pages and reduces the physical memory required. Whenever a process needs to be executed, it would be swapped into the memory by using a lazy swapper called a pager. The pager tries to guess which page needs to get access to the memory based on a predefined algorithm and swaps that process. This ensures that the whole process is not swapped into the memory, but only the necessary parts of the process are swapped utilizing pages. This decreases the time taken to swap and unnecessary reading of memory pages and reduces the physical memory required.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "6. What is the issue with the following piece of code?",
        "answer": "int square (volatile int *p){\n    return (*p) * (*p) ;\n} int square (volatile int *p){\n    return (*p) * (*p) ;\n} From the code given, it appears that the function intends to return the square of the values pointed by the pointer p. But, since we have the pointer point to a volatile integer, the compiler generates code as below: int square ( volatile int *p){\n    int x , y;\n    x = *p ;\n    y = *p ;\n    return x * y ;\n} int square ( volatile int *p){\n    int x , y;\n    x = *p ;\n    y = *p ;\n    return x * y ;\n} Since the pointer can be changed to point to other locations, it might be possible that the values of the x and y would be different which might not even result in the square of the numbers. Hence, the correct way for achieving the square of the number is by coding as below: long square (volatile int *p ){\n    int x ;\n    x = *p ;\n    return x*x;\n} long square (volatile int *p ){\n    int x ;\n    x = *p ;\n    return x*x;\n}",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "7. The following piece of code uses __interrupt keyword to define an ISR. Comment on the correctness of the code.",
        "answer": "__interrupt double calculate_circle_area (double radius){\n    double circle_area  = PI ∗ radius ∗ radius;\n    printf ( 'Area = %f ' , circle_area);\n    return circle_area;\n} __interrupt double calculate_circle_area (double radius){\n    double circle_area  = PI ∗ radius ∗ radius;\n    printf ( 'Area = %f ' , circle_area);\n    return circle_area;\n} Following things are wrong with the given piece of code: ISRs are not supposed to return any value. The given code returns a value of datatype double.\nIt is not possible to pass parameters to ISRs. Here, we are passing a parameter to the ISR which is wrong.\nIt is not advisable to have printf inside the ISR as they are non-reentrant and thereby it impacts the performance. ISRs are not supposed to return any value. The given code returns a value of datatype double. It is not possible to pass parameters to ISRs. Here, we are passing a parameter to the ISR which is wrong. It is not advisable to have printf inside the ISR as they are non-reentrant and thereby it impacts the performance.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "8. What is the result of the below code?",
        "answer": "void demo(void){\n    unsigned int x = 10 ;\n    int y = −40;\n    if(x+y > 10) {\n        printf(\"Greater than 10\");\n    } else {\n        printf(\"Less than or equals 10\");\n    }\n} void demo(void){\n    unsigned int x = 10 ;\n    int y = −40;\n    if(x+y > 10) {\n        printf(\"Greater than 10\");\n    } else {\n        printf(\"Less than or equals 10\");\n    }\n} In Embedded C, we need to know a fact that when expressions are having signed and unsigned operand types, then every operand will be promoted to an unsigned type. Herem the -40 will be promoted to unsigned type thereby making it a very large value when compared to 10. Hence, we will get the statement “Greater than 10” printed on the console.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "9. What are the reasons for Interrupt Latency and how to reduce it?",
        "answer": "Following are the various causes of Interrupt Latency: Hardware: Whenever an interrupt occurs, the signal has to be synchronized with the CPU clock cycles. Depending on the hardware of the processor and the logic of synchronization, it can take up to 3 CPU cycles before the interrupt signal has reached the processor for processing.\nPipeline: Most of the modern CPUs have instructions pipelined. Execution happens when the instruction has reached the last stage of the pipeline. Once the execution of an instruction is done, it would require some extra CPU cycles to refill the pipeline with instructions. This contributes to the latency. Hardware: Whenever an interrupt occurs, the signal has to be synchronized with the CPU clock cycles. Depending on the hardware of the processor and the logic of synchronization, it can take up to 3 CPU cycles before the interrupt signal has reached the processor for processing. Hardware Pipeline: Most of the modern CPUs have instructions pipelined. Execution happens when the instruction has reached the last stage of the pipeline. Once the execution of an instruction is done, it would require some extra CPU cycles to refill the pipeline with instructions. This contributes to the latency. Pipeline Interrupt latency can be reduced by ensuring that the ISR routines are short. When a lower priority interrupt gets triggered while a higher priority interrupt is getting executed, then the lower priority interrupt would get delayed resulting in increased latency. In such cases, having smaller ISR routines for lower priority interrupts would help to reduce the delay. Also, better scheduling and synchronization algorithms in the processor CPU would help minimize the ISR latency.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "10. Why is the statement ++i faster than i+1?",
        "answer": "++i instruction uses single machine instruction like INR (Increment Register) to perform the increment.\nFor the instruction i+1, it requires to load the value of the variable i and then perform the INR operation on it. Due to the additional load, ++i is faster than the i+1 instruction. ++i instruction uses single machine instruction like INR (Increment Register) to perform the increment. For the instruction i+1, it requires to load the value of the variable i and then perform the INR operation on it. Due to the additional load, ++i is faster than the i+1 instruction.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "11. What do you understand by Wild Pointer? How is it different from Dangling Pointer?",
        "answer": "A pointer is said to be a wild pointer if it has not been initialized to NULL or a valid memory address. Consider the following declaration: int *ptr;\n*ptr = 20; int *ptr;\n*ptr = 20; Here the pointer ptr is not initialized and in the next step, we are trying to assign a valid value to it. If the ptr has a garbage location address, then that would corrupt the upcoming instructions too. If we are trying to de-allocate this pointer and free it as well using the free function, and again if we are not assigning the pointer as NULL or any valid address, then again chances are that the pointer would still be pointing to the garbage location and accessing from that would lead to errors. These pointers are called dangling pointers.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "12. What are the differences between the following 2 statements #include \"...\" and #include <...>?",
        "answer": "Both declarations specify for the files to be included in the current source file. The difference is in how and where the preprocessor looks for including the files. For #include \"...\", the preprocessor just searches for the file in the current directory as where the source file is present and if not found, it proceeds to search in the standard directories specified by the compiler. Whereas for the #include <...> declaration, the preprocessor looks for the files in the compiler designated directories where the standard library files usually reside. #include \"...\" #include <...>",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "13. When does a memory leak occur? What are the ways of avoiding it?",
        "answer": "Memory leak is a phenomenon that occurs when the developers create objects or make use of memory to help memory and then forget to free the memory before the completion of the program. This results in reduced system performance due to the reduced memory availability and if this continues, at one point, the application can crash. These are serious issues for applications involving servers, daemons, etc that should ideally never terminate. Example of Memory Leak: Example of Memory Leak: #include <stdlib.h>\n \nvoid memLeakDemo()\n{\n   int *p = (int *) malloc(sizeof(int));\n \n   /* Some set of statements */\n \n   return; /* Return from the function without freeing the pointer p*/\n} #include <stdlib.h>\n \nvoid memLeakDemo()\n{\n   int *p = (int *) malloc(sizeof(int));\n \n   /* Some set of statements */\n \n   return; /* Return from the function without freeing the pointer p*/\n} In this example, we have created pointer p inside the function and we have not freed the pointer before the completion of the function. This causes pointer p to remain in the memory. Imagine 100s of pointers like these. The memory will be occupied unnecessarily and hence resulting in a memory leak. We can avoid memory leaks by always freeing the objects and pointers when no longer required. The above example can be modified as: #include <stdlib.h>;\n \nvoid memLeakFix()\n{\n   int *p = (int *) malloc(sizeof(int));\n \n   /* Some set of statements */\n \n   free(p); // Free method to free the memory allocated to the pointer p\n   return;\n} #include <stdlib.h>;\n \nvoid memLeakFix()\n{\n   int *p = (int *) malloc(sizeof(int));\n \n   /* Some set of statements */\n \n   free(p); // Free method to free the memory allocated to the pointer p\n   return;\n}",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "14. What kind of loop is better - Count up from zero or Count Down to zero?",
        "answer": "Loops that involve count down to zero are better than count-up loops. This is because the compiler can optimize the comparison to zero at the time of loop termination. The processors need not have to load both the loop variable and the maximum value for comparison due to the optimization. Hence, count down to 0 loops are always better.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "15. What do you understand by a null pointer in Embedded C?",
        "answer": "A null pointer is a pointer that does not point to any valid memory location. It is defined to ensure that the pointer should not be used to modify anything as it is invalid. If no address is assigned to the pointer, it is set to NULL. NULL Syntax: Syntax: data_type *pointer_name = NULL; data_type *pointer_name = NULL; One of the uses of the null pointer is that once the memory allocated to a pointer is freed up, we will be using NULL to assign to the pointer so that it does not point to any garbage locations.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "16. Following are some incomplete declarations, what do each of them mean?",
        "answer": "1. const int x;\n2. int const x;\n3. const  int  *x;\n4. int * const x;\n5. int  const * x const; 1. const int x;\n2. int const x;\n3. const  int  *x;\n4. int * const x;\n5. int  const * x const; The first two declaration points 1 and 2 mean the same. It means that the variable x is a read-only constant integer.\nThe third declaration represents that the variable a is a pointer to a constant integer. The integer value can't be modified but the pointer can be modified to point to other locations.\nThe fourth declaration means that the variable x is a constant pointer to an integer value. It means that the integer value can be changed, but the pointer can't be made to point to anything else.\nThe last declaration means that the variable x is a constant pointer to a constant integer which means that neither the pointer can point to a different location nor the integer value can be modified. The first two declaration points 1 and 2 mean the same. It means that the variable x is a read-only constant integer. x The third declaration represents that the variable a is a pointer to a constant integer. The integer value can't be modified but the pointer can be modified to point to other locations. a The fourth declaration means that the variable x is a constant pointer to an integer value. It means that the integer value can be changed, but the pointer can't be made to point to anything else. x The last declaration means that the variable x is a constant pointer to a constant integer which means that neither the pointer can point to a different location nor the integer value can be modified.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "1. Write an Embedded C program to multiply any number by 9 in the fastest manner.",
        "answer": "This can be achieved by involving bit manipulation techniques - Shift left operator as shown below: #include<stdio.h>\nvoid main(){\n    int num;\n    printf(“Enter number: ”);\n    scanf(“%d”,&num);\n    printf(“%d”, (num<<3)+num);\n} #include<stdio.h>\nvoid main(){\n    int num;\n    printf(“Enter number: ”);\n    scanf(“%d”,&num);\n    printf(“%d”, (num<<3)+num);\n}",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "2. How will you swap two variables? Write different approaches for the same.",
        "answer": "Using Extra Memory Space: Using Extra Memory Space: Using Extra Memory Space: int num1=20, num2=30, temp;\ntemp = num1;\nnum1 = num2;\nnum2 = temp; int num1=20, num2=30, temp;\ntemp = num1;\nnum1 = num2;\nnum2 = temp; Using Arithmetic Operators: Using Arithmetic Operators: Using Arithmetic Operators: int num1=20, num2=30;\nnum1=num1 + num2;\nnum2=num1 - num2;\nnum1=num1 - num2; int num1=20, num2=30;\nnum1=num1 + num2;\nnum2=num1 - num2;\nnum1=num1 - num2; Using Bit-Wise Operators: Using Bit-Wise Operators: Using Bit-Wise Operators: int num1=20, num2=30;\nnum1=num1 ^ num2;\nnum2=num2 ^ num1;\nnum1=num1 ^ num2; int num1=20, num2=30;\nnum1=num1 ^ num2;\nnum2=num2 ^ num1;\nnum1=num1 ^ num2; Using One-liner Bit-wise Operators: Using One-liner Bit-wise Operators: Using One-liner Bit-wise Operators: int num1=20, num2=30;\nnum1^=num2^=num1^=num2; int num1=20, num2=30;\nnum1^=num2^=num1^=num2; The order of evaluation here is right to left. Using One-liner Arithmetic Operators: Using One-liner Arithmetic Operators: Using One-liner Arithmetic Operators: int num1=20, num2=30;\nnum1 = (num1+num2)-(num2=num1); int num1=20, num2=30;\nnum1 = (num1+num2)-(num2=num1); Here the order of evaluation is from left to right.",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "3. Write a program to check if a number is a power of 2 or not.",
        "answer": "We can do this by using bitwise operators. void main (){\n    int num;\n    printf (\"Enter any no:\");\n    scanf (\"%d\", &num);\n    if (num & & ((num & num-1) == 0))\n        printf (\"Number is a power of 2\");\n    else\n        printf (\"Number is not a power of 2\");\n} void main (){\n    int num;\n    printf (\"Enter any no:\");\n    scanf (\"%d\", &num);\n    if (num & & ((num & num-1) == 0))\n        printf (\"Number is a power of 2\");\n    else\n        printf (\"Number is not a power of 2\");\n}",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "4. Write a program to print numbers from 1 to 100 without making use of conditional operators?",
        "answer": "void main (){\n   int i=0;\n   while (100 – i++)\n   printf (\"%d\", i);\n} void main (){\n   int i=0;\n   while (100 – i++)\n   printf (\"%d\", i);\n}",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "5. Write a MIN macro program that takes two arguments and returns the smallest of both arguments.",
        "answer": "#define MIN(NUM1,NUM2) ( (NUM1) <= (NUM2) ? (NUM1) : (NUM2) ) #define MIN(NUM1,NUM2) ( (NUM1) <= (NUM2) ? (NUM1) : (NUM2) ) Useful Resource Useful Resource C Interview Questions C Interview Questions C++ Interview Questions C++ Interview Questions Practice Coding Practice Coding InterviewBit Blog InterviewBit Blog Online C++ Compiler Online C++ Compiler",
        "reference": "interviewbit.com",
        "role": "embedded-c"
    },
    {
        "question": "1) What is Embedded C? / What do you understand by Embedded C language?",
        "answer": "Embedded C is a set of language extensions for the C programming language specified by the C Standards Committee. It is generally used to address commonality issues that exist between C extensions for different embedded systems. Embedded C programming typically requires nonstandard extensions to the C language to support enhanced microprocessor features such as fixed-point arithmetic, multiple distinct memory banks, and basic I/O operations.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "2) What do you understand by the embedded system?",
        "answer": "An embedded system is a microprocessor-based computer hardware system and software designed to perform a specific function. An embedded system is either an independent system or acts as a part of a large system.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "3) What are the key differences between C and Embedded C?",
        "answer": "C is a general-purpose, high-level programming language used to design any desktop-based applications. On the other hand, Embedded C is an extension of the C language, and it is used to develop micro-controller based applications. Here, Embedded refers to the hosting computer or microcontroller and not the programming language. Let's see the key differences between C and Embedded C in the following table.\nDifferences between C and Embedded C:\nC language Embedded C\nC is a general-purpose programming language used to design any desktop-based applications. Embedded C is nothing but an extension C programming language, and it is used to develop micro-controller based applications.\nC is a type of high-level programming language. Embedded C is an extension of the C programming language.\nC programming language is the hardware-independent language. Embedded C is a completely hardware-dependent language.\nC is a simple language, and it is easy to read and modify. Embedded C is comparatively tough, and it is not easy to read and modify the Embedded C language.\nThe compilers of the C programming language are OS-dependent. The compilers of Embedded C are OS independent.\nIn the C programming language, the standard compilers are used to compile and execute the program. In Embedded C language, a specific compiler that can generate particular hardware/micro-controller based output is used to compile the code.\nSome popular compilers used to execute a C language program are:\nGCC (GNU Compiler collection)\nBorland Turbo C\nIntel C++ Some popular compilers used to execute an Embedded C language program are:\nKeil compiler\nBiPOM ELECTRONIC\nGreen Hill software\nC programming language has a free format of program coding. In Embedded C language, formatting depends upon the type of microprocessor used in the application.\nBug fixing is easy in a C language program. Bug fixing is complicated in an Embedded C language program.\nC language also supports other various programming languages during application. Embedded C language supports only the required processor of the application and not the programming languages.\nC programming language must require an operating system. Embedded C may or may not require an operating system.\nIn the C programming language, we can give input to the program while it is running. In Embedded C language, we can give only the pre-defined inputs to the running program.\nThe C programming language supports normal optimization. Embedded C supports the high level of optimization.\nC programming language generally uses the resources of a desktop PC like memory, OS, etc. Embedded C language has to use with the limited resources, such as RAM, ROM, I/Os on an embedded processor.\nSome examples of the C Program applications:\nLogical programs\nSystem software programs etc. Some examples of the Embedded C Program applications:\nDVD\nTV\nDigital camera etc.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "4) Is embedded C a programming language?",
        "answer": "Embedded C is not a core programming language. It is an extension of C programming language that is used to develop micro-controller based applications. The extensions introduced in Embedded C language from normal C programming language are the I/O Hardware Addressing, fixed-point arithmetic operations, accessing address spaces, etc.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "5) What are the main advantages of Embedded C?",
        "answer": "Embedded C is the extension of the C programming language. Let's see the key advantages of Embedded C:\nKey advantages of Embedded C:\nADVERTISEMENT\nThe coding speed of Embedded C is high, and it is simple and easy to understand.\nIt doesn't require any hardware changes such as extra memory or space for storage as it performs the same task all the time.\nIt is dedicated to its specific task and performs only one task at one time.\nIt is mainly used in modern automatic applications. Embedded applications are very suitable for industrial purposes.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "6) What are the main disadvantages of Embedded C?",
        "answer": "Disadvantages of Embedded C:\nEmbedded C performs only one task at a time, so it is not preferred when we have to perform multiple tasks simultaneously.\nEmbedded C only supports the hardware system. So, if you have to change the program, then you must have to change the hardware.\nEmbedded C also has some scalability issues, so; it cannot be easily scaled up as scope change or demand.\nIt has some limitations, such as limited memory or computer compatibility.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "7) What is the volatile keyword in Embedded C, and what is its usage?",
        "answer": "In Embedded C, the volatile keyword is a type qualifier that prevents the objects from compiler optimization. According to the C standard, we can modify the volatile-qualified type object in ways unknown to the implementation. In other words, we can say that the value of the volatile-qualified object can be changed at any time without making any changes in the code. If the volatile qualifier qualifies an object, the compiler will reload the value from memory each time the program accesses it. Reading the value from memory is the only way to check the unpredictable change of the value.\nThe volatile keyword is mainly used when we have to deal with GPIO, interrupt or flag Register directly. It is also used with a global variable or buffer shared between the threads.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "8) What is the segmentation fault error in C? What are some common causes for the segmentation fault error?",
        "answer": "Segmentation fault error is a runtime error, which may occur due to some causes when a program runs.\nFollowing is a list of some common causes for the segmentation fault error in C:\nUsages of the dereferenced pointer: If we use a pointer that may not have a valid address/memory location to point, it may create a segmentation fault error.\nA program may return a segmentation fault error if you try to access a read-only memory area.\nSegmentation fault error may also occur when you try to free memory (using a pointer), which is already freed.\nThe occurrence of segmentation fault error is the reason to generate stack overflow error in C.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "9) What is the full form of ISR in Embedded C?",
        "answer": "In Embedded C, ISR stands for Interrupt Service Routines. These are the procedures stored at specific memory addresses and called when a certain type of interrupt occurs.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "10) What is a stack overflow error in C?",
        "answer": "In C language, the stack overflow error may occur if the program tries to access the memory beyond its available maximum limit. For example, the stack overflow error may occur if a pointer exceeds the stack limitations (boundaries).\nWhen the stack overflow error occurs, the program terminates and does not execute further instructions. So, we must be very careful while using the pointer and limit boundaries.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "11) Is it possible to pass any parameter and return a value from the ISR?",
        "answer": "No. It is not possible to pass any parameter and return a value from the ISR. The ISR returns nothing and does not allow passing any parameter. An ISR is called when a hardware or software event occurs, and the code does not call it. That's why no parameters are passed into an ISR. As the code does not call ISR, there is no calling code to read the returned values of the ISR. That's why an ISR does not return any value.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "12) What do you understand by interrupt latency?",
        "answer": "Interrupt Latency is the number of clock cycles the processor takes to respond to an interrupt request. This clock cycle number is count between the interrupt request's assertions and the interrupt handler's first instruction.\nInterrupt Latency on the Cortex-M processor family:\nCortex-M processors have very low interrupt latency. The following table shows the Interrupt latency of Cortex-M processors with zero wait state memory systems.\nProcessors Cycles with zero wait state memory\nCortex-M0 16\nCortex-M0+ 15\nCortex-M3 12\nCortex-M4 12\nCortex-M7 12",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "13) How can you measure the interrupt latency in Embedded C?",
        "answer": "In Embedded C, we can measure the interrupt latency with the help of the oscilloscope. Follow the steps given below:\nTake two GPIOs first. Configure one GPIO to generate the interrupt and the second for the toggling (you can attach an LED also).\nUse the oscilloscope or analyzer to monitor the PIN, which is already configured to generate the interrupt.\nNow, monitor the second pin, which is toggled at the beginning of the interrupt service routine by using the oscilloscope or analyzer.\nWhen you generate the interrupt, the signal of both GPIOs will change.\nNow, you can easily read the instrument's interval between the two signals (interrupt latency).",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "14) How can you reduce the interrupt latency?",
        "answer": "There are several ways to reduce the interrupt latency in Embedded C. The interrupt latency depends on many factors. Following is a list of some factors:\nPlatform and interrupt controller\nCPU clock speed\nTimer frequency\nCache configuration\nApplication program etc.\nSo, we can easily reduce the interrupt latency by using the proper selection of platform and processor. We can also reduce the interrupt latency by making the ISR shorter and avoid to calling a function within the ISR.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "15) What is a static variable in C? Why do we use a static variable in C?",
        "answer": "Static variables have the property of preserving their value even after they are out of their scope. It means we can initialize static variables only once. Its scope is local, but it lives until the end of the program. The compiler persists with the variable till the end of the program. We can define static variables inside or outside the function. The default value of static variables is zero. The static variables are alive till the execution of the program.\nSyntax for the static variables in C language:\nstatic datatype variable_name = value;  \nA static variable is generally used to count something. For example, the function openBakAccount() calls whenever a new account opens in the bank. Then, to count the total number of opened accounts, we can declare a static variable in the function and increase it on each function call.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "16) What are some interesting facts about static variables in C?",
        "answer": "Following is a list of some interesting facts about static variables in C:\nThere are two types of static variables, static int variable and static auto variable. A static int variable remains in memory while the program is running and a normal or auto variable is destroyed when a function call declared is over. For example, we can use a static int variable to count the number of times a function is called, but we cannot use an auto variable for this purpose.\nStatic variables are allocated memory in the data segment, not the stack segment.\nThe default value for static variables is 0. Like global variables, they are initialized as 0 if not initialized explicitly.\nIn C language, we can initialize the static variables using only constant literals.\nStatic global variables and functions are also possible in C++. They are mainly used to limit the scope of a variable or function to a file.\nWe should not declare static variables inside the structure because the C compiler requires the entire structure elements to be placed together.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "17) How can you use a variable in a source file defined in another source file?",
        "answer": "We can use the \"extern\" keyboard to declare a variable that allows accessing the variable in another file. This is how we can use a variable in a source file defined in another source file.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "18) How can you protect a character pointer by some accidental modification with the pointer address?",
        "answer": "We can use the constant character pointer (const char*) to protect a character pointer by accidentally modifying the pointer address. It prevents unnecessary modifications with the pointer address in the string.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "19) What are the main differences between CISC and RISC?",
        "answer": "There are many differences between the RISC and CISC. Some of them are as follows:\nRISC CISC\nRISC stands for Reduced Instruction Set Computer. CISC stands for Complex Instruction Set Computer.\nRISC does not consist of a memory unit. CISC consists of a memory unit.\nRISC is a relatively faster processor than CISC in terms of calculations. CISC is a comparatively slower processor than RISC in terms of calculations.\nRISC is used to ensure the simple decoding of operations. CISC doesn't ensure simple decoding of operations.\nThe execution time is RISC is low. The execution time is CISC is high.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "20) What do you understand by a function pointer?",
        "answer": "A function pointer is a pointer that points to a function instead of a variable. That's why a function pointer is completely different from the class of other pointers. A function pointer stores the address of a particular function so that the concerned program can avail of it through function invoking.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "21) Can a variable be both constant and volatile in C?",
        "answer": "Yes, a variable can be both constant and volatile in C. we can use constant and volatile both variables together. The volatile and const variable together is used at the time of accessing the GPIO registers. In this case, its value is changed by the 'external factors' if a switch or any output device is attached with GPIO. In this situation, the volatile variable is important because it ensures that the compiler always read the value from the GPIO address and avoids making any assumption.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "22) What is a dangling pointer in embedded C?",
        "answer": "A dangling pointer is a pointer that points to a memory location that has been already free-ed by the application and is no longer in use. Sometimes, the programmers fail to initialize the pointer with a valid address; these types of initialized pointers are known as dangling pointers. Dangling pointers occur at the time of the object's destruction when the object is deleted or de-allocated from memory without modifying the pointer's value. If you try to dereference a dangling pointer, it will potentially lead to a runtime error.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "23) What is the size of a character, integer, integer pointer, and character pointer in C?",
        "answer": "The size of the character is 1 byte, the size of the integer is 4 bytes, the size of the integer pointer, and the character pointer is 8 bytes on a 64-bit machine and 4 bytes on a 32-bit machine.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "24) What are some Real-Time applications of Embedded Processors?",
        "answer": "Some real-time applications of Embedded Processors are:\nDishwashers\nAutomatic passengers cars\nMobile Phones\nTelevision\nMedical equipment, etc.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "25) What are some examples of the embedded systems to use in Aerospace Applications?",
        "answer": "Some examples of the embedded systems to use in Aerospace Applications are:\nFlight control systems\nAutopilot mode\nA passenger in-flight embedded system\nEngine controllers\nLanding and takeoff controller etc.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "26) How many bits that the Embedded Software supports?",
        "answer": "The Embedded Software supports 8, 16 or 32 bit embedded processors.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "27) What do you understand by a NULL pointer? What is its usage?",
        "answer": "NULL is a macro defined in C. The Null pointer is a pointer that does not point to any valid location. The NULL pointer is defined when we want to ensure that the pointer does not point to any valid location and not to use that pointer to change anything. Without using a null pointer, we can't verify whether this pointer points to any valid location or not.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "28) Are Countdown to zero loops better than Count_up_loops?",
        "answer": "Yes, Countdown to zero loops are better than Count_up_loops because, at loop termination, comparison to zero can be optimized by the compiler. Most of the processors have instructions for comparing to zero. So they don't need to load the loop variable and the maximum value; subtract them and then compare them to zero. That is why count down to zero loops are better.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "29) What are some examples of Embedded systems in automotive applications?",
        "answer": "Following are some examples of Embedded systems in automotive applications:\nTraffic control systems\nBraking systems\nsteer-by-wire systems\nCruise control applications\nAirbag release systems\nEngine management units etc.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "30) What are some examples of domestic appliances that use an Embedded System?",
        "answer": "Following is a list of some examples of domestic appliances that use Embedded Systems:\nSmart Televisions\nWashing machines\nMicrowave ovens\nDishwashers\nGarage door controllers\nVideo recorders and\nSecurity systems etc.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "31) What do you understand by the term structure padding in Embedded C?",
        "answer": "Structure padding is a concept used in the C programming language. It is used to add one or more empty bytes between the memory addresses to align the data in the memory. The compiler automatically does it to ensure that all its members are byte aligned.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "32) What are some examples of Medical Equipments that uses the concept of Embedded Systems?",
        "answer": "Following are some examples of Medical Equipments that uses the concept of Embedded Systems:\nAnaesthesia monitoring systems\nECG monitors\nMRI Scanners\nDrug delivery systems\nUltrasound equipment etc.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "33) Which Defense Systems use the concept of Embedded Systems?",
        "answer": "Following are some examples of Defense Systems that use the concept of Embedded Systems:\nRadio systems\nRadar systems\nMissile guidance systems\nFighter aircraft flight control system\nTarget guidance systems etc.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "34) What do you understand by Machine Code?",
        "answer": "Machine Code is the language of the computer rather than the programmer. A computer only accepts the instructions in the form of machine code or object code. When a programmer interprets the code, it is complex and error-prone. Whether in languages such as C, C++, and Java, all software must ultimately be translated into machine code to be executed by the computer.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "35) What are the Discrete Components used in Embedded systems?",
        "answer": "The list of Discrete Components used in Embedded systems is:\nTransistors\nDiodes\nResistors\nCapacitor",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "36) What is the link between oscillator frequency and machine-cycle period?",
        "answer": "A general rule specifies that the oscillator frequency directly determines the speed at which your application runs. So, in most cases, if you double the oscillator frequency, the speed of the application would be doubled.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "37) What is the full form of MIPS?",
        "answer": "MIPS stands for Million Instructions Per Second. It is an approximate measure of a computer's raw processing power. It may be misleading because measurement techniques often differ, and different computers may require different sets of instructions to perform the same activity.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "38) How can we improve the 8051 microcontroller performance?",
        "answer": "The simplest way to improve the performance of the 8051 microcontrollers is to increase the clock frequency. The 8051 microcontrollers allow the use of clock speeds well beyond the 12MHz limit of the original devices. The best way to improve the performance is to make internal changes to the microcontroller so that fewer oscillator cycles are required to execute each machine instruction.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "39) What is the range of maximum oscillator frequency and the peak performance in the 8051 microcontrollers?",
        "answer": "The 8051 microcontroller has a maximum oscillator frequency of 12 MHz, and peak performance is 1 MIP.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "40) What do you understand by Memory Fragmentation?",
        "answer": "Memory Fragmentation is an issue that arises while using dynamic memory allocation. When we keep allocating and releasing memory spaces over time, in the end, we will get non-contiguous memory blocks that are free, and our in-use variables are scattered everywhere in the RAM. This is called memory fragmentation. This can potentially lead to dynamic memory allocation failure. For example, if you have to allocate an array of 100 integers and there is no contiguous block of memory with that space, this causes a runtime error. This is why we don't use dynamic memory allocation in embedded systems firmware in the first place.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "41) What are inline functions in Embedded C?",
        "answer": "Inline functions are the types of function whose definitions are small and be substituted at the place where its function call has happened. The ARM compilers support inline functions with the keyword __inline. These functions have a small definition, and the function body is substituted in each call to the inline function.",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    },
    {
        "question": "42) What are the types of memory in an Embedded System in C language?",
        "answer": "Following are the types of memory in an Embedded System in C language:\nDRAM (Dynamic RAM)\nSRAM (Static RAM)\nMask Read-only Memory (ROM)\nPROM (Programmable Read-Only Memory)\nUV EPROM (UV Erasable Programmable Read-Only Memory)\nEEPROM (Electrically - Erasable PROM)",
        "reference": "javatpoint.com",
        "role": "embedded-c"
    }
]