[
    {
        "question": "1. How will you modify a linked list of integers so that all even numbers appear before all odd numbers in the modified linked list? Also, keep the even and odd numbers in the same order.",
        "answer": "Example:\nInput: 17->15->8->12->10->5->4->1->7->6->NULL\nOutput: 8->12->10->4->6->17->15->5->1->7->NULL Example:   Algorithm:\nThe approach is to divide the linked list into two sections, one with all even nodes and the other with all odd nodes. In order to split the Linked List, traverse the original Linked List and move all odd nodes to a new Linked List. The original list will include all the even nodes at the end of the loop, while the odd node list will have all the odd nodes. We must place all the odd nodes at the end of the odd node list to maintain the same ordering of all nodes. And, in order to do it in real-time, we'll need to maintain track of the last pointer in the odd node list. Finally, the odd node linked list is to be attached after the even node linked list. Algorithm:  Implementation: Implementation: Node* separateEvenOdd(struct Node *head)\n{\n   // Starting node of the list having\n   // even values\n   Node *evenStart = NULL;\n    \n   // Starting node of the list having odd values\n   Node *oddStart = NULL;\n    \n   // Ending node of the list having even values\n   Node *evenEnd = NULL;\n    \n   // Ending node of the list having odd values\n   Node *oddEnd = NULL;\n    \n   // Node for list traversal.\n   Node *currentNode;\n    \n   for(currentNode = head; currentNode != NULL; currentNode = currentNode -> next)\n   {\n       int value = currentNode -> value;\n        \n       // If the current value is even, add\n       // it to the list of even values.\n       if(value % 2 != 0) \n       {\n          if(oddStart != NULL)\n           {\n               oddEnd -> next = currentNode;\n               oddEnd = oddEnd -> next;\n           }\n           else\n           {\n               oddStart = currentNode;\n               oddEnd = oddStart;               \n           }\n       }\n        \n       // If current value is odd, add\n       // it to the list of odd values.\n       else\n       {\n           if(evenStart != NULL)\n           {\n               evenEnd -> next = currentNode;\n               evenEnd = evenEnd -> next;               \n           }\n            \n           else\n           {\n              evenStart = currentNode;\n              evenEnd = evenStart;\n           }\n       }\n                    \n  }\n    \n   // If any of the two- odd list or even list is empty,\n   // no change is required\n   if(!oddStart || !evenStart)\n   {\n       return;\n   }\n    \n   // Add the odd list after the even list.    \n   evenEnd -> next = oddStart;\n   oddEnd -> next = NULL;\n    \n   // Modify the head pointer to\n   // the start of the even list.\n   head = evenStart;\n   return head;\n} Node* separateEvenOdd(struct Node *head)\n{\n   // Starting node of the list having\n   // even values\n   Node *evenStart = NULL;\n    \n   // Starting node of the list having odd values\n   Node *oddStart = NULL;\n    \n   // Ending node of the list having even values\n   Node *evenEnd = NULL;\n    \n   // Ending node of the list having odd values\n   Node *oddEnd = NULL;\n    \n   // Node for list traversal.\n   Node *currentNode;\n    \n   for(currentNode = head; currentNode != NULL; currentNode = currentNode -> next)\n   {\n       int value = currentNode -> value;\n        \n       // If the current value is even, add\n       // it to the list of even values.\n       if(value % 2 != 0) \n       {\n          if(oddStart != NULL)\n           {\n               oddEnd -> next = currentNode;\n               oddEnd = oddEnd -> next;\n           }\n           else\n           {\n               oddStart = currentNode;\n               oddEnd = oddStart;               \n           }\n       }\n        \n       // If current value is odd, add\n       // it to the list of odd values.\n       else\n       {\n           if(evenStart != NULL)\n           {\n               evenEnd -> next = currentNode;\n               evenEnd = evenEnd -> next;               \n           }\n            \n           else\n           {\n              evenStart = currentNode;\n              evenEnd = evenStart;\n           }\n       }\n                    \n  }\n    \n   // If any of the two- odd list or even list is empty,\n   // no change is required\n   if(!oddStart || !evenStart)\n   {\n       return;\n   }\n    \n   // Add the odd list after the even list.    \n   evenEnd -> next = oddStart;\n   oddEnd -> next = NULL;\n    \n   // Modify the head pointer to\n   // the start of the even list.\n   head = evenStart;\n   return head;\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "2. A given linked list is sorted based on absolute values. Write a function to sort the list based on actual values in O(n) time.",
        "answer": "  All the negative elements can be found in the reverse order. Therefore, as we traverse the list, whenever we find an element that is out of order, it is moved to the front of the linked list. Auxiliary Space: O(1) Implementation: Implementation: void sortList(Node** head)\n{\n   // Initialize the previous and the current nodes\n   Node* previous = (*head);\n   Node* current;\n\n   // list traversal\n   for(current = (*head)->next; current != NULL; current = current->next)\n   {\n       // continue if the current element\n       // is at its right place\n       if (current->value >= previous->value)\n       {\n          previous = current;\n       }\n        \n       // If current is smaller than previous, then\n       // it must be moved to head\n       else\n       {\n          // Detach current from the linked list\n           previous->next = current->next;\n\n           // Move the current node to the beginning\n           current->next = (*head);\n           (*head) = current;\n\n           // Update current\n           current = previous;\n          \n        }\n   }\n} void sortList(Node** head)\n{\n   // Initialize the previous and the current nodes\n   Node* previous = (*head);\n   Node* current;\n\n   // list traversal\n   for(current = (*head)->next; current != NULL; current = current->next)\n   {\n       // continue if the current element\n       // is at its right place\n       if (current->value >= previous->value)\n       {\n          previous = current;\n       }\n        \n       // If current is smaller than previous, then\n       // it must be moved to head\n       else\n       {\n          // Detach current from the linked list\n           previous->next = current->next;\n\n           // Move the current node to the beginning\n           current->next = (*head);\n           (*head) = current;\n\n           // Update current\n           current = previous;\n          \n        }\n   }\n}",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "3. Given a linked list and a number n, you have to find the sum of the last n nodes of the linked list in a single traversal. Explain your approach in brief.",
        "answer": "The use of two-pointers will require a single traversal. We will have to maintain two pointers – reference pointer and main pointer. Both these pointers will be initialized to head. First, the reference pointer will be moved to n nodes from the head, and while traversing, we will keep adding the values and store them into a variable called sum1. Now both the pointers will move simultaneously until the reference pointer reaches the end of the list and while traversing, we will keep adding the values of the nodes. The reference pointer is storing this sum in the variable sum1, and the main pointer will be storing it in sum2. Now, (sum1 – sum2) is the answer, that is the required sum of the last n nodes. int getSum(Node* head, int n)\n{\n   if (n <= 0)\n       return 0;\n\n   int sum1 = 0, sum2 = 0;\n   struct Node* ptr1 = head;\n   struct Node* ptr2 = head;\n\n   // the sum of the first n nodes is to be calculated\n   for (ptr1 = head; ptr1 != NULL; ptr1 = ptr1->next;) \n   {                  \n       sum += ptr1->value;\n       n--;\n       if(n == 0)\n         break;\n   }\n   // now there is a distance of n nodes between the two pointers\n   // move to the end of the linked list\n   while (ptr1 != NULL) \n   { \n       // sum of all the nodes\n       sum1 += ptr1->value;\n       // sum of the first length -  n nodes\n       sum2 += ptr2->value;\n\n       ptr1 = ptr2->next;\n       ptr2 = ptr2->next;\n   }\n\n   // returning the required sum\n   return (sum1 - sum2);\n} int getSum(Node* head, int n)\n{\n   if (n <= 0)\n       return 0;\n\n   int sum1 = 0, sum2 = 0;\n   struct Node* ptr1 = head;\n   struct Node* ptr2 = head;\n\n   // the sum of the first n nodes is to be calculated\n   for (ptr1 = head; ptr1 != NULL; ptr1 = ptr1->next;) \n   {                  \n       sum += ptr1->value;\n       n--;\n       if(n == 0)\n         break;\n   }\n   // now there is a distance of n nodes between the two pointers\n   // move to the end of the linked list\n   while (ptr1 != NULL) \n   { \n       // sum of all the nodes\n       sum1 += ptr1->value;\n       // sum of the first length -  n nodes\n       sum2 += ptr2->value;\n\n       ptr1 = ptr2->next;\n       ptr2 = ptr2->next;\n   }\n\n   // returning the required sum\n   return (sum1 - sum2);\n} Time Complexity is O(n) and space complexity is O(1).",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "4. How will you find the middle element of a singly linked list without iterating the list more than once?",
        "answer": "To solve this problem, we can use the two-pointer method. You have two pointers, one fast and one slow, in the two-pointer approach. The fast pointer travels two nodes per step, while the slow pointer only moves one. The slow pointer will point to the middle node of the linked list when the fast pointer points to the last node, i.e. when the next node is null. Node* getMiddle(Node *head)\n{\n     struct Node *slow = head;\n     struct Node *fast = head;\n \n     if (head)\n     {\n         while (fast != NULL && fast->next != NULL)\n         {\n             fast = fast->next->next;\n             slow = slow->next;\n         }\n     }\n     return slow;\n} Node* getMiddle(Node *head)\n{\n     struct Node *slow = head;\n     struct Node *fast = head;\n \n     if (head)\n     {\n         while (fast != NULL && fast->next != NULL)\n         {\n             fast = fast->next->next;\n             slow = slow->next;\n         }\n     }\n     return slow;\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "5. A linked list of coordinates is given, with neighboring points forming either a vertical or horizontal line. Remove points in between the starting and ending points of the horizontal or vertical line from the linked list.",
        "answer": "  The objective is to keep track of the current node, the next node, and the node after that. Continue deleting the next node when it is the same as the next-next node. We must keep a watch on the shifting of pointers and check for NULL values throughout the entire procedure. Time Complexity is O(n).\nSpace Complexity is O(1)  Implementation: Implementation: void deleteNode(Node *head, Node *t)\n{\n   head->next = t->next;\n   t->next = NULL;\n   free(t);\n}\n\n// This function deletes the intermediate nodes in a sequence of\n// horizontal and vertical line segments represented by a\n// linked list.\nNode* deleteMiddleNodes(Node *head)\n{\n   if (head == NULL || head->next == NULL || head->next->next == NULL)\n       return head;\n\n   Node* t = head->next;\n   Node *tt = t->next;\n\n   // Check whether this is a vertical line or horizontal line\n   if (t->y == head->y)     \n   {\n       // Find intermediate nodes with same y value, and delete them\n       while (tt != NULL && t->y == tt->y)\n       {\n           deleteNode(head, t);\n\n           // Update t and tt for the next iteration\n           t = tt;\n           tt = tt->next;\n       }\n   }\n       // check for vertical line\n   else if (t->x == head->x)\n   {\n       // Find intermediate nodes with same x value, and delete them\n       while (tt != NULL && t->x == tt->x)\n       {\n           deleteNode(head, t);\n\n           // Update t and tt for the next iteration\n           t = tt;\n           tt = tt->next;\n       }\n   }\n   // Adjacent points must either have same x or same y\n   else \n   {\n       cout<<\"Given linked list is not valid\";\n       return NULL;\n   }\n\n   // Recursion for the next segment\n   deleteMiddleNodes(head->next);\n\n   return head;\n} void deleteNode(Node *head, Node *t)\n{\n   head->next = t->next;\n   t->next = NULL;\n   free(t);\n}\n\n// This function deletes the intermediate nodes in a sequence of\n// horizontal and vertical line segments represented by a\n// linked list.\nNode* deleteMiddleNodes(Node *head)\n{\n   if (head == NULL || head->next == NULL || head->next->next == NULL)\n       return head;\n\n   Node* t = head->next;\n   Node *tt = t->next;\n\n   // Check whether this is a vertical line or horizontal line\n   if (t->y == head->y)     \n   {\n       // Find intermediate nodes with same y value, and delete them\n       while (tt != NULL && t->y == tt->y)\n       {\n           deleteNode(head, t);\n\n           // Update t and tt for the next iteration\n           t = tt;\n           tt = tt->next;\n       }\n   }\n       // check for vertical line\n   else if (t->x == head->x)\n   {\n       // Find intermediate nodes with same x value, and delete them\n       while (tt != NULL && t->x == tt->x)\n       {\n           deleteNode(head, t);\n\n           // Update t and tt for the next iteration\n           t = tt;\n           tt = tt->next;\n       }\n   }\n   // Adjacent points must either have same x or same y\n   else \n   {\n       cout<<\"Given linked list is not valid\";\n       return NULL;\n   }\n\n   // Recursion for the next segment\n   deleteMiddleNodes(head->next);\n\n   return head;\n}",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "6. Construct a doubly linked list out of a ternary tree.",
        "answer": "A ternary tree is similar to a binary tree, except that instead of two nodes, it has three: left, middle, and right. The attributes of the doubly linked list should be as follows: The ternary tree's left pointer should be used as the previous pointer in a doubly-linked list.\nThe ternary tree's middle pointer should not point to anything.\nThe ternary tree's right pointer should be the doubly linked list's next pointer.\nEach ternary tree node is entered into a doubly-linked list before its subtrees, with the left child of each node being inserted first, followed by the middle and right child (if any). The ternary tree's left pointer should be used as the previous pointer in a doubly-linked list. The ternary tree's middle pointer should not point to anything. The ternary tree's right pointer should be the doubly linked list's next pointer. Each ternary tree node is entered into a doubly-linked list before its subtrees, with the left child of each node being inserted first, followed by the middle and right child (if any).   The approach is to make a preorder traversal of the tree. When we visit a node, we will use a tail pointer to insert it into a doubly-linked list at the end. That's how we keep the required insertion order. Then, in that order, we call for the left child, middle child, and right child. Implementation: Implementation: //Utility function that creates a doubly linked list\n//by inserting the current node at the end of the doubly\n//linked list by employing a tail pointer\nvoid push(Node** tail_reference, Node* n)\n{\n   // the tail pointer is to be initialized\n   if (*tail_reference == NULL)\n   {\n       *tail_reference = n;\n\n       // set left, middle and right child to point\n       // to NULL\n       n->left = NULL;\n       n->middle = NULL;\n       n->right = NULL;\n\n       return;\n   }\n\n   // using tail pointer, insert node in the end \n   (*tail_reference)->right = n;\n   // the middle and right child are set to point to NULL\n   n->right = NULL;\n   n->middle = NULL;\n\n   // set previous of the node\n   n->left = (*tail_reference);\n\n    \n   // now tail pointer is pointing to the inserted node\n   (*tail_reference) = n;\n}\n\n// From a ternary tree, create a doubly linked list,\n// by making a preorder traversal of the tree\nNode* ternaryTreeToList(Node** head_reference, Node* root)\n{\n   // Base case\n   if (!root)\n       return NULL;\n\n   //a static tail pointer to be created\n   static Node* tail = NULL;\n\n   // left, middle and right nodes to be stored\n   // for future calls.\n   Node* left = root->left;\n   Node* middle = root->middle;\n   Node* right = root->right;\n\n   // set the head of the doubly linked list\n   // as the root of the ternary tree\n   if (*head_reference == NULL)\n       *head_reference = root;\n\n   // push the current node in the end of the doubly linked list\n   push(&tail, root);\n\n   //recursion for left, middle and right child\n   ternaryTreeToList(head_reference, left);\n   ternaryTreeToList(head_reference, middle);\n   ternaryTreeToList(head_reference, right);\n} //Utility function that creates a doubly linked list\n//by inserting the current node at the end of the doubly\n//linked list by employing a tail pointer\nvoid push(Node** tail_reference, Node* n)\n{\n   // the tail pointer is to be initialized\n   if (*tail_reference == NULL)\n   {\n       *tail_reference = n;\n\n       // set left, middle and right child to point\n       // to NULL\n       n->left = NULL;\n       n->middle = NULL;\n       n->right = NULL;\n\n       return;\n   }\n\n   // using tail pointer, insert node in the end \n   (*tail_reference)->right = n;\n   // the middle and right child are set to point to NULL\n   n->right = NULL;\n   n->middle = NULL;\n\n   // set previous of the node\n   n->left = (*tail_reference);\n\n    \n   // now tail pointer is pointing to the inserted node\n   (*tail_reference) = n;\n}\n\n// From a ternary tree, create a doubly linked list,\n// by making a preorder traversal of the tree\nNode* ternaryTreeToList(Node** head_reference, Node* root)\n{\n   // Base case\n   if (!root)\n       return NULL;\n\n   //a static tail pointer to be created\n   static Node* tail = NULL;\n\n   // left, middle and right nodes to be stored\n   // for future calls.\n   Node* left = root->left;\n   Node* middle = root->middle;\n   Node* right = root->right;\n\n   // set the head of the doubly linked list\n   // as the root of the ternary tree\n   if (*head_reference == NULL)\n       *head_reference = root;\n\n   // push the current node in the end of the doubly linked list\n   push(&tail, root);\n\n   //recursion for left, middle and right child\n   ternaryTreeToList(head_reference, left);\n   ternaryTreeToList(head_reference, middle);\n   ternaryTreeToList(head_reference, right);\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "7. The task is to determine pairs in a doubly-linked list whose sum equals the provided value ‘val’ without consuming any extra space for a given sorted doubly-linked list of positive distinct entries. The expected complexities are O(n) time and O(1) space.",
        "answer": "The approach is as follows: Two pointer variables are to be initialized to find the possible elements in the sorted doubly linked list. Initialize num1 with the head of the doubly linked list,i.e., num1=head, and num2 with the last node of the doubly linked list, i.e., num2=lastNode.\nIf the current sum of num1 and num2 is less than Val, then we advance num1 in the forward direction. If the current total of the num1 and num2 is greater than x, then num2 is moved in the backward direction.\nWhen the two pointers cross each other (num2->next = num1) or they become equal (num1 == num2), the loop ends. The condition \"num1==num2\" will handle the circumstance where no such pairs are present. Two pointer variables are to be initialized to find the possible elements in the sorted doubly linked list. Initialize num1 with the head of the doubly linked list,i.e., num1=head, and num2 with the last node of the doubly linked list, i.e., num2=lastNode. If the current sum of num1 and num2 is less than Val, then we advance num1 in the forward direction. If the current total of the num1 and num2 is greater than x, then num2 is moved in the backward direction. When the two pointers cross each other (num2->next = num1) or they become equal (num1 == num2), the loop ends. The condition \"num1==num2\" will handle the circumstance where no such pairs are present. Implementation: Implementation: vector<pair<int,int>> sumPair(struct Node *head, int val)\n{\n   // Two pointers are to be set, one to the beginning\n   // and the other to the last of the DLL.\n   struct Node *num1 = head;\n   struct Node *num2 = head;\n   while (num2->next != NULL)  //to get to the last node\n       num2 = num2->next;\n   \n   vector<pair<int,int>> ans;\n   // The loop ends when two pointers\n   // cross each other or they are equal\n   while (num1 != num2 && num2->next != num1)\n   {\n       if ((num1->value + num2->value) == val)\n       {\n           ans.push_back(make_pair(num1->value,num2->value));\n           \n           // move num1 in the forward direction\n           num1 = num1->next;\n\n           // move num2 in the backward direction\n           num2 = num2->prev;\n       }\n       else\n       {\n           if ((num1->value + num2->value) > val)\n               num2 = num2->prev;\n           else\n               num1 = num1->next;\n       }\n   }\n\n  return ans;\n} vector<pair<int,int>> sumPair(struct Node *head, int val)\n{\n   // Two pointers are to be set, one to the beginning\n   // and the other to the last of the DLL.\n   struct Node *num1 = head;\n   struct Node *num2 = head;\n   while (num2->next != NULL)  //to get to the last node\n       num2 = num2->next;\n   \n   vector<pair<int,int>> ans;\n   // The loop ends when two pointers\n   // cross each other or they are equal\n   while (num1 != num2 && num2->next != num1)\n   {\n       if ((num1->value + num2->value) == val)\n       {\n           ans.push_back(make_pair(num1->value,num2->value));\n           \n           // move num1 in the forward direction\n           num1 = num1->next;\n\n           // move num2 in the backward direction\n           num2 = num2->prev;\n       }\n       else\n       {\n           if ((num1->value + num2->value) > val)\n               num2 = num2->prev;\n           else\n               num1 = num1->next;\n       }\n   }\n\n  return ans;\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "8. Given a 2-D matrix. You need to convert it into a linked list matrix such that each node is linked to its next right and down node and display it.",
        "answer": "  The idea is to create a new node for each element of the matrix and then create its next down and right nodes in a recursive manner. Implementation: Implementation: Node* construct(int A[][3], int m, int n, int i, int j)\n{\n   // check if i or j is out of bounds\n   if (i > n - 1 || j > m - 1)\n       return NULL;\n\n   // a new node for current i and j is created\n   // and its down and right pointers are\n   //recursively allocated\n   Node* t = new Node();\n   t->value = A[i][j];\n   t->right = construct(A, m, n, i, j + 1);\n   t->down  = construct(A, m, n, i + 1, j);\n   return t;\n}\n\n// function to display linked list data\nvoid printData(Node* head)\n{\n   // pointer to move down\n   Node* d;\n   // pointer to move down\n   \n   Node* r;\n\n   // loop till node->down is not NULL\n   for( d = head; d!=NULL; d = d->down)\n   {\n       for( r = d; r!=NULL; r = r->right)\n       {\n       // loop till node->right is not NULL\n           cout << r->value << \" \";\n           \n       }\n       cout << endl;\n      \n   }\n} Node* construct(int A[][3], int m, int n, int i, int j)\n{\n   // check if i or j is out of bounds\n   if (i > n - 1 || j > m - 1)\n       return NULL;\n\n   // a new node for current i and j is created\n   // and its down and right pointers are\n   //recursively allocated\n   Node* t = new Node();\n   t->value = A[i][j];\n   t->right = construct(A, m, n, i, j + 1);\n   t->down  = construct(A, m, n, i + 1, j);\n   return t;\n}\n\n// function to display linked list data\nvoid printData(Node* head)\n{\n   // pointer to move down\n   Node* d;\n   // pointer to move down\n   \n   Node* r;\n\n   // loop till node->down is not NULL\n   for( d = head; d!=NULL; d = d->down)\n   {\n       for( r = d; r!=NULL; r = r->right)\n       {\n       // loop till node->right is not NULL\n           cout << r->value << \" \";\n           \n       }\n       cout << endl;\n      \n   }\n} Time Complexity: O(m * n)\nSpace Complexity: O(1), ignoring the space required for the final answer. ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "9. Extract all leaves from a Binary Tree into a Doubly Linked List (DLL).",
        "answer": "It's worth noting that the DLL must be created in place. Assume that the DLL and Binary Tree node structures are identical, with the exception that the meanings of the left and right pointers. Left denotes the previous pointer, whereas right denotes the next pointer in DLL.   All of the leaves must be traversed and connected by adjusting the left and right pointers. By adjusting the left or right pointers in parent nodes, we can also delete them from the Binary Tree. There are numerous options for resolving this issue. We add leaves to the beginning of the current linked list and update the list's head using the pointer to head pointer in the following code. We must process leaves in reverse order because we insert from the beginning. We traverse the right subtree first, then the left subtree, in reverse order. To update the left and right pointers in parent nodes, we employ return values. Implementation: Implementation: // The function extracts all the\n// leaves from a given Binary Tree.\n// The function returns new root of\n// the Binary Tree. The function also sets\n// *head_reference as the head of the DLL.\n// The left pointer of the tree is used as prev \n// and the right pointer is used as next in the DLL.\nNode* extractLeaf(Node **head_reference, Node *root)\n{\n  if (!root) \n      return NULL;\n\n  if (root->right == NULL && root->left == NULL)\n  {\n      // This node will be added to the doubly linked \n      // list of leaves. We will have to\n      // set the right pointer of this node\n      // as the previous head of DLL. We\n      // don't need to set the left pointer \n      // as the left is already NULL.\n      root->right = *head_reference;\n\n      // Change the left pointer of previous head\n      if (*head_reference) \n         (*head_reference)->left = root;\n\n      // Change the head of the linked list\n      *head_reference = root;\n\n      return NULL;\n  }\n\n  // Recursion for right and left subtrees\n  root->right = extractLeaf(&head_reference, root->right);\n  root->left = extractLeaf(&head_reference, root->lef);\n\n  return root;\n} // The function extracts all the\n// leaves from a given Binary Tree.\n// The function returns new root of\n// the Binary Tree. The function also sets\n// *head_reference as the head of the DLL.\n// The left pointer of the tree is used as prev \n// and the right pointer is used as next in the DLL.\nNode* extractLeaf(Node **head_reference, Node *root)\n{\n  if (!root) \n      return NULL;\n\n  if (root->right == NULL && root->left == NULL)\n  {\n      // This node will be added to the doubly linked \n      // list of leaves. We will have to\n      // set the right pointer of this node\n      // as the previous head of DLL. We\n      // don't need to set the left pointer \n      // as the left is already NULL.\n      root->right = *head_reference;\n\n      // Change the left pointer of previous head\n      if (*head_reference) \n         (*head_reference)->left = root;\n\n      // Change the head of the linked list\n      *head_reference = root;\n\n      return NULL;\n  }\n\n  // Recursion for right and left subtrees\n  root->right = extractLeaf(&head_reference, root->right);\n  root->left = extractLeaf(&head_reference, root->lef);\n\n  return root;\n} Time Complexity: O(n)\nSpace Complexity: O(1), ignoring the recursion stack space ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "10. Write a program to delete all odd positioned nodes from a circular linked list. (Consider 1-based indexing).",
        "answer": "  The approach is to begin traversing the circular linked list by keeping track of the current node's position using a count variable. Delete the current node if it is at an odd position. Implementation: Implementation: // l is the length of the linked list\nvoid DeleteAllOddNodes(struct Node** head_reference, int l)\n{\n   int cnt = 0;\n   struct Node *prev = *head_reference, *next = *head_reference;\n\n   // check if the list is empty\n   if (*head_reference == NULL) \n   {\n       cout<<\"List is empty\"<<endl;\n       return;\n   }\n\n   // check if there is a single node in the list\n   if (l == 1) \n   {\n       // Function to delete first node\n       *head_reference=NULL;\n       return;\n   }\n\n   while (l > 0) \n   {\n       // delete first position node as it is odd\n       if (cnt == 0) \n       {\n           struct Node *t1 = *head_reference, *t2 = *head_reference;\n           if (t1->next == t1) \n           {\n              *head_reference = NULL;\n           }\n           while(t1->next!=*head_reference)\n           {\n              t1 = t1->next;\n              t2 = t1->next;\n           }\n           t1->next = t2->next;\n           *head_reference = t1->next;\n           free(t2);\n       }\n\n       // if the position is odd, delete that node\n       if (cnt % 2 == 0 && cnt != 0) \n       {\n           struct Node* tmp = head_reference;\n           if (head_reference == prev) \n           {\n               head_reference = prev->next;\n           }\n           while (tmp->next != prev) \n           {\n               tmp = tmp->next;\n           }\n           tmp->next = prev->next;\n           free(prev);\n       }\n\n       prev = prev->next;\n       next = prev->next;\n       \n       cnt++;\n       l--;       \n   }\nturn;\n   re} // l is the length of the linked list\nvoid DeleteAllOddNodes(struct Node** head_reference, int l)\n{\n   int cnt = 0;\n   struct Node *prev = *head_reference, *next = *head_reference;\n\n   // check if the list is empty\n   if (*head_reference == NULL) \n   {\n       cout<<\"List is empty\"<<endl;\n       return;\n   }\n\n   // check if there is a single node in the list\n   if (l == 1) \n   {\n       // Function to delete first node\n       *head_reference=NULL;\n       return;\n   }\n\n   while (l > 0) \n   {\n       // delete first position node as it is odd\n       if (cnt == 0) \n       {\n           struct Node *t1 = *head_reference, *t2 = *head_reference;\n           if (t1->next == t1) \n           {\n              *head_reference = NULL;\n           }\n           while(t1->next!=*head_reference)\n           {\n              t1 = t1->next;\n              t2 = t1->next;\n           }\n           t1->next = t2->next;\n           *head_reference = t1->next;\n           free(t2);\n       }\n\n       // if the position is odd, delete that node\n       if (cnt % 2 == 0 && cnt != 0) \n       {\n           struct Node* tmp = head_reference;\n           if (head_reference == prev) \n           {\n               head_reference = prev->next;\n           }\n           while (tmp->next != prev) \n           {\n               tmp = tmp->next;\n           }\n           tmp->next = prev->next;\n           free(prev);\n       }\n\n       prev = prev->next;\n       next = prev->next;\n       \n       cnt++;\n       l--;       \n   }\nturn;\n   re} Time Complexity: O(n^2)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "11. Why is merge sort a better option than quicksort for linked lists?",
        "answer": "When it comes to linked lists, there are a few things to keep in mind. The issue is unique due to the memory allocation differences between arrays and linked lists. Unlike arrays, linked list nodes in memory may not be adjacent.\nWe can insert items in the middle of a linked list in O(1) extra space and O(1) time if we are given a reference/pointer to the previous node, unlike an array. As a result, the merge sort operation can be accomplished without the need for additional linked list space.\nWe can do random access in arrays since the elements are continuous in memory. In contrast to arrays, we can't access a linked list at random.\nQuick Sort necessitates a great deal of this type of access. Because we don't have a continuous block of memory, we have to travel from the head to the i'th node to get to the i'th index in a linked list. Merge sort accesses data in a sequential manner, with less requirement for random access. When it comes to linked lists, there are a few things to keep in mind. The issue is unique due to the memory allocation differences between arrays and linked lists. Unlike arrays, linked list nodes in memory may not be adjacent. We can insert items in the middle of a linked list in O(1) extra space and O(1) time if we are given a reference/pointer to the previous node, unlike an array. As a result, the merge sort operation can be accomplished without the need for additional linked list space. We can do random access in arrays since the elements are continuous in memory. In contrast to arrays, we can't access a linked list at random. Quick Sort necessitates a great deal of this type of access. Because we don't have a continuous block of memory, we have to travel from the head to the i'th node to get to the i'th index in a linked list. Merge sort accesses data in a sequential manner, with less requirement for random access.",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "12. What algorithm will you implement to find similar elements from two Linked Lists given and return the result in the form of a Linked List? Assume there are no duplicates.",
        "answer": "Create an empty hash table and set the result list to NULL. While traversing List1, insert the element in the hash table for each element visited in List1. While traversing List2, look for the entries in the hash table for each element visited in List2. If the element is already existing, add it to the result list. If the element isn't present, it is to be ignored. The overall time and space complexity are linear. Node* getIntersection(Node* head1, Node* head2)\n{\n       unordered_map < int > m;\n       Node* n1 = head1;\n       Node* n2 = head2;\n       Node* head = NULL;\n\n       // loop stores all the elements of list1 in hset\n       while (n1) \n       {\n           m[n1->value] = 1;\n           n1 = n1->next;\n       }\n\n       // For every element of list2 present in hset\n       // loop inserts the element into the result\n       while (n2 != null) \n       {\n           if (m[n2->value] == 1)\n           {\n               Node* temp = new Node();\n               temp->value = n2->value;\n               temp->next = head;\n               head = temp;\n           }\n           n2 = n2->next;\n       }\n       return head;\n} Node* getIntersection(Node* head1, Node* head2)\n{\n       unordered_map < int > m;\n       Node* n1 = head1;\n       Node* n2 = head2;\n       Node* head = NULL;\n\n       // loop stores all the elements of list1 in hset\n       while (n1) \n       {\n           m[n1->value] = 1;\n           n1 = n1->next;\n       }\n\n       // For every element of list2 present in hset\n       // loop inserts the element into the result\n       while (n2 != null) \n       {\n           if (m[n2->value] == 1)\n           {\n               Node* temp = new Node();\n               temp->value = n2->value;\n               temp->next = head;\n               head = temp;\n           }\n           n2 = n2->next;\n       }\n       return head;\n}",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "13. How will you remove a cycle from a linked list?",
        "answer": "One method of identifying the cycle is Floyd's cycle detect technique, popularly known as the tortoise and hare algorithm since it uses two pointers/references that move at opposite speeds. If there is a cycle, after a limited number of steps, the two pointers (say, slow and fast) will point to the same element. It's interesting to note that the element where they meet will be the same distance from the loop's start (continuing to traverse the list in the same, forward direction) as the loop's start is from the list's head. That is, if the linear component of the list contains k elements, the two pointers will meet inside a loop of length m at a location m-k from the loop's start or k elements from the loop's 'end' (of course, it's a loop, so there is no 'end' - it's just the ‘start' again). That gives us a technique to find the loop's beginning. Once a cycle has been detected, keep fast pointing to the element where the loop for the previous step ended, but reset slow to point back to the beginning of the list. Now, one element at a time, move each pointer. Fast will keep looping because it started inside the loop. Slow and fast will meet again after k steps (equivalent to the distance between the start of the loop and the head of the list). This will serve as a pointer to the beginning of the loop. It's now simple to set slow (or fast) to point to the loop's starting element and traverse the loop until slow returns to the starting element. Slow is referring to the 'last' element list at this point, and its next pointer can be adjusted to null. Implementation: Implementation: Node* getLastNode(Node* head) \n{\n   Node* slow = head;\n   Node* fast = head;\n   // find the intersection point using Tortoise and Hare algorithm\n   while (fast->next != NULL) \n   { \n       slow = slow->next; \n       fast = fast->next->next; \n       if (slow == fast) \n           break; \n   }\n   //check if there is no loop\n   if (fast->next == NULL) \n   {\n       return NULL;\n   }\n   slow = head; \n   // run this loop till both the references are one short of the start of the loop\n   while (slow->next != fast->next) \n   { \n       slow = slow->next; \n       fast = fast->next; \n   }\n   // Now the fast pointer is pointing to the start of the loop \n   return fast;\n}\nNode* getLastNode = findStartOfLoop(head);\ngetLastNode->next = null; Node* getLastNode(Node* head) \n{\n   Node* slow = head;\n   Node* fast = head;\n   // find the intersection point using Tortoise and Hare algorithm\n   while (fast->next != NULL) \n   { \n       slow = slow->next; \n       fast = fast->next->next; \n       if (slow == fast) \n           break; \n   }\n   //check if there is no loop\n   if (fast->next == NULL) \n   {\n       return NULL;\n   }\n   slow = head; \n   // run this loop till both the references are one short of the start of the loop\n   while (slow->next != fast->next) \n   { \n       slow = slow->next; \n       fast = fast->next; \n   }\n   // Now the fast pointer is pointing to the start of the loop \n   return fast;\n}\nNode* getLastNode = findStartOfLoop(head);\ngetLastNode->next = null; Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "14. How will you convert a binary tree into a doubly-linked list?",
        "answer": "In a converted doubly linked list, the left and right pointers in nodes of a binary tree will be used as previous and next pointers, respectively. The nodes in the doubly linked list must be in the same order as the provided Binary Tree's Inorder. The head node of the doubly linked list must be the first node of Inorder traversal (leftmost node in the binary tree).   void btToDLL(Node *root, Node **head_reference, Node **previous)\n{\n   if (!root) \n      return;\n\n   // Recursive conversion of left subtree\n   btToDLL(root->left, head_reference, previous);\n\n   if (*head_reference == NULL)\n       *head_reference = root;\n   else\n   {\n       root->left = *previous;\n       *previous->right = root;\n   }\n   *previous = root;\n\n   // Recursive conversion of right subtree\n   btToDLL(root->right, head_reference, previous);\n} void btToDLL(Node *root, Node **head_reference, Node **previous)\n{\n   if (!root) \n      return;\n\n   // Recursive conversion of left subtree\n   btToDLL(root->left, head_reference, previous);\n\n   if (*head_reference == NULL)\n       *head_reference = root;\n   else\n   {\n       root->left = *previous;\n       *previous->right = root;\n   }\n   *previous = root;\n\n   // Recursive conversion of right subtree\n   btToDLL(root->right, head_reference, previous);\n} Time Complexity: O(n)\nAuxiliary Space: O(1) Time Complexity: O(n) Auxiliary Space: O(1)",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "1. Given a linked list with each node representing a linked list and two pointers of its type given below. You need to flatten the lists into a single linked list. The flattened linked list also needs to be sorted. Discuss the approach.",
        "answer": "Pointer to the next node in the main list (the \"right\" pointer).\nPointer to a linked list, this node being the head (the 'down' pointer). Pointer to the next node in the main list (the \"right\" pointer). Pointer to the next node in the main list (the \"right\" pointer). Pointer to a linked list, this node being the head (the 'down' pointer). Pointer to a linked list, this node being the head (the 'down' pointer).   The approach is to use the merge() procedure of merge sort for linked lists. To merge lists one by one, we use merge(). We merge() the current list with the flattened list recursively.\nThe flattened list's nodes are linked via the down pointer.  Another approach is to use heaps. It is important to notice that there are N nodes connecting in a downward manner from each top node, but those downward nodes are in sorted order. As a result, the objective is to sort everything in ascending order (or decreasing order). Push all the heads of the linked lists in the priority queue's downward list.\nPop the node with the smallest priority from the priority queue.\nCheck the node's location so that the next node which is being pointed by the current node can be inserted into the priority queue.\nPop the smallest element once more and push the next node pointed by the current node until the heap is empty.\nContinue to add node data to a new linked list that is popped out to the new list.\nPrint the above-mentioned linked list. Push all the heads of the linked lists in the priority queue's downward list. Pop the node with the smallest priority from the priority queue. Check the node's location so that the next node which is being pointed by the current node can be inserted into the priority queue. Pop the smallest element once more and push the next node pointed by the current node until the heap is empty. Continue to add node data to a new linked list that is popped out to the new list. Print the above-mentioned linked list. struct cmp {\n   bool operator()(Node* x, Node* y)\n   {\n       return x->value > y->value;\n   }\n};\n\n//the following function returns the flattened linked list’s root\nNode* flattenList(Node* root)\n{\n   Node* p = root;\n   Node* head = NULL;\n\n   // this min heap returns the current smallest element in the heap\n   priority_queue < Node*, vector <Node*>, cmp > pqueue;\n\n   // the head nodes of every\n   // downward linked list is pushed into the heap\n   while (p) \n   {\n       pqueue.push(p);\n       p = p->right;\n   }\n\n   while (!pqueue.empty()) \n   { \n       // pop out the topmost node\n       Node* t = pqueue.top();\n       pqueue.pop();\n\n       if (t->down) \n       {\n           pqueue.push(t->down);\n       }\n\n       // Create the required linked list\n       if (head != NULL) \n           p->down = t;\n       else \n           head = t;\n           \n       p = t;\n       p->right = NULL;\n       \n   }\n\n   // Pointer to head node\n   return head;\n}\nvoid printList(Node* head)\n{\n   while (head != NULL) \n   {\n       cout << head->value << ” “ << endl;\n       head = head->down;\n   }\n} struct cmp {\n   bool operator()(Node* x, Node* y)\n   {\n       return x->value > y->value;\n   }\n};\n\n//the following function returns the flattened linked list’s root\nNode* flattenList(Node* root)\n{\n   Node* p = root;\n   Node* head = NULL;\n\n   // this min heap returns the current smallest element in the heap\n   priority_queue < Node*, vector <Node*>, cmp > pqueue;\n\n   // the head nodes of every\n   // downward linked list is pushed into the heap\n   while (p) \n   {\n       pqueue.push(p);\n       p = p->right;\n   }\n\n   while (!pqueue.empty()) \n   { \n       // pop out the topmost node\n       Node* t = pqueue.top();\n       pqueue.pop();\n\n       if (t->down) \n       {\n           pqueue.push(t->down);\n       }\n\n       // Create the required linked list\n       if (head != NULL) \n           p->down = t;\n       else \n           head = t;\n           \n       p = t;\n       p->right = NULL;\n       \n   }\n\n   // Pointer to head node\n   return head;\n}\nvoid printList(Node* head)\n{\n   while (head != NULL) \n   {\n       cout << head->value << ” “ << endl;\n       head = head->down;\n   }\n} Time Complexity : O(nlogn)\nSpace Complexity : O(n)  Conclusion: We hope that this article has helped you learn the fundamentals and advanced questions of linked lists. These questions cover the most important concepts related to linked lists which will help you in both interview and understanding this data structure in depth. Useful Resources Linked List MCQ\nApplication of Linked List\nTypes of Linked List Linked List MCQ Linked List MCQ Application of Linked List Application of Linked List Types of Linked List Types of Linked List ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "2. In a standard Doubly Linked List, two address fields are required to contain the addresses of previous and next nodes. Can you create a doubly linked list using only one space for the address field with every node?",
        "answer": "Yes, there is a memory-saving version of the Doubly Linked List that uses only one space for the address field in each node. Because the list uses the bitwise XOR operation to save space for one address, it is known as the XOR Linked List or Memory Efficient. Instead of storing actual memory addresses, each node in the XOR linked list stores the XOR of previous and next node addresses. In the XOR representation, let's call the address variable npx (XOR of next and previous). We can traverse the XOR Linked List in both forward and reverse directions while traversing it. We must remember the address of the previously visited node when traversing the list in order to determine the address of the next node. Node W: \nnpx = 0 XOR add(X)  Node X: \nnpx = add(W) XOR add(Y)  Node Y: \nnpx = add(X) XOR add(Z)  Node Z: \nnpx = add(Y) XOR 0  Calculation: Calculation: npx(Y) XOR add(X) \n=> (add(X) XOR add(Z)) XOR add(X)              // npx(Y) = add(X) XOR add(Z)\n=> add(X) XOR add(Z) XOR add(X)                // w^x = w^x and (w^x)^y = w^(x^y)\n=> add(Z) XOR 0                                             // x^x = 0\n=> add(Z)                                                         // x^0 = x    ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "3. Given a singly linked list with an additional \"arbitrary\" pointer at each node that currently points to NULL. What algorithm will you implement to make the \"arbitrary\" pointer point to the next node with a greater value?",
        "answer": "  A simple solution is to go through all nodes one by one, finding the node with the next bigger value than the current node and changing the next pointer for each node. This solution has an O time complexity (n^2). An Efficient Solution takes O(nLogn) time to complete. The approach is to use Merge Sort for linked lists. Traverse input list and for each node, copy the next pointer to arbit pointer.\nSort the linked list formed by arbit pointers using Merge Sort. Traverse input list and for each node, copy the next pointer to arbit pointer. Sort the linked list formed by arbit pointers using Merge Sort. Here, all of the merge sort methods are altered to work with arbit pointers rather than the next pointers.",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "4. Given a linked list, find the length of the longest palindrome list that appears in that linked list using O(1) extra space.",
        "answer": "The concept is built on reversing a linked list iteratively. We loop through the given linked list, reversing each prefix of the linked list one by one from the left. We discover the longest common list beginning with the reversed prefix and the list after the reversed prefix, after reversing a prefix. Time complexity is O(n^2). Implementation: Implementation: int calcCommon(Node *x, Node *y)\n{\n   int cnt = 0;\n\n   // count common in the list starting\n   // from node x and y\n  while (1)\n  {\n       // increase the count by one for same values\n       if (x->value == y->value)\n           cnt++;\n       else\n           break;\n       x = x->next;\n       y = y->next;\n  }\n  return cnt;\n}\n\n// Returns length of the longest palindrome sublist\nint maxPalindrome(Node *head)\n{\n   Node *previous = NULL, *current = head;\n   int answer = 0;\n   // loop running till the end of the linked list\n   while (1)\n   {\n       if(current==NULL)\n          break;\n       // reversed sublist from head to current\n       Node *next = current->next;\n       current->next = previous;\n\n       // check for odd length palindrome\n       answer = max(result, 2*calcCommon(previous, next)+1);\n\n       // check for even length palindrome\n       answer = max(result, 2*calcCommon(current, next));\n\n       // update previous and current for next iteration\n       previous = current;\n       current = next;\n   }\n   return answer;\n} int calcCommon(Node *x, Node *y)\n{\n   int cnt = 0;\n\n   // count common in the list starting\n   // from node x and y\n  while (1)\n  {\n       // increase the count by one for same values\n       if (x->value == y->value)\n           cnt++;\n       else\n           break;\n       x = x->next;\n       y = y->next;\n  }\n  return cnt;\n}\n\n// Returns length of the longest palindrome sublist\nint maxPalindrome(Node *head)\n{\n   Node *previous = NULL, *current = head;\n   int answer = 0;\n   // loop running till the end of the linked list\n   while (1)\n   {\n       if(current==NULL)\n          break;\n       // reversed sublist from head to current\n       Node *next = current->next;\n       current->next = previous;\n\n       // check for odd length palindrome\n       answer = max(result, 2*calcCommon(previous, next)+1);\n\n       // check for even length palindrome\n       answer = max(result, 2*calcCommon(current, next));\n\n       // update previous and current for next iteration\n       previous = current;\n       current = next;\n   }\n   return answer;\n}",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "5. Given a value x and a sorted doubly linked list of different nodes (no two nodes have the same data). Count the number of triplets in the list that add up to x. The expected time complexity is O(n^2) and the expected space complexity is O(1).",
        "answer": "Following the approach os using two pointers: From left to right, traverse the doubly linked list. Initialize two pointers for each current node during the traversal: first = pointer to the node next to the current node, and last = pointer to the list's last node. Count the number of pairs in the list that add up to the value (x – the current node's data) from the first to the last pointer (algorithm described in Q8). This number should be added to the total count of triplets. Pointer to the last node can be retrieved only once at the beginning. Implementation: Implementation: int pairCount(struct Node* num1, struct Node* num2, int val)\n{\n   int cnt = 0;\n   // The loop terminates when either of two the pointers\n   // become NULL, or they cross each other or they become equal\n   while (num1 != NULL && num2 != NULL &&\n          num1 != num2 && num2->next != num1) \n   {\n\n       // pair found\n       if ((num1->value + num2->value) == val) \n       {\n\n           cnt++;\n\n           // second is moved in backward direction\n           num2 = num2->prev;\n           // first is moved in forward direction\n           num1 = num1->next;\n       }\n       // else first is moved in forward direction\n       else if ((num1->value + num2->value) < val)\n           num1 = num1->next;\n   \n       // if sum is greater than 'value'\n       // second is moved in backward direction\n       else\n           num2 = num2->prev;\n     }\n\n   // required number of pairs\n   return cnt;\n}\n\n// function to count triplets in a sorted DLL\n// whose sum equals a given value 'x'\nint tripletCount(struct Node* head, int x)\n{\n   // check if the list is empty\n   if (!head)\n       return 0;\n   int cnt = 0;\n   struct Node* current = head;\n   struct Node* last = head;\n   struct Node* first;\n   // get pointer to the last node of the doubly linked list\n   \n   while (last->next)\n       last = last->next;\n\n   // traverse the doubly linked list\n   \n   while (current) \n   { \n       // for every current node\n       first = current->next;\n\n       // count the number of pairs with sum(x - current->data) in the range\n       // first to last and add it to the 'cnt' of triplets\n       cnt += pairCount(first, last, x - current->value);\n       current = current->next;\n   }\n\n   // required number of triplets\n   return cnt;\n} int pairCount(struct Node* num1, struct Node* num2, int val)\n{\n   int cnt = 0;\n   // The loop terminates when either of two the pointers\n   // become NULL, or they cross each other or they become equal\n   while (num1 != NULL && num2 != NULL &&\n          num1 != num2 && num2->next != num1) \n   {\n\n       // pair found\n       if ((num1->value + num2->value) == val) \n       {\n\n           cnt++;\n\n           // second is moved in backward direction\n           num2 = num2->prev;\n           // first is moved in forward direction\n           num1 = num1->next;\n       }\n       // else first is moved in forward direction\n       else if ((num1->value + num2->value) < val)\n           num1 = num1->next;\n   \n       // if sum is greater than 'value'\n       // second is moved in backward direction\n       else\n           num2 = num2->prev;\n     }\n\n   // required number of pairs\n   return cnt;\n}\n\n// function to count triplets in a sorted DLL\n// whose sum equals a given value 'x'\nint tripletCount(struct Node* head, int x)\n{\n   // check if the list is empty\n   if (!head)\n       return 0;\n   int cnt = 0;\n   struct Node* current = head;\n   struct Node* last = head;\n   struct Node* first;\n   // get pointer to the last node of the doubly linked list\n   \n   while (last->next)\n       last = last->next;\n\n   // traverse the doubly linked list\n   \n   while (current) \n   { \n       // for every current node\n       first = current->next;\n\n       // count the number of pairs with sum(x - current->data) in the range\n       // first to last and add it to the 'cnt' of triplets\n       cnt += pairCount(first, last, x - current->value);\n       current = current->next;\n   }\n\n   // required number of triplets\n   return cnt;\n}",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "6. Let's say there are two lists of varying lengths that merge at a certain point; how do we know where the merging point is?",
        "answer": "  You begin with List 1 and assume that the NULL at the end is a pointer to the start of List 2, giving the illusion of a cyclic list. After that, the algorithm will inform you how far down List 1 the merging is. Make an iterator pointer that runs forward until it reaches the end of the list, then jumps to the start of the opposite list, and so on.\nMake two of them, each pointing to two different heads.\nEach time you advance the pointers by one, they will eventually meet in the intersection point (IP). After one or two passes, this will occur. Make an iterator pointer that runs forward until it reaches the end of the list, then jumps to the start of the opposite list, and so on. Make two of them, each pointing to two different heads. Each time you advance the pointers by one, they will eventually meet in the intersection point (IP). After one or two passes, this will occur. Count the number of nodes traversed from head1-> tail1-> head2 -> intersection point and head2-> tail2-> head1 -> intersection point to have a better understanding. Both will be equal (Draw diff types of linked lists to verify this). The reason for this is that both pointers must traverse identical distances (head1->IP + head2->IP) before returning to IP. As a result, by the time it reaches IP, both pointers will be equal, and we will have arrived at the merging point. Node* getIP(Node* head1, Node* head2)\n{\n   // two pointers ptr1 and ptr2\n   // at the heads of the two lists\n   Node* p1 = head1;\n   Node* p2 = head2;\n\n   if (p1 == NULL || p2 == NULL)\n      return NULL;\n    \n   // the two lists are to be traversed until we reach the IP \n   while (p1 != p2) \n   { \n       p1 = p1->next;\n       p2 = p2->next;\n       \n       // When p1 reaches the end of the list, it is\n       // redirected to head2.\n       if (p1 == NULL)  \n           p1 = head2;\n       \n       // When p2 reaches the end of the list, it is\n       // redirected to head1.\n       if (p2 == NULL)\n           p2 = head1;\n       \n       // If at any node p1 meets p2, we have got our IP.\n       if (p1 == p2) \n           return p2;\n       \n   }\n\n   return p2;\n} Node* getIP(Node* head1, Node* head2)\n{\n   // two pointers ptr1 and ptr2\n   // at the heads of the two lists\n   Node* p1 = head1;\n   Node* p2 = head2;\n\n   if (p1 == NULL || p2 == NULL)\n      return NULL;\n    \n   // the two lists are to be traversed until we reach the IP \n   while (p1 != p2) \n   { \n       p1 = p1->next;\n       p2 = p2->next;\n       \n       // When p1 reaches the end of the list, it is\n       // redirected to head2.\n       if (p1 == NULL)  \n           p1 = head2;\n       \n       // When p2 reaches the end of the list, it is\n       // redirected to head1.\n       if (p2 == NULL)\n           p2 = head1;\n       \n       // If at any node p1 meets p2, we have got our IP.\n       if (p1 == p2) \n           return p2;\n       \n   }\n\n   return p2;\n} OR Make a circular linked list by traversing the first linked list (counting the elements). (Keep track of the last node so we can break the circle later.)\nReframe the issue as locating the loop in the second linked list.\nWe already know the length of the loop which is equal to the length of the first linked list. We have to traverse those many numbers of nodes in the second list first, and then another pointer should be started from the beginning of the second list. We have to continue traversing until they meet, and that is the required intersection point.\nThe circle should be removed from the linked list. Make a circular linked list by traversing the first linked list (counting the elements). (Keep track of the last node so we can break the circle later.) Reframe the issue as locating the loop in the second linked list. We already know the length of the loop which is equal to the length of the first linked list. We have to traverse those many numbers of nodes in the second list first, and then another pointer should be started from the beginning of the second list. We have to continue traversing until they meet, and that is the required intersection point. The circle should be removed from the linked list. Both the approaches have O(n+m) time and O(1) space complexity.",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "7. Given two polynomial expressions represented by linked lists. You need to write a function that adds these lists, that is, adds the coefficients that have the same variable powers.",
        "answer": "  Implementation: Implementation: struct Node \n{\n   int coefficient;\n   int power;\n   struct Node* next;\n};\n\nvoid createNode(int x, int y, struct Node** t)\n{\n   struct Node *v, *z;\n   z = *t;\n   if (z == NULL) \n   {\n       v = new Node;\n       v->coefficient = x;\n       v->power = y;\n       *t = v;\n       v->next = new Node;\n       v = v->next;\n       v->next = NULL;\n   }\n   else \n   {\n       v->coefficient = x;\n       v->power = y;\n       v->next = new Node;\n       v = v->next;\n       v->next = NULL;\n   }\n}\n\n// Function to add two polynomial expressions\nvoid polyAdd(struct Node* poly1, struct Node* poly2,\n            struct Node* poly)\n{\n   while (poly1->next && poly2->next) \n   {\n       // If the power of the 1st polynomial is greater than that of 2nd,\n       // then store 1st as it is and move its pointer\n       if (poly2->power < poly1->power) \n       {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient;\n           poly1 = poly1->next;\n       }\n\n       // If the power of the 2nd polynomial is greater than that of 1st,\n       // then store 2nd as it is and move its pointer\n       else if (poly1->power < poly2->power) \n       {\n           poly->power = poly2->power;\n           poly->coefficient = poly2->coefficient;\n           poly2 = poly2->next;\n       }\n\n       // If power of both polynomial expressions is same then\n       // add their coefficients\n       else \n       {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient + poly2->coefficient;\n           poly1 = poly1->next;\n           poly2 = poly2->next;\n       }\n\n       poly->next = new Node;\n       poly = poly->next;\n       poly->next = NULL;\n   }\n   while (poly1->next || poly2->next) \n   {\n       if (poly1->next) {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient;\n           poly1 = poly1->next;\n       }\n       if (poly2->next) \n       {\n           poly->power = poly2->power;\n           poly->coefficient = poly2->coefficient;\n           poly2 = poly2->next;\n       }\n       poly->next = new Node;\n       poly = poly->next;\n       poly->next = NULL;\n   }\n} struct Node \n{\n   int coefficient;\n   int power;\n   struct Node* next;\n};\n\nvoid createNode(int x, int y, struct Node** t)\n{\n   struct Node *v, *z;\n   z = *t;\n   if (z == NULL) \n   {\n       v = new Node;\n       v->coefficient = x;\n       v->power = y;\n       *t = v;\n       v->next = new Node;\n       v = v->next;\n       v->next = NULL;\n   }\n   else \n   {\n       v->coefficient = x;\n       v->power = y;\n       v->next = new Node;\n       v = v->next;\n       v->next = NULL;\n   }\n}\n\n// Function to add two polynomial expressions\nvoid polyAdd(struct Node* poly1, struct Node* poly2,\n            struct Node* poly)\n{\n   while (poly1->next && poly2->next) \n   {\n       // If the power of the 1st polynomial is greater than that of 2nd,\n       // then store 1st as it is and move its pointer\n       if (poly2->power < poly1->power) \n       {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient;\n           poly1 = poly1->next;\n       }\n\n       // If the power of the 2nd polynomial is greater than that of 1st,\n       // then store 2nd as it is and move its pointer\n       else if (poly1->power < poly2->power) \n       {\n           poly->power = poly2->power;\n           poly->coefficient = poly2->coefficient;\n           poly2 = poly2->next;\n       }\n\n       // If power of both polynomial expressions is same then\n       // add their coefficients\n       else \n       {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient + poly2->coefficient;\n           poly1 = poly1->next;\n           poly2 = poly2->next;\n       }\n\n       poly->next = new Node;\n       poly = poly->next;\n       poly->next = NULL;\n   }\n   while (poly1->next || poly2->next) \n   {\n       if (poly1->next) {\n           poly->power = poly1->power;\n           poly->coefficient = poly1->coefficient;\n           poly1 = poly1->next;\n       }\n       if (poly2->next) \n       {\n           poly->power = poly2->power;\n           poly->coefficient = poly2->coefficient;\n           poly2 = poly2->next;\n       }\n       poly->next = new Node;\n       poly = poly->next;\n       poly->next = NULL;\n   }\n} Time Complexity: O(m + n), where m and n are the respective numbers of nodes in the first and second lists.",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "8. How will you find the length of a linked list which contains a cycle?",
        "answer": "The algorithm to determine the length of the list: At a time, pointer A advances one node while pointer B advances two nodes.\nStarting from the head, they move until B reaches null (no loop) or A and B refer to the same node.\nNow, if A simply advances, A will run into B again. The length of the loop, let's call it x, may be calculated from this.\nBegin again from the head, but this time have a pointer C which has moved x nodes, followed by a pointer D behind it. Both will move one node further at a time.\nWhen they meet, the length of the linked list with a loop is equal to the number of nodes traversed by D plus x. At a time, pointer A advances one node while pointer B advances two nodes. Starting from the head, they move until B reaches null (no loop) or A and B refer to the same node. Now, if A simply advances, A will run into B again. The length of the loop, let's call it x, may be calculated from this. Begin again from the head, but this time have a pointer C which has moved x nodes, followed by a pointer D behind it. Both will move one node further at a time. When they meet, the length of the linked list with a loop is equal to the number of nodes traversed by D plus x. int calcLen( Node* head )\n{\n  struct Node *A = head, *B = head;\n\n   while ( A && B && B->next )\n   {\n       A = A->next;\n       B = B->next->next;\n\n       /* If slow_p and fast_p meet at\n       some point then there is a loop */\n       if (A == B)\n       {\n          int x = 1;\n          struct Node *t = A;\n          while (t->next != A)\n          {\n              x++;\n              t = t->next;\n          }\n       }\n   }\n  \n   struct Node *C = head, *D = head;\n   int y = 0;\n   for ( int i = 0; i < x; i++ )\n   {\n      C = C->next;\n   }\n   while( C != D )\n   {\n      y++;\n      C = C->next;\n      D = D->next;\n   }\n \n   return x+y;\n} int calcLen( Node* head )\n{\n  struct Node *A = head, *B = head;\n\n   while ( A && B && B->next )\n   {\n       A = A->next;\n       B = B->next->next;\n\n       /* If slow_p and fast_p meet at\n       some point then there is a loop */\n       if (A == B)\n       {\n          int x = 1;\n          struct Node *t = A;\n          while (t->next != A)\n          {\n              x++;\n              t = t->next;\n          }\n       }\n   }\n  \n   struct Node *C = head, *D = head;\n   int y = 0;\n   for ( int i = 0; i < x; i++ )\n   {\n      C = C->next;\n   }\n   while( C != D )\n   {\n      y++;\n      C = C->next;\n      D = D->next;\n   }\n \n   return x+y;\n} Time Complexity: O(n)\nSpace Complexity: O(1) ",
        "reference": "interviewbit.com",
        "role": "linked-list"
    },
    {
        "question": "",
        "answer": "A linked list may be defined as a linear data structure which can store a collection of items. In another way, the linked list can be utilized to store various objects of similar types. Each element or unit of the list is indicated as a node. Each node contains its data and the address of the next node. It is similar to a chain. Linked lists are used to create graphs and trees.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "2) How will you represent a linked list in a graphical view?",
        "answer": "A linked list may be defined as a data structure in which each element is a separate object. Linked list elements are not kept at the contiguous location. The pointers are used to link the elements of the Linked List.\nEach node available in a list is made up of two items- the data itself and a reference (also known as a link) to the next node in the sequence. The last node includes a reference to null. The starting point into a linked list is known as the head of the list. It should be noted that the head is a reference to the first node, not a separate node. The head is considered as a null reference if the list is empty.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "3) How many types of Linked List exist?",
        "answer": "There are multiple types of Linked Lists available:\nADVERTISEMENT\nSingly Linked List\nDoubly Linked List\nMultiply Linked List\nCircular Linked List",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "",
        "answer": "The singly linked list includes nodes which contain a data field and next field. The next field further points to the next node in the line of nodes.\nIn other words, the nodes in singly linked lists contain a pointer to the next node in the list. We can perform operations like insertion, deletion, and traversal in singly linked lists.\nA singly linked list is shown below whose nodes contain two fields: an integer value and a pointer value (a link to the next node).",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "5) What do you understand by Doubly Linked List?",
        "answer": "The doubly linked list includes a pointer (link) to the next node as well as to the previous node in the list. The two links between the nodes may be called \"forward\" and \"backward, \"or \"next\" and \"prev (previous).\" A doubly linked list is shown below whose nodes consist of three fields: an integer value, a link that points to the next node, and a link that points to the previous node.\n\nA technique (known as XOR-linking) is used to allow a doubly-linked list to be implemented with the help of a single link field in each node. However, this technique needs more ability to perform some operations on addresses, and therefore may not be available for some high-level languages.\nMost of the modern operating systems use doubly linked lists to maintain references to active threads, processes, and other dynamic objects.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "",
        "answer": "In a multiply linked list, each node consists of two or more link fields. Each field is used to join the same set of records in a different order of the same set, e.g. \"by name, by date of birth, by the department, etc.\".",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "7) How will you explain Circular Linked List?",
        "answer": "In the last node of a linked list, the link field often contains a null reference. Instead of including a null pointer at the end of the list, the last node in circular linked lists includes a pointer pointing to the first node. In such cases, the list is said to be ?circularly linked? otherwise it is said to be 'open' or 'linear.' A circular linked list is that type of list where the last pointer points or contains the address of the first node.\n\nIn case of a circular doubly linked list, the first node also points to the last node of the list.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "8) How many pointers are necessary to implement a simple Linked List?",
        "answer": "There are generally three types of pointers required to implement a simple linked list:\nA 'head' pointer which is used for pointing to the start of the record in a list.\nA 'tail' pointer which is used for pointing to the last node. The key factor in the last node is that its subsequent pointer points to nothing (NULL).\nA pointer in every node which is used for pointing to the next node element.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "9) How can you represent a linked list node?",
        "answer": "The simplest method to represent a linked list node is wrapping the data and the link using typedef structure. Then further assigning the structure as a Node pointer that points to the next node.\nAn example of representation in C can be defined as:\n/*ll stands for linked list*/  \ntypedefstructll  \n{  \nint data;  \nstructll *next;  \n} Node",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "10) Which type of memory allocation is referred for Linked List?",
        "answer": "Dynamic memory allocation is referred for Linked List.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "11) What do you know about traversal in linked lists?",
        "answer": "The term 'traversal' refers to the operation of processing each element present in the list.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "12) What are the main differences between the Linked List and Linear Array?",
        "answer": "Linked List Linear Array\nDeletion and insertion are easy. Deletion and insertion are tough.\nThe linked list doesn't require movement of nodes while performing deletion and insertion. Linear Array requires movement of nodes while performing deletion and insertion.\nIn the Linked List, space is not wasted. In Linear Array, space is wasted.\nLinked List is not expensive. Linear Array is a bit expensive.\nIt has an option to be extended or reduced as per the requirements. It cannot be reduced or extended.\nTo avail each element in Linked List, a different amount of time is required. To avail each element in Linear Array, the same amount of time is required.\nElements in the linked list may or may not be stored in consecutive memory locations. In consecutive memory locations, elements are stored.\nTo reach a particular node, we need to go through all the nodes that come before that particular node. We can reach any particular element directly.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "13) What does the dummy header in the linked list contain?",
        "answer": "In a linked list, the dummy header consists of the first record of the actual data.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "14) Mention a few applications of Linked Lists?",
        "answer": "Few of the main applications of Linked Lists are:\nLinked Lists let us implement queues, stacks, graphs, etc.\nLinked Lists let us insert elements at the beginning and end of the list.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "15) How can you insert a node to the beginning of a singly linked list?",
        "answer": "To insert the node to the beginning of the list, we need to follow these steps:\nCreate a new node\nInsert new node by assigning the head pointer to the new node's next pointer\nUpdate the head pointer to point the new node\nNode *head;  \nvoidInsertNodeAtFront(int data)  \n{  \n/* 1. create the new node*/  \nNode *temp = new Node;  \ntemp->datadata = data;  \n/* 2. insert it at the first position*/  \ntemp->next = head;  \n/* 3. update head to point to this new node*/  \nhead = temp;  \n}",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "",
        "answer": "Both queues and stacks can be implemented using a linked list. Some of the other applications that use linked list are a binary tree, skip, unrolled linked list, hash table, etc.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "17) Differentiate between singly and doubly linked lists?",
        "answer": "Doubly linked list nodes consist of three fields: an integer value and two links pointing to two other nodes (one to the last node and another to the next node).\nOn the other hand, a singly linked list consists of a link which points only to the next node.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "18) What is the main advantage of a linked list?",
        "answer": "The main advantage of a linked list is that we do not need to specify a fixed size for the list. The more elements we add to the chain, the bigger the chain gets.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "19) How can someone add an item to the beginning of the list?",
        "answer": "Adding an item to the beginning of the list, we need to follow the given steps:\nCreate a new item and set up its value.\nLink the newly created item pointing to the head of the list.\nSet up the head of the list as our new item.\nIf we are using a function to do this operation, we need to alter the head variable.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "20) How can someone insert a node at the end of Linked List?",
        "answer": "This case is a little bit difficult as it depends upon the type of implementation. If we have a tail pointer, then it is simple. In case we do not have a tail pointer, we will have to traverse the list until we reach to the end (i.e., the next pointer is NULL). Then we need to create a new node and make that last node?s next pointer point to the new node.\nvoidInsertNodeAtEnd(int data)  \n{  \n   /* 1. create the new node*/  \n    Node *temp = new Node;  \ntemp->datadata = data;  \ntemp->next = NULL;  \n    /* check if the list is empty*/  \nif (head == NULL)  \n    {  \nhead = temp;  \nreturn;  \n    }  \nelse  \n    {  \n        /* 2. traverse the list till the end */  \n        Node *traveler = head;  \nwhile (traveler->next != NULL)  \ntravelertraveler = traveler->next;  \n        /* 3. Set up the last node to point to this new node*/  \ntraveler->next = temp;  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "21) How can someone insert a node in a random location of the Linked List?",
        "answer": "If we want to insert a node in the first position or an empty list, we can insert the node easily. Otherwise, we need to traverse the list until we reach the specified position or at the end of the list. Then we can insert a new node. Inserting a node in the middle position is a little bit difficult as we have to make sure that we perform the pointer assignment in the correct order. To insert a new node in the middle, follow the steps:\nFirst, we need to set the new node's next pointer to that node which is present before it.\nThen we are required to assign a previous node's next pointer to the starting position of the new node.\n\n\nCheck the example below:\nvoidInsertNode(int data, int position)  \n{  \n/* 1. create the new node */  \n    Node *temp = new Node;  \ntemp->datadata = data;  \ntemp->next = NULL;  \n    /* confirm if the position to insert is first or the list is empty */  \nif ((position == 1) || (head == NULL))  \n    {  \n        // set up the new node pointing to head  \n        // because list may not be empty  \ntemp->next = head;  \n        // Now point head to the first node  \nhead = temp;  \nreturn;  \n    }  \nelse  \n    {  \n   /* 2. traverse to the required position */  \n    Node *t = head;  \nintcurrPos = 2;  \nwhile ((currPos< position) && (t->next != NULL))  \n        {  \n            tt = t->next;  \ncurrPos++;  \n        }  \n /* 3. now we are at the required location */  \n        /* 4 first set up the pointer for the new node */  \ntemp->next = t->next;  \n        /* 5 now set up the previous node pointer */  \nt->next = temp;  \n    }  \n}",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "22) How can we delete the first node from the singly linked list?",
        "answer": "To delete the first node from the singly linked list, we need to follow below steps:\nCopy the first node address to some temporary variable.\nChange the head to the second node of the linked list.\nRemove the connection of the first node to the second node.\nDelete temp and free up the memory occupied by the first node.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "23) How can we delete any specific node from the linked list?",
        "answer": "If a node that we want to delete is a root node, we can delete it easily. To delete a middle node, we must have a pointer pointing to that node which is present before the node that we want to delete. So if the position is non-zero, then we run a position loop and get a pointer to the previous node.\nThe steps given below are used to delete the node from the list at the specified position:\nSet up the head to point to that node which the head is pointing.\nTraverse the list to the desired position or till the end of the list (whichever comes first)\nWe need to point the previous node to the next node.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "24) How can we reverse a singly linked list?",
        "answer": "To reverse the singly linked list, we are required to iterate through the list. We need to reverse the link at each step like after the first iteration, the head will point to null, and the next element will point to the head. At the end of traversal when we reach the tail of the linked list, the tail will start pointing to the second last element and will become a new head. It is because we can further traverse through all the elements from that particular node.\nThe steps given below can be used to reverse a singly linked list:\nFirst, we need to set a pointer (*current) pointing to the first node (i.e., current=head).\nMove ahead until current! =null (till the end of the list).\nSet another pointer (*next) pointing to the next node (i.e. next=current->next>next=result\nKeep reference of *next in a temporary variable (*result) i.e. current->next=result\nExchange the result value with current, i.e., result=current\nAnd then swap the current value with next, I.e., current=next.\nReturn result and repeat from step 2.\nA linked list can also be reversed by using recursion which eliminates the use of a temporary variable.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "25) How can we remove loops in a linked list? What are the functions of fast and slow pointers?",
        "answer": "The main concept to detect and remove a loop in a linked list is to use two pointers (one slow pointer and a fast pointer). The slow pointer traverses single node at a time, whereas the fast pointer traverses twice as fast as the first one. If the linked list contains loop in it, the fast and slow pointer will be at the same node. On the other hand, if the list doesn't consist loop in it, obviously the fast pointer will reach the end before the slow pointer does. A loop is detected if these two pointers ever met. If the loop is detected, the start of the loop can help us remove the detected loop in the linked list. It is called Floyd's Cycle-Finding Algorithm. The given diagram shows how a loop looks like in a linked list:",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "26) What will you prefer for traversing through a list of elements between singly and doubly linked lists?",
        "answer": "Double linked lists need more space for each node in comparison to the singly linked list. In a doubly linked list, the elementary operations such as insertion and deletion are more expensive, but they are easier to manipulate because they provide quick and easy sequential access to the list in both the directions. But, doubly linked lists cannot be used as persistent data structures. Hence, the doubly linked list would be a better choice for traversing through a list of the node.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "27) Where will be the free node available while inserting a new node in a linked list?",
        "answer": "If a new node is inserted in a linked list, the free node is found in Avail List.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "28) For which header list, the last node contains the null pointer?",
        "answer": "For grounded header list, you will find the last node containing the null pointer.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "29) How can you traverse a linked list in Java?",
        "answer": "There are several ways to traverse a linked list in Java, e.g., we can use traditional for, while, or do-while loops and go through the linked list until we reach at the end of the linked list. Alternatively, we can use enhanced for loop of Java 1.5 or iterator to traverse through a linked list in Java. From JDK 8 onwards, we have an option to use java.util.stream.Stream for traversing a linked list.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "30) How to calculate the length of a singly linked list in Java?",
        "answer": "We can iterate over the linked list and keep a count of nodes until we reach the end of the linked list where the next node will be null. The value of the counter is considered as the length of the linked list.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "31) How can someone display singly linked list from first to last?",
        "answer": "One must follow these steps to display singly linked list from first to last:\nCreate a linked list using create().\nThe address stored inside the global variable \"start\" cannot be changed, so one must declare one temporary variable \"temp\" of type node.\nTo traverse from start to end, one should assign the address of starting node in the pointer variable, i.e., temp.\nstruct node *temp;  //Declare temp variable  \ntemp = start;       //Assign Starting Address to temp  \nIf the temp is NULL, then it means that the last node is accessed.\nwhile(temp!=NULL)  \n{  \nprintf(\"%d\",temp->data);  \ntemptemp=temp->next;  \n}",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "",
        "answer": "Some of the important drawbacks of the linked list are given below:\nRandom access is not allowed. We need to access elements sequentially starting from the first node. So we cannot perform a binary search with linked lists.\nMore memory space for a pointer is required with each element of the list.\nSlow O(n) index access, since accessing linked list by index means we have to loop over the list recursively.\nPoor locality, the memory used for the linked list is scattered around in a mess.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "",
        "answer": "The package that is used for Linked list in Java is java.util.",
        "reference": "javatpoint.com",
        "role": "linked-list"
    },
    {
        "question": "",
        "answer": "Some of the main interfaces implemented by Java Linked Lists are:\nSerializable\nQueue\nList\nCloneable\nCollection\nDeque\nIterable",
        "reference": "javatpoint.com",
        "role": "linked-list"
    }
]