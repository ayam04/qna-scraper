[
    {
        "question": "",
        "answer": "Example: 1\narr[] = {3, 4, 5, 1, 6, 10, 9, 7, 8}; s = 9\n true\nExplanation: All the numbers that are coming before 6 are smaller than 6, and all the elements that are coming after 6 are greater than 6. Hence, the answer is true.\nExample: 2\narr[] = {4, 5, 1}; s = 3\n false\nExplanation: There is not a single number that fits the given condition. Hence, the answer is false.\nFileName: PeakElement.java\nADVERTISEMENT\n// import statement  \nimport java. util. Arrays;  \n  public class PeakElement  \n{  \nboolean isPeak(int a[], int s)  \n{  \nboolean []l = new boolean[s];  \nboolean []r = new boolean[s];  \n  int max = a[0];  \nl[0] = false;  \n  // a loop to find those elements   \n// that are greater than elements that are left of it  \nfor (int j = 1; j < s; j++)   \n{  \nif (a[j] > max)   \n{  \nmax = a[j];  \nl[j] = true;  \n}   \nelse   \n{  \nl[j] = false;  \n}  \n}  \nint min = a[s - 1];  \nr[s - 1] = false;  \nfor (int j = s - 2; j >= 0; j--)   \n{  \n  if (a[j] < min)   \n{  \nr[j] = true;  \nmin = a[j];  \n}   \nelse   \n{  \nr[j] = false;  \n}  \n}  \n  // a loop to find those elements   \n// that are greater than elements that are right of it  \nfor (int j = 0; j < s; j++)   \n{  \nif (l[j] && r[j])   \n{  \nreturn true;  \n}  \n}  \nreturn false;  \n}  \n// main method  \npublic static void main(String argvs[])  \n{  \n// creating an object of the class PeakElement  \nPeakElement obj = new PeakElement();  \n  // input array 1  \nint arr[] = { 10, 2, 3, 4, 5, 4, 3, 2, 3, 10 };  \nint size = arr.length;  \n  if(obj.isPeak(arr, size))  \n{  \nSystem.out.println(\"The array \" + Arrays.toString(arr) + \" has got a peak element.\");  \n}  \nelse  \n{  \nSystem.out.println(\"The array \" + Arrays.toString(arr) + \" has not got a peak element.\");   \n}  \n  // input array 2  \nint arr1[] = {3, 4, 5, 1, 6, 10, 9, 7, 8};   \nsize = arr1.length;  \n  if(obj.isPeak(arr1, size))  \n{  \nSystem.out.println(\"The array \" + Arrays.toString(arr1) + \" has got a peak element.\");  \n}  \nelse  \n{  \nSystem.out.println(\"The array \" + Arrays.toString(arr1) + \" has not got a peak element.\");   \n}  \n}  \n}  \nOutput:\nThe array [10, 2, 3, 4, 5, 4, 3, 2, 3, 10] has not got a peak element.\nThe array [3, 4, 5, 1, 6, 10, 9, 7, 8] has got a peak element.",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr[] = {1, 3, 5, 2, 3}; s = 5\n a1 = 3, a2 = 4\nExplanation: The repeating number is 3, and the missing number is 4.\nExample: 2\narr[] = {1, 2, 1}; s = 3\n a1 = 1, a2 = 3\nExplanation: The repeating number is 1, and the missing number is 3.\nFileName: MissingAndRepeatingElement.java\n// import statement  \nimport java. util. Arrays;  \n  public class MissingAndRepeatingElement  \n{  \nvoid findEle(int a[], int s)  \n{  \n  // finding sum of n natural numbers (n * (n + 1)) / 2  \nlong nsum = (s * (s + 1)) / 2;  \n  // finding sum of square of n natural numbers (n * (n + 1) * (2 * n + 1)) / 6  \nlong nsqrsum = (nsum * ( 2 * s + 1)) / 3;  \n    long sqrsum = 0, sum = 0;  \n  for(int i = 0; i < s; i++)  \n{  \n// find sum of elements present in the array  \nsum = sum + a[i];  \n  // finding sum of square of elements presenet in the array  \nsqrsum = sqrsum + ((long) a[i] * a[i]);  \n}  \n  // finding a1^2 - a2^2  \nlong sqrdiff = sqrsum - nsqrsum;  \n  // finding a1 - a2  \nlong diff = sum - nsum;  \n  // finding a1 + a2 using mathematical identity  \n// a1^2 - a2^2 = (a1 + a2)(a1 - a2)  \nsum = sqrdiff/diff;  \n  // finding a1 using a1 + a2 and a1 - a2  \nlong a1 = (sum + diff)/2;  \n  // finding y  \nlong a2 = sum - a1;  \n  System.out.println(\"For array: \" + Arrays.toString(a) + \"\\n\");  \nSystem.out.println(\"a1 is: \" + a1);  \nSystem.out.println(\"a2 is: \" + a2);  \n  return;  \n}  \n  public static void main(String argvs[])  \n{  \n// creating an object of the class MissingAndRepeatingElement  \nMissingAndRepeatingElement obj = new MissingAndRepeatingElement();  \n  int arr[] = {1, 3, 5, 4, 1};  \nint size = arr.length;  \n  obj.findEle(arr, size);  \n  int arr1[] = {1, 3, 5, 2, 3};  \nsize = arr1.length;  \n  System.out.println();  \nobj.findEle(arr1, size);  \n  }  \n}  \nOutput:\nFor array: [1, 3, 5, 4, 1]\n\na1 is: 1\na2 is: 2\n\nFor array: [1, 3, 5, 2, 3]\n\na1 is: 3\na2 is: 4",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\n\narr[] = {0, 1, -1, 0}; s = 4\n 1\nExplanation: There is only one way to split the array into three parts whose sum is equal. {0}, {1, -1}, {0}\nExample: 2\narr[] = {2, 2, 4, 0, 4}; s = 5\n 2\n\nExplanation: There are two ways to split the array into three parts whose sum is equal.\n{2, 2}, {4, 0}, {4}\n{2, 2}, {4}, {0, 4}\nFileName: ParititionArray.java\n// import statement  \nimport java. util. Arrays;  \n  public class PartitionArray  \n{  \n// A method that returns the number of ways  \n// the array arr can be partitioned into 3 parts  \n// such that sum of each part is equal  \nint countWays(int arr[], int size)  \n{  \n  int pre[] = new int[size + 1];  \npre[0] = 0;;  \nfor (int j = 0; j < size; j++)   \n{  \n// Creating a prefix array for retrieving the sum in O(1)  \npre[j + 1] = pre[j] + arr[j];   \n}  \n  int ans = 0;  \n    // Sum of all the elements of the array must be divisible   \n// by 3; otherwise, it is not possible to partition the array  \nif(pre[size] % 3 == 0)   \n{  \n// partition happen at two points at 1 / 3 and 2 / 3  \nint u = pre[size] / 3;  \nint v = 2 * pre[size] / 3;     \n// Count for first partition  \nint count = 0;                    \nfor (int j = 1; j < size; j++)   \n{  \nif (pre[j] == v)  \n{  \n// If the sum is of 2 partitions, then add the count to answer  \nans = ans + count;   \n}  \n  if (pre[j] == u)  \n{  \n // If sum is of 1 partition then increase the count by 1  \ncount = count + 1;   \n}  \n}  \n}  \nreturn ans;     \n}  \npublic static void main(String argvs[])  \n{  \n// creating an object of the class PartitionArray  \nPartitionArray obj = new PartitionArray();  \n  int arr[] = {2, 2, 4, 0, 4};  \nint size = arr.length;  \n  int ways = obj.countWays(arr, size);  \n    System.out.println(\"For array: \" + Arrays.toString(arr));  \nSystem.out.println(\"The number of ways to it partition is: \" + ways + \"\\n\");  \n  int arr1[] = {-1, 1, 0, 0, -1, 1};  \nsize = arr1.length;  \n  ways = obj.countWays(arr1, size);  \n  System.out.println(\"For array: \" + Arrays.toString(arr1));  \nSystem.out.println(\"The number of ways to it partition is: \" + ways + \"\\n\");  \n    int arr2[] = {4, 6, 8, 9, -13, 9};  \nsize = arr2.length;  \n  ways = obj.countWays(arr2, size);  \n  System.out.println(\"For array: \" + Arrays.toString(arr2));  \nSystem.out.println(\"The number of ways to it partition is: \" + ways);  \n  }  \n}  \nOutput:\nFor array: [2, 2, 4, 0, 4]\nThe number of ways to it partition is: 2\n\nFor array: [-1, 1, 0, 0, -1, 1]\nThe number of ways to it partition is: 3\n\nFor array: [4, 6, 8, 9, -13, 9]\nThe number of ways to it partition is: 0",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr[] = {1, -1, 3};\n 5\nExplanation:\nf(0, 0) = f(1, 1) = f(2, 2) = 0\nf(0, 1) = f(1, 0) = 3\nf(0, 2) = f(2, 0) = 4\nf(1, 2) = f(2, 1) = 5\nWe see that the maximum value is 5. Hence, the answer is 5.\nExample: 2\narr[] = {2, -1, -1, 3};\n 6\nExplanation:\nf(0, 0) = f(1, 1) = f(2, 2) = f(3, 3) = 0\nf(0, 1) = f(1, 0) = 4\nf(0, 2) = f(2, 0) = 5\nf(0, 3) = f(3, 0) = 4\nf(1, 2) = f(2, 1) = 1\nf(1, 3) = f(3, 1) = 6\nf(2, 3) = f(3, 2) = 5\nWe see that the maximum value is 6. Hence, the answer is 6.\nFileName: AbsoluteValue.java\n// import statement  \nimport java. util. Arrays;  \n  public class AbsoulteValue  \n{  \npublic int maxVal(int arr[], int s)  \n{  \nint max1 = Integer.MIN_VALUE;  \nint max2 = Integer.MIN_VALUE;  \nint min1 = Integer.MAX_VALUE;  \nint min2 = Integer.MAX_VALUE;  \n  // loop for finding the maximum and minimum value of  \n// arr[i] + i and arr[i] - i  \nfor(int i  = 0; i < s; i++)  \n{  \nmax1 = Math.max(max1, arr[i] + i);  \nmin1 = Math.min(min1, arr[i] + i);  \nmin2 = Math.min(min2, arr[i] - i);  \nmax2 = Math.max(max2, arr[i] - i);  \n  }  \n  // finding the maximum between  \n// max(arr[i] + i) - min(arr[i] + i) &  \n// max(arr[i] - i) - min(arr[i] - i)  \nint ans = Math.max(max1 - min1, max2 - min2);  \nreturn ans;  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// creating an object of the class AbsoulteValue  \nAbsoulteValue obj = new AbsoulteValue();  \nint arr[] ={1, 3, -1};  \nint size = arr.length;  \n  int ans = obj.maxVal(arr, size);  \n  System.out.print(\"The maximum absolute value of the array: \" + Arrays.toString(arr));  \nSystem.out.println(\" is \" + ans + \"\\n\");  \n  int arr1[] = {3, 4, 5, 9, 12};  \n  size = arr1.length;  \n  ans = obj.maxVal(arr1, size);  \n  System.out.print(\"The maximum absolute value of the array: \" + Arrays.toString(arr1));  \nSystem.out.println(\" is \" + ans + \"\\n\");  \n  int arr2[] = {13, -4, 5, -12};  \n  size = arr2.length;  \n  ans = obj.maxVal(arr2, size);  \n  System.out.print(\"The maximum absolute value of the array: \" + Arrays.toString(arr2));  \nSystem.out.println(\" is \" + ans + \"\\n\");  \n  int arr3[] = {-1, 2, 9, -7};  \n  size = arr3.length;  \n  ans = obj.maxVal(arr3, size);  \n  System.out.print(\"The maximum absolute value of the array: \" + Arrays.toString(arr3));  \nSystem.out.println(\" is \" + ans + \"\\n\");  \n  }  \n}  \nOutput:\nThe maximum absolute value of the array: [1, 3, -1] is 5\n\nThe maximum absolute value of the array: [3, 4, 5, 9, 12] is 13\n\nThe maximum absolute value of the array: [13, -4, 5, -12] is 28\n\nThe maximum absolute value of the array: [-1, 2, 9, -7] is 17",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr[] = {3, 1, 2}; s = 3;\n 321\nExplanation: The number formed using the array elements is 312. The next permutation of the number 312 is 321.\nExample: 2\narr[] = {1, 2, 3};\n 132\nExplanation: The number formed using the array elements is 123. The next permutation of the number 123 is 132.\nFileName: NextPermutation.java\n// import statement  \nimport java.util.Arrays;  \n  public class NextPermutation  \n{  \n// reversing the array from the position pos  \npublic void reverse(int array[], int pos)  \n{  \nint size = array.length;  \n  for(int i = pos, j = size - 1; i <= j; i++, j--)  \n{  \n// swap elements  \nint temp = array[i];  \narray[i] = array[j];  \narray[j] = temp;  \n}  \n}  \n    //  a method that finds next permutation using the array elements  \npublic int[] nextPermutation(int arr[], int s)  \n{  \nif(s == 1)   \n{  \nreturn arr;  \n}  \nint i;  \nfor(i = s - 2; i >= 0; i--)  \n{  \nif(arr[i] < arr[i + 1])  \nbreak;  \n}  \n// if the whole array is sorted in the ascending order  \n// then the next permutation is reverse of the array arr  \nif(i < 0)  \n{  \n// reverse the complete array  \nreverse(arr, 0);  \n  return arr;  \n}  \nint j;  \nfor(j = s - 1; j > i; j--)  \n{  \nif(arr[j] > arr[i])  \n{  \nbreak;  \n}  \n}  \n  // swap elements  \nint temp = arr[i];  \narr[i] = arr[j];  \narr[j] = temp;  \n  // reverse from position i + 1  \nreverse(arr, i + 1);  \n  return arr;  \n  }  \n  // generating number from the array elements  \nint findNo(int arr[], int size)  \n{  \n    int ans = 0;  \n    for(int i = 0; i < size; i++)  \n    {  \n        ans = arr[i] + (ans * 10);  \n    }  \n          return ans;  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// creating an object of the class NextPermutation  \nNextPermutation obj = new NextPermutation();  \n  // input array - 1  \nint arr[] ={1, 2, 3};  \nint size = arr.length;  \n  int orginialNo = obj.findNo(arr, size);  \n  int ans[] = obj.nextPermutation(arr, size);  \n  int permutedNo = obj.findNo(ans, size);  \n  System.out.println(\"The next permutation of \" + orginialNo + \" is \" + permutedNo);  \n  // input array - 2  \nint arr1[] ={1, 4, 3, 2};  \nsize = arr1.length;  \n  orginialNo = obj.findNo(arr1, size);  \n  int ans1[] = obj.nextPermutation(arr1, size);  \n  permutedNo = obj.findNo(ans1, size);  \n  System.out.println(\"The next permutation of \" + orginialNo + \" is \" + permutedNo);  \n  // input array - 3  \nint arr2[] ={1, 3, 7, 9, 4};  \nsize = arr2.length;  \n  orginialNo = obj.findNo(arr2, size);  \n  int ans2[] = obj.nextPermutation(arr2, size);  \n  permutedNo = obj.findNo(ans2, size);  \n  System.out.println(\"The next permutation of \" + orginialNo + \" is \" + permutedNo);  \n  }  \n}  \nOutput:\nThe next permutation of 123 is 132\nThe next permutation of 1432 is 2134\nThe next permutation of 13794 is 13947",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr[] = {35, 1, 9};\n 9351\nExplanation: 9 is the largest number digit, so it will be put first. After that, the digit 3 is greater than digit 1. Therefore, 35 is put before 1.\nExample: 2\narr[] = {17, 22, 83, 7, 5};\n\n 83752217\nExplanation: 8 is the largest digit in the given array. Therefore, 83 is put first. The same treatment is given to other numbers too.\nFileName: LargestNoExample.java\n// import statement  \nimport java.util.*;  \n  public class LargestNoExample   \n{  \n  public String largestNumber(int a[], int size)   \n{  \n  String[] arr = new String[size];  \nfor (int i = 0; i < size; i++)   \n{  \narr[i] = String.valueOf(a[i]);  \n}  \n    Arrays.sort(arr, new Comparator<String>()  \n{  \npublic int compare(String a, String b)  \n{  \n    // the biggest digit has to be put first  \n    return (b + a).compareTo(a + b);  \n}  \n});  \n    StringBuilder sb = new StringBuilder();  \nfor(String s: arr)  \n{  \nsb.append(s);  \n}  \n  // if 0 is present is at the   \n// first index, then it means all the  \n// number present at the other index are also zero  \nif(sb.charAt(0) == '0')  \n{      \n//check if all zeroes are there  \nreturn String.valueOf(0);  \n}  \n  return sb.toString();     \n}  \n            // main method  \npublic static void main(String argvs[])  \n{  \n      // creating an object of the class LargestNoExample  \nLargestNoExample obj = new LargestNoExample();  \n  // input array - 1  \nint arr[] = {17, 22, 83, 7, 5};  \nint size = arr.length;  \n  String str = obj.largestNumber(arr, size);  \n  System.out.println(\"The largest number formed from the array: \" + Arrays.toString(arr) + \" is \" + str);  \n    // input array - 2  \nint arr1[] = {79, 21, 83, 7, 58};  \nsize = arr1.length;  \n  str = obj.largestNumber(arr1, size);  \n  System.out.println(\"The largest number formed from the array: \" + Arrays.toString(arr1) + \" is \" + str);  \n    // input array - 2  \nint arr2[] = {0, 9, 99, 79, 87, 158};  \nsize = arr2.length;  \n  str = obj.largestNumber(arr2, size);  \n  System.out.println(\"The largest number formed from the array: \" + Arrays.toString(arr2) + \" is \" + str);  \n  }  \n  }  \nOutput:\nThe largest number formed from the array: [17, 22, 83, 7, 5] is 83752217\nThe largest number formed from the array: [79, 21, 83, 7, 58] is 837975821\nThe largest number formed from the array: [0, 9, 99, 79, 87, 158] is 99987791580",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\n\nExample: 2\n\nFileName: RotateMatrix.java\n// import statement  \nimport java.util.Arrays;  \n  public class RotateMatrix  \n{  \npublic void rotate(int al[][])   \n{  \ntranspose(al);   \nint rowSize = al.length;  \nint colSize = al[0].length;  \nint i = 0;  \nwhile(i < colSize)  \n{  \nfor(int j = 0; j < rowSize; j++)  \n{  \n    int temp =  al[j][i];  \n    al[j][i] = al[j][colSize - 1];  \n    al[j][colSize - 1] = temp;  \n}  \n  i = i + 1;  \ncolSize = colSize - 1;  \n}  \n}  \n  void transpose(int a[][])   \n{   \nint rowSize = a.length;  \nint colSize = a[0].length;  \nfor (int row = 0; row < rowSize; row++)   \n{  \nfor (int col = row; col < colSize; col++)   \n{   \n    int temp = a[row][col];  \n    a[row][col] = a[col][row];  \n    a[col][row] = temp;  \n}   \n}  \n}  \n  public void display(int arr[][])  \n{  \nint rowSize = arr.length;  \nint colSize = arr[0].length;  \n  for(int i = 0; i < rowSize; i++)  \n{  \nfor(int j = 0; j < colSize; j++)  \n{  \n    System.out.print(arr[i][j] + \" \");  \n}  \n  System.out.println();  \n}  \n}  \n        // main method  \npublic static void main(String argvs[])  \n{  \n      // creating an object of the class RotateMatrix  \nRotateMatrix obj = new RotateMatrix();  \n  int[][] arr = new int[2][2];  \n  arr[0][0] = 1; arr[0][1] = 3;  \narr[1][0] = 2; arr[1][1] = 4;  \n  System.out.println(\"The array is: \");  \nobj.display(arr);  \n  obj.rotate(arr);  \nSystem.out.println();  \nSystem.out.println(\"After rotating to 90 degrees clockwise the array is: \");  \nobj.display(arr);  \n  int[][] arr1 = new int[4][4];  \n  arr1[0][0] = 4; arr1[0][1] = 8; arr1[0][2] = 7; arr1[0][3] = 2;  \narr1[1][0] = 9; arr1[1][1] = 5; arr1[1][2] = 6; arr1[1][3] = 3;  \narr1[2][0] = 0; arr1[2][1] = 8; arr1[2][2] = 1; arr1[2][3] = 6;  \narr1[3][0] = 4; arr1[3][1] = 3; arr1[3][2] = 2; arr1[3][3] = 5;   \n  System.out.println();  \nSystem.out.println(\"The array is: \");  \nobj.display(arr1);  \n  obj.rotate(arr1);  \nSystem.out.println();  \nSystem.out.println(\"After rotating to 90 degrees clockwise the array is: \");  \nobj.display(arr1);  \n  }  \n  }  \nOutput:\nThe array is: \n1 3 \n2 4 \n\nAfter rotating to 90 degrees clockwise the array is: \n2 1 \n4 3 \n\nThe array is: \n4 8 7 2 \n9 5 6 3 \n0 8 1 6 \n4 3 2 5 \n\nAfter rotating to 90 degrees clockwise the array is: \n4 0 9 4 \n3 8 5 8 \n2 1 6 7 \n5 6 3 2",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr[] = {2, 4, 3, 8, 9};\n {1, 2}\nExplanation: The subarray starting from index 1 and ending at index 2 is the smallest subarray that gets sorted, then the whole array gets sorted.\nExample: 2\narr[] = {12, 34, 45, 67, 78, 88, 99, 102};\n { }\nExplanation: The given array is already sorted. Hence, the subarray is empty.\nFileName: SmallestSubArray.java\n// import statement  \nimport java.util.Arrays;  \n  public class SmallestSubArray   \n{  \n// method that finds the starting and ending   \n// indices of the subarray that should be sorted to   \n// sort the whole array  \npublic int[] findSubarray(int a[], int size)  \n{  \n// for storing the first index of the subarray  \nint first = -1;  \n  // for storing the second index of the subarray  \nint second = -1;  \n// for storing the result  \nint ans[] = {-1, -1};  \nfor(int i = 0; i < size - 1; i++)  \n{  \nif(a[i] > a[i + 1])  \n{  \nfirst = i + 1;  \nbreak;  \n}  \n}  \n  if(first == -1)  \n{  \n// if control reaches here, then the input array is already sorted.  \nreturn ans;  \n}  \n  for(int j = size - 1; j >= 1; j--)  \n{  \nif(a[j] < a[j - 1])  \n{  \nsecond = j - 1;   \nbreak;  \n}  \n}  \n  int temp = first;  \nfor(int i1 = temp; i1 < size; i1++)  \n{  \nif(a[i1] <= a[first])  \nfirst = i1;  \n}  \ntemp = second;  \nfor(int j = temp; j >= 0; j--)  \n{  \nif(a[j] >= a[second])  \nsecond = j;  \n  }  \n  temp = first;  \nfor(int i = 0; i <= temp; i++)  \n{  \nif(a[i]  > a[first])  \n{  \nfirst = i;   \nbreak;  \n}  \n  }  \n  temp = second;  \nfor(int i = size-1; i >= temp; i--)  \n{  \nif(a[i] < a[second])  \n{  \nsecond = i;   \nbreak;  \n  }  \n}  \n    ans[0] = first;  \nans[1] = second;  \n  return ans;  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n      // creating an object of the class SmallestSubArray  \nSmallestSubArray obj = new SmallestSubArray();  \n  int[] arr = {2, 4, 3, 8, 9};  \nint size = arr.length;  \nSystem.out.println(\"The array is: \" + Arrays.toString(arr));  \nint ans[] = obj.findSubarray(arr, size);  \nif(ans[0] < 0)  \n{  \nSystem.out.println(\"Minimum subarray is not found as the array is already sorted \\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"Minimum subarray for sorting the array is:\");  \nSystem.out.print(\"[\");  \nfor(int i = ans[0]; i < ans[1]; i++)  \n{  \nSystem.out.print(arr[i] + \", \");  \n}  \nSystem.out.println(arr[ans[1]] + \"] \\n\");  \n}  \n    int[] arr1 = {12, 34, 45, 67, 78, 88, 99, 102, 345, 555, 666, 777, 888, 999};  \nsize = arr.length;  \nSystem.out.println(\"The array is: \" + Arrays.toString(arr1));  \nint ans1[] = obj.findSubarray(arr1, size);  \nif(ans1[0] < 0)  \n{  \nSystem.out.println(\"Minimum subarray is not found as the array is already sorted \\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"Minimum subarray for sorting the array is:\");  \nSystem.out.print(\"[\");  \nfor(int i = ans1[0]; i < ans1[1]; i++)  \n{  \nSystem.out.print(arr1[i] + \", \");  \n}  \nSystem.out.println(arr1[ans1[1]] + \"] \\n\");  \n}  \n    int[] arr2 = {1, 2, 3, 3, 4, 4, 5, 5, 7, 8, 9, 20, 14, 16, 19, 14, 19, 19, 20, 21, 22, 27, 30};  \nsize = arr2.length;  \nSystem.out.println(\"The array is: \" + Arrays.toString(arr2));  \nint ans2[] = obj.findSubarray(arr2, size);  \nif(ans2[0] < 0)  \n{  \nSystem.out.println(\"Minimum subarray is not found as the array is already sorted \\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"Minimum subarray for sorting the array is:\");  \nSystem.out.print(\"[\");  \nfor(int i = ans2[0]; i < ans2[1]; i++)  \n{  \nSystem.out.print(arr2[i] + \", \");  \n}  \nSystem.out.println(arr2[ans2[1]] + \"] \\n\");  \n}  \n  }  \n}  \nOutput:\nThe array is: [2, 4, 3, 8, 9]\nMinimum subarray for sorting the array is:\n[4, 3] \n\nThe array is: [12, 34, 45, 67, 78, 88, 99, 102, 345, 555, 666, 777, 888, 999]\nMinimum subarray is not found as the array is already sorted \n\nThe array is: [1, 2, 3, 3, 4, 4, 5, 5, 7, 8, 9, 20, 14, 16, 19, 14, 19, 19, 20, 21, 22, 27, 30]\nMinimum subarray for sorting the array is:\n[20, 14, 16, 19, 14, 19, 19]",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr[] = {5, 3, 2, 4, 3, 9, 11, 3, 12, 67, 45, 3}; sz = 12; k = 3; s = 3;\n Yes, each segment of the array arr of size s contains the key k.\nExplanation: sz / s = 12 / 3 = 4. These four segments are:\n{5, 3, 2} -----> contains the key 3\n{4, 3, 9} -----> contains the key 3\n{11, 3, 12} -----> contains the key 3\n{67, 45, 3} -----> contains the key 3\nThus, each segment contains the key k, which is 3.\nExample: 2\narr[] = {23, 56, 65, 21, 34, 67, 89, 9, 0, 23, 55, 44, 33, 22, 23}; sz = 15; k = 23; s = 5;\n Yes, each segment of the array arr of size s contains the key k.\nExplanation: sz / s = 15 / 5 = 3. These three segments are:\n{23, 56, 65, 21, 34} -----> contains the key 23\n{67, 89, 9, 0, 23} -----> contains the key 23\n{55, 44, 33, 22, 23} -----> contains the key 23\nThus, each segment contains the key k, which is 23.\nFileName: ArraySegmentKey.java\n// A Java code that finds the every  \n// segment of size s of array arr have  \n// key K or not  \n  import java.util.*;  \npublic class ArraySegmentKey   \n{  \npublic boolean findingKinWindowSize(int size, int[] arr, int K, int s)  \n{  \nint i;  \nboolean b = false;  \n  // Iterate from 0 to size - 1  \nfor (i = 0; i < size; i = i + s)   \n{  \nint j;  \n// Iterate from 0 to s - 1  \nfor (j = 0; j < s; j++)   \n{  \nif (i + j < size && arr[i + j] == K)  \n{  \nbreak;  \n}  \n}  \nif (j == s)  \n{  \nreturn false;  \n}  \nif (i + j >= size)  \n{  \nreturn false;  \n}  \n}  \nif (i >= size)  \n{  \nreturn true;  \n}  \nelse  \n{  \nreturn b;  \n}  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// creating an object of the class ArraySegmentKey  \nArraySegmentKey obj = new ArraySegmentKey();  \n  int arr[] = {5, 3, 2, 4, 3, 9, 11, 3, 12, 67, 45, 3};  \nint k = 3;  \nint s = 3;  \nint sz = arr.length;  \nif (obj.findingKinWindowSize(sz, arr, k, s))  \n{  \nSystem.out.println(\"For array \" + Arrays.toString(arr));  \nSystem.out.println(\"Each segment of size \" + s + \" contains the key \" + k + \"\\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"For array \" + Arrays.toString(arr));  \nSystem.out.println(\"Each segment of the array of size \" + s + \" does not contain the key \" + k + \"\\n\");  \n}  \n  int arr1[] = {23, 56, 65, 21, 34, 67, 89, 9, 0, 23, 55, 44, 33, 22, 23};  \nint k1 = 23;  \nint s1 = 5;  \nint sz1 = arr1.length;  \nif (obj.findingKinWindowSize(sz1, arr1, k1, s1))  \n{  \nSystem.out.println(\"For array \" + Arrays.toString(arr1));  \nSystem.out.println(\"Each segment of size \" + s1 + \" contains the key \" + k1 + \"\\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"For array \" + Arrays.toString(arr1));  \nSystem.out.println(\"Each segment of the array of size \" + s1 + \" does not contain the key \" + k1 + \"\\n\");  \n}  \n  int arr2[] = {1, 6, 7, 2, 3, 8, 9};  \nint k2 = 6;  \nint s2 = 1;  \nint sz2 = arr2.length;  \nif (obj.findingKinWindowSize(sz2, arr2, k2, s2))  \n{  \nSystem.out.println(\"For array \" + Arrays.toString(arr2));  \nSystem.out.println(\"Each segment of size \" + s2 + \" contains the key \" + k2 + \"\\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"For array \" + Arrays.toString(arr2));  \nSystem.out.println(\"Each segment of the array of size \" + s2 + \" does not contain the key \" + k2 + \"\\n\");  \n}  \n  }  \n}  \nOutput:\nFor array [5, 3, 2, 4, 3, 9, 11, 3, 12, 67, 45, 3]\nEach segment of size 3 contains the key 3\n\nFor array [23, 56, 65, 21, 34, 67, 89, 9, 0, 23, 55, 44, 33, 22, 23]\nEach segment of size 5 contains the key 23\n\nFor array [1, 6, 7, 2, 3, 8, 9]\nEach segment of the array of size 1 does not contain the key 6",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\nstr = \"caa\"\n The rank of \"caa\" is 3 among its lexicographically sorted permutations.\nExplanation: The string has three characters, 'a', 'a', and 'c', and their lexicographically sorted permutations are:\n\"aac\" ----------> rank - 1\n\"aca\" ----------> rank - 2\n\"caa\" ----------> rank - 3\nHence, the rank is 3.\nExample: 2\nstr = \"dcab\"\n The rank of \"dcab\" is 23 among its lexicographically sorted permutations.\nExplanation: The string has four characters, 'a', 'b', 'c', 'd', and their lexicographically sorted permutations are:\n\"abcd\" ----------> rank - 1\n\"abdc\" ----------> rank - 2\n\"acbd\" ----------> rank - 3\n\"acdb\" ----------> rank - 4\n\"adbc\" ----------> rank - 5\n\"adcb\" ----------> rank - 6\n\"bacd\" ----------> rank - 7\n\"badc\" ----------> rank - 8\n\"bcad\" ----------> rank - 9\n\"bcda\" ----------> rank - 10\n\"bdac\" ----------> rank - 11\n\"bdca\" ----------> rank - 12\n\"cabd\" ----------> rank - 13\n\"cadb\" ----------> rank - 14\n\"cbad\" ----------> rank - 15\n\"cbda\" ----------> rank - 16\n\"cdab\" ----------> rank - 17\n\"cdba\" ----------> rank - 18\n\"dabc\" ----------> rank - 19\n\"dacb\" ----------> rank - 20\n\"dbac\" ----------> rank - 21\n\"dbca\" ----------> rank - 22\n\"dcab\" ----------> rank - 23\nHence, the rank is 23.\nFileName: PermutationRank.java\npublic class PermutationRank   \n{  \n// a method that finds the rank  \npublic int findRank(String str)   \n{  \nint size = str.length();  \n// for storing factorials of numbers  \nlong[] fact = new long[size + 1];  \nfact[0] = 1;  \n  for (int i = 1; i <= size; i++)   \n{  \nfact[i] = (fact[i - 1] * i);  \n}  \n  // for storing the frequency of character   \nint[] c = new int[52];  \n  for (char ch : str.toCharArray())   \n{  \nc[o(ch)] = c[o(ch)] + 1;  \n}  \n  long rank = 0;  \nint count = str.length();  \n  for (char ch : str.toCharArray())   \n{  \ncount = count - 1;  \nfor (int t = 0; t < o(ch); t++)   \n{  \nif (c[t] > 0)   \n{  \nc[t] = c[t] - 1;  \nlong trank = fact[count];  \n  for (int i = 0; i < 52; i++)   \n{  \nif (c[i] > 0)   \n{  \n// a! / b!  \n// where a! represent the factorial when the charactes are unique and  \n// where b! is the factorial of repeated characters  \ntrank = (trank / fact[c[i]]);  \n}  \n}  \nrank = (rank + trank);  \nc[t] = c[t] + 1;  \n}  \n}  \nc[o(ch)] = c[o(ch)] - 1;  \n}  \nreturn new Long((rank + 1)).intValue();  \n}  \n  private int o(char ch)   \n{  \nif (ch <= 'Z') return ch - 'A';  \nreturn ch - 'a' + 26;  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \nPermutationRank obj = new PermutationRank();  \nString str = \"caa\";  \nint rank = obj.findRank(str);  \nstr = \"'caa'\";  \nSystem.out.print(\"The rank of the string \" + str + \" is \");  \nSystem.out.println(rank + \" among its lexicographically sorted permutations. \\n\");  \n    str = \"dcab\";  \nrank = obj.findRank(str);  \nstr = \"'dcab'\";  \nSystem.out.print(\"The rank of the string \" + str + \" is \");  \nSystem.out.println(rank + \" among its lexicographically sorted permutations. \\n\");  \n    str = \"haaxxy\";  \nrank = obj.findRank(str);  \nstr = \"'haaxxy'\";  \nSystem.out.print(\"The rank of the string \" + str + \" is \");  \nSystem.out.println(rank + \" among its lexicographically sorted permutations. \\n\");  \n  str = \"mttlks\";  \nrank = obj.findRank(str);  \nstr = \"'mttlks'\";  \nSystem.out.print(\"The rank of the string \" + str + \" is \");  \nSystem.out.println(rank + \" among its lexicographically sorted permutations. \\n\");  \n}  \n  }  \nOutput:\nThe rank of the string 'caa' is 3 among its lexicographically sorted permutations. \n\nThe rank of the string 'dcab' is 23 among its lexicographically sorted permutations. \n\nThe rank of the string 'haaxxy' is 61 among its lexicographically sorted permutations. \n\nThe rank of the string 'mttlks' is 177 among its lexicographically sorted permutations.",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr = {-11, -10, -9, -2, 5, 17}\narr1 = {-4, 4, 7, 13, 16, 17, 19}\n The median of these sorted arrays is at the index.\nExplanation: When these sorted arrays are merged, we get the following.\nmergedArray = {-11, -10, -9, -4, -2, 4, 5, 7, 13, 16, 17, 17, 19};\nThe size of the mergedArray is 13, which is odd. Hence, there is only one middle element sitting at the index 13 / 2 = 6. At the 6th index, we get 5. Hence, 5 is the median of these sorted arrays.\nNote: We are merging it here only for the explanation purpose. In the code, we will not merge the arrays.\nExample: 2\narr = {5, 7, 9, 11, 13, 16, 19, 22}\narr1 = {-4, 4, 7, 8, 10, 11, 12, 14}\n The median of these sorted arrays is 10.\nExplanation: When these sorted arrays are merged, we get the following.\nmergedArray = {-4, 4, 5, 7, 7, 8, 9, 10, 11, 11, 12, 13, 14, 16, 19, 22};\nThe size of the mergedArray is 16, which is even. Hence, there are two middle elements which are sitting at 16 / 2 = 8th and 16 / 2 - 1 = 7th indices. Thus, the median is (10 + 11) / 2 = 10.5.\nFileName: FindMedian.java\n// import statement  \nimport java.util.Arrays;  \n  public class FindMedian   \n{  \n  // A utility method to get the median of two integers  \nprivate float MOI2(int x, int y)   \n{  \nreturn (float) ((x + y) / 2.0);  \n}  \n  // A utility method to get the median of three integers  \nprivate float MOI3(int x, int y, int z)   \n{  \nreturn x + y + z - Math.max(x, Math.max(y, z)) - Math.min(x, Math.min(y, z));  \n}  \n  // A utility method to get the median of four integers  \nprivate float MOI4(int w, int x, int y, int z)   \n{  \nint max = Math.max(w, Math.max(x, Math.max(y, z)));  \nint min = Math.min(w, Math.min(x, Math.min(y, z)));  \nreturn (float) ((w + x + y + z - max - min) / 2.0);  \n}  \n  // a utility method to get the median of a single array  \nprivate float medSingle(int arr1[], int s)   \n{  \nif (s == 0)  \n{  \nreturn -1;  \n}  \nif (s % 2 == 0)  \n{  \nreturn (float) ((double) (arr1[s / 2] + arr1[s / 2 - 1]) / 2);  \n  }  \n  return arr1[s / 2];  \n}  \n  // The method assumes that s2 is less than or equal to s1  \n// the method returns -1 if both the arrays are empty  \nprivate float findMedUtil(int arr1[], int s2, int arr2[], int s1)   \n{  \n  // the median only lies in the second array if the  \n// first array is empty  \nif (s2 == 0)  \nreturn medSingle(arr1, s1);  \n  // only one element is present in the smaller array  \nif (s2 == 1)   \n{  \n  // Case 1: only one element is present in the larger array,  \n// simply call MO2()  \nif (s1 == 1)  \nreturn MOI2(arr1[0], arr2[0]);  \n  // Case 2: consider the middle 3 elements of larger array and  \n// the only element of smaller array, if the larger array   \n// has odd number of elements.   \nif (s1 % 2 == 1)  \n{  \nreturn MOI2(arr2[s1 / 2], (int) MOI3(arr1[0], arr2[s1 / 2 - 1], arr2[s1 / 2 + 1]));  \n}  \n  // Case 3: The following will be the three elements   \n// if the larger array has even number of elements  \n// ... The middle two elements of the larger array  \n// ... The only one element of the smaller array  \nreturn MOI3(arr2[s1 / 2], arr2[s1 / 2 - 1], arr1[0]);  \n}  \n  // two elements is present in the smaller array  \nelse if (s2 == 2)   \n{  \n  // Case 4: Invoke MOI4() when the larger array also has two elements  \nif (s1 == 2)  \n{  \nreturn MOI4(arr1[0], arr1[1], arr2[0], arr2[1]);  \n}  \n  // Case 5: when number of elements are present in the larger array are not multiple of 2  \n// then the median will be one of the following 3 elements  \n// 1. In the larger array, the element at the middle index  \n// 2. Maximum of the first element of the smaller array   \n//    and element just before the middle of the larger array  \n// 3. Minimum of the second element of the smaller array and   \n//    element just after the middle of the larger array  \nif (s1 % 2 == 1)  \n{  \nreturn MOI3(arr2[s1 / 2], Math.max(arr1[0], arr2[s1 / 2 - 1]), Math.min(arr1[1], arr2[s1 / 2 + 1]));  \n}  \n  // Case 6: when number of elements are present in the larger array are multiples of 2  \n// Then, the median eleement will be one the following four elements  \n// 1 & 2) two middle elements of the larger array  \n// 3) In the smaller array, the maximum of the first element and   \n//    the element that comes just before the first middle element present in the larger array  \n// 4. In the smaller array, the minimum of the second element and   \n//    element just after the second middle in the larger array  \nreturn MOI4(arr2[s1 / 2], arr2[s1 / 2 - 1], Math.max(arr1[0], arr2[s1 / 2 - 2]), Math.min(arr1[1], arr2[s1 / 2 + 1]));  \n}  \n  int indxa = (s2 - 1) / 2;  \nint indxb = (s1 - 1) / 2;  \n  /* \n* if a[indxa] <= b[indxb], then median \nmust be present in a[indxa....] and B[....indxb] \n*/  \nif (arr1[indxa] <= arr2[indxb])  \n{  \nreturn findMedUtil(Arrays.copyOfRange(arr1, indxa, arr1.length), s2 / 2 + 1, arr2, s1 - indxa);  \n}  \n  /* \n* if arr1[indxa] > arr2[indxb], then median \nmust be present in arr1[...indxa] and arr2[indxb....] \n*/  \nreturn findMedUtil(arr1, s2 / 2 + 1, Arrays.copyOfRange(arr2, indxb, arr2.length), s1 - indxa);  \n}  \n  // A wrapper method written around the findMedianUtil(). The method  \n// ensures that the smaller array is passed as first argument  \n// to findMedUtil  \npublic float findMedn(int arr1[], int s2, int arr2[], int s1)  \n{  \nif (s2 > s1)  \n{  \nreturn findMedUtil(arr2, s1, arr1, s2);  \n}  \n  return findMedUtil(arr1, s2, arr2, s1);  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// instantiating the class FindMedian  \nFindMedian obj = new FindMedian();  \n  int arr1[] = {-11, -10, -9, -2, 5, 17};  \nint arr2[] = {-4, 4, 7, 13, 16, 17, 19};  \n  int s2 = arr1.length;  \nint s1 = arr2.length;    \n  float f = obj.findMedn(arr1, s2, arr2, s1);  \n  System.out.println(\"The median element is: \" + f + \"\\n\");  \n    int arr3[] = {5, 7, 9, 11, 13, 16, 19, 22};  \nint arr4[] = {-4, 4, 7, 8, 10, 11, 12, 14};  \ns2 = arr3.length;  \ns1 = arr4.length;  \nf = obj.findMedn(arr3, s2, arr4, s1);  \n  System.out.println(\"The median element is: \" + f);  \n}  \n}  \nOutput:\nThe median element is: 5.0\n\nThe median element is: 10.5",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr = {7, 8, 9, 10, 0, 3, 4, 5, 6}; s = 9; tar = 3;\n 5.\nExplanation: the number 3 is present at the index 5.\nExample: 2\narr = {4, 5, 1, 2, 3}; s = 5; tar = 6;\n -1\nExplanation: the number 6 is not present in the array.\nFileName: FindElement.java\npublic class FindElement  \n{  \n  // when the array is rotated, we get two sorted arrays.  \n// for example {4, 5, 0, 1, 2, 3} has two sorted arrays  \n// {4, 5} and {0, 1, 2, 3}. In these two sorted arrays, one   \n// can apply the binary search to find the index of the target element.  \n// Therefore, our first task is to find the boundary which divides   \n// the given array into two subarrays which are sorted.  \n// Then, we will apply the binary search on these two subarrays to   \n// look for the target element.  \n  // a method that finds the element ele in the array a of length size  \npublic int findIndex(int a[], int size, int ele)  \n{  \nint first = a[0];  \nint last = a[size - 1];  \nint mid;  \nint min = 0;  \nint max = size - 1;  \n  // loop for finding the boundary  \nwhile(max - min != 1)  \n{  \nmid= (min + max) / 2;  \nif(a[mid] >= first)  \n{  \nmin = mid;  \n}  \nelse  \n{  \nmax = mid;  \n}  \n}  \n  // boundary found  \n// one subarray is 0 to min  \n// and another subarray is min + 1 to size - 1  \nint min1 = 0;  \nint min2 = min;  \n  // searching in the first subarray, which is sorted, using the binary search.  \nwhile(min1 <= min2)  \n{  \nmid = (min1 + min2)/2;  \nif(a[mid] == ele)  \n{  \nreturn mid;  \n}  \nelse if(a[mid] > ele)  \n{  \nmin2 = mid - 1;  \n}  \nelse  \n{  \nmin1 = mid + 1;  \n}  \n}  \n  min = min + 1;  \nmax= size - 1;  \n  // searching in the second subarray, which is also sorted, using the binary search.  \nwhile(min <= max)  \n{  \nmid = (min + max) / 2;  \nif(a[mid] == ele)  \n{  \nreturn mid;  \n}  \nelse if(a[mid] > ele)  \n{  \nmax = mid - 1;  \n}  \nelse  \n{  \nmin = mid + 1;  \n}  \n}  \n  // target element not found!!  \nreturn -1;  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// instantiating the class FindElement  \nFindElement obj = new FindElement();  \n  // input array   \nint arr[] = {7, 8, 9, 10, 0, 3, 4, 5, 6};  \nint s = arr.length;  \nint tar = 3; // number to be searched   \n  int index = obj.findIndex(arr, s, tar);  \n  if(index >= 0)  \n{  \nSystem.out.println(\"The target element \" + tar + \" is found at the index \" + index + \"\\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"The target element is not found! \\n\");     \n}  \n    // input array   \nint arr1[] = {34, 56, 67, 12, 13, 14, 15, 26, 28};  \ns = arr1.length;  \ntar = 19; // number to be searched   \n  index = obj.findIndex(arr1, s, tar);  \n  if(index >= 0)  \n{  \nSystem.out.println(\"The target element \" + tar + \" is found at the index \" + index + \"\\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"The target element is not found!\");     \n}  \n  }  \n  }  \nOutput:\nThe target element 3 is found at the index 5\n\nThe target element is not found!\nNote: The linear search will also do the job here. However, its time complexity would be more as compared to the binary search.",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr = {1, 2, 3, 4, 5, 5, 5, 5, 6, 7, 8, 9, 10}; s = 13; tar = 5;\n starting index: 4, ending index: 7\nExplanation: Between the indices 4 to 7, the number 5 is present.\nExample: 2\narr = {8, 10, 12, 56, 67, 70, 70, 70, 70, 75, 77, 78, 90, 93, 97}; s = 15; tar = 19;\n The target number 19 is not present in the given array\nFileName: FindRange.java\n// import statement  \nimport java.util.Arrays;  \n  public class FindRange  \n{  \n// a method that finds the range of the element target  \n// in the array a. if the element is not found an array {-1, -1}  \n// is returned. If the element is found, then the starting   \n// and ending index of the element is returned.  \npublic int[] findIndex(int a[], int size, int target)  \n{  \nint first = 0;  \nint last = size - 1;  \nint ans[] = {-1, -1}; // for storing the indices  \n  // loop for finding the starting index  \nwhile(first < last)  \n{  \nint mid = (first + last) / 2;  \nif(a[mid] < target)  \n{  \nfirst = mid + 1;  \n}  \nelse  \n{  \nlast = mid;  \n}  \n}  \n  // target element is  not found!  \n// hence {-1, -1} is returned  \nif(a[first] != target)  \n{  \nreturn ans;  \n}  \n  // target element is found!  \n// update the ans array  \nans[0] = first;  \nlast = size - 1;  \n  // loop for looking after the ending index  \nwhile(first < last)  \n{     \nint mid = (first + ((last - first) / 2)) + 1;  \nif(a[mid] > target)  \n{  \nlast = mid - 1;  \n}  \nelse  \n{  \nfirst = mid;  \n}  \n  }  \n  ans[1] = last;  \nreturn ans;  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// instantiating the class FindRange  \nFindRange obj = new FindRange();  \n  // input array   \nint arr[] = {1, 2, 3, 4, 5, 5, 5, 5, 6, 7, 8, 9, 10};  \nint s = arr.length;  \nint tar = 5; // number to be searched   \n  int index[] = obj.findIndex(arr, s, tar);  \n  if(index[0] >= 0)  \n{  \nSystem.out.println(\"Range of target element \" + tar + \" is: \" + Arrays.toString(index) + \"\\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"The target element is not found! \\n\");     \n}  \n    // input array   \nint arr1[] = {8, 10, 12, 56, 67, 70, 70, 70, 70, 75, 77, 78, 90, 93, 97};  \ns = arr.length;  \ntar = 19; // number to be searched   \n  int index1[] = obj.findIndex(arr1, s, tar);  \n  if(index1[0] >= 0)  \n{  \nSystem.out.println(\"Range of target element \" + tar + \" is: \" + Arrays.toString(index1) + \"\\n\");  \n}  \nelse  \n{  \nSystem.out.println(\"The target element is not found! \\n\");     \n}  \n    }  \n}  \nOutput:\nRange of target element 5 is: [4, 7]\n\nThe target element is not found!",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\nstr = \"ABC\";\n 2\nExplanation: Inserting \"B\" at the beginning, we get B + ABC ---> BABC.\nInserting \"C\" at the beginning, we get C + BABC ---> CBABC. Thus, there are 2 insert operations. Hence, the answer is 2.\nExample: 2\nstr = \"ABEBAAAA\";\n 3\nExplanation: Inserting \"A\" at the beginning, we get A + ABEBAAAA ---> AABEBAAAA.\nInserting \"A\" at the beginning, we get A + AABEBAAAA ---> AAABEBAAAA.\nInserting \"A\" at the beginning, we get A + AAABEBAAAA ---> AAAABEBAAAA.\nThus, there are 3 insert operations. Hence, the answer is 3.\nFileName: MakePalindrome.java\npublic class MakePalindrome  \n{  \npublic int minNoOfChars(String A)   \n{  \nint n = A.length();  \nint ans = n;  \nwhile(n > 1 && !isPalindrome(A, n))   \n{  \nn = n - 1;  \n}  \nreturn ans - n;  \n}  \n  public boolean isPalindrome(String A, int len)   \n{  \nint i = 0, j = len - 1;  \nwhile(i <= j && (A.charAt(i) == A.charAt(j)))   \n{  \ni = i + 1;  \nj = j - 1;  \n}  \nif(i > j)   \n{  \nreturn true;  \n}  \nreturn false;  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// instantiating the class MakePalindrome  \nMakePalindrome obj = new MakePalindrome();  \n  String str= \"ABC\";  \n  int noOfChars = obj.minNoOfChars(str);  \nstr = \"'ABC'\";  \n  System.out.println(noOfChars + \" insert operations are required to make \" + str + \" a palindrome string.\" + \"\\n\");  \n  str= \"ABEBAAAA\";  \n  noOfChars = obj.minNoOfChars(str);  \nstr = \"'ABEBAAAA'\";  \n  System.out.println(noOfChars + \" insert operations are required to make \" + str + \" a palindrome string.\" + \"\\n\");  \n  }  \n}  \nOutput:\n2 insert operations are required to make 'ABC' a palindrome string.\n\n3 insert operations are required to make 'ABEBAAAA' a palindrome string.",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example:\nWords = {\"It\", \"is\", \"the\", \"example\", \"of\", \"sorting\", \"technique\"}\nN = 16\n the formatted lines are:\n[  \n\"It     is    the\"  \n\"example       of\"  \n\"sorting         \"  \n\"technique       \"  \n]  \nFileName: TextJustified.java\n// import statement  \nimport java.util.*;  \n  public class TextJustified   \n{  \npublic ArrayList<String> fullJustify(ArrayList<String> words, int maxWidth)   \n{  \nArrayList<String> result = new ArrayList<String>();  \n  if(words == null || words.size() == 0)  \n{  \nreturn result;  \n}  \n    int count = 0;  \nint last = 0;  \nArrayList<String> list = new ArrayList<String>();  \nfor(int i = 0; i < words.size(); i++)  \n{  \ncount = count + words.get(i).length();  \n  if(count + i - last > maxWidth)  \n{  \nint wordsLen = count-words.get(i).length();  \nint spaceLen = maxWidth - wordsLen;  \nint eachLen = 1;  \nint extraLen = 0;  \n  if(i - last - 1 > 0)  \n{  \neachLen = spaceLen / (i - last - 1);  \nextraLen = spaceLen % (i - last - 1);  \n}  \n  StringBuilder sb = new StringBuilder();  \n  for(int k = last; k < i - 1; k++)  \n{  \nsb.append(words.get(k));  \n  int ce = 0;  \nwhile(ce < eachLen)  \n{  \nsb.append(\" \");  \nce = ce + 1;  \n}  \n  if(extraLen > 0)  \n{  \nsb.append(\" \");  \nextraLen = extraLen - 1;  \n}  \n}  \n  sb.append(words.get(i - 1)); // the last words of the line  \n  // only single word is possible in this line, required to fill the left with the spaces  \nwhile(sb.length() < maxWidth)  \n{  \nsb.append(\" \");  \n}  \n  result.add(sb.toString());  \n  last = i;  \ncount=words.get(i).length();  \n}  \n}  \n  int lastLen = 0;  \nStringBuilder sb = new StringBuilder();  \n  for(int i = last; i < words.size() - 1; i++)  \n{  \ncount = count + words.get(i).length();  \nsb.append(words.get(i) + \" \");  \n}  \n  sb.append(words.get(words.size() - 1));  \nint d = 0;  \nwhile(sb.length() < maxWidth)  \n{  \nsb.append(\" \");  \n}  \nresult.add(sb.toString());  \n  return result;  \n}  \npublic static void main(String argvs[])  \n{  \n  // instantiating the class TextJustified  \nTextJustified obj = new TextJustified();  \n  ArrayList<String> al = new ArrayList<String>  \n(  \nArrays.asList(\"It\", \"is\", \"the\", \"example\", \"of\", \"sorting\", \"technique\")  \n);  \nint n = 16;  \nal = obj.fullJustify(al, n);  \n  for(String str: al)  \n{  \nString s = \"'\";  \nSystem.out.println(s + str + s);  \n}  \n  }  \n}  \nOutput:\n'It     is    the'\n'example       of'\n'sorting         '\n'technique       '",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example:\narr[] ={2, 2, 2, 4, 6, 6, 6, 5, 4, 9, 9, 9, 0, 0, 4, 0}\n 5\nExplanation: Number 5 is only repeated once.\nFileName: UniqueNumber.java\n// import statement  \nimport java.util.Arrays;  \n  public class UniqueNumber  \n{  \n  // a method that finds the number that   \n// is repeated only once  \npublic int findNo(int arr[], int size)  \n{  \n  int singleRepeat = 0;  \nint doubleRepeat = 0;  \nint commonMask;  \n   for( int j = 0; j < size; j++)  \n{  \n  // bits that are coming twice  \ndoubleRepeat  = doubleRepeat | (singleRepeat & arr[j]);  \n  // bits that are coming once  \nsingleRepeat  = singleRepeat ^ arr[j];  \n  // bits that common in singleReapt and doubleRepeat  \n// only possible in those number which are getting  \n// repeat thrice  \ncommonMask = (singleRepeat & doubleRepeat);  \n  // eliminating the common bits  \nsingleRepeat &= ~commonMask;  \n  doubleRepeat &= ~commonMask;  \n  }  \n  return singleRepeat;  \n    }  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// instantiating the class UniqueNumber  \nUniqueNumber obj = new UniqueNumber();  \n  // input array   \nint arr[] = {2, 2, 2, 4, 6, 6, 6, 5, 4, 9, 9, 9, 0, 0, 4, 0};  \nint s = arr.length;  \nint uniqueNo = obj.findNo(arr, s);  \nSystem.out.println(\"Array is: \" + Arrays.toString(arr));  \nSystem.out.println(\"The unique number is: \" + uniqueNo + \"\\n\");  \n  int arr1[] = {6, 6, 6, 1, 1, 1, 4, 4, 4, 12, 0, 0, 0};  \ns = arr1.length;  \nuniqueNo = obj.findNo(arr1, s);  \nSystem.out.println(\"Array is: \" + Arrays.toString(arr1));  \nSystem.out.println(\"The unique number is: \" + uniqueNo + \"\\n\");  \n  }  \n}  \nOutput:\nArray is: [2, 2, 2, 4, 6, 6, 6, 5, 4, 9, 9, 9, 0, 0, 4, 0]\nThe unique number is: 5\n\nArray is: [6, 6, 6, 1, 1, 1, 4, 4, 4, 12, 0, 0, 0]\nThe unique number is: 12",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example:\narr[] = {2, 1, 0}\n {0, 1, 2};\nExplanation: arr[0] = 2 => arr[arr[0]] becomes arr[2] = 0;\narr[1] = 1 => arr[arr[1]] = arr[1] = 1\narr[2] = 0 => arr[arr[2]] = arr[0] = 2\nThus, the updated array is {0, 1, 2}\nFileName: RearrangeArray.java\n// import statement  \nimport java.util.Arrays;  \n  public class RearrangeArray  \n{  \n  // method for rearranging the elements  \npublic int[] rearrange(int a[], int size)  \n{  \n// Increase every Array element Arr[i] by (Arr[Arr[i]] % size) * size  \nfor (int i = 0; i < size; i++)  \n{  \na[i] = ((a[a[i]] % size) * size) + a[i];  \n}  \n  // Divide every element by size.  \nfor (int i = 0; i < size; i++)  \n{  \na[i] = a[i] / size;  \n}  \nreturn a;  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \nRearrangeArray obj = new RearrangeArray();  \n  int a[] = {2, 1, 0};  \nint size = a.length;  \nSystem.out.println(\"Array before rearranging is: \" + Arrays.toString(a));  \nint res[] = obj.rearrange(a, size);  \n  System.out.println(\"Array after rearranging is: \" + Arrays.toString(res) + \"\\n\");  \n  int arr[] = {2, 4, 3, 1, 0};  \nsize = arr.length;  \nSystem.out.println(\"Array before rearranging is: \" + Arrays.toString(arr));  \nint res1[] = obj.rearrange(arr, size);  \n  System.out.println(\"Array after rearranging is: \" + Arrays.toString(res1));  \n  }  \n}  \nOutput:\nArray before rearranging is: [2, 1, 0]\nArray after rearranging is: [0, 1, 2]\n\nArray before rearranging is: [2, 4, 3, 1, 0]\nArray after rearranging is: [3, 0, 1, 4, 2]\nNote: if the O(1) space complexity condition is removed, then the problem is straightforward. One can create an array of the same size as of input array and can copy the values of a[a[i]] to the recently created array. The O(1) space complexity makes the problem tricky.",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\nn = 20\n 2\nExplanation: The binary representation of 20 is 10100. The total number of trailing zeros present in 10100 is 2. Hence, the answer is 2.\nExample: 2\nn = 9\n 0\nExplanation: The binary representation of 9 is 1001. The total number of trailing zeros present in 1001 is 0. Hence, the answer is 0.\nFileName: TrailingZeros.java\npublic class TrailingZeros  \n{  \npublic int countZeros(int n)  \n{  \n// array for storing the bits of the number  \nint arr[] = new int[n];  \nint index = 0;  \n  // loop for converting the number into its binary representation  \nwhile(n != 0)  \n{  \n    int bit = n % 2;  \n    arr[index] = bit;  \n    index = index + 1;  \n    n = n / 2;  \n}  \n  // for counting trailing zeros  \nint count = 0;  \n  int size = arr.length;  \nfor(int i = 0; i < size; i++)  \n{  \n    if(arr[i] == 0)  \n    {  \n        count = count + 1;  \n    }  \n    else  \n    {  \n        break;  \n    }  \n}  \n  return count;  \n  }  \n  // main method  \npublic static void main(String argvs[])  \n{  \nTrailingZeros obj = new TrailingZeros();  \n  int n = 20;  \n  int countZeros = obj.countZeros(n);  \n  System.out.println(\"For number \" + n + \", there are \" + countZeros + \" trailing zeros.\");  \n  n = 64;  \n  countZeros = obj.countZeros(n);  \n  System.out.println(\"For number \" + n + \", there are \" + countZeros + \" trailing zeros.\");  \n    n = 3;  \n  countZeros = obj.countZeros(n);  \n  System.out.println(\"For number \" + n + \", there are \" + countZeros + \" trailing zeros.\");  \n  }  \n}  \nOutput:\nFor number 20, there are 2 trailing zeros.\nFor number 64, there are 6 trailing zeros.\nFor number 3, there are 0 trailing zeros.",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\nn = 1\n 1\nExplanation: The binary representation of 1 is 1, and 1 is a palindrome. 1 is also the 1st number.\nExample: 2\nn = 3\n 5\nExplanation: The 3rd number whose binary representation is a palindrome is 5. Its binary representation is 101.\nExample: 3\nn = 9\n 27\nExplanation: The 9th number whose binary representation is a palindrome is 27. Its binary representation is 11011.\nFileName: PalindromeNumbers.java\n// import statement  \nimport java.util.*;  \n  public class PalindromeNumbers   \n{  \n// converting the binary string into an integer  \npublic static int changeStringToInt(String str)  \n{  \nint a = 0;  \n  // loop for converting the binary string into integer  \nfor (int j = 0; j < str.length(); j++)   \n{  \nif (str.charAt(j) == '1')  \n{  \na += 1 << j;  \n}  \n}  \nreturn a;  \n}  \n  // a method for finding the nth number  \n// whose binary representation is a palindrome  \npublic static int findNthNumber(int no)  \n{  \n// stores the binary palindrome string  \nQueue<String> que = new LinkedList<>();  \n  // base case  \nif (no == 1)  \nreturn 1;  \nno = no - 1;  \n  // adding the second palindrome string  \nque.add(\"11\");  \n  while (no-- > 0)   \n{  \n  // removing the current binary palindrome string   \n// from the queue  \nString current = que.remove();  \n  if (no == 0)  \n{  \nreturn changeStringToInt(current);  \n}  \n  int l = current.length();  \n  // if the length is even, then we have to choices  \n// for example 11 -> 101 or 111  \nif (l % 2 == 0)   \n{  \nque.add(current.substring(0, l / 2) + \"0\" + current.substring(l / 2));  \nque.add(current.substring(0, l / 2) + \"1\" + current.substring(l / 2));  \n}  \n  // if the length is odd, then we have only one choice  \n// for example 1 -> 111  \nelse   \n{  \nchar midCh = current.charAt(l / 2);  \nque.add(current.substring(0, l / 2) + midCh  \n+ current.substring(l / 2));  \n}  \n}  \nreturn -1;  \n}  \n  // main method  \npublic static void main(String[] argvs)  \n{  \nint n = 7;  \nint no = findNthNumber(n);  \nSystem.out.println(\"The \" + n + \"th number whose binary representation is palindrome is: \" + no);  \n  n = 13;  \nno = findNthNumber(n);  \nSystem.out.println(\"The \" + n + \"th number whose binary representation is palindrome is: \" + no);  \n  }  \n}  \nOutput:\nThe 7th number whose binary representation is palindrome is: 17\nThe 13th number whose binary representation is palindrome is: 51",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example:\narr[] = {1, 4, -1, -4, 6, 4, 7, 8}; w = 3;\n {4, 4, 6, 6, 7, 8}\nExplanation:\n{[1, 4, -1,] -4, 6, 4, 7, 8} -> max(1, 4, -1) = 4\n{1, [4, -1, -4,] 6, 4, 7, 8} -> max(4, -1, -4) = 4\n{1, 4, [-1, -4, 6,] 4, 7, 8} -> max(-1, -4, 6) = 6\n{1, 4, -1, [-4, 6, 4,] 7, 8} -> max(-4, 6, 4) = 6\n{1, 4, -1, -4, [6, 4, 7,] 8} -> max(6, 4, 7) = 7\n{1, 4, -1, -4, 6, [4, 7, 8]} -> max(4, 7, 8) = 8\nFileName: SlidingWindowMax.java\n// import statement  \nimport java.util.*;  \n  public class SlidingWindowMax   \n{  \n// Uses a doubled-ended queue. When going through the array, we only care about the  \n// largest elements we receive. Any smaller element that came before the current   \n// one is no longer required. Essentially our queue must always be in descending order.  \npublic static ArrayList<Integer> slidingMaximum(List<Integer> A, int B)   \n{  \nDeque<Integer> window = new LinkedList<Integer>();  \nArrayList<Integer> result = new ArrayList<Integer>();  \nfor (int i = 0; i < A.size(); i++)   \n{  \nint val = A.get(i);  \n// Remove all elements smaller than the current one from the queue  \nwhile (!window.isEmpty() && val >= A.get(window.getLast()))   \n{  \nwindow.removeLast();  \n}  \n// Add the current element's index to the queue. It is important that we  \n// store the indices rather than the values.  \nwindow.add(i);  \n// The first element of the queue is always the largest. If the index of   \n// this number is smaller than the window's stating index, then we remove it  \nif (window.getFirst() < (i + 1) - B)   \n{  \nwindow.removeFirst();  \n}  \n// Ignores the first few interations  \nif (i >= B - 1)  \n{  \nresult.add(A.get(window.getFirst()));  \n}  \n}  \nreturn result;  \n}  \n            // main method  \npublic static void main(String argvs[])  \n{  \n  ArrayList<Integer> arr = new ArrayList<Integer>  \n(  \nArrays.asList(1, 4, -1, -4, 6, 4, 7, 8)  \n);  \n  int b = 3;  \n  System.out.println(\"The array is: \" + arr + \"\\n\");  \n  arr = slidingMaximum(arr, b);  \n  System.out.println(\"The maximum values are: \" + arr);  \n    }  \n  }  \nOutput:\nThe array is: [1, 4, -1, -4, 6, 4, 7, 8]\n\nThe maximum values are: [4, 4, 6, 6, 7, 8]",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example:\nA = [\"4\", \"3\", \"+\", \"5\", \"*\"]\n 35\nExplanation:\n* -> () * ()\n5: -> () * (5)\n+: (() + ()) * (5)\n3: (() + (3)) * (5)\n4: ((4) + (3)) * (5)\n= (7) * (5) = 35\nFileName: EvaluateExpression.java\n// import statement  \nimport java.util.*;  \n  public class EvaluateExpression   \n{  \npublic static int evaluateExp(ArrayList<String> al)   \n{  \nStack<Integer> stk = new Stack<>();  \n  for(String st : al)   \n{  \nif(st.equals(\"+\") || st.equals(\"-\") || st.equals(\"*\") || st.equals(\"/\"))   \n{  \n// fetching first two numeric values from the right  \n// of the array list  \nint n1 = stk.pop();  \nint n2 = stk.pop();  \n  // switch case for handling the operation  \nswitch(st)   \n{  \ncase \"+\" :   \nint s = n1 + n2;  \n  // after performing the operation add the value to the stack  \nstk.push(s);  \nbreak;  \ncase \"-\" :   \nint d = n2 - n1;  \nstk.push(d);  \nbreak;  \ncase \"*\" :   \nint m = n1 * n2;  \nstk.push(m);  \nbreak;  \ncase \"/\" :   \nint div = n2 / n1;  \nstk.push(div);  \n}  \n}  \nelse   \n{  \nstk.push(Integer.parseInt(st));  \n}  \n}  \n  return stk.pop();  \n}  \n// main method  \npublic static void main(String argvs[])  \n{  \n  ArrayList<String> exp = new ArrayList<String>  \n(  \nArrays.asList(\"4\", \"3\", \"+\", \"5\", \"*\")  \n);  \n      System.out.println(\"The expression is: \" + exp + \"\\n\");  \n  int ans = evaluateExp(exp);  \n  System.out.println(\"The value of the expression is: \" + ans + \"\\n\");  \n  exp = new ArrayList<String>  \n(  \nArrays.asList(\"4\", \"13\", \"5\", \"/\", \"+\")  \n);  \n      System.out.println(\"The expression is: \" + exp + \"\\n\");  \n  ans = evaluateExp(exp);  \n  System.out.println(\"The value of the expression is: \" + ans);  \n    }  \n  }  \nOutput:\nThe expression is: [4, 3, +, 5, *]\n\nThe value of the expression is: 35\n\nThe expression is: [4, 13, 5, /, +]\n\nThe value of the expression is: 6",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example:\nN = 3;\n {0, 1, 3, 2, 6, 7, 5, 4}\n0 0 0 ---> 0\n0 0 1 ---> 1\n0 1 1 ---> 3\n0 1 0 ---> 2\n1 1 0 ---> 6\n1 1 1 ---> 7\n1 0 1 ---> 5\n1 0 0 ---> 4\nFileName: GrayCode.java\n// import statement  \nimport java.util.*;  \n  public class GrayCode   \n{  \n    public ArrayList<Integer> findSeq(int a)   \n    {  \n        ArrayList<Integer> res = new ArrayList<Integer>();  \n        if(a == 0)  \n        {  \n            return res;  \n        }  \n                  // first two gray sequence are always 0 and 1  \n        res.add(0);  \n        res.add(1);  \n                  if(a== 1)  \n        {  \n            return res;  \n        }  \n        while(a > 1)  \n        {  \n            int s = res.size();  \n            for(int i = s - 1; i >= 0; i--)  \n            {  \n                res.add(s + res.get(i));  \n            }  \n            a = a - 1;  \n        }  \n                  return res;  \n    }  \n      // main method  \npublic static void main(String argvs[])  \n{  \n  int n = 3;  \nGrayCode obj = new GrayCode();  \n  ArrayList<Integer> al = obj.findSeq(n);  \n  System.out.println(\"For n = \" + n + \", the gray code sequence is: \" + al + \"\\n\");  \n  n = 4;  \nal = obj.findSeq(n);  \n  System.out.println(\"For n = \" + n + \", the gray code sequence is: \" + al + \"\\n\");  \n  n = 5;  \nal = obj.findSeq(n);  \n  System.out.println(\"For n = \" + n + \", the gray code sequence is: \" + al + \"\\n\");  \n  }  \n  }  \nOutput:\nFor n = 3, the gray code sequence is: [0, 1, 3, 2, 6, 7, 5, 4]\n\nFor n = 4, the gray code sequence is: [0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8]\n\nFor n = 5, the gray code sequence is: [0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8, 24, 25, 27, 26, 30, 31, 29, 28, 20, 21, 23, 22, 18, 19, 17, 16]",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example:\narr = {-2, 0, 2, 4, -2, -4};\n There are three unique triplets. {-2, 0, 2}, {-2, -2, 4}, {-4, 0, 4}\nFileName: FindTriplets.java\n// import statement  \nimport java.util.*;  \n  public class FindTriplet   \n{  \n// a method that finds the unqiue triplets whose sum is zero  \npublic ArrayList<ArrayList<Integer>> threeSumZero(ArrayList<Integer> A)   \n{  \nint B = 0;  \n  // for storing the unique triplets  \nArrayList<ArrayList<Integer>> total = new ArrayList();  \n    // sorting the list  \nCollections.sort(A);  \nint i = 0;  \n  // loop that uses three pointer approach  \nwhile(i < A.size())  \n{  \nint j = i + 1, k = A.size() - 1;  \n  while(j < k)   \n{  \nlong sum = (long)A.get(i) + (long)A.get(j) + (long)A.get(k);  \n  if(sum == B)  \n{  \nArrayList<Integer> ans = new ArrayList();  \nans.add(A.get(i));  \nans.add(A.get(j));  \nans.add(A.get(k));  \n  // checks whether the found triplet is unique or not  \n// if unique, then add it; otherwise, discard it.  \nif(!total.contains(ans))  \n{  \ntotal.add(ans);  \n}  \n}  \nif(sum > B)   \n{  \nk = k - 1;  \n}  \n  else   \n{  \nj = j + 1;  \n}  \n}  \n  i = i + 1;  \n}  \nreturn total;  \n}  \n      // main method  \npublic static void main(String argvs[])  \n{  \n  // creating an object of the class FindTriplet   \nFindTriplet obj = new FindTriplet();  \nArrayList<Integer> al = new ArrayList<Integer>  \n(  \nArrays.asList(-2, 0, 2, 4, -2, -4)  \n);  \n    ArrayList<ArrayList<Integer>> triplets = obj.threeSumZero(al);  \n  System.out.println(\"For the list: \" + al);  \nSystem.out.println(\"Triplets are: \" + triplets + \"\\n\");  \n    al = new ArrayList<Integer>  \n(  \nArrays.asList(1, -4, 0, 0, 5, -5, 1, 0, -2, 4, -4, 1, -1, -4, 3, 4, -1, -1, -3)  \n);  \n  triplets = obj.threeSumZero(al);  \n  System.out.println(\"For the list: \" + al);  \nSystem.out.println(\"Triplets are: \" + triplets + \"\\n\");  \n  }  \n  }  \nOutput:\nFor the list: [-4, -2, -2, 0, 2, 4]\nTriplets are: [[-4, 0, 4], [-2, -2, 4], [-2, 0, 2]]\n\nFor the list: [-5, -4, -4, -4, -3, -2, -1, -1, -1, 0, 0, 0, 1, 1, 1, 3, 4, 4, 5]\nTriplets are: [[-5, 0, 5], [-5, 1, 4], [-4, -1, 5], [-4, 0, 4], [-4, 1, 3], [-3, -2, 5], [-3, -1, 4], [-3, 0, 3], [-2, -1, 3], [-2, 1, 1], [-1, 0, 1], [0, 0, 0]]",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr = {5, 1, 2, 3};\n 9\nExplanation: There are 4 vertical lines in the given array, which are of height 5, 1, 2, and 3, respectively. Also, 5 and 3 are 3 distances apart. So, the capacity is min(5, 3) * 3 = 9. If we take any other pair of the vertical lines, we do not get a capacity of more than 9.\nFileName: ContainerCapacity.java\n// import statement  \nimport java.util.*;  \n  public class ContainerCapacity   \n{  \n// a method that finds the maximum capacity  \npublic int findMaxCapacity(ArrayList<Integer> height)   \n{  \nint len = height.size();  \nint low = 0;  \nint high = len -1 ;    \nint maxArea = 0;    \nwhile (low < high)   \n{    \nmaxArea = Math.max(maxArea, (high - low) * Math.min(height.get(low), height.get(high)));    \nif (height.get(low) < height.get(high))   \n{    \nlow = low + 1;    \n}   \nelse   \n{    \nhigh = high - 1;    \n}    \n}    \nreturn maxArea;  \n}  \n      // main method  \npublic static void main(String argvs[])  \n{  \n  // creating an object of the class ContainerCapacity   \nContainerCapacity obj = new ContainerCapacity();  \nArrayList<Integer> al = new ArrayList<Integer>  \n(  \nArrays.asList(5, 1, 2, 3)  \n);  \n  int capacity = obj.findMaxCapacity(al);  \n  System.out.println(\"For the list: \" + al);  \nSystem.out.println(\"The maximum capacity is: \" + capacity + \"\\n\");  \n  }  \n}  \nOutput:\nFor the list: [5, 1, 2, 3]\nThe maximum capacity is: 9",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr = {5, 1, 2, 3, 2, 5, 9, 8, 0, 0, 0}; J = 3\n {3, 3, 2, 3, 3, 3, 3, 2, 1}\nExplanation: All the windows of size J, which is 3, are:\n{5, 1, 2} ---> 3 unique numbers\n{1, 2, 3} ---> 3 unique numbers\n{2, 3, 2} ---> 2 unique numbers\n{3, 2, 5} ---> 3 unique numbers\n{2, 5, 9} ---> 3 unique numbers\n{5, 9, 8} ---> 3 unique numbers\n{9, 8, 0} ---> 3 unique numbers\n{8, 0, 0} ---> 2 unique numbers\n{0, 0, 0} ---> 1 unique number\nIf we make a list of unique elements, we get {3, 3, 2, 3, 3, 3, 3, 2, 1}.\nFileName: UniqueNumbers.java\n// import statement  \nimport java.util.*;  \n  public class UniqueNumbers   \n{  \n// a method that finds count of unique numbers in the window of size B  \npublic ArrayList<Integer> uniqueNums(ArrayList<Integer> A, int B)   \n{  \n          HashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();  \n  int i = 0;  \nint j = 0;  \nArrayList<Integer> result = new ArrayList<Integer>();  \n  while(j < A.size())  \n{  \nhm.put(A.get(j), hm.getOrDefault(A.get(j), 0) + 1);  \n  if(B<(j - i + 1))  \n{  \n  hm.put(A.get(i), hm.getOrDefault(A.get(i), 0)-1);  \n  if(hm.get(A.get(i))==0)  \nhm.remove(A.get(i));  \n  i = i + 1;   \n}  \nif(B==(j-i+1))  \n{  \n  result.add(hm.size());  \n}  \nj = j + 1;  \n}  \nreturn result;  \n}  \n      // main method  \npublic static void main(String argvs[])  \n{  \n  // creating an object of the class UniqueNumbers   \nUniqueNumbers obj = new UniqueNumbers();  \nArrayList<Integer> al = new ArrayList<Integer>  \n(  \nArrays.asList(5, 1, 2, 3, 2, 5, 9, 8, 0, 0, 0)  \n);  \nInteger J = 3;  \n    System.out.println(\"For the list: \" + al);  \nal = obj.uniqueNums(al, J);  \n  System.out.println(\"The list of unique numbers are: \" + al + \"\\n\");  \n    al = new ArrayList<Integer>  \n(  \nArrays.asList(5, 6, 7, 3, 3, 3, 1)  \n);  \nJ = 1;  \n  System.out.println(\"For the list: \" + al);  \nal = obj.uniqueNums(al, J);  \n  System.out.println(\"The list of unique numbers are: \" + al + \"\\n\");  \n  }  \n}  \nOutput:\nFor the list: [5, 1, 2, 3, 2, 5, 9, 8, 0, 0, 0]\nThe list of unique numbers are: [3, 3, 2, 3, 3, 3, 3, 2, 1]\n\nFor the list: [5, 6, 7, 3, 3, 3, 1]\nThe list of unique numbers are: [1, 1, 1, 1, 1, 1, 1]",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\narr = {-2, 0, 2, 4, -2, -4};\n {0, 1, 2, 5}\nExplanation: Values at the indices 0, 1, 2, and, 5 are -2, 0, 2, and, -4 respectively, and\n-2 + 0 = 2 + -4 => 2. Other answer can be {0, 2, 3, 5}, or {1, 2, 3, 4}\nFileName: EqualSum.java\n// import statement  \nimport java.util.*;  \n  public class EqualSum   \n{  \npublic ArrayList<Integer> findInidices(ArrayList<Integer> A)   \n{  \n// a map whose key is an integer and value is an array list  \n// the array list contains the indices such that sum of values   \n// at those indices is equal to the key  \n// for example - A = [9, 4, 3, 2]  \n// map[13, [0, 1]];  \n// Now, 13 = A[0] + A[1] = 9 + 4 = 13  \nMap<Integer, ArrayList<Integer>> map = new HashMap<>();  \n  // for storing those 4 indices such that A[i] + A[j] = A[k] + A[l]  \nArrayList<Integer> result = new ArrayList<>();  \nfor(int i = 0; i < A.size() - 1; i++)  \n{  \nfor(int j = i + 1; j < A.size(); j++)  \n{  \nint sum = A.get(i) + A.get(j);  \nif(map.containsKey(sum))  \n{  \n// the k and l must be unique  \n// it is obivous that A[i] + A[j] = A[j] + A[i]  \n//   \nint k = map.get(sum).get(0);  \nint l = map.get(sum).get(1);  \nif(k == i || k == j || l == i || l == j)   \n{  \ncontinue;  \n}  \nmap.get(sum).addAll(Arrays.asList(i,j));  \n}  \nelse map.put(sum,new ArrayList<>(Arrays.asList(i,j)));  \n}  \n}  \nfor(int i = 0;i < A.size() - 1; i++)  \n{  \nfor(int j = i + 1; j < A.size(); j++)  \n{  \nint sum = A.get(i) + A.get(j);  \n// size greater than two means   \n// we have found our four indices  \nif(map.get(sum).size() > 2)  \n{  \nresult.addAll(Arrays.asList(i, j, map.get(sum).get(2), map.get(sum).get(3)));  \nreturn result;  \n}  \n}  \n}  \nreturn new ArrayList<>();  \n}  \n  public static void main(String args[])  \n{   \n// creating an object of the class EqualSum  \nEqualSum obj = new EqualSum();  \n    ArrayList<Integer> al = new ArrayList<Integer>  \n(  \nArrays.asList(-2, 0, 2, 4, -2, -4)  \n);  \n  System.out.println(\"For the list: \" + al);  \nal = obj.findInidices(al);  \n  System.out.println(\"The list of indices are: \" + al + \"\\n\");  \n  al = new ArrayList<Integer>  \n(  \nArrays.asList(2, 4, 5, 9, -1, 15, 7)  \n);  \n  System.out.println(\"For the list: \" + al);  \nal = obj.findInidices(al);  \n  System.out.println(\"The list of indices are: \" + al + \"\\n\");  \n    }  \n}  \nOutput:\nFor the list: [-2, 0, 2, 4, -2, -4]\nThe list of indices are: [0, 1, 2, 5]\n\nFor the list: [2, 4, 5, 9, -1, 15, 7]\nThe list of indices are: [0, 1, 4, 6]",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example: 1\nS = \"APPLBEXODEBLBNC\"\nX = \"LNC\"\n \"LBNC\"\nExplanation: Any other window will take more characters. The window of minimum size is mentioned in the answer.\nFileName: SmallestWindow.java\n// import statement  \nimport java.util.*;  \n  public class SmallestWindow   \n{  \n      int[] a;  \n    int[] b;  \npublic String minWindow(String A, String B)   \n{  \n// for storing the frequency of characters  \na = new int[256];  \nb = new int[256];  \nfor(char c: B.toCharArray())  \n{  \n// storing the frequency of occurrance of   \n// characters in the array b   \nb[(int)c]++;  \n}  \nint n = A.length();  \nint l = 0;  \nint x = -1;  \nint y = n + 1;  \nfor(int r = 0; r < n; r++)  \n{  \nchar c = A.charAt(r);  \na[(int)c]++;  \n  while(l <= r && good(A.charAt(l)))  \n{  \na[(int)A.charAt(l)]--;  \nl = l + 1;  \n}  \nif(good() && (r - l) < (y - x))  \n{  \ny = r;  \nx = l;  \n}  \n  }  \n  if(x == -1 && y == n + 1)  \n{  \nreturn \"\";  \n}  \n  return A.substring(x, y + 1);  \n  }  \npublic boolean good(char c)  \n{  \nfor(int i = 0; i < 256; i++)  \n{  \nif(a[i] < b[i])  \n{  \nreturn false;  \n}  \n}  \n  return (a[(int)c] - b[(int)c] >= 1);  \n}  \npublic boolean good()  \n{  \n// frequency of occurrance charcters in the String A   \n// has to be greater than or equal to the frequency of characters   \n// present in the string B  \nfor(int i = 0; i < 256; i++)  \n{  \nif(a[i] < b[i])  \n{  \nreturn false;  \n}  \n}  \n  return true;  \n}  \n        // main method  \npublic static void main(String args[])  \n{   \n  // creating an object of the class SmallestWindow  \nSmallestWindow obj = new SmallestWindow();  \n  String str = \"APPLBEXODEBLBNC\";  \nString t = \"LNC\";  \n  String ans = obj.minWindow(str, t);  \n  str = \"'APPLBEXODEBLBNC'\";  \nSystem.out.println(\"For the string: \" + str);  \n  System.out.println(\"The smallest window is: \" + ans + \"\\n\");  \n  }  \n}  \nOutput:\nFor the string: 'APPLBEXODEBLBNC'\nThe smallest window is: LBNC",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "What is the length of the longest subsequence, which is first increasing and then decreasing?",
        "answer": "Example:\narr = {2, 11, 3, 10, 5, 4, 3, 2, 1}; l = 9\n 8\nExplanation: The longest subsequence which is increasing and then decreasing is {2, 3, 10, 5, 4, 3, 2, 1}. There are 8 elements in it. Hence, the answer is 8.\nFileName: LongestSubsequence.java\n// import statement  \nimport java.util.*;  \n  public class LongestSubsequence   \n{  \n// DO NOT MODIFY THE LIST. IT IS READ ONLY  \npublic int longestSubsequenceLength(final List<Integer> A)   \n{  \n// list for containing the total number of elements in the increasing part  \nList<Integer> leftLIS = new ArrayList<>();  \n  // list for containing the total number of elements in the decreasing part  \nList<Integer> rightLIS = new ArrayList<>();  \n  if(A.isEmpty())  \n{  \nreturn 0;  \n}  \n  int size = A.size();  \n  // initializing the array  \nfor(int i = 0 ; i < size ; i++)   \n{  \nleftLIS.add(i, 1);  \nrightLIS.add(i, 1);  \n}  \n  int max = 0;  \n  // loop for considering the increasing part  \nfor(int i = 0 ; i < size ; i++)   \n{  \nfor(int j = 0 ; j < i ; j++)   \n{  \nif(A.get(i) > A.get(j))   \n{  \nleftLIS.set(i, Math.max(leftLIS.get(i), leftLIS.get(j) + 1));  \n}  \n}  \n}  \n  // loop for considering the decreasing part  \nfor(int i = size - 2 ; i >= 0; i -- )  \n{  \nfor(int j = size - 1 ; j > i ; j--)   \n{  \nif(A.get(i) > A.get(j))   \n{  \nrightLIS.set(i, Math.max(rightLIS.get(i), rightLIS.get(j) + 1));  \n}  \n}  \n}  \n  // one part contains the increasing part  \n// other part contains the decreasing part  \n// Therefore, we have to combine the value from both the list  \n// The following loop does the same work and then finds the maximum  \n// In order to remove the redundant element -1 is used  \nfor(int i = 0 ; i < size ; i++)   \n{  \n// if max is less the sum of values from leftLIS, rightLIS, and - 1  \n// then update the max  \nif(max < (leftLIS.get(i) + rightLIS.get(i)) - 1)   \n{  \nmax = (leftLIS.get(i) + rightLIS.get(i)) - 1;  \n}  \n}  \nreturn max;  \n}  \n    // main method  \npublic static void main(String argvs[])  \n{  \n// creating an object of the class LongestSubsequence  \nLongestSubsequence obj = new LongestSubsequence();  \n  ArrayList<Integer> al = new ArrayList<Integer>  \n(  \nArrays.asList(2, 11, 3, 10, 5, 4, 3, 2, 1)  \n);  \n  int val = obj.longestSubsequenceLength(al);  \n  System.out.println(\"For the list: \" + al);  \nSystem.out.println(\"The length of subsquence which is increasing and then decreasing is: \" + val + \"\\n\");  \n  al = new ArrayList<Integer>  \n(  \nArrays.asList(7, 6, 8, 10, 2, 5, 12, 30, 31, 20, 22, 18)  \n);  \n  val = obj.longestSubsequenceLength(al);  \n  System.out.println(\"For the list: \" + al);  \nSystem.out.println(\"The length of subsequence which is increasing and then decreasing is: \" + val);  \n  }  \n}  \nOutput:\nFor the list: [2, 11, 3, 10, 5, 4, 3, 2, 1]\nThe length of subsequence which is increasing and then decreasing is: 8\n\nFor the list: [7, 6, 8, 10, 2, 5, 12, 30, 31, 20, 22, 18]\nThe length of subsequence which is increasing and then decreasing is: 8",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Example:\nX = {2, 3, 5, 7}; S = 15\n 10\nExplanation: There are 10 ways to get the sum S = 15. Following are those 10 ways:\n2 + 2 + 2 + 2 + 2 + 2 + 3 = 15\n2 + 2 + 2 + 3 + 3 + 3 = 15\n2 + 2 + 2 + 2 + 2 + 5 = 15\n2 + 3 + 5 + 5 = 15\n2 + 2 + 3 + 3+ 5 = 15\n2 + 2 + 2 + 2 + 7 = 15\n2 + 3 + 3 + 7 = 15\n3 + 3 + 3 + 3 + 3 = 15\n3 + 5 + 7 = 15\n5 + 5 + 5 = 15\nFileName: CoinSum.java\n// import statement  \nimport java.util.*;  \n  public class CoinSum   \n{  \npublic int countWays(ArrayList<Integer> A, int B)   \n{  \n// the value of dp[j] represent the  \n// number of ways to get the sum j  \nint dp[] = new int[B + 1];  \nArrays.fill(dp, 0);  \n          dp[0] = 1;  \n          for(int i = 0; i < A.size(); i++)  \n{  \nfor(int j = A.get(i); j <= B; j++)  \n{  \n// finding the number of ways when   \n// A[i] is included  \ndp[j] = dp[j] + dp[j - A.get(i)];  \n                  // finding number of ways when A[i]  \n// is excluded  \ndp[j] = dp[j];  \n}  \n}  \n          return dp[B];  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// creating an object of the class CoinSum  \nCoinSum obj = new CoinSum();  \n  ArrayList<Integer> X = new ArrayList<Integer>  \n(  \nArrays.asList(2, 3, 5, 7)  \n);  \n  int sum = 15;  \n    int ways = obj.countWays(X, sum);  \n  System.out.println(\"For the set of coins: \" + X);  \nSystem.out.println(\"There are \" + ways + \" ways to get the sum \" + sum + \"\\n\");  \n  X = new ArrayList<Integer>  \n(  \nArrays.asList(4, 6, 8, 9, 10)  \n);  \n  sum = 90;  \n    ways = obj.countWays(X, sum);  \n  System.out.println(\"For the set of coins: \" + X);  \nSystem.out.println(\"There are \" + ways + \" ways to get the sum \" + sum);  \n    }  \n}  \nOutput:\nFor the set of coins: [2, 3, 5, 7]\nThere are 10 ways to get the sum 15\n\nFor the set of coins: [4, 6, 8, 9, 10]\nThere are 385 ways to get the sum 90",
        "reference": "javatpoint.com",
        "role": "programming"
    },
    {
        "question": "",
        "answer": "Note:\n1) Queen moves any number of squares at a time in the vertical direction, horizontal direction, or diagonally on any chessboard. A queen is not a knight; therefore, it can not jump over other queens.\n2) An array of R strings is given, each of the size C. The string only contains '0' and '1'. 1 represents queen, and 0 means empty cell. Thus, at any cell, either a queen is present, or the cell is empty.\n3) The worst time complexity can not exceed O(R * C).\nExample:\nSuppose the chessboard be\n[1 0 0]\n[0 0 1]\n[0 1 0]\nWhere 1 is the queen position and 0 is empty.\nNo queen attacks the cell(1, 1). Remember, we have to assume that no queen is present at the cell which we are evaluating for the attack.\n3 attacks are coming from the queens to the cell (1, 2). One from the queen at the cell(1, 1), one from the queen at the cell(2, 3), and another from the cell(3, 2).\nQueens at (2, 3) and (1, 1) attack the cell(1, 3). Note that we have considered 1-indexing this time.\nSimilarly, we can calculate the queen attack for other cells too.\nThe final matrix is:\n[0, 3, 2]\n[3, 3, 1]\n[2, 1, 3]\nFileName: QueenAttack.java\n// import statement  \nimport java.util.*;  \n  public class QueenAttack   \n{  \n  public void fillQueens(int[][] grid,int i,int j,int n,int m,int[][] dp)  \n{  \nint[] dx = {-1, 0, 0, 1, -1, -1, 1, 1};  \nint[] dy = {0, -1, 1, 0, 1, -1, 1, -1};  \nfor(int k = 0; k < 8; k++)  \n{  \nint x = i + dx[k];  \nint y = j + dy[k];  \nwhile(x >= 0 && x < n && y >= 0 && y < m)  \n{  \ndp[x][y]++;  \nif(grid[x][y] == 1)  \nbreak;  \nx += dx[k];  \ny += dy[k];  \n}  \n}  \n}  \n  public ArrayList<ArrayList<Integer>> queenAttack(ArrayList<String> A)   \n{  \nint n = A.size();  \nint m = A.get(0).length();  \nint[][] grid = new int[n][m];  \nfor(int i = 0; i < n; i++)  \n{  \nfor(int j = 0; j < m; j++)  \n{  \ngrid[i][j] = (A.get(i).charAt(j) == '0') ? 0 : 1;  \n}  \n}  \nint[][] dp =new int[n][m];  \nfor(int i=0;i<n;i++)  \n{  \nfor(int j=0;j<m;j++)  \n{  \nif(grid[i][j] == 1)  \n{  \nfillQueens(grid,i,j,n,m,dp);  \n}  \n}  \n}  \n  ArrayList<ArrayList<Integer>> arr=new ArrayList<>();  \nfor(int i = 0;i < n; i++)  \n{  \narr.add(new ArrayList<>());  \nfor(int j = 0;j < m; j++)  \n{  \narr.get(i).add(dp[i][j]);  \n}  \n}  \nreturn arr;  \n}  \n    public int countWays(ArrayList<Integer> A, int B)   \n{  \n// the value of dp[j] represent the  \n// number of ways to get the sum j  \nint dp[] = new int[B + 1];  \nArrays.fill(dp, 0);  \n  dp[0] = 1;  \n  for(int i = 0; i < A.size(); i++)  \n{  \nfor(int j = A.get(i); j <= B; j++)  \n{  \n// finding the number of ways when   \n// A[i] is included  \ndp[j] = dp[j] + dp[j - A.get(i)];  \n  // finding number of ways when A[i]  \n// is excluded  \ndp[j] = dp[j];  \n}  \n}  \n  return dp[B];  \n}  \n  // main method  \npublic static void main(String argvs[])  \n{  \n// creating an object of the class QueenAttack  \nQueenAttack obj = new QueenAttack();  \n  ArrayList<String> al = new ArrayList<String>  \n(  \nArrays.asList(\"100\", \"001\", \"010\")  \n);  \n  ArrayList<ArrayList<Integer>> arr = obj.queenAttack(al);  \n  System.out.println(\"For the chessboard: \");  \nfor(String str : al)  \n{  \nSystem.out.println(str);  \n}  \nSystem.out.println();  \nSystem.out.println(\"The following matrix gives the number of queen attacks\");  \n  for(ArrayList<Integer> i : arr)  \n{  \nSystem.out.println(i);  \n}  \n  }  \n}  \nOutput:\nFor the chessboard: \n1 0 0\n0 0 1\n0 1 0\n\nThe following matrix gives the number of queen attacks\n[0, 3, 2]\n[3, 3, 1]\n[2, 1, 3]",
        "reference": "javatpoint.com",
        "role": "programming"
    }
]