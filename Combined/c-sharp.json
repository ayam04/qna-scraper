[
    {
        "question": "1. How is C# different from C?",
        "answer": "You would always know C being the procedural language while C# is a more object-oriented language. The biggest difference is that C# supports automatic garbage collection by Common Language Runtime (CLR) while C does not. C# primarily needs a .NET framework to execute while C is a platform-agnostic language. .NET framework .NET framework",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "2. What is inheritance? Does C# support multiple inheritance?",
        "answer": "Inheritance means acquiring some of the properties from a master class. Multiple Inheritance in C#  Multiple Inheritance in C# Here, class C can inherit properties from Class A and Class B. Here is an example of inheritance: // C# program to illustrate\n// multiple class inheritance\nusing System;\nusing System.Collections;\n\n// Parent class 1\nclass Scaler {\n\n  // Providing the implementation\n  // of features() method\n  public void features()\n  {\n\n      // Creating ArrayList\n      ArrayList My_features= new ArrayList();\n\n      // Adding elements in the\n      // My_features ArrayList\n      My_features.Add(\"Abstraction\");\n      My_features.Add(\"Encapsulation\");\n      My_features.Add(\"Inheritance\");\n\n      Console.WriteLine(\"Features provided by OOPS:\");\n      foreach(var elements in My_features)\n      {\n          Console.WriteLine(elements);\n      }\n  }\n}\n\n// Parent class 2\nclass Scaler2 :Scaler{\n\n  // Providing the implementation\n  // of courses() method\n  public void languages()\n  {\n\n      // Creating ArrayList\n      ArrayList My_features = new ArrayList();\n\n      // Adding elements in the\n      // My_features ArrayList\n      My_features.Add(\"C++\");\n      My_features.Add(\"C#\");\n      My_features.Add(\"JScript\");\n     \n\n      Console.WriteLine(\"\\nLanguages that use OOPS concepts:\");\n      foreach(var elements in My_features)\n      {\n          Console.WriteLine(elements);\n      }\n  }\n}\n\n// Child class\nclass ScalertoScaler : Scaler2 {\n}\n\npublic class Scaler1 {\n\n  // Main method\n  static public void Main()\n  {\n\n      // Creating object of ScalertoScaler class\n      ScalertoScaler obj = new ScalertoScaler();\n      obj.features();\n      obj.languages();\n  }\n} // C# program to illustrate\n// multiple class inheritance\nusing System;\nusing System.Collections;\n\n// Parent class 1\nclass Scaler {\n\n  // Providing the implementation\n  // of features() method\n  public void features()\n  {\n\n      // Creating ArrayList\n      ArrayList My_features= new ArrayList();\n\n      // Adding elements in the\n      // My_features ArrayList\n      My_features.Add(\"Abstraction\");\n      My_features.Add(\"Encapsulation\");\n      My_features.Add(\"Inheritance\");\n\n      Console.WriteLine(\"Features provided by OOPS:\");\n      foreach(var elements in My_features)\n      {\n          Console.WriteLine(elements);\n      }\n  }\n}\n\n// Parent class 2\nclass Scaler2 :Scaler{\n\n  // Providing the implementation\n  // of courses() method\n  public void languages()\n  {\n\n      // Creating ArrayList\n      ArrayList My_features = new ArrayList();\n\n      // Adding elements in the\n      // My_features ArrayList\n      My_features.Add(\"C++\");\n      My_features.Add(\"C#\");\n      My_features.Add(\"JScript\");\n     \n\n      Console.WriteLine(\"\\nLanguages that use OOPS concepts:\");\n      foreach(var elements in My_features)\n      {\n          Console.WriteLine(elements);\n      }\n  }\n}\n\n// Child class\nclass ScalertoScaler : Scaler2 {\n}\n\npublic class Scaler1 {\n\n  // Main method\n  static public void Main()\n  {\n\n      // Creating object of ScalertoScaler class\n      ScalertoScaler obj = new ScalertoScaler();\n      obj.features();\n      obj.languages();\n  }\n} // C# program to illustrate // multiple class inheritance using using // Parent class 1 class Scaler // Providing the implementation // of features() method public void features() public void features  // Creating ArrayList new // Adding elements in the // My_features ArrayList \"Abstraction\" \"Encapsulation\" \"Inheritance\" \"Features provided by OOPS:\" foreach var in // Parent class 2 class Scaler2 Scaler // Providing the implementation // of courses() method public void languages() public void languages  // Creating ArrayList new // Adding elements in the // My_features ArrayList \"C++\" \"C#\" \"JScript\" \"\\nLanguages that use OOPS concepts:\" foreach var in // Child class class ScalertoScaler Scaler2 public class Scaler1 // Main method static public void Main() static public void Main  // Creating object of ScalertoScaler class new Also, C# doesn’t support multiple inheritances. \nInstead, you can use interfaces to inherit the properties using the class name in the signature. ",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "3. What is the difference between an Array and ArrayList in C#?",
        "answer": "An array is a collection of similar variables clubbed together under one common name. While ArrayList is a collection of objects that can be indexed individually. With ArrayList you can access a number of features like dynamic memory allocation, adding, searching, and sorting items in the ArrayList. When declaring an array the size of the items is fixed therefore, the memory allocation is fixed. But with ArrayList, it can be increased or decreased dynamically.\nArray belongs to system.array namespace while ArrayList belongs to the system.collection namespace.\nAll items in an array are of the same datatype while all the items in an ArrayList can be of the same or different data types.\nWhile arrays cannot accept null, ArrayList can accept null values. When declaring an array the size of the items is fixed therefore, the memory allocation is fixed. But with ArrayList, it can be increased or decreased dynamically. Array belongs to system.array namespace while ArrayList belongs to the system.collection namespace. All items in an array are of the same datatype while all the items in an ArrayList can be of the same or different data types. While arrays cannot accept null, ArrayList can accept null values. For ex.: For ex.: // C# program to illustrate the ArrayList\nusing System;\nusing System.Collections;\n \nclass IB {\n \n   // Main Method\n   public static void Main(string[] args)\n   {\n \n       // Create a list of strings\n       ArrayList al = new ArrayList();\n       al.Add(\"Bruno\");\n       al.Add(\"Husky\");\n       al.Add(10);\n       al.Add(10.10);\n \n       // Iterate list element using foreach loop\n       foreach(var names in al)\n       {\n           Console.WriteLine(names);\n       }\n   }\n} // C# program to illustrate the ArrayList\nusing System;\nusing System.Collections;\n \nclass IB {\n \n   // Main Method\n   public static void Main(string[] args)\n   {\n \n       // Create a list of strings\n       ArrayList al = new ArrayList();\n       al.Add(\"Bruno\");\n       al.Add(\"Husky\");\n       al.Add(10);\n       al.Add(10.10);\n \n       // Iterate list element using foreach loop\n       foreach(var names in al)\n       {\n           Console.WriteLine(names);\n       }\n   }\n} // C# program to illustrate the ArrayList using using class IB // Main Method public static void Main(string[] args) public static void Main string[] args string // Create a list of strings new \"Bruno\" \"Husky\" 10 10.10 // Iterate list element using foreach loop foreach var in",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "4. What are Generics in C#?",
        "answer": "In C# collections, defining any kind of object is termed okay which compromises C#’s basic rule of type-safety. Therefore, generics were included to type-safe the code by allowing re-use of the data processing algorithms. Generics in C# mean not linked to any specific data type. Generics reduce the load of using boxing, unboxing, and typecasting objects. Generics are always defined inside angular brackets <>. To create a generic class, this syntax is used: GenericList<float> list1 = new GenericList<float>();\nGenericList<Features> list2 = new GenericList<Features>();\nGenericList<Struct> list3 = new GenericList<Struct>(); GenericList<float> list1 = new GenericList<float>();\nGenericList<Features> list2 = new GenericList<Features>();\nGenericList<Struct> list3 = new GenericList<Struct>(); Here, GenericList<float> is a generic class. In each of these instances of GenericList<T>, every occurrence of T in the class is substituted at run time with the type argument. By substituting the T, we have created three different type-safe using the same class.",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "5. What are extension methods in C#?",
        "answer": "Extension methods help to add new methods to the existing ones. The methods that are added are static. At times, when you want to add methods to an existing class but don’t perceive the right to modify that class or don’t hold the rights, you can create a new static class containing the new methods. Once the extended methods are declared, bind this class with the existing one and see the methods will be added to the existing one. // C# program to illustrate the concept\n// of the extension methods\nusing System;\n \nnamespace ExtensionMethod {\nstatic class NewMethodClass {\n \n   // Method 4\n   public static void M4(this Scaler s)\n   {\n       Console.WriteLine(\"Method Name: M4\");\n   }\n \n   // Method 5\n   public static void M5(this Scaler s, string str)\n   {\n       Console.WriteLine(str);\n   }\n}\n \n// Now we create a new class in which\n// Scaler class access all the five methods\npublic class IB {\n \n   // Main Method\n   public static void Main(string[] args)\n   {\n       Scaler s = new Scaler();\n       s.M1();\n       s.M2();\n       s.M3();\n       s.M4();\n       s.M5(\"Method Name: M5\");\n   }\n}\n} // C# program to illustrate the concept\n// of the extension methods\nusing System;\n \nnamespace ExtensionMethod {\nstatic class NewMethodClass {\n \n   // Method 4\n   public static void M4(this Scaler s)\n   {\n       Console.WriteLine(\"Method Name: M4\");\n   }\n \n   // Method 5\n   public static void M5(this Scaler s, string str)\n   {\n       Console.WriteLine(str);\n   }\n}\n \n// Now we create a new class in which\n// Scaler class access all the five methods\npublic class IB {\n \n   // Main Method\n   public static void Main(string[] args)\n   {\n       Scaler s = new Scaler();\n       s.M1();\n       s.M2();\n       s.M3();\n       s.M4();\n       s.M5(\"Method Name: M5\");\n   }\n}\n} // C# program to illustrate the concept // of the extension methods using namespace ExtensionMethod static class NewMethodClass // Method 4 public static void M4(this Scaler s) public static void M4 this Scaler s this \"Method Name: M4\" // Method 5 public static void M5(this Scaler s, string str) public static void M5 this Scaler s, string str this string // Now we create a new class in which // Scaler class access all the five methods public class IB // Main Method public static void Main(string[] args) public static void Main string[] args string new \"Method Name: M5\" Output: Output: Method Name: M1 Method Name: M2 Method Name: M3 Method Name: M4 Method Name: M5",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "6. What are the differences between ref and out keywords?",
        "answer": "C# ref keywords pass arguments by reference and not value. To use the ‘ref’ keyword, you need to explicitly mention ‘ref’. void Method(ref int refArgument)\n{\n   refArgument = refArgument + 10;\n}\nint number = 1;\nMethod(ref number);\nConsole.WriteLine(number);\n// Output: 11 void Method(ref int refArgument)\n{\n   refArgument = refArgument + 10;\n}\nint number = 1;\nMethod(ref number);\nConsole.WriteLine(number);\n// Output: 11 void Method(ref int refArgument) void Method ref int refArgument ref int 10 int 1 ref // Output: 11 C# out keywords pass arguments within methods and functions. \n‘out’ keyword is used to pass arguments in a method as a reference to return multiple values. Although it is the same as the ref keyword, the ref keyword needs to be initialised before it is passed. Here, The out and ref keywords are useful when we want to return a value in the same variables that are passed as an argument.   public static string GetNextFeature(ref int id)  \n{  \n   string returnText = \"Next-\" + id.ToString();  \n   id += 1;  \n   return returnText;  \n}  \npublic static string GetNextFeature(out int id)  \n{  \n   id = 1;  \n   string returnText = \"Next-\" + id.ToString();  \n   return returnText;  \n} public static string GetNextFeature(ref int id)  \n{  \n   string returnText = \"Next-\" + id.ToString();  \n   id += 1;  \n   return returnText;  \n}  \npublic static string GetNextFeature(out int id)  \n{  \n   id = 1;  \n   string returnText = \"Next-\" + id.ToString();  \n   return returnText;  \n} public static string GetNextFeature(ref int id) public static string GetNextFeature ref int id ref int string \"Next-\" 1 return public static string GetNextFeature(out int id) public static string GetNextFeature out int id out int 1 string \"Next-\" return",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "7. What is the difference between an abstract class and an interface?",
        "answer": "Let’s dig into the differences between an abstract class and an interface: Abstract classes are classes that cannot be instantiated ie. that cannot create an object. The interface is like an abstract class because all the methods inside the interface are abstract methods.\nSurprisingly, abstract classes can have both abstract and non-abstract methods but all the methods of an interface are abstract methods.\nSince abstract classes can have both abstract and non-abstract methods, we need to use the Abstract keyword to declare abstract methods. But in the interface, there is no such need. Abstract classes are classes that cannot be instantiated ie. that cannot create an object. The interface is like an abstract class because all the methods inside the interface are abstract methods. Surprisingly, abstract classes can have both abstract and non-abstract methods but all the methods of an interface are abstract methods. Since abstract classes can have both abstract and non-abstract methods, we need to use the Abstract keyword to declare abstract methods. But in the interface, there is no such need. An abstract class has constructors while an interface encompasses none. Ex. Abstract class: Abstract class: public abstract class Shape{\npublic abstract void draw();\n} public abstract class Shape{\npublic abstract void draw();\n} public abstract class Shape public abstract void draw() public abstract void draw  Interface: Interface: public interface Paintable{\nvoid paint();\n} public interface Paintable{\nvoid paint();\n} public interface Paintable void paint() void paint ",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "8. What is a managed and unmanaged code?",
        "answer": "Managed code lets you run the code on a managed CLR runtime environment in the .NET framework. \nManaged code runs on the managed runtime environment than the operating system itself. \nBenefits: Provides various services like a garbage collector, exception handling, etc. \n\nUnmanaged code is when the code doesn’t run on CLR, it is an unmanaged code that works outside the .NET framework. \nThey don’t provide services of the high-level languages and therefore, run without them. Such an example is C++. Managed code     Unmanaged code ",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "9. What are the types of classes in C#?",
        "answer": "Class is an entity that encapsulates all the properties of its objects and instances as a single unit. C# has four types of such classes: Static class: Static class, defined by the keyword ‘static’ does not allow inheritance. Therefore, you cannot create an object for a static class. Static class: Static class, defined by the keyword ‘static’ does not allow inheritance. Therefore, you cannot create an object for a static class. Static class: Sample code: Sample code: Sample code: static class classname  \n{  \n  //static data members  \n  //static methods  \n} static class classname  \n{  \n  //static data members  \n  //static methods  \n} static class classname //static data members //static methods Partial class: Partial class, defined by the keyword ‘partial’ allows its members to partially divide or share source (.cs) files.\nAbstract class: Abstract classes are classes that cannot be instantiated where you cannot create objects. Abstract classes work on the OOPS concept of abstraction. Abstraction helps to extract essential details and hide the unessential ones.\nSealed class: Sealed classes are classes that cannot be inherited. Use the keyword sealed to restrict access to users to inherit that class. Partial class: Partial class, defined by the keyword ‘partial’ allows its members to partially divide or share source (.cs) files. Partial class: Abstract class: Abstract classes are classes that cannot be instantiated where you cannot create objects. Abstract classes work on the OOPS concept of abstraction. Abstraction helps to extract essential details and hide the unessential ones. Abstract class: Sealed class: Sealed classes are classes that cannot be inherited. Use the keyword sealed to restrict access to users to inherit that class. Sealed class:  sealed class InterviewBit\n{\n   // data members\n   // methods\n   .\n   .\n   .\n} sealed class InterviewBit\n{\n   // data members\n   // methods\n   .\n   .\n   .\n} sealed class InterviewBit // data members // methods",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "10. What is garbage collection in C#?",
        "answer": "Garbage collection is the process of freeing up memory that is captured by unwanted objects. When you create a class object, automatically some memory space is allocated to the object in the heap memory. Now, after you perform all the actions on the object, the memory space occupied by the object becomes waste. It is necessary to free up memory. Garbage collection happens in three cases: If the occupied memory by the objects exceeds the pre-set threshold value.\nIf the garbage collection method is called\nIf your system has low physical memory If the occupied memory by the objects exceeds the pre-set threshold value. If the garbage collection method is called If your system has low physical memory",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "11. What is Common Language Runtime (CLR)?",
        "answer": "CLR handles program execution for various languages including C#. The architecture of CLR handles memory management, garbage collection, security handling, and looks like: Architecture of CLR  Architecture of CLR",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "1. What are partial classes in C#?",
        "answer": "Partial classes implement the functionality of a single class into multiple files. These multiple files are combined into one during compile time. The partial class can be created using the partial keyword. public partial Clas_name  \n{\n       // code\n} public partial Clas_name  \n{\n       // code\n} public partial // code You can easily split the functionalities of methods, interfaces, or structures into multiple files. You can even add nested partial classes.",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "2. What is the difference between String and StringBuilder in C#?",
        "answer": "The major difference between String and StringBuilder is that String objects are immutable while StringBuilder creates a mutable string of characters. StringBuilder will make the changes to the existing object rather than creating a new object. StringBuilder simplifies the entire process of making changes to the existing string object. Since the String class is immutable, it is costlier to create a new object every time we need to make a change. So, the StringBuilder class comes into picture which can be evoked using the System.Text namespace. In case, a string object will not change throughout the entire program, then use String class or else StringBuilder. For ex: string s = string.Empty; \nfor (i = 0; i < 1000; i++) \n  { \n    s += i.ToString() + \" \"; \n  } string s = string.Empty; \nfor (i = 0; i < 1000; i++) \n  { \n    s += i.ToString() + \" \"; \n  } string string for 0 1000 \" \" Here, you’ll need to create 2001 objects out of which 2000 will be of no use. The same can be applied using StringBuilder: StringBuilder sb = new StringBuilder(); \nfor (i = 0; i < 1000; i++) \n { \n   sb.Append(i); sb.Append(' '); \n } StringBuilder sb = new StringBuilder(); \nfor (i = 0; i < 1000; i++) \n { \n   sb.Append(i); sb.Append(' '); \n } new for 0 1000 ' ' By using StringBuilder here, you also de-stress the memory allocator. ",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "3. What is the difference between constant and readonly in C#?",
        "answer": "A const keyword in C# is used to declare a constant field throughout the program. That means once a variable has been declared const, its value cannot be changed throughout the program. \n\nIn C#, a constant is a number, string, null reference, or boolean values. \n\nFor ex: const const     class IB {\n \n   // Constant fields\n   public const int xvar = 20;\n   public const string str = \"InterviewBit\";\n \n   // Main method\n   static public void Main()\n   {\n \n       // Display the value of Constant fields\n       Console.WriteLine(\"The value of xvar: {0}\", xvar);\n       Console.WriteLine(\"The value of str: {0}\", str);\n   }\n}\nOutput:\nThe value of xvar is 20.\nThe value of string is Interview Bit class IB {\n \n   // Constant fields\n   public const int xvar = 20;\n   public const string str = \"InterviewBit\";\n \n   // Main method\n   static public void Main()\n   {\n \n       // Display the value of Constant fields\n       Console.WriteLine(\"The value of xvar: {0}\", xvar);\n       Console.WriteLine(\"The value of str: {0}\", str);\n   }\n}\nOutput:\nThe value of xvar is 20.\nThe value of string is Interview Bit class IB // Constant fields public const int 20 public const string \"InterviewBit\" // Main method static public void Main() static public void Main  // Display the value of Constant fields \"The value of xvar: {0}\" \"The value of str: {0}\" value is 20. value string is On the other hand, with readonly keyword, you can assign the variable only when it is declared or in a constructor of the same class in which it is declared. Ex: public readonly int xvar1;\n   public readonly int yvar2;\n \n   // Values of the readonly \n   // variables are assigned\n   // Using constructor\n   public IB(int b, int c)\n   {\n \n       xvar1 = b;\n       yvar2 = c;\n       Console.WriteLine(\"The value of xvar1 {0}, \"+\n                       \"and yvar2 {1}\", xvar1, yvar2);\n   }\n \n   // Main method\n   static public void Main()\n   {\n     IB obj1 = new IB(50, 60);\n   }\n}\n\nOutput:\nThe value of xvar1 is 50, and yvar2 is 60 public readonly int xvar1;\n   public readonly int yvar2;\n \n   // Values of the readonly \n   // variables are assigned\n   // Using constructor\n   public IB(int b, int c)\n   {\n \n       xvar1 = b;\n       yvar2 = c;\n       Console.WriteLine(\"The value of xvar1 {0}, \"+\n                       \"and yvar2 {1}\", xvar1, yvar2);\n   }\n \n   // Main method\n   static public void Main()\n   {\n     IB obj1 = new IB(50, 60);\n   }\n}\n\nOutput:\nThe value of xvar1 is 50, and yvar2 is 60 public readonly int public readonly int // Values of the readonly // variables are assigned // Using constructor public IB(int b, int c) public IB int b, int c int int \"The value of xvar1 {0}, \" \"and yvar2 {1}\" // Main method static public void Main() static public void Main  new 50 60 value is 50 and is 60 Constants are static by default while readonly should have a value assigned when the constructor is declared. \nConstants can be declared within functions while readonly modifiers can be used with reference types. ",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "4. What is Reflection in C#?",
        "answer": "Reflection in C# extracts metadata from the datatypes during runtime. \n\nTo add reflection in the .NET framework, simply use System.Refelction namespace in your program to retrieve the type which can be anything from:   Assembly\nModule\nEnum\nMethodInfo\nConstructorInfo\nMemberInfo\nParameterInfo\nType\nFieldInfo\nEventInfo\nPropertyInfo Assembly Module Enum MethodInfo ConstructorInfo MemberInfo ParameterInfo Type FieldInfo EventInfo PropertyInfo",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "5. What are the different ways in which a method can be Overloaded in C#?",
        "answer": "Overloading means when a method has the same name but carries different values to use in a different context. Only the main() method cannot be overloaded. In order to overload methods in C#, Change the number of parameters in a method, or\nChange the order of parameters in a method, or\nUse different data types for parameters\nIn these ways, you can overload a method multiple times. Change the number of parameters in a method, or Change the order of parameters in a method, or Use different data types for parameters\nIn these ways, you can overload a method multiple times.  For ex. public class Area {\n   public double area(double x) {\n       double area = x * x;\n       return area;\n   }\n   public double area(double a, double b) {\n       double area = a * b;\n       return area;\n   }\n} public class Area {\n   public double area(double x) {\n       double area = x * x;\n       return area;\n   }\n   public double area(double a, double b) {\n       double area = a * b;\n       return area;\n   }\n} public class Area public double area(double x) public double area double x double double return public double area(double a, double b) public double area double a, double b double double double return Here, the method Area is used twice. In the first declaration, one argument is used while in the second one, there were two arguments are used. Using different parameters in the same method, we were able to overload the method area().",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "6. Difference between the Equality Operator (==) and Equals() Method in C#?",
        "answer": "Although both are used to compare two objects by value, still they both are used differently. For ex.: For ex.: int x = 10;\nint y = 10;\nConsole.WriteLine( x == y);\nConsole.WriteLine(x.Equals(y));\nOutput:\nTrue\nTrue int x = 10;\nint y = 10;\nConsole.WriteLine( x == y);\nConsole.WriteLine(x.Equals(y));\nOutput:\nTrue\nTrue int 10 int 10 Equality operator (==) is a reference type which means that if equality operator is used, it will return true only if both the references point to the same object.  \n\nEquals() method: Equals method is used to compare the values carried by the objects. int x=10, int y=10. If x==y is compared then, the values carried by x and y are compared which is equal and therefore they return true. \n\nEquality operator: Compares by reference\n\nEquals(): Compares by value Equality operator (==   Equals() method:   Equality operator:   Equals():",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "7. What are Indexers in C#?",
        "answer": "Indexers are called smart arrays that allow access to a member variable. Indexers allow member variables using the features of an array. They are created using the Indexer keyword. Indexers are not static members. For ex. Here the indexer is defined the same way. For ex. <return type> this[<parameter type> index]\n{\n   get{\n       // return the value from the specified index of an internal collection\n   }\n   set{\n       // set values at the specified index in an internal collection\n   }\n} <return type> this[<parameter type> index]\n{\n   get{\n       // return the value from the specified index of an internal collection\n   }\n   set{\n       // set values at the specified index in an internal collection\n   }\n} return this get // return the value from the specified index of an internal collection set // set values at the specified index in an internal collection",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "8. What are the Arrays in C#?",
        "answer": "When a group of similar elements is clubbed together under one name, they are called arrays. \n\nFor ex. An array of tea Atea[4]: [green tea, chamomile tea, black tea, lemon tea]. The length of the array defines how many elements are present in the array. \n\nIn C#, the memory allocations for the elements of the array happen dynamically.  This is how values are stored in an array sequentially.     Arrays in C#  Arrays in C# A few pointers for arrays in C#: A few pointers for arrays in C#: The memory allocation is DYNAMIC.\nArrays in C# are treated as objects.\nThe length of the array is easy to find by detecting the number of members in the array.\nThe members in the array are ordered and begin with the index value=0.\nThe array types are reference types derived from the base array type. The memory allocation is DYNAMIC. Arrays in C# are treated as objects. The length of the array is easy to find by detecting the number of members in the array. The members in the array are ordered and begin with the index value=0. The array types are reference types derived from the base array type. Syntax: < Data Type > [ ] < Name_Array > < Data Type > [ ] < Name_Array >",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "9. What is the difference between late binding and early binding in C#?",
        "answer": "Late binding and early binding are examples of one of the primary concepts of OOPS: Polymorphism. \n\nFor ex: one function calculateBill() will calculate bills of premium customers, basic customers, and semi-premium customers based on their policies differently. The calculation for all the customer objects is done differently using the same function which is called polymorphism. \n\nWhen an object is assigned to an object variable in C#, the .NET framework performs the binding. \n\nWhen the binding function happens at compile-time, it is called early binding. It investigates and checks the methods and properties of the static objects. With early binding, the number of run-time errors decreases substantially and it executes pretty quickly. \n\nBut when the binding happens at runtime, it is called late binding. Late binding happens when the objects are dynamic (decided based on the data they hold) at run-time. It is slower as it looks through during run-time. Polymorphism.   For ex: For ex:      ",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "10. What are Properties in C#?",
        "answer": "Properties in C# are public members of a class where they provide the ability to access private members of a class. The basic principle of encapsulation lets you hide some sensitive properties from the users by making the variables private. The private members are not accessible otherwise in a class. Therefore, by using properties in C# you can easily access the private members and set their values. \n\nThe values can be easily assigned using get and set methods, also known as accessors. While the get method extracts the value, the set method assigns the value to the variables.  ",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "11. What is Boxing and Unboxing in C#?",
        "answer": "The two functions are used for typecasting the data types: Boxing: Boxing converts value type (int, char, etc.) to reference type (object) which is an implicit conversion process using object value. Boxing: Example: Example: Example: int num = 23; // 23 will assigned to num\nObject Obj = num; // Boxing int num = 23; // 23 will assigned to num\nObject Obj = num; // Boxing int 23 // 23 will assigned to num // Boxing Unboxing: Unboxing converts reference type (object) to value type (int, char, etc.) using an explicit conversion process. Unboxing: Example: Example: Example: int num = 23;         // value type is int and assigned value 23\nObject Obj = num;    // Boxing\nint i = (int)Obj;    // Unboxing int num = 23;         // value type is int and assigned value 23\nObject Obj = num;    // Boxing\nint i = (int)Obj;    // Unboxing int 23 // value type is int and assigned value 23 // Boxing int int // Unboxing",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "1. Write a C# program to find if a positive integer is prime or not?",
        "answer": "static void Main(string[] args) \n{ \n    if (FindPrime(47)) \n    { \n        Console.WriteLine(\"Prime\"); \n    } \n    else \n    { \n        Console.WriteLine(\"Not Prime\"); \n    } \n    Console.ReadLine(); \n}   \ninternal static bool FindPrime(int number) \n{ \n    if (number == 1) return false; \n    if (number == 2) return true; \n    if (number % 2 == 0) return false; \n     var squareRoot = (int)Math.Floor(Math.Sqrt(number)); \n     for (int i = 3; i <= squareRoot; i += 2) \n    { \n        if (number % i == 0) return false; \n    } \n     return true; \n} static void Main(string[] args) \n{ \n    if (FindPrime(47)) \n    { \n        Console.WriteLine(\"Prime\"); \n    } \n    else \n    { \n        Console.WriteLine(\"Not Prime\"); \n    } \n    Console.ReadLine(); \n}   \ninternal static bool FindPrime(int number) \n{ \n    if (number == 1) return false; \n    if (number == 2) return true; \n    if (number % 2 == 0) return false; \n     var squareRoot = (int)Math.Floor(Math.Sqrt(number)); \n     for (int i = 3; i <= squareRoot; i += 2) \n    { \n        if (number % i == 0) return false; \n    } \n     return true; \n} static void Main(string[] args) static void Main string[] args string if 47 \"Prime\" else \"Not Prime\" internal static bool FindPrime(int number) internal static bool FindPrime int number int if 1 return false if 2 return true if 2 0 return false var int for int 3 2 if 0 return false return true",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "2. Write a C# program to find the substring from a given string.",
        "answer": "internal static void findallsubstring(string str) \n{ \n   for (int i = 0; i < str.Length; ++i) \n   { \n       StringBuilder subString = new StringBuilder(str.Length - i); \n       for (int j = i; j < str.Length; ++j) \n       { \n           subString.Append(str[j]); \n           Console.Write(subString + \" \"); \n       } \n   } \n} internal static void findallsubstring(string str) \n{ \n   for (int i = 0; i < str.Length; ++i) \n   { \n       StringBuilder subString = new StringBuilder(str.Length - i); \n       for (int j = i; j < str.Length; ++j) \n       { \n           subString.Append(str[j]); \n           Console.Write(subString + \" \"); \n       } \n   } \n} internal static void findallsubstring(string str) internal static void findallsubstring string str string for int 0 new for int \" \"",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "3. Write a program in C# Sharp to find if a given string is palindrome or not?",
        "answer": "internal static void chkPalindrome(string str) \n{ \n   bool flag = false; \n   for (int i = 0, j = str.Length - 1; i < str.Length / 2; i++, j--) \n   { \n       if (str[i] != str[j]) \n       { \n           flag = false; \n           break; \n       } \n       else \n           flag = true; \n   } \n   if (flag) \n   { \n       Console.WriteLine(\"Palindrome\"); \n   } \n   else \n       Console.WriteLine(\"Not Palindrome\"); internal static void chkPalindrome(string str) \n{ \n   bool flag = false; \n   for (int i = 0, j = str.Length - 1; i < str.Length / 2; i++, j--) \n   { \n       if (str[i] != str[j]) \n       { \n           flag = false; \n           break; \n       } \n       else \n           flag = true; \n   } \n   if (flag) \n   { \n       Console.WriteLine(\"Palindrome\"); \n   } \n   else \n       Console.WriteLine(\"Not Palindrome\"); internal static void chkPalindrome(string str) internal static void chkPalindrome string str string bool false for int 0 1 2 if false break else true if \"Palindrome\" else \"Not Palindrome\" Output: \n\nInput: Key Output: Not Palindrome\nInput: step on no pets Output: Palindrome Output:   ",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "4. Write a program in C# Sharp to reverse the order of the given words?",
        "answer": "internal static void ReverseWordOrder(string str) \n{ \n  int i; \n  StringBuilder reverseSentence = new StringBuilder(); \n   int Start = str.Length - 1; \n  int End = str.Length - 1; \n   while (Start > 0) \n  { \n      if (str[Start] == ' ') \n      { \n          i = Start + 1; \n          while (i <= End) \n          { \n              reverseSentence.Append(str[i]); \n              i++; \n          } \n          reverseSentence.Append(' '); \n          End = Start - 1; \n      } \n      Start--; \n  } \n   for (i = 0; i <= End; i++) \n  { \n      reverseSentence.Append(str[i]); \n  } \n  Console.WriteLine(reverseSentence.ToString()); \n} internal static void ReverseWordOrder(string str) \n{ \n  int i; \n  StringBuilder reverseSentence = new StringBuilder(); \n   int Start = str.Length - 1; \n  int End = str.Length - 1; \n   while (Start > 0) \n  { \n      if (str[Start] == ' ') \n      { \n          i = Start + 1; \n          while (i <= End) \n          { \n              reverseSentence.Append(str[i]); \n              i++; \n          } \n          reverseSentence.Append(' '); \n          End = Start - 1; \n      } \n      Start--; \n  } \n   for (i = 0; i <= End; i++) \n  { \n      reverseSentence.Append(str[i]); \n  } \n  Console.WriteLine(reverseSentence.ToString()); \n} internal static void ReverseWordOrder(string str) internal static void ReverseWordOrder string str string int new int 1 int 1 while 0 if ' ' 1 while ' ' 1 for 0",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "5. Write a program in C# Sharp to reverse a string?",
        "answer": "internal static void ReverseString(string str) \n{ \n   \n  char[] charArray = str.ToCharArray(); \n  for (int i = 0, j = str.Length - 1; i < j; i++, j--) \n  { \n      charArray[i] = str[j]; \n      charArray[j] = str[i]; \n  } \n  string reversedstring = new string(charArray); \n  Console.WriteLine(reversedstring); internal static void ReverseString(string str) \n{ \n   \n  char[] charArray = str.ToCharArray(); \n  for (int i = 0, j = str.Length - 1; i < j; i++, j--) \n  { \n      charArray[i] = str[j]; \n      charArray[j] = str[i]; \n  } \n  string reversedstring = new string(charArray); \n  Console.WriteLine(reversedstring); internal static void ReverseString(string str) internal static void ReverseString string str string char for int 0 1 string new string",
        "reference": "interviewbit.com",
        "role": "c-sharp"
    },
    {
        "question": "1) What is C#?",
        "answer": "C# is a simple, modern, general purpose programming language. It is an object oriented programming language developed by Microsoft. It is a safe and managed language that is compiled by .NET framework to generate Microsoft intermediate language (machine code).",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "2) What is the reason behind the invention of C#?",
        "answer": "C# is designed for Common Language Infrastructure (CLI). It contains the executable code and runtime environment that makes the users able to use various high-level languages on different computer platforms and architectures.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "3) What are the main reasons to use C# language?",
        "answer": "These are top reasons to use C# language:\nADVERTISEMENT\nEasy to learn\nGeneral purpose and object oriented programming language\nComponent oriented\nStructured language\nCan be compiled on variety of computer platforms\nProduces efficient programs\nPart of .net framework",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "4) What is the difference between public, static and void?",
        "answer": "You can access public declared variables anywhere in the application.\nStatic declared variables are globally accessible without creating an instance of the class.\nVoid is a type modifier that specifies that the method doesn't return any value.\n5) What are constructors in C#?\nA constructor is a member function in the class and has the same name as its class. Whenever the object class is created, the constructor is automatically invoked. It constructs the value of data members while initializing the class.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "5) What are constructors in C#?",
        "answer": "A constructor is a member function in the class and has the same name as its class. Whenever the object class is created, the constructor is automatically invoked. It constructs the value of data members while initializing the class.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "6) What are the different types of constructors in C#?",
        "answer": "Basically, there are five types of constructors:\nStatic constructor\nPrivate constructor\nCopy constructor\nDefault constructor\nParameterized constructor",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "7) What is static constructor?",
        "answer": "Static constructor is used to initialize static data members as soon as the class is referenced first time.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "8) What is method overloading in C#?",
        "answer": "Method overloading is mechanism to create multiple methods with the same name and unique signature in the same class. When you go for compilation, the compiler uses overload resolution to determine the specific method to be invoked.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "9) Is overriding of a function possible in the same class?",
        "answer": "No",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "10) What is array?",
        "answer": "Array is a set of related instances either value or reference types.\nThere are three types of array supported by C#:\nSingle Dimensional Array: It contains a single row. It is also known as vector array.\nMulti Dimensional Array: It is rectangular and contains rows and columns.\nJagged Array: It also contains rows and columns but it has an irregular shape.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "11) What is ArrayList?",
        "answer": "ArrayList is a dynamic array. You can add and remove the elements from an ArrayList at runtime. In the ArrayList, elements are not automatically sorted.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "12) What is a collection?",
        "answer": "A collection works as a container for instances of other classes. All classes implement ICollection interface.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "13) What is an interface?",
        "answer": "Interface is an abstract class that has only public abstract method. These methods only have declaration not the definition. These abstract methods must be implemented in the inherited classes.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "14) What is the lock statement in C#?",
        "answer": "Lock statement is used to ensure that one thread doesn?t enter a critical section of code while another thread is in the critical section. If another thread attempts to enter a locked code it will wait, block, until the object is released.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "15) What is serialization?",
        "answer": "If you want to transport an object through network then you have to convert the object into a stream of bytes. The process of converting an object into a stream of bytes is called serialization.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "16) How to declare a property in a class?",
        "answer": "int m_PersonID = 0;  \npublic int PersonID  \n{  \nget { return m_PersonID; }  \nset { m_PersonID = value; }  \n}",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "17) What is the difference between early binding and late binding in C#?",
        "answer": "Early binding and late binding are the concept of polymorphism. There are two types of polymorphism in C#.\nCompile Time Polymorphism: It is also known as early binding.\nRun Time Polymorphism: It is also known as late binding or method overriding or dynamic polymorphism.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "18) Which are the access modifiers available in C#?",
        "answer": "Following are the access modifiers generally used for accessibility:\nPublic: If you define an attribute or method as public, it can be accessed from any code of the project.\nPrivate: A private defined attribute or method can be accessed by any code within the containing class only.\nProtected: If you define the method or attribute as protected it can be accessed by any method in the inherited classes and any method within the same class.\nInternal: If you define an attribute or a method as internal, it is restricted to classes within the current position assembly.\nProtected internal: If you define an attribute or method as protected internal, access is restricted to classes within the current project assembly or types derived from the containing class.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "19) What is the difference between abstract class and interface in C#?",
        "answer": "Abstract class can have abstract and concrete methods whereas interface has only abstract methods.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "20) What is the difference between dispose() and finalize() methods in C#?",
        "answer": "The dispose() method is explicitly called by user to free unmanaged resources such as files, database connections etc whereas finalize() method is implicitly called by garbage collector to free unmanaged resources like files, database connections etc.\nThe dispose() method belongs to IDisposable interface whereas finalize() method belongs the Object class.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "21) What is the difference between method overloading and method overriding in C#?",
        "answer": "Method parameters must be different in method overloading whereas it must be same in method overriding.\nInheritance is not required in method overloading, it occurs within the same class. But inheritance is required in method overriding.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "Net?",
        "answer": "Object pool is a container of ready to use objects. It reduces the overhead of creating new object.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "23) What is delegate in C#?",
        "answer": "A delegate in C# is an object that holds the reference to a method. It is like function pointer in C++.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "24) What is Hashtable?",
        "answer": "A Hashtable is a collection of key/value pairs. It contains values based on the key.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    },
    {
        "question": "25) What is Reflection?",
        "answer": "Reflection allows us to get metadata and assemblies of an object at runtime.",
        "reference": "javatpoint.com",
        "role": "c-sharp"
    }
]