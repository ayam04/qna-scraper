[
    {
        "question": "1. What are some features that Swift classes can support but Swift structs cannot?",
        "answer": "Given below are some features which Swift classes can support but Swift structs cannot: To develop our own custom view controller subclasses, we can inherit from another class, such as UIViewController. This cannot be achieved using Swift structs.\nBefore a class is destroyed, it can be deinitialized by calling the deinit() function. This cannot be done for Swift structs.\nStructures are value types, while classes are reference types.\nValue Types: When you copy a value type (for example, when it is assigned, initialised, or passed into a function), each instance preserves its own copy of the data. If you update one instance, it does not affect the other.\nReference Types: When you copy a reference type, the data is shared among all instances. The reference is copied, but the data it refers to is not. When one is altered, the other is altered as well. To develop our own custom view controller subclasses, we can inherit from another class, such as UIViewController. This cannot be achieved using Swift structs. Before a class is destroyed, it can be deinitialized by calling the deinit() function. This cannot be done for Swift structs. Structures are value types, while classes are reference types.\nValue Types: When you copy a value type (for example, when it is assigned, initialised, or passed into a function), each instance preserves its own copy of the data. If you update one instance, it does not affect the other.\nReference Types: When you copy a reference type, the data is shared among all instances. The reference is copied, but the data it refers to is not. When one is altered, the other is altered as well. Value Types: When you copy a value type (for example, when it is assigned, initialised, or passed into a function), each instance preserves its own copy of the data. If you update one instance, it does not affect the other.\nReference Types: When you copy a reference type, the data is shared among all instances. The reference is copied, but the data it refers to is not. When one is altered, the other is altered as well. Value Types: When you copy a value type (for example, when it is assigned, initialised, or passed into a function), each instance preserves its own copy of the data. If you update one instance, it does not affect the other. Value Types: Reference Types: When you copy a reference type, the data is shared among all instances. The reference is copied, but the data it refers to is not. When one is altered, the other is altered as well. Reference Types:",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "2. How is memory management done in iOS Swift?",
        "answer": "Automatic Reference Counting is used by Swift (ARC) in order to do memory management. This is the same thing in Swift as it is in Objective C in terms of notion. When you assign or unassign instances of classes (reference types) to constants, properties, and variables, ARC keeps track of strong references to those instances and increases or decreases their reference count correspondingly. It frees up memory consumed by objects with a reference count of zero. Because value types are copied when assigned, ARC does not raise or decrease its reference count. If you don't declare differently, all references will be strong references by default.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "3. Highlight the key difference between Upcast and Downcast in ios Swift.",
        "answer": "The key difference between Upcast and Downcast in ios Swift is that upcasting from a derived to a base class can be verified at compile-time and will never fail to compile and Downcasts, on the other hand, can fail to compile since the precise class is not always known. It is possible that the UIView you have is a UITableView or a UIButton.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "4. What is the difference between the \"==\" operator and the \"===\" operator in ios Swift?",
        "answer": "The fundamental difference between the \"==\" operator and the \"===\" operator in ios Swift is that the equal to \"==\" operator compares value types to see if the values are the same while the equivalent to \"===\" operator compares reference types to see if the references point to the same instance (both point to the same memory address) or not.  Let us consider the following example for understanding the difference between the two in a better way: class Human: Equatable {\n   let id: Int\n   let nameOfPerson: String\n   init(id: Int, nameOfPerson: String) {\n       self.id = id\n       self.nameOfPerson = nameOfPerson\n   }\n   static func == (left: Human, right: Human) -> Bool {\n       return left.id == right.id\n   }\n}\nlet human1 = Human(id: 2, nameOfPerson: \"Janvi\")\nlet human2 = Human(id: 2, nameOfPerson: \"Janvi\") class Human: Equatable {\n   let id: Int\n   let nameOfPerson: String\n   init(id: Int, nameOfPerson: String) {\n       self.id = id\n       self.nameOfPerson = nameOfPerson\n   }\n   static func == (left: Human, right: Human) -> Bool {\n       return left.id == right.id\n   }\n}\nlet human1 = Human(id: 2, nameOfPerson: \"Janvi\")\nlet human2 = Human(id: 2, nameOfPerson: \"Janvi\") Now, for the piece of code given below, we can say that the two human instances are equal since their id is the same. Therefore, \"Equal Instances!\" gets printed. if human1 == human2 {\n  print(\"Equal Instances!\")\n}else{\n  print(\"Instances Not Equal!\")\n} if human1 == human2 {\n  print(\"Equal Instances!\")\n}else{\n  print(\"Instances Not Equal!\")\n} Now, for the piece of code given below, we can say that the two human instances are not equivalent even though their id is the same since they point to different areas in the Heap Area, that is, they point to different addresses. Therefore, \"Instances are not Equivalent!\" gets printed. if human1 === human2 {\n  print(\"Equivalent Instances!\")\n}else{\n  print(\"Instances are not Equivalent!\")\n} if human1 === human2 {\n  print(\"Equivalent Instances!\")\n}else{\n  print(\"Instances are not Equivalent!\")\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "5. Throw light on some of the differences between Swift and Objective C.",
        "answer": "Some of the differences between ios Swift and Objective C are as follows: Comparison Parameter ios Swift Objective C\nType of Programming Language. ios Swift is an object-oriented and functional programming language. Objective C is a class-based object-oriented programming language.\nDynamic Libraries Dynamic Libraries are supported by ios Swift. For instance, system iOS and macOS libraries are dynamic. In other words, these applications will receive improvements from Apple’s updates without new build submission. Dynamic Libraries are not supported by Objective C.\nTuples Tuples are supported by ios Swift. Tuples are not supported by Objective C.\nUsage of Semicolons Usage of Semicolons is not mandatory in ios Swift. Usage of Semicolons is mandatory in Objective C.\nMethod definition in Classes, Structures and Enumerations The definition of methods in Classes, Structures and Enumerations is allowed in ios Swift. The definition of methods in Classes, Structures and Enumerations is not allowed in Objective C. Comparison Parameter ios Swift Objective C\nType of Programming Language. ios Swift is an object-oriented and functional programming language. Objective C is a class-based object-oriented programming language.\nDynamic Libraries Dynamic Libraries are supported by ios Swift. For instance, system iOS and macOS libraries are dynamic. In other words, these applications will receive improvements from Apple’s updates without new build submission. Dynamic Libraries are not supported by Objective C.\nTuples Tuples are supported by ios Swift. Tuples are not supported by Objective C.\nUsage of Semicolons Usage of Semicolons is not mandatory in ios Swift. Usage of Semicolons is mandatory in Objective C.\nMethod definition in Classes, Structures and Enumerations The definition of methods in Classes, Structures and Enumerations is allowed in ios Swift. The definition of methods in Classes, Structures and Enumerations is not allowed in Objective C. Comparison Parameter ios Swift Objective C Comparison Parameter ios Swift Objective C Comparison Parameter ios Swift Objective C Type of Programming Language. ios Swift is an object-oriented and functional programming language. Objective C is a class-based object-oriented programming language.\nDynamic Libraries Dynamic Libraries are supported by ios Swift. For instance, system iOS and macOS libraries are dynamic. In other words, these applications will receive improvements from Apple’s updates without new build submission. Dynamic Libraries are not supported by Objective C.\nTuples Tuples are supported by ios Swift. Tuples are not supported by Objective C.\nUsage of Semicolons Usage of Semicolons is not mandatory in ios Swift. Usage of Semicolons is mandatory in Objective C.\nMethod definition in Classes, Structures and Enumerations The definition of methods in Classes, Structures and Enumerations is allowed in ios Swift. The definition of methods in Classes, Structures and Enumerations is not allowed in Objective C. Type of Programming Language. ios Swift is an object-oriented and functional programming language. Objective C is a class-based object-oriented programming language. Type of Programming Language. ios Swift is an object-oriented and functional programming language. Objective C is a class-based object-oriented programming language. Dynamic Libraries Dynamic Libraries are supported by ios Swift. For instance, system iOS and macOS libraries are dynamic. In other words, these applications will receive improvements from Apple’s updates without new build submission. Dynamic Libraries are not supported by Objective C. Dynamic Libraries Dynamic Libraries are supported by ios Swift. For instance, system iOS and macOS libraries are dynamic. In other words, these applications will receive improvements from Apple’s updates without new build submission. Dynamic Libraries are not supported by Objective C. Tuples Tuples are supported by ios Swift. Tuples are not supported by Objective C. Tuples Tuples are supported by ios Swift. Tuples are not supported by Objective C. Usage of Semicolons Usage of Semicolons is not mandatory in ios Swift. Usage of Semicolons is mandatory in Objective C. Usage of Semicolons Usage of Semicolons is not mandatory in ios Swift. Usage of Semicolons is mandatory in Objective C. Method definition in Classes, Structures and Enumerations The definition of methods in Classes, Structures and Enumerations is allowed in ios Swift. The definition of methods in Classes, Structures and Enumerations is not allowed in Objective C. Method definition in Classes, Structures and Enumerations The definition of methods in Classes, Structures and Enumerations is allowed in ios Swift. The definition of methods in Classes, Structures and Enumerations is not allowed in Objective C.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "6. List down three ways in which we can append two arrays in ios Swift.",
        "answer": "Let us consider that the two arrays are declared as follows: var firstArray = [\"Sonal\", \"Rahul\"]\nlet secondArray = [\"Nawaz\", \"Riya\"] var firstArray = [\"Sonal\", \"Rahul\"]\nlet secondArray = [\"Nawaz\", \"Riya\"] A thing to be noted is that the first array has been kept mutable so we can append the second array to it. The three ways in which we can append the second array to the first one are as follows: Using the method \"append(contentsOf: )\"- In this method, the contents of the second array are copied into the first array. Using the method \"append(contentsOf: )\"- In this method, the contents of the second array are copied into the first array. Using the method \"append(contentsOf: )\" firstArray.append(contentsOf: secondArray) firstArray.append(contentsOf: secondArray) Using the \"+=\" operator - In this method also, the contents of the second array are copied into the first array. Using the \"+=\" operator - In this method also, the contents of the second array are copied into the first array. Using the \"+=\" operator firstArray += secondArray firstArray += secondArray Appending two arrays by using the \"+\" operator and adding the result to a new array - Appending two arrays by using the \"+\" operator and adding the result to a new array - Appending two arrays by using the \"+\" operator and adding the result to a new array let thirdArray = firstArray + secondArray let thirdArray = firstArray + secondArray",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "7. Explain the various steps (or execution states) involved in the development of an ios Swift application.",
        "answer": "The various steps (or execution states) involved in the development of an ios Swift application are as follows: Not Running: This is a simple condition in which our program has not been launched or no code has been executed. The program has been terminated by the system.\nInactive: This is merely a stage in the process of becoming active. Our program is in an inactive state, which means it is running in the background but unable to receive events.\nActive: This is the main execution state, in which our software is running and receiving events.\nBackground: This is the condition in which our application is running in the background while still being able to run code.\nSuspended: This state indicates that our application has not been terminated but is present in the background and that the system has suspended it for the time being. Now, the application cannot execute any code. Not Running: This is a simple condition in which our program has not been launched or no code has been executed. The program has been terminated by the system. Not Running: Inactive: This is merely a stage in the process of becoming active. Our program is in an inactive state, which means it is running in the background but unable to receive events. Inactive: Active: This is the main execution state, in which our software is running and receiving events. Active: Background: This is the condition in which our application is running in the background while still being able to run code. Background: Suspended: This state indicates that our application has not been terminated but is present in the background and that the system has suspended it for the time being. Now, the application cannot execute any code. Suspended:",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "8. In iOS Swift, what types of objects are considered basic data types?",
        "answer": "For various purposes, Swift uses a common set of basic data types such as Boolean values, integers, and strings: Int: The integer value is stored in the int variable. Example - 5\nDouble and Float: When working with decimal numbers in Swift, double and float are taken into account. Example - 5.78\nBool: The bool type is used to store the value of a Boolean. True and false conditions are used in Swift. Example - true\nString: In Swift, the user defines the content that is enclosed by double quotes in String literals. Example - \"Muskan\"\nArrays: Arrays are collections of objects of the same type from a list. Example - [2,4,11,90,78]\nDictionaries: A dictionary is an unsorted collection of elements of a specific type linked by a single key. Example - [{name:\"Nidhi\"}] Int: The integer value is stored in the int variable. Example - 5 Int: Double and Float: When working with decimal numbers in Swift, double and float are taken into account. Example - 5.78 Double and Float: Bool: The bool type is used to store the value of a Boolean. True and false conditions are used in Swift. Example - true Bool: String: In Swift, the user defines the content that is enclosed by double quotes in String literals. Example - \"Muskan\" String: Arrays: Arrays are collections of objects of the same type from a list. Example - [2,4,11,90,78] Arrays: Dictionaries: A dictionary is an unsorted collection of elements of a specific type linked by a single key. Example - [{name:\"Nidhi\"}] Dictionaries:",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "9. In Swift, what does the init() method do?",
        "answer": "The process of preparing an instance of an enumeration, structure, or class for use is known as initialization. Initializers are also used when a new instance of a type is created. An initializer is a no parameter instance method. The init keyword can be written using the initializer. Their primary role is to ensure that new instances of a type are correctly initialized before they’re used for the first time. Its syntax is given below: init()\n{\n// New Instances are initialized here\n} init()\n{\n// New Instances are initialized here\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "10. State the control transfer statements present in ios Swift.",
        "answer": "The control transfer statements present in ios Swift are as follows: Continue: The continue statement skips the current iteration of a loop and directs the program's control flow to the next iteration.\nBreak: When the break statement is found, a loop is immediately terminated.\nReturn: In Swift, the return statement is used in functions and methods to return values that meet our needs. In the Swift programming language, we can return values from functions/methods based on our requirements by utilising the return keyword.\nFallthrough: The fallthrough keyword merely directs code execution to the statements contained in the following case (or default case) block. Continue: The continue statement skips the current iteration of a loop and directs the program's control flow to the next iteration. Continue: Break: When the break statement is found, a loop is immediately terminated. Break Return: In Swift, the return statement is used in functions and methods to return values that meet our needs. In the Swift programming language, we can return values from functions/methods based on our requirements by utilising the return keyword. Return: Fallthrough: The fallthrough keyword merely directs code execution to the statements contained in the following case (or default case) block. Fallthrough",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "11. What are some common features in Swift structures and Swift classes?",
        "answer": "Some common features in Swift structures and Swift classes are as follows: Swift Structs and Swift classes can both define attributes for storing values and functions.\nWith init, both structures and classes in Swift can create initializers to set up their initial state ()\nThey can be extended using extensions.\nThey can follow protocols, such as those used in Protocol Oriented Programming.\nThey can collaborate with generics to create types that are adaptable and reusable. Swift Structs and Swift classes can both define attributes for storing values and functions. With init, both structures and classes in Swift can create initializers to set up their initial state () They can be extended using extensions. They can follow protocols, such as those used in Protocol Oriented Programming. They can collaborate with generics to create types that are adaptable and reusable.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "12. List some advantages and disadvantages of using ios Swift.",
        "answer": "Some advantages of using ios Swift are as follows: It is very fast in terms of execution and both type-safe and memory-safe: Swift is an extremely fast language as far as execution speed is concerned. Also, it is very easy to learn and code in Swift is easy. Type safety refers to the language's ability to prevent type mistakes. Memory safety refers to the absence of flaws caused by uninitialized pointers, which could cause a program to crash. Developers can discover any code flaws with a shorter feedback loop (where outputs are sent back as inputs, which determines the cause and effect of that loop), which reduces debugging time and eliminates the danger of low-quality code.\nSwift is interoperable with Objective C: In Swift, Projects can be written in either Objective C or C++ because they are interoperable. This is particularly beneficial for large projects that are being upgraded when new Swift features are added and subsequently incorporated into the Objective C core.\nApplications made using ios Swift are easy to maintain: Swift makes it simple to maintain an application once it has been built. Swift merges the Objective C header (.m) and implementation files (.h) into a single programme (.swift) file, as opposed to Objective C, which is managed in two separate files. It is worth noting that Swift has dependencies. On macOS, Swift is already installed and ready to use; however, on Linux, you must first install essential dependencies, such as Python and then use it.\nApplications developed using Swift provide a better experience to its users: Swift developed applications take less time to install and consume less on device memory, giving users a better application experience.\nSwift has efficient memory management: Swift expands on its ObjectiveC predecessor with a mechanism called Automatic Reference Counting (ARC). The ARC identifies which class instances aren't in use and removes them from developers' workspaces. This frees up time for developers to focus on the application's performance rather than lowering CPU or memory usage.\nSwift provides Application Binary Interface (ABI) stability: Swift's Application Binary Interface (ABI) is the binary version of the Swift Application Programming Interface (API). While ABI stability is an important accomplishment for any programming language, \"the ultimate advantage to the Swift ecosystem was to enable binary compatibility for applications and libraries,\" according to Swift. In practice, the ABI enables code compiled with multiple versions of Swift, as well as Objective-C, to communicate with one another.\nThe usage of optionals in Swift: Optionals are a programming technique that allows developers to avoid application crashes because of Null Pointers while maintaining clean code across the application. Consider it a wrapper type that protects the value inside. An optional might be filled with data or left blank. Optionals must be unwrapped to be sure, and if done correctly, will not cause crashes. It is very fast in terms of execution and both type-safe and memory-safe: Swift is an extremely fast language as far as execution speed is concerned. Also, it is very easy to learn and code in Swift is easy. Type safety refers to the language's ability to prevent type mistakes. Memory safety refers to the absence of flaws caused by uninitialized pointers, which could cause a program to crash. Developers can discover any code flaws with a shorter feedback loop (where outputs are sent back as inputs, which determines the cause and effect of that loop), which reduces debugging time and eliminates the danger of low-quality code. It is very fast in terms of execution and both type-safe and memory-safe: Swift is interoperable with Objective C: In Swift, Projects can be written in either Objective C or C++ because they are interoperable. This is particularly beneficial for large projects that are being upgraded when new Swift features are added and subsequently incorporated into the Objective C core. Swift is interoperable with Objective C: Applications made using ios Swift are easy to maintain: Swift makes it simple to maintain an application once it has been built. Swift merges the Objective C header (.m) and implementation files (.h) into a single programme (.swift) file, as opposed to Objective C, which is managed in two separate files. It is worth noting that Swift has dependencies. On macOS, Swift is already installed and ready to use; however, on Linux, you must first install essential dependencies, such as Python and then use it. Applications made using ios Swift are easy to maintain: Applications developed using Swift provide a better experience to its users: Swift developed applications take less time to install and consume less on device memory, giving users a better application experience. Applications developed using Swift provide a better experience to its users: Swift has efficient memory management: Swift expands on its ObjectiveC predecessor with a mechanism called Automatic Reference Counting (ARC). The ARC identifies which class instances aren't in use and removes them from developers' workspaces. This frees up time for developers to focus on the application's performance rather than lowering CPU or memory usage.\nSwift provides Application Binary Interface (ABI) stability: Swift's Application Binary Interface (ABI) is the binary version of the Swift Application Programming Interface (API). While ABI stability is an important accomplishment for any programming language, \"the ultimate advantage to the Swift ecosystem was to enable binary compatibility for applications and libraries,\" according to Swift. In practice, the ABI enables code compiled with multiple versions of Swift, as well as Objective-C, to communicate with one another. Swift has efficient memory management:  The usage of optionals in Swift: Optionals are a programming technique that allows developers to avoid application crashes because of Null Pointers while maintaining clean code across the application. Consider it a wrapper type that protects the value inside. An optional might be filled with data or left blank. Optionals must be unwrapped to be sure, and if done correctly, will not cause crashes. The usage of optionals in Swift: Some disadvantages of using ios Swift are as follows: Swift is a new language: Swift is a newcomer compared to Objective C, which has been around since the 1980s. Swift came into being in 2014. It may experience growth pains as a result of this. Swift has a restricted set of tools and libraries, despite recent improvements with ABI Stability and backward compatibility. Also, there is not a very big community of ios Swift developers to help the budding ios Swift developers with their problems.\nBinary compatibility does not work every time: Despite the fact that Swift 5.1 has ABI Stability, code generated using multiple versions of Swift can cause issues. Code might have been built as a static library and put into a project as a dependency when developers mostly used Objective C. It was impossible to develop static libraries in Swift prior to the release of Swift's ABI. While this is now possible, including those dependencies in a project poses challenges.\nIt is not a Reflective Language: Reflection is a technique that can be used to watch and change the execution of a program while it is running. A reflection oriented software component can track the execution of a code enclosure and adjust its behaviour to meet the enclosure's goals. This is usually performed by assigning programme code dynamically at runtime. Swift is not a reflective programming language in the same way that Java or Kotlin are. Instead, it provides an alternative: the Mirror feature. Swift can \"self describe\" an object with this, but it can't alter it from within. If Swift had a reflection, it would automatically inject dependencies, however, this is thought to be impossible to achieve. Swift is a new language: Swift is a newcomer compared to Objective C, which has been around since the 1980s. Swift came into being in 2014. It may experience growth pains as a result of this. Swift has a restricted set of tools and libraries, despite recent improvements with ABI Stability and backward compatibility. Also, there is not a very big community of ios Swift developers to help the budding ios Swift developers with their problems. Swift is a new language: Binary compatibility does not work every time: Despite the fact that Swift 5.1 has ABI Stability, code generated using multiple versions of Swift can cause issues. Code might have been built as a static library and put into a project as a dependency when developers mostly used Objective C. It was impossible to develop static libraries in Swift prior to the release of Swift's ABI. While this is now possible, including those dependencies in a project poses challenges. Binary compatibility does not work every time: It is not a Reflective Language: Reflection is a technique that can be used to watch and change the execution of a program while it is running. A reflection oriented software component can track the execution of a code enclosure and adjust its behaviour to meet the enclosure's goals. This is usually performed by assigning programme code dynamically at runtime. Swift is not a reflective programming language in the same way that Java or Kotlin are. Instead, it provides an alternative: the Mirror feature. Swift can \"self describe\" an object with this, but it can't alter it from within. If Swift had a reflection, it would automatically inject dependencies, however, this is thought to be impossible to achieve. It is not a Reflective Language:",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "13. Name the JSON framework which is supported by iOS.",
        "answer": "iOS supports the SBJson framework. The SBJson framework adds more control and flexibility to the JSON handling process. It is a well designed and extremely adaptable framework that allows APIs (Application Programming Interfaces) to function in a variety of ways. SBJSON is one of the many open-source JSON parsers or generators created with Objective-C. These allow you to use JSON easily when coding Objective-C apps.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "14. What is the use of the \"mutating\" keyword in ios Swift?",
        "answer": "Ios Swift structs are immutable since they are of the value type. Other variables, for example, cannot modify the values of structure at any point in time. Only the \"mutating\" keyword is necessary to change the values of self variables within the function of the structure. Let us take the following code snippet for example: struct demoStruct {\n   var foo: String = \"Initial String\"\n   func transformString() {\n       foo = \"Transformed String\". \n//The above results in a compile time error: Cannot assign to property: 'self' is immutable. \n//We need to mark the method 'mutating' to make 'self' mutable.\n   }\n} struct demoStruct {\n   var foo: String = \"Initial String\"\n   func transformString() {\n       foo = \"Transformed String\". \n//The above results in a compile time error: Cannot assign to property: 'self' is immutable. \n//We need to mark the method 'mutating' to make 'self' mutable.\n   }\n} We get a compile-time error when we try to alter the value of variable \"foo\" inside a function declared in the struct itself. As a result, we will need to create a mutating function to update the value inside the structure. As a result, the correct code is: struct demoStruct {\n   var foo: String = \"Initial String\"\n   mutating func transformString() {\n       foo = \"Transformed String\". \n   }\n} struct demoStruct {\n   var foo: String = \"Initial String\"\n   mutating func transformString() {\n       foo = \"Transformed String\". \n   }\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "15. What do you understand about protocols in ios Swift?",
        "answer": "The protocol is a concept that is similar to a Java interface and is a highly common component of the Swift programming language. A protocol is a set of attributes, methods, and other requirements that are appropriate for a specific activity. The protocol, in its most basic form, is an interface that describes some methods and characteristics. Instead of implementation, the protocol is described as a skeleton of properties or methods. Enumerations, functions, and classes can be used to implement properties and methods. After the structure, enumeration, or class type names, protocols are declared. It is possible to declare both a single and several protocols. Commas are used to separate multiple protocols. A protocol can be defined in a similar way to structures, enumerations, and classes: Protocol demoProtocol\n{\n// the protocol definition will be going at this place\n} Protocol demoProtocol\n{\n// the protocol definition will be going at this place\n} Multiple protocols can be defined by separating them using commas: Class demoClass: demoSuperclass, protocolOne, protocolTwo\n{\n// the Structure definition will be going at this place\n} Class demoClass: demoSuperclass, protocolOne, protocolTwo\n{\n// the Structure definition will be going at this place\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "1. What do you understand about Grand Central Dispatch (GDC)?",
        "answer": "GCD (Grand Central Dispatch) is a low-level API for controlling several operations at the same time. This notion is employed to aid in the enhancement of application performance. This procedure is used to handle numerous jobs at once. The most relevant API for multitasking with Async and Sync programming in iOS is Grand Central Dispatch (GCD). Dispatch Queue: The task is managed in FIFO (First In First Out) order by the Dispatch Queue. Dispatch queues are thread-safe because they can be accessed by several threads at the same time.\nConcurrent: This process has started numerous tasks at the same time but does not know when they will finish. It can be completed in whatever sequence you want. They perform one or more things concurrently at the same time. The work is finished in the order in which it was queued, not in the order in which it was completed.\nSerial: A single task will be executed at a time. It is possible to use it to synchronize access to a certain resource.\nSync: After the work is completed, a synchronous function returns control to the caller.\nAsynchronous: An asynchronous function returns instantly after ordering a job to begin but does not wait for it to finish. Dispatch Queue: The task is managed in FIFO (First In First Out) order by the Dispatch Queue. Dispatch queues are thread-safe because they can be accessed by several threads at the same time. Dispatch Queue: Concurrent: This process has started numerous tasks at the same time but does not know when they will finish. It can be completed in whatever sequence you want. They perform one or more things concurrently at the same time. The work is finished in the order in which it was queued, not in the order in which it was completed. Concurrent: Serial: A single task will be executed at a time. It is possible to use it to synchronize access to a certain resource. Serial: Sync: After the work is completed, a synchronous function returns control to the caller. Sync: Asynchronous: An asynchronous function returns instantly after ordering a job to begin but does not wait for it to finish. Asynchronous",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "2. State your understanding of delegates in ios Swift.",
        "answer": "Delegate, in ios Swift, is a design pattern that allows data or communication to be passed across structs or classes. Delegate allows one object to deliver a message to another when a certain event occurs, and it is used to handle table and collection view events. Delegates have a one on one interaction and communicate with one another. An example of a delegate is given below: // Defining a custom delegate known as SeeActionDelegate\nprotocol SeeActionDelegate {\n   // Defining the required delegate variables\n   var state: GetState { get }\n   var userIdentity: String? { get set }\n   // Defining the required delegate blocks\n   var errorHandler: ((Error) -> Void)? { get set }\n   // Defining the required delegate functions\n   func handle(action: GetAction)\n} // Defining a custom delegate known as SeeActionDelegate\nprotocol SeeActionDelegate {\n   // Defining the required delegate variables\n   var state: GetState { get }\n   var userIdentity: String? { get set }\n   // Defining the required delegate blocks\n   var errorHandler: ((Error) -> Void)? { get set }\n   // Defining the required delegate functions\n   func handle(action: GetAction)\n} The enums used in the above delegate are: enum GetState {\n   case `default`\n   case loading\n}\nenum GetAction {\n   case saved\n   case canceled\n} enum GetState {\n   case `default`\n   case loading\n}\nenum GetAction {\n   case saved\n   case canceled\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "3. How can the double question mark symbol \"??\" be used in ios Swift programming?",
        "answer": "The nil-coalescing operator \"??\" is a shorthand for the ternary conditional operator, which we used to test for nil. A double question mark can also be used to set a variable's default value. \"default string\" stringVar?? This does precisely what you would expect: if stringVar is not nil, it is returned; otherwise, the \"default string\" is returned.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "4. What is the meaning of a GUARD statement? What are the advantages of using Swift's GUARD statement?",
        "answer": "When one or more conditions are not met, a GUARD statement is used to transfer program control out of the scope. This remark aids in avoiding the doomsday pyramid.  The following is the syntax of a GUARD statement: guard condition else\n{\nStatements\n} guard condition else\n{\nStatements\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "5. What do you understand about generics in ios Swift?",
        "answer": "Generics are a way to avoid code duplication. It is usual to repeat a method that takes one type of parameter to accommodate a parameter of a different type. Generics can be used in both functions and data types in Swift, such as classes, structures, and enumerations. func integerEquality(_ a: Int, _ b: Int) -> Bool {\n return a == b\n}\nfunc stringEquality(_ a: String, _ b: String) -> Bool {\n return a == b\n}\nstringEquality(\"hello\", \"hello\") // returns true\nintegerEquality(5, 5) // returns true func integerEquality(_ a: Int, _ b: Int) -> Bool {\n return a == b\n}\nfunc stringEquality(_ a: String, _ b: String) -> Bool {\n return a == b\n}\nstringEquality(\"hello\", \"hello\") // returns true\nintegerEquality(5, 5) // returns true For example, the second function in the above code is a \"clone\" of the first, but it accepts texts rather than numbers. func commonEquality<T: Equatable>(_ a: T, _ b: T) -> Bool {\n return a == b\n}\ncommonEquality(\"hello\", \"hello\") // returns true\ncommonEquality(5, 5) // returns true func commonEquality<T: Equatable>(_ a: T, _ b: T) -> Bool {\n return a == b\n}\ncommonEquality(\"hello\", \"hello\") // returns true\ncommonEquality(5, 5) // returns true You can consolidate the two functions into one and maintain type safety at the same time by using generics. Given above is the way to do it in general. Because you are testing equality here, you can use any type that implements the Equatable protocol as a parameter. This code achieves the desired outcome while preventing the use of non-typed parameters.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "6. What do you understand about optionals in ios Swift? What is the problem which they solve?",
        "answer": "An optional, in ios Swift, allows any type of variable to reflect a lack of value. The absence of value in Objective C is only available in reference types that use the nil special value. This is not possible with value types like int or float. With optionals, ios Swift extends the absence of value ideas to both reference and value types. An optional variable can be set to either a value or nil, which indicates that it has no value. An example of an optional is given below: var text: String?\ntext = \"I will go to school.\"\nprint(text) var text: String?\ntext = \"I will go to school.\"\nprint(text)",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "7. What are a few scenarios in which we can't avoid using implicitly unwrapped optionals and why so?",
        "answer": "The following are the most prevalent reasons for using implicitly unwrapped optionals: When you can't initialise a property that is not nil (absence of value) by definition at the moment of instantiation. An Interface Builder outlet, for example, is always initialised after its owner. In this case, you have ensured that the outlet is non-nil before using it, provided it's properly configured in Interface Builder.\nTo tackle the problem of a strong reference cycle, which occurs when two instances refer to each other and one of them requires a non-nil reference to the other. In this situation, one side of the reference is marked as unowned, while the other employs an implicitly unwrapped optional. When you can't initialise a property that is not nil (absence of value) by definition at the moment of instantiation. An Interface Builder outlet, for example, is always initialised after its owner. In this case, you have ensured that the outlet is non-nil before using it, provided it's properly configured in Interface Builder. To tackle the problem of a strong reference cycle, which occurs when two instances refer to each other and one of them requires a non-nil reference to the other. In this situation, one side of the reference is marked as unowned, while the other employs an implicitly unwrapped optional.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "8. In Swift, how would you describe a circular reference? What are your options for resolving it?",
        "answer": "When two instances have a strong connection to one other, a circular reference occurs, resulting in a memory leak because neither of the two instances will ever be deallocated. The reason for this is that you can't deallocate an instance if it has a strong reference to it, yet each instance maintains the other alive due to the strong reference. This might lead to a deadlock which is extremely bad for the application. Breaking the strong circular reference by replacing one of the strong references with a weak or unowned reference would fix the problem of a circular reference.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "9. State your understanding of core data.",
        "answer": "Apple's Core Data framework is one of the most powerful frameworks for macOS and iOS programmes. In our applications, core data is used to manage the model layer object. Within iOS applications, we may use Core Data as a framework to filter, alter, save, and track data. Core Data is not a relational database in the traditional sense. Without learning SQL, we can easily connect the objects in our app to the table records in the database using core data. The M in the MVC structure stands for core data. Some features of Core data are listed below: features of Core data Integration with the iOS and macOS toolchains is seamless.\nData organisation, filtering, and grouping in memory and in the user interface (User Interface).\nObject storage is supported automatically.\nProperty values are validated automatically.\nThe first object graph management framework.\nThe object graph's life cycle is managed using the Core Data framework. Integration with the iOS and macOS toolchains is seamless. Data organisation, filtering, and grouping in memory and in the user interface (User Interface). Object storage is supported automatically. Property values are validated automatically. The first object graph management framework. The object graph's life cycle is managed using the Core Data framework.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "10. What are the several methods for unwrapping an optional in Swift?",
        "answer": "The several methods for unwrapping an optional in Swift are as follows: Forced unwrapping: It consists in adding a ! after an Optional value, to automatically unwrap it, without having to check whether it is nil or not. Example - let v:String = b!\nOptional chaining: The technique of querying and calling properties, methods, and subscripts on an optional that is currently nil is known as optional chaining. The property, method, or subscript call succeeds if the optional includes a value; if the optional is nil, the property, method, or subscript call returns nil. Multiple inquiries can be chained together, and if any link in the chain is nil, the entire chain will fail gracefully. Example - Forced unwrapping: It consists in adding a ! after an Optional value, to automatically unwrap it, without having to check whether it is nil or not. Example - let v:String = b!\nOptional chaining: The technique of querying and calling properties, methods, and subscripts on an optional that is currently nil is known as optional chaining. The property, method, or subscript call succeeds if the optional includes a value; if the optional is nil, the property, method, or subscript call returns nil. Multiple inquiries can be chained together, and if any link in the chain is nil, the entire chain will fail gracefully. Example - Forced unwrapping:  let v = b?.count let v = b?.count Nil coalescing operator: If there is a value inside an optional, the nil coalescing operator unwraps it and returns it. If no value is provided – for example, if the optional is nil – a default value is used instead. The result will not be optional in either case: it will be either the value from within the optional or the default value used as a backup. Example - Nil coalescing operator: If there is a value inside an optional, the nil coalescing operator unwraps it and returns it. If no value is provided – for example, if the optional is nil – a default value is used instead. The result will not be optional in either case: it will be either the value from within the optional or the default value used as a backup. Example - Nil coalescing operator: let v = b ?? \"\" let v = b ?? \"\" Optional pattern: An optional pattern matches items wrapped in an Optional<Wrapped> enumeration's some(Wrapped) case. Optional patterns appear in the same places as enumeration case patterns and consist of an identifier pattern followed by a question mark. An example is given below: Optional pattern: An optional pattern matches items wrapped in an Optional<Wrapped> enumeration's some(Wrapped) case. Optional patterns appear in the same places as enumeration case patterns and consist of an identifier pattern followed by a question mark. An example is given below: Optional pattern: if case let v? = b {\n print(v)\n} if case let v? = b {\n print(v)\n} Guard statement: When certain requirements are not met, the guard statement in Swift is used to shift program control out of scope. With one key exception, the guard statement is comparable to the if statement. When a given condition is met, the if statement is executed. The guard statement, on the other hand, is executed when a given condition is not met. Example is given below: Guard statement: When certain requirements are not met, the guard statement in Swift is used to shift program control out of scope. With one key exception, the guard statement is comparable to the if statement. When a given condition is met, the if statement is executed. The guard statement, on the other hand, is executed when a given condition is not met. Example is given below: Guard statement: guard let v = b else {\n return\n} guard let v = b else {\n return\n} Optional binding: Optional binding is used to determine whether or not an optional has a value. If it does have a value, unwrap it and save it in a temporary variable or constant. Example is given below: Optional binding: Optional binding is used to determine whether or not an optional has a value. If it does have a value, unwrap it and save it in a temporary variable or constant. Example is given below: Optional binding if let v = b {\n print(\"b has been unwrapped with success and is = \\(v)\")\n} if let v = b {\n print(\"b has been unwrapped with success and is = \\(v)\")\n} Implicitly unwrapped variable declaration: Because a variable may start life as nil, but will always have a value before you need to use it, implicitly unwrapped optionals exist. It's helpful not to have to write if let all the time because you know they'll have value by the time you need them. Example: Implicitly unwrapped variable declaration: Because a variable may start life as nil, but will always have a value before you need to use it, implicitly unwrapped optionals exist. It's helpful not to have to write if let all the time because you know they'll have value by the time you need them. Example: Implicitly unwrapped variable declaration: var v = b! var v = b!",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "11. What is a Swift module?",
        "answer": "A single unit of code distribution in ios Swift is referred to as a module. The Swift \"import\" keyword can be used to import a framework or application that has been created and shipped as a single unit. In Swift, each Xcode build target is treated as an independent module. An example of using the \"import\" keyword is given below: import UIKit import UIKit",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "12. Explain the difference between Self and self in ios Swift.",
        "answer": "There is a distinction between Self (capital S) and self (small S) when writing protocols and protocol extensions. When used with a capital S, Self refers to the protocol compliant type, such as String or Int. When used with a lowercase S, self refers to the value contained within that type, such as \"hi\" or 999, for instance. Consider the following SquareInteger extension as an example: extension SquareInteger {\n   func squareANumber() -> Self {\n       return self * self\n   }\n} extension SquareInteger {\n   func squareANumber() -> Self {\n       return self * self\n   }\n} Remember that Self with a capital S refers to any type that follows the protocol. Because Int conforms to SquareInteger in the example above, when called on Int, the method returns an Int.  Self with a lowercase S, on the other hand, refers to the type's current value. If the preceding example were run on an Int containing the value 4, the result would be 4 * 4.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "13. What do you understand about PLIST in ios? List some examples of types of PLIST.",
        "answer": "The abbreviation PLIST in ios stands for Property List. PLIST is a value and key dictionary that can be saved in our file system using the .plist file extension. The property list is used to store a smaller quantity of data in a portable and lightweight manner. In most cases, they are written in XML. The following are examples of several sorts of property lists: Binary Property List\nXML Property List Binary Property List XML Property List",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "14. ASCII Legacy Property ListQuestion: What do you understand about training closure syntax in ios Swift?",
        "answer": "Many iOS Swift functions accept multiple parameters, the last of which is a closure. Trailing closure syntax is a small amount of syntactic sugar that makes reading and writing common code easier. For example, consider the following code snippet: func RunClosureAfterGreeting(name: String, closure: () -> ()) {\n   print(\"Hi, \\(name)!!!\")\n   closure()\n} func RunClosureAfterGreeting(name: String, closure: () -> ()) {\n   print(\"Hi, \\(name)!!!\")\n   closure()\n} Instead of the above code snippet, we can write the following code (which is way cleaner than the previous one): RunClosureAfterGreeting(name: \"Sonia\") {\n   print(\"The closure has been run\")\n} RunClosureAfterGreeting(name: \"Sonia\") {\n   print(\"The closure has been run\")\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "15. Explain Protocol Vs Class in ios Swift.",
        "answer": "A protocol, in its most basic form, explains what an unknown sort of object can accomplish. It has two or three different sorts of properties, as well as procedures. Protocol never includes anything inside the methods, nor does it provide actual storage for the properties. You can build extensions to your protocols that give default implementations of the methods in a more advanced form. However, you are still unable to provide storage for properties. A protocol, in its most basic form, explains what an unknown sort of object can accomplish. It has two or three different sorts of properties, as well as procedures. Protocol never includes anything inside the methods, nor does it provide actual storage for the properties. You can build extensions to your protocols that give default implementations of the methods in a more advanced form. However, you are still unable to provide storage for properties. extension Car : CustomStringConvertible {\n   var description : String { get { return \"Car: \\(colour)\" } }\n} extension Car : CustomStringConvertible {\n   var description : String { get { return \"Car: \\(colour)\" } }\n} Classes are tangible objects. They are not needed to embrace protocols, which means they do not have to implement the required attributes and methods. Classes can be used to generate objects, whereas protocols are simply typed declarations. Consider protocols to be abstract definitions, whereas classes and structs are actual objects that can be created. An example of a class is given below: Classes are tangible objects. They are not needed to embrace protocols, which means they do not have to implement the required attributes and methods. Classes can be used to generate objects, whereas protocols are simply typed declarations. Consider protocols to be abstract definitions, whereas classes and structs are actual objects that can be created. An example of a class is given below: class Car {\n   var colour: String\n} class Car {\n   var colour: String\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "16. How should one consider the usage of strong, weak and unowned references?",
        "answer": "Ask yourself, \"Am I dealing with reference types?\" to see if you need to worry about strong, weak, or unowned. If you are working with Structs or Enums, ARC is not in charge of memory management, so you do not have to worry about defining weak or unowned constants or variables. In hierarchical relationships, strong references are acceptable when the parent refers to the child, but not when the child refers to the parent. Strong references are, in fact, the most appropriate type of reference the majority of the time. If two instances are optionally linked, make sure one of them has a weak reference to the other. When two instances are linked to the point where one cannot exist without the other, the instance with the obligatory dependency must keep an unowned reference to the other instance.  ",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "17. When is the usage of a set more preferable than an array in ios Swift?",
        "answer": "If all of the following conditions are met, you should use a set rather than an array: You only want to add each item once. Duplicates are never permitted in sets.\nThe order of the items in the collection is irrelevant to you.\nYou are storing Hashable types, either your own or those provided by Swift, such as strings and integers. Hash values are used in sets to look for things quickly. You only want to add each item once. Duplicates are never permitted in sets. The order of the items in the collection is irrelevant to you. You are storing Hashable types, either your own or those provided by Swift, such as strings and integers. Hash values are used in sets to look for things quickly.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "18. Show the use of \"self\" in a method using an example.",
        "answer": "In Swift, the self property of an instance is a special property that holds the instance itself. In most cases, self appears in a class, structure, or enumeration's initializer or method. The most common use of self is in initializers when you are likely to want parameter names that match your type's property names, such as this: struct student {\n   var myName: String\n   var myFriend: String\n   init(myName: String, myFriend: String) {\n       print(\"\\(name) is being enrolled in class...\")\n       self.myName = myName\n       self.myFriend = myFriend\n   }\n} struct student {\n   var myName: String\n   var myFriend: String\n   init(myName: String, myFriend: String) {\n       print(\"\\(name) is being enrolled in class...\")\n       self.myName = myName\n       self.myFriend = myFriend\n   }\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "19. How can we use the \"inout\" parameter in ios Swift? Explain with an example.",
        "answer": "By default, function parameters are constants. Changing the value of a function parameter from within the function's body causes a compile-time error. Modifying the local variable also modifies the passed in arguments, which is known as the \"inout\" parameter. The passed-in arguments will have the same value if it is not present. Trying to remember the reference type while using inout and the value type when not using it. The swap function, which modifies the parameters handed in, is an excellent example. Consider reducing the copying overhead as well. If you have a function that takes a memory-intensive large value type as an argument (say, a huge structure type) and returns the same type, and the function return is only used to replace the caller argument, the inout parameter is the associated function parameter to use. As we can see in the example given below, a call to the function \"demoFunction\" copies arguments to function property 'aBigStruct'(copy 1) and the function property is mutated after which, the function returns a copy of the mutated property to the caller (copy 2). However, in the function \"demoFunctionWithLessCopyOverhead\", call by reference is being done and zero value copy overhead is there because of the usage of inout optimization. struct demoStruct {\n   private var counter: Int = 1\n   // ... a lot of stored properties\n   mutating func incrementCounter() {\n       counter += 1\n   }\n}\n/* call to this function copies argument to function property 'aBigStruct'(copy 1)\n  function property is mutated\n  function returns a copy of mutated property to caller (copy 2) */\nfunc demoFunction(var aBigStruct: MyStruct) -> MyStruct {\n   aBigStruct.incrementCounter()\n   return aBigStruct\n}\n/* call by reference -> zero value copy overhead because of the inout optimization */\nfunc demoFunctionWithLessCopyOverhead(inout aBigStruct: MyStruct) {\n   aBigStruct.incrementCounter()\n}\nvar ex = MyStruct()\nex = demoFunction(ex) // copy, copy: overhead\ndemoFunctionWithLessCopyOverhead(&ex) \n// call by reference: no memory reallocation struct demoStruct {\n   private var counter: Int = 1\n   // ... a lot of stored properties\n   mutating func incrementCounter() {\n       counter += 1\n   }\n}\n/* call to this function copies argument to function property 'aBigStruct'(copy 1)\n  function property is mutated\n  function returns a copy of mutated property to caller (copy 2) */\nfunc demoFunction(var aBigStruct: MyStruct) -> MyStruct {\n   aBigStruct.incrementCounter()\n   return aBigStruct\n}\n/* call by reference -> zero value copy overhead because of the inout optimization */\nfunc demoFunctionWithLessCopyOverhead(inout aBigStruct: MyStruct) {\n   aBigStruct.incrementCounter()\n}\nvar ex = MyStruct()\nex = demoFunction(ex) // copy, copy: overhead\ndemoFunctionWithLessCopyOverhead(&ex) \n// call by reference: no memory reallocation",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "1. Let us take into consideration the following code snippet in ios Swift:",
        "answer": "struct Course{\n var toughness: Int = 3\n}\nvar courseOne = Course()\nvar courseTwo = courseOne\ncourseTwo.toughness = 4 struct Course{\n var toughness: Int = 3\n}\nvar courseOne = Course()\nvar courseTwo = courseOne\ncourseTwo.toughness = 4 What will be the respective values of courseOne.toughness and courseTwo.toughness? If Course was a class instead of a struct, would the values be any different? What will be the respective values of courseOne.toughness and courseTwo.toughness? If Course was a class instead of a struct, would the values be any different? The value of courseOne.toughness will be 3 and the value of courseTwo.toughness will be 4 if Course is a structure since Structures in ios Swift are value types and the following line just copies the courseOne to courseTwo by value and not by reference: var courseTwo = courseOne var courseTwo = courseOne If Course was a class instead of a struct, then the above given line would copy courseOne to courseTwo by reference and therefore, the values of both courseOne and courseTwo would be 4 by the end of the code snippet as they have the same address. Classes in ios Swift are Reference types therefore both the given courses have the same address.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "2. In the given code snippet, we have used var to declare viewOne and let to create viewTwo. Will the last line compile?",
        "answer": "import UIKit\nvar viewOne = UIView()\nviewOne.alpha = 0.7\nlet viewTwo = UIView()\nviewTwo.alpha = 0.7 // Does this line compile? import UIKit\nvar viewOne = UIView()\nviewOne.alpha = 0.7\nlet viewTwo = UIView()\nviewTwo.alpha = 0.7 // Does this line compile? The last line will, in fact, compile. viewOne is a variable that we can reassign to a new UIView object. Because we can only assign a value once with let, the following code will not compile: viewTwo = viewOne // Error: viewTwo is immutable viewTwo = viewOne // Error: viewTwo is immutable However, because UIView is a reference-based class, we can change the properties of viewTwo — which means the following code will compile: let viewTwo = UIView()\nviewTwo.alpha = 0.7 // Yes, this compiles! let viewTwo = UIView()\nviewTwo.alpha = 0.7 // Yes, this compiles!",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "3. Take a look at the code snippet given below. Will the given code fail to compile? If yes, why?",
        "answer": "public class TemperatureClass {\n private(set) var temp: Double = 50.0\n public func changeTemperature(_ temp: Double) {\n   self.temp = temp\n }\n}\nlet temperatureClass = TemperatureClass()\ntemperatureClass.changeTemperature(72.3)\npublic struct TemperatureStruct {\n private(set) var temp: Double = 50.0\n public mutating func changeTemperature(_ temp: Double) {\n   self.temp = temp\n }\n}\nlet temperatureStruct = TemperatureStruct ()\ntemperatureStruct.changeTemperature(72.3) public class TemperatureClass {\n private(set) var temp: Double = 50.0\n public func changeTemperature(_ temp: Double) {\n   self.temp = temp\n }\n}\nlet temperatureClass = TemperatureClass()\ntemperatureClass.changeTemperature(72.3)\npublic struct TemperatureStruct {\n private(set) var temp: Double = 50.0\n public mutating func changeTemperature(_ temp: Double) {\n   self.temp = temp\n }\n}\nlet temperatureStruct = TemperatureStruct ()\ntemperatureStruct.changeTemperature(72.3) Yes, the code given will fail to compile because of the last line of the code. The TemperatureStruct has a mutating method to change its internal variable temp, which is correctly declared. Because we called changeTemperature on an object generated using let, which is immutable, the compiler gives an error. To make the example compile, change let to var. Methods that affect the internal state of a structure must be marked as mutating, but they cannot be invoked from immutable variables.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "4. Predict the output of the following ios Swift program:",
        "answer": "var item = \"apples\"\nlet closure = { [item] in\n print(\"He wanted to eat \\(item)\")\n}\nitem = \"oranges\"\nclosure() var item = \"apples\"\nlet closure = { [item] in\n print(\"He wanted to eat \\(item)\")\n}\nitem = \"oranges\"\nclosure() The output of the given code snippet will be \"He wanted to eat apples\". When we define the closure, the capture list generates a duplicate of the item. This means that even if you modify the value of an object, the captured value remains the same.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "5. Predict the output of the ios Swift code snippet given below",
        "answer": "var item = \"apples\"\nlet closure = {\n print(\"He wanted to eat \\(item)\")\n}\nitem = \"oranges\"\nclosure() var item = \"apples\"\nlet closure = {\n print(\"He wanted to eat \\(item)\")\n}\nitem = \"oranges\"\nclosure() The above-given code snippet prints \"He wanted to eat oranges\". If you do not include a capture list in the closure, the compiler will use a reference rather than a copy. As a result, any change to the variable is reflected when the closure is invoked.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "6. Take into consideration the following struct:",
        "answer": "public struct Temperature{\n public var temp: Double\n public init(temp: Double) {\n   self.temp = temp\n }\n} public struct Temperature{\n public var temp: Double\n public init(temp: Double) {\n   self.temp = temp\n }\n} Can we do an initialization using the following code: Can we do an initialization using the following code: var temp: Temperature = 60.5 var temp: Temperature = 60.5 Yes, Swift specifies protocols that allow you to use the assignment operator to initialize a type with literal values. Literal initialization of a certain type is possible by adopting the corresponding protocol and supplying a public initializer. You implement ExpressibleByFloatLiteral as follows in the example of Temperature: extension Temperature: ExpressibleByFloatLiteral {\n public init(floatLiteral value: FloatLiteralType) {\n   self.init(temp: value)\n }\n} extension Temperature: ExpressibleByFloatLiteral {\n public init(floatLiteral value: FloatLiteralType) {\n   self.init(temp: value)\n }\n} After this, we can do the above-given initialization without any errors.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "7. To conduct arithmetic or logic tasks, Swift offers a collection of predefined operators. It also enables for the construction of bespoke unary and binary operators.",
        "answer": "Define and implement a custom power ^^ operator that satisfies the following requirements: Define and implement a custom power ^^ operator that satisfies the following requirements: As arguments, it accepts two Ints.\nThe first parameter is returned after raising it to the second parameter's power.\nThe equation is correctly evaluated using the conventional algebraic sequence of operations.\nOverflow errors are not taken into account. As arguments, it accepts two Ints. As arguments, it accepts two Ints. The first parameter is returned after raising it to the second parameter's power. The first parameter is returned after raising it to the second parameter's power. The equation is correctly evaluated using the conventional algebraic sequence of operations. The equation is correctly evaluated using the conventional algebraic sequence of operations. Overflow errors are not taken into account. Overflow errors are not taken into account. There are two steps to creating a new custom operator: Declaration: The \"operator\" keyword is used in the declaration to indicate the type of the operator (unary or binary), the sequence of letters that make up the operator, associativity, and precedence. The operator here is ^^ and the type is infix (binary) in this case. Equal precedence operators ^^ should evaluate the equation from right to left (associativity is right). The following is the declaration step: Declaration: The \"operator\" keyword is used in the declaration to indicate the type of the operator (unary or binary), the sequence of letters that make up the operator, associativity, and precedence. The operator here is ^^ and the type is infix (binary) in this case. Equal precedence operators ^^ should evaluate the equation from right to left (associativity is right). The following is the declaration step: Declaration: precedencegroup ExponentPrecedence {\n higherThan: MultiplicationPrecedence\n associativity: right\n}\ninfix operator ^^: ExponentPrecedence precedencegroup ExponentPrecedence {\n higherThan: MultiplicationPrecedence\n associativity: right\n}\ninfix operator ^^: ExponentPrecedence Implementation: In Swift, there is no set precedence for exponential operations. Exponents should be calculated before multiplication and division in the normal algebra sequence of operations. As a result, you will need to set custom precedence that puts them ahead of multiplication. The following is the implementation step: Implementation: In Swift, there is no set precedence for exponential operations. Exponents should be calculated before multiplication and division in the normal algebra sequence of operations. As a result, you will need to set custom precedence that puts them ahead of multiplication. The following is the implementation step: Implementation: func ^^(base: Int, exponent: Int) -> Int {\n let left = Double(base)\n let right = Double(exponent)\n let powerValue = pow(left, right)\n return Int(powerValue)\n} func ^^(base: Int, exponent: Int) -> Int {\n let left = Double(base)\n let right = Double(exponent)\n let powerValue = pow(left, right)\n return Int(powerValue)\n} It can be noted that as the program does not take overflows into consideration, in the event of the operation producing a result that Int can't represent, for example, a value more than Int.max, then a runtime error occurs.",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "8. You are on a two-dimensional infinite grid where you can move in any of the eight directions (x,y) to (x-1, y-1), (x-1, y), (x-1, y+1), (x , y-1), (x , y+1), (x+1, y-1), (x+1, y) , (x+1, y+1).",
        "answer": "You are given a list of points to cover and the order in which you must do so. Write an ios Swift code to give the shortest number of steps you can take to achieve it. You begin from the first point of the given list. You are given a list of points to cover and the order in which you must do so. Write an ios Swift code to give the shortest number of steps you can take to achieve it. You begin from the first point of the given list. Because the order in which the points are covered is already known, the problem is reduced to figuring out how to calculate the distance between two points (A, B) and the distance between two points (A, B) and the distance between two points (A, B) and the distance between two points (A, B) and the distance between two points (A, B) and the distance (C, D). It is worth noting that just X = abs(A-C) and Y = abs(A-C) are important (B-D). You will progress along the diagonal while X and Y are both positive, and X and Y will both decrease by one. When one of them reaches zero, you move on to the next stage, reducing the remaining number by one. In other words, the total number of steps would be equal to the maximum number of steps (X, Y) The code in ios Swift to solve this given problem is given below: import Foundation\nclass Solution {\n   func coverEveryPoint(_ X: inout [Int], _ Y: inout [Int]) -> Int {\n   \n       if X.count != Y.count || X.count == 0 || X.count == 1 {\n           return 0\n       }\n       var dist = 0\n       for j in 0 ..< X.count - 1 {\n           let xOne = X[j]\n           let yOne = Y[j]\n           let xTwo = X[j + 1]\n           let yTwo = Y[j + 1]\n           dist += distanceFinder((xOne , yOne), (xTwo, yTwo))\n       }\n       return dist\n   }\n   \n   func distanceFinder(_ X: (x: Int, y: Int), _ Y: (x: Int, y: Int)) -> Int {\n       return (abs(X.y - Y.y) - abs(X.x - Y.x)) > 0 ? abs(X.y - Y.y) : abs(X.x - Y.x)\n   }\n} import Foundation\nclass Solution {\n   func coverEveryPoint(_ X: inout [Int], _ Y: inout [Int]) -> Int {\n   \n       if X.count != Y.count || X.count == 0 || X.count == 1 {\n           return 0\n       }\n       var dist = 0\n       for j in 0 ..< X.count - 1 {\n           let xOne = X[j]\n           let yOne = Y[j]\n           let xTwo = X[j + 1]\n           let yTwo = Y[j + 1]\n           dist += distanceFinder((xOne , yOne), (xTwo, yTwo))\n       }\n       return dist\n   }\n   \n   func distanceFinder(_ X: (x: Int, y: Int), _ Y: (x: Int, y: Int)) -> Int {\n       return (abs(X.y - Y.y) - abs(X.x - Y.x)) > 0 ? abs(X.y - Y.y) : abs(X.x - Y.x)\n   }\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "9. There is a compile time error in the following code. Are you able to recognise it and explain why it occurs? What are some possible solutions?",
        "answer": "struct Cat{\n}\nfunc showCat(cat: Cat?) {\n guard let c = cat else {\n   print(\"No presence of cat\")\n }   \n print(c)\n} struct Cat{\n}\nfunc showCat(cat: Cat?) {\n guard let c = cat else {\n   print(\"No presence of cat\")\n }   \n print(c)\n} The problem with the given code is that a guard's else block requires an escape path, which can be achieved by returning, throwing an exception, or calling a @noreturn. Adding a return statement is the simplest approach: @noreturn func showCat(cat: Cat?) {\n guard let c = Cat else {\n   print(\"No presence of cat\")\n   return\n }\n print(c)\n} func showCat(cat: Cat?) {\n guard let c = Cat else {\n   print(\"No presence of cat\")\n   return\n }\n print(c)\n} A fatalError() can also be called which is a @noreturn function: @noreturn struct Cat{\n}\nfunc showCat(cat: Cat?) {\n guard let c = Cat else {\n   print(\"No presence of cat\")\n   fatalError()\n }\n print(c)\n} struct Cat{\n}\nfunc showCat(cat: Cat?) {\n guard let c = Cat else {\n   print(\"No presence of cat\")\n   fatalError()\n }\n print(c)\n}",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "10. This below given difficult code sorts an array of fruits. Write down ways to code the given logic in a simpler way than the code given below.",
        "answer": "var fruits = [\"apples\", \"oranges\", \"papaya\", \"kiwi\"]\nfruits.sort { (a: String, b: String) -> Bool in\n   return a < b\n}\nprint(fruits) var fruits = [\"apples\", \"oranges\", \"papaya\", \"kiwi\"]\nfruits.sort { (a: String, b: String) -> Bool in\n   return a < b\n}\nprint(fruits) There are three ways in which we can simplify the given code snippet: fruits.sort { (a,b) in return a < b } fruits.sort { (a,b) in return a < b } fruits.sort { $0 < $1 } fruits.sort { $0 < $1 } fruits.sort(by: <) fruits.sort(by: <) Conclusion: Apple gadgets are used by billions of people all over the world. The number of iOS users has been constantly increasing, which is good news for iOS application developers. iOS Swift developers must also keep up with the latest developments in the iOS Swift community. Make sure you are keeping up with Apple developer news, podcasts, and blogs. This is unlikely to be a question in an interview, but it distinguishes you. We hope that the Swift Interview questions answered here are extremely helpful in studying the fundamentals and advanced topics of iOS Swift. Any beginner or experienced professional who understands these Swift and iOS developer interview questions will be able to pass the interview on the first try. All the best for your upcoming interviews! iOS application developers iOS application developers",
        "reference": "interviewbit.com",
        "role": "swift"
    },
    {
        "question": "1) What is Swift? How is it different from Objective-C?",
        "answer": "Swift and Objective-C both are used in iOS development but both are significantly different in terms of efficiency and usage.\nADVERTISEMENT\nSwift is an open-source programming language developed by Apple platform and expanded to build on Linus while Objective-C is not an open-source programming language and is limited to Apple.\nSwift syntax is easy, clear and brief. It makes API's easy to read and maintain while Objective-C is based on C language which is comparatively hard to use.\nSwift is more rational and precise that's why it has less number of code and easy to learn while Objective-C code is lengthy as double to Swift code.\nSwift can be compiled as a dynamic framework while Objective-C cannot be compiled into static libraries and dynamic framework.\nFor more information: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "2) What is the meaning of question mark \"?\" in Swift?",
        "answer": "In Swift, question mark \"?\" is used in property declaration. It tells the compiler that this property is optional. The property may hold a value or not. It avoids runtime errors when accessing that property by using ?. This is useful in optional chaining and a variant of this example is in conditional clauses.\nFor example:\nvar optionalName : String? = \"John\"  \nif optionalName != nil {  \n    print(\"Your name is \\(optionalName!)\")  \n}",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "3) How can you make a property optional in Swift?",
        "answer": "We have to declare a question mark ??' in the code to make a property optional. If a property doesn't have a value, then the symbol ? helps to avoid the runtime error.",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "4) What are the Half Open Range operators in Swift?",
        "answer": "Swift supports several types of operators. One of them is Half Open Range operator. The half open range operator specifies a range between two values a and b (a<b) where b is not included. It is known as half open range operator because it contains its first value only not the final value.\nTo learn more on Swift operators: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "5) What are functions in Swift?",
        "answer": "Functions are the set of codes used to perform specific task. In Swift programming language, functions are used to pass local as well global parameter values inside the function's call.\nIn Swift4, functions can be categorized in two types:\nUser Defined Functions\nBuilt-in Functions (Library Functions)\nTo learn more functions in Swift: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "6) What is Nested Function in Swift?",
        "answer": "A function inside a function is called a nested function.\nSyntax:\nfunc function1() {    \n    //statements of outer function    \n    func function2() {    \n        //statements of inner function    \n    }    \n}    \nTo learn more about nested functions: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "",
        "answer": "Enum is also known as Swift Enumeration. Enum is a data type which contains a set of the related values. It is declared in a class and its values are accessed through the instance members of that class.\nSyntax:\nenum enum_name    \n{    \n// values are described here    \n}",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "8) What are Regular Expression and Responder Chain in Swift?",
        "answer": "Regular Expression: Regular expressions are the special string patterns that specify how to perform a search through a string.\nResponder Chain: Responder Chain is a hierarchy of objects that obtain the opportunity to respond to the events.",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "",
        "answer": "Swift Dictionary is used to store the key-value pairs and access the value by using the key. It is just like hash tables in other programming languages.\nTo learn more about Swift dictionary: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "10) How would you define variables and constants in Swift programming language?",
        "answer": "You have to declare variables and constants before using it. Constants are declared by using let keyword and variables by var keyword.\nExample:\nvar javatpoint = \"This is JavaTpoint\"  \nlet fees = 10000",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "11) Explain the different features of Swift programming language?",
        "answer": "Features of Swift programming language:\nSwift is very easy to learn and precise to use. It provides a safe programming approach.\nIn Swift programming language, variables and constants must be initialized before use.\nAutomatic memory management.\nSwift uses \"switch\" function instead of \"if\" statement for conditional programming.\nSwift follows Objective-C like syntax.\nIt checks Arrays and integers for overflow.\n\nRead more features of Swift: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "12) What type of literals does Swift language have?",
        "answer": "A Swift literal is a direct value of a variable or a constant. It may be a number, character or string. Literals are used to initialize or assign value to variables or constants.\nDifferent types of literals are:\nBinary Literals\nOctal Literals\nHexadecimal Literals\nDecimal Literals\nLearn more about Swift literals: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "13) What is floating point number in Swift? What are the different floating point numbers in Swift?",
        "answer": "Numbers with decimal values or fractional components are called floating numbers. For example: 1.34 is a floating point number. Floating point types can represent a wider range of values than integer types. There are two signed floating point number:\nDouble: It represents a 64 bit floating point number. It is used when floating point values are very large.\n\nFloat: It represents a 32 bit floating point number. It is used when floating point values does not need 64 bit precision.",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "14) How can you write a comment in Swift?",
        "answer": "In Swift programming language, single-line comments are started with double slashes (//).\nFor example:\n// This is a single line comment.  \nMulti-line comment: Multiline comments are started with a forward-slash followed by an asterisk (/*) and end with an asterisk followed by a forward-slash (*/).\nFor example:\n/* this is multi \nLine comment*/  \nLearn more about Swift syntax: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "15) What are the different control transfer statements used in Swift?",
        "answer": "Swift language consists of following Control transfer statements:\nContinue\nBreak\nFallthrough\nReturn",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "16) What do you mean by Optional Chaining in Swift?",
        "answer": "In Swift programming language, Optional Chaining is a process of querying and calling properties. You can chain multiple queries together, but if any link in the chain is nil then, the entire chain fails.",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "17) What is lazy stored procedure in Swift and when is it used?",
        "answer": "Lazy stored properties are used for a property whose initial values are not calculated until the first time it is used. A lazy stored property can be declared by writing the lazy modifier before its declaration. Lazy properties are useful when the initial value for a property is reliant on outside factors whose values are unknown.",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "18) What is the usage of switch statement in Swift language?",
        "answer": "Switch statement are used as a substitute for the long if-else-if statements.\nSwitch statement supports any type of data, synchronizes them and also checks for equality.\nBreak is not required in switch statement because there is no fall through in switch statement.\nSwitch statement must have covered all possible values for your variable.\nTo read more about Swift switch statement: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "19) What is the use of break statement in Swift language?",
        "answer": "The break statement is used within a loop where you have to immediately terminate a statement. It is also used to terminate a case in switch statement.\nTo read more about Swift break statement: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "20) What is the use of continue statement in Swift loop?",
        "answer": "The continue statement is used in Swift loop to change execution from its normal sequence. It stops currently executing statement and starts again at the beginning of the next iteration through the loop.\nTo read more about Swift continue statement: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "21) What are the different collection types available in Swift?",
        "answer": "There are two varieties of collection types in Swift:\nArray: In Swift, you can create an array of single type or an array of multiple type.\nRead more information about Swift array: Click Here...\nDictionary: In Swift, dictionary is similar to hash table in other programing language. You can store a key-value pair in a dictionary and access the value by using the key.\nRead more information about Swift dictionary: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    },
    {
        "question": "22) What is Inheritance in Swift?",
        "answer": "Inheritance is a process in which a class can inherit properties, methods and other characteristics from another class. Inheritance is supported in Swift programming language. There are two types of classes in Inheritance in Swift:\nSub class: The class which inherits the properties from other class is called child class or sub class.\nSuper class: The main class from where the subclass inherits the properties is known as parent class or super class.\nRead more information about Swift inheritance: Click Here...",
        "reference": "javatpoint.com",
        "role": "swift"
    }
]