[
    {
        "question": "1. Write a program in Java to show a basic “divide by 0 exception”.",
        "answer": "Divide by zero exception occurs when we try to divide a number by 0 in Java. Following is the program showing divide by 0 exception. import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        System.out.println(\"Dividing this number by 0\");\n        try {\n            System.out.println(n/0);\n        } catch(Exception e) {\n            System.out.println(e);\n        }\n        System.out.println(\"Program completed\");\n }\n} import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        System.out.println(\"Dividing this number by 0\");\n        try {\n            System.out.println(n/0);\n        } catch(Exception e) {\n            System.out.println(e);\n        }\n        System.out.println(\"Program completed\");\n }\n} import class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here new int \"Dividing this number by 0\" try 0 catch \"Program completed\" Output Output Input: 3\n\nOutput:\nDividing this number by 0\njava.lang.ArithmeticException: / by zero\nProgram completed Input: 3\n\nOutput:\nDividing this number by 0\njava.lang.ArithmeticException: / by zero\nProgram completed 3 this 0 Important: In this question, we used the try and catch block for handling the divide by 0 exception. Hence, the complete execution of the program took place. Otherwise, the program would have stopped at the exception, and “Program completed” would not have been printed. Important:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "2. Write a program to show a single thread in Java.",
        "answer": "Java Program to show Single Thread Java Program to show Single Thread public class Main {\n    public static void main(String[] args) {\n       Thread t = Thread.currentThread();\n       t.setName(\"My Main Thread\");\n       t.setPriority(7);\n       System.out.println(t);\n       System.out.println(t.getName());\n       System.out.println(t.getPriority());\n       \n   }\n} public class Main {\n    public static void main(String[] args) {\n       Thread t = Thread.currentThread();\n       t.setName(\"My Main Thread\");\n       t.setPriority(7);\n       System.out.println(t);\n       System.out.println(t.getName());\n       System.out.println(t.getPriority());\n       \n   }\n} public class Main class Main public static void main(String[] args) public static void main (String[] args) \"My Main Thread\" 7 Output Output Thread[My Main Thread,7,main]\nMy Main Thread\n7 Thread[My Main Thread,7,main]\nMy Main Thread\n7 7 7",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "3. Write a program in Java to generate the Nth Fibonacci Number using Iteration and Constant Space.",
        "answer": "Fibonacci Series is a series in which the Nth term is the sum of the previous 2 terms i.e. (N-1)th and (N-2)th terms. The first 2 terms of the Fibonacci sequence are always known. They are 0 and 1 respectively. After this, the further terms can be generated as follows:   So, in general, we can derive a generic term i.e. Fib(N) = Fib(N - 1) + Fib(N - 2) Fib(N) = Fib(N - 1) + Fib(N - 2) So, let us now write a program to find the Nth Fibonacci Number using iteration. a. Java Program to generate Nth Fibonacci Number using Iteration. a. Java Program to generate Nth Fibonacci Number using Iteration. import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  int n = scn.nextInt();\n\n  int a = 0; //0th fibonacci number\n  int b = 1; //1st fibonacci number\n\n  if(n < 0) {\n   System.out.println(\"N cannot be negative\");\n   return;\n  }\n\n  if(n == 0) System.out.println(a);\n  else if(n == 1) System.out.println(b);\n  else {\n   int c = 0;\n   for(int i=2;i<=n;i++) {\n    c = a + b;\n    a = b;\n    b = c;\n   }\n\n   System.out.println(c);\n  }\n\n }\n} import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  int n = scn.nextInt();\n\n  int a = 0; //0th fibonacci number\n  int b = 1; //1st fibonacci number\n\n  if(n < 0) {\n   System.out.println(\"N cannot be negative\");\n   return;\n  }\n\n  if(n == 0) System.out.println(a);\n  else if(n == 1) System.out.println(b);\n  else {\n   int c = 0;\n   for(int i=2;i<=n;i++) {\n    c = a + b;\n    a = b;\n    b = c;\n   }\n\n   System.out.println(c);\n  }\n\n }\n} import class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here new int int 0 //0th fibonacci number int 1 //1st fibonacci number if 0 \"N cannot be negative\" return if 0 else if 1 else int 0 for int 2 Sample Input/Output: Run Code Sample Input/Output: Run Code Run Code Input: 7\nOutput: 13 Input: 7\nOutput: 13 7 13 Corner Cases You might Miss: The simple mistake of not handling the corner case when N is negative can happen to a lot of programmers. Since the number of terms can’t be negative, this should be handled separately as shown in the code above.\nTime Complexity: O(N) because we have to travel N terms\nAuxiliary Space:  O(1) as no extra space is used.\nFollow up: You can also solve this problem using dynamic programming. This will take up O(N) space as well and the time complexity will be the same i.e. O(N). Try the dynamic programming approach yourself. Corner Cases You might Miss: The simple mistake of not handling the corner case when N is negative can happen to a lot of programmers. Since the number of terms can’t be negative, this should be handled separately as shown in the code above. Corner Cases You might Miss: Time Complexity: O(N) because we have to travel N terms Time Complexity: Auxiliary Space:  O(1) as no extra space is used. Auxiliary Space: Follow up: You can also solve this problem using dynamic programming. This will take up O(N) space as well and the time complexity will be the same i.e. O(N). Try the dynamic programming approach yourself. Follow up:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "4. Write a program in Java to show inheritance in Java.",
        "answer": "This program is for testing the concepts of inheritance in Java and the usage of extends keyword. Following is an example program in which a class SmartPhone extends a class Phone. This is a real-life example as a phone has basic features of calling and messaging whereas a smartphone has several other features like clicking pictures, playing music, etc. Java Code for showing Inheritance Java Code for showing Inheritance class Phone {\n    private int number;\n    \n    Phone() {\n\n    }\n\n    void setNumber(int number) {\n        this.number = number;\n    }\n\n    int getNumber() {\n        return number;\n    }\n\n    public void call() {\n        System.out.println(\"Call is made\");\n    }\n\n    public void message() {\n        System.out.println(\"Message is sent\");\n    }\n\n}\n\nclass SmartPhone extends Phone {\n\n    int cameraMegaPX;\n\n    public void click() {\n        System.out.println(\"A photograph was clicked\");\n    }\n\n    public void playMusic() {\n        System.out.println(\"Music Started Playing\");\n    }\n\n    public void pauseMusic() {\n        System.out.println(\"Music Paused\");       \n    }\n\n    public void stopMusic() {\n        System.out.println(\"Music Stopped\");\n    }\n}\n\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n\n        SmartPhone p1 = new SmartPhone();\n        p1.setNumber(9863472);\n        System.out.println(\"Phone number is: \" + p1.getNumber());\n        p1.call();\n        p1.playMusic();\n }\n} class Phone {\n    private int number;\n    \n    Phone() {\n\n    }\n\n    void setNumber(int number) {\n        this.number = number;\n    }\n\n    int getNumber() {\n        return number;\n    }\n\n    public void call() {\n        System.out.println(\"Call is made\");\n    }\n\n    public void message() {\n        System.out.println(\"Message is sent\");\n    }\n\n}\n\nclass SmartPhone extends Phone {\n\n    int cameraMegaPX;\n\n    public void click() {\n        System.out.println(\"A photograph was clicked\");\n    }\n\n    public void playMusic() {\n        System.out.println(\"Music Started Playing\");\n    }\n\n    public void pauseMusic() {\n        System.out.println(\"Music Paused\");       \n    }\n\n    public void stopMusic() {\n        System.out.println(\"Music Stopped\");\n    }\n}\n\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n\n        SmartPhone p1 = new SmartPhone();\n        p1.setNumber(9863472);\n        System.out.println(\"Phone number is: \" + p1.getNumber());\n        p1.call();\n        p1.playMusic();\n }\n} Sample Output Sample Output Phone number is: 9863472\nCall is made\nMusic Started Playing Phone number is: 9863472\nCall is made\nMusic Started Playing 9863472",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "5. Write a class “Programmer”. Give some properties and methods to it and show how you will access them in the main method by creating object(s) of this class.",
        "answer": "The following is the example code. Java Code for Custom Class Java Code for Custom Class import java.util.*;\n\nclass Programmer {\n\n    private int age;\n    private String name;\n\n    Programmer() {\n\n    }\n\n    Programmer(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    void setAge(int age) {\n        this.age = age;\n    }\n\n    void setName(String name) {\n        this.name = name;\n    }\n\n    int getAge() {\n        return age;\n    }\n\n    String getName() {\n        return name;\n    }\n\n    public void codes() {\n        System.out.println(this.name + \" writes codes\");\n    }\n\n    public void drinksCoffee() {\n        System.out.println(this.name + \" drinks coffee and can then convert exponential complexity codes to polynomial\");\n    }\n}\n\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Programmer p1 = new Programmer(22,\"Guneet\");\n        p1.codes();\n        p1.drinksCoffee();\n }\n} import java.util.*;\n\nclass Programmer {\n\n    private int age;\n    private String name;\n\n    Programmer() {\n\n    }\n\n    Programmer(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    void setAge(int age) {\n        this.age = age;\n    }\n\n    void setName(String name) {\n        this.name = name;\n    }\n\n    int getAge() {\n        return age;\n    }\n\n    String getName() {\n        return name;\n    }\n\n    public void codes() {\n        System.out.println(this.name + \" writes codes\");\n    }\n\n    public void drinksCoffee() {\n        System.out.println(this.name + \" drinks coffee and can then convert exponential complexity codes to polynomial\");\n    }\n}\n\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Programmer p1 = new Programmer(22,\"Guneet\");\n        p1.codes();\n        p1.drinksCoffee();\n }\n} import class Programmer class Programmer private int private int this this void setAge(int age) void setAge (int age) int this void setName(String name) void setName (String name) this int getAge() int getAge () return String getName() getName () return public void codes() public void codes () this \" writes codes\" public void drinksCoffee() public void drinksCoffee () this \" drinks coffee and can then convert exponential complexity codes to polynomial\" class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here new 22 \"Guneet\" Sample Output Sample Output Guneet writes codes\nGuneet drinks coffee and can then convert exponential complexity codes to polynomial. Guneet writes codes\nGuneet drinks coffee and can then convert exponential complexity codes to polynomial. Some things you should keep in mind: The properties must usually be set private and we should have getter and setter methods to access and modify them. This is good OOPS practice. Also, always create a default constructor as when we create a parameterized constructor, Java removes its own default constructor and the object creation without passing the parameters to the constructor would not be possible. Some things you should keep in mind: The properties must usually be set private and we should have getter and setter methods to access and modify them. This is good OOPS practice. Also, always create a default constructor as when we create a parameterized constructor, Java removes its own default constructor and the object creation without passing the parameters to the constructor would not be possible. Some things you should keep in mind:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "6. Write a program in Java to print the elements of the matrix in Wave Order as shown below. (The matrix can have different numbers of rows and columns).",
        "answer": "  It is clear from the image itself that we are traversing column-wise. Now, when we traverse an even column, we traverse it from top to bottom and when we traverse an odd column, we traverse it from bottom to top direction. Code for Wave Print a Matrix in Java Code for Wave Print a Matrix in Java import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\npublic static void main(String[] args) throws Exception {\n    // write your code here\n    Scanner scn = new Scanner(System.in);\n    int n = scn.nextInt();\n    int m = scn.nextInt();\n    \n    int[][] mat = new int[n][m];\n    \n    //input the matrix\n    for(int i=0;i<n;i++) {\n        for(int j=0;j<m;j++) {\n            mat[i][j] = scn.nextInt();\n        }\n    } \n    \n    for(int j=0;j<mat[0].length;j++) {\n        if(j% 2 == 0) {\n            for(int i=0;i<mat.length;i++) {\n                System.out.print(mat[i][j] + \" \");\n            }\n        } else {\n            for(int i=mat.length-1;i>=0;i--) {\n                System.out.print(mat[i][j] + \" \");\n            }\n        }\n        System.out.println();\n    } \n }\n\n} import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\npublic static void main(String[] args) throws Exception {\n    // write your code here\n    Scanner scn = new Scanner(System.in);\n    int n = scn.nextInt();\n    int m = scn.nextInt();\n    \n    int[][] mat = new int[n][m];\n    \n    //input the matrix\n    for(int i=0;i<n;i++) {\n        for(int j=0;j<m;j++) {\n            mat[i][j] = scn.nextInt();\n        }\n    } \n    \n    for(int j=0;j<mat[0].length;j++) {\n        if(j% 2 == 0) {\n            for(int i=0;i<mat.length;i++) {\n                System.out.print(mat[i][j] + \" \");\n            }\n        } else {\n            for(int i=mat.length-1;i>=0;i--) {\n                System.out.print(mat[i][j] + \" \");\n            }\n        }\n        System.out.println();\n    } \n }\n\n} import import public class Main class Main public static void main(String[] args) throws Exception public static void main (String[] args) throws // write your code here new int int int new int //input the matrix for int 0 for int 0 for int 0 0 if 2 0 for int 0 \" \" else for int 1 0 \" \" Sample Output Sample Output Input: \n1 2 3 \n4 5 6\n7 8 9\n\nOutput:\n1 4 7\n8 5 2\n3 6 9 Input: \n1 2 3 \n4 5 6\n7 8 9\n\nOutput:\n1 4 7\n8 5 2\n3 6 9 1 2 3 4 5 6 7 8 9 1 4 7 8 5 2 3 6 9 Time Complexity: O(N * M) where N is the number of rows and M is the number of columns.\nAuxiliary Space: O(1) as we have not used any extra space to solve this problem. Time Complexity: O(N * M) where N is the number of rows and M is the number of columns. Time Complexity: Auxiliary Space: O(1) as we have not used any extra space to solve this problem. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "7. Write a program in Java to input an NxN matrix and display it row-wise and column-wise.",
        "answer": "Simply input the matrix. Now, display the matrix row-wise by starting from the first row and moving to the next elements within the same row. For displaying column-wise, start from the first column and keep moving in the same column to the next elements. This is shown below.   Java Code to input and display 2-D Matrix Java Code to input and display 2-D Matrix import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        int N = scn.nextInt();\n        int[][] mat = new int[N][N];\n\n        for(int i=0;i<N;i++) {\n            for(int j=0;j<N;j++) {\n                mat[i][j] = scn.nextInt();\n            }\n        }\n\n        //Display Row wise\n        for(int i=0;i<N;i++) {\n            System.out.print(\"Row \" + i + \" : \");\n            for(int j=0;j<N;j++) {\n                System.out.print(mat[i][j] + \" \");\n            }\n            System.out.println(\"\\t\");\n        }\n\n        System.out.println();\n\n        //Display Col wise\n        for(int j=0;j<N;j++) {\n            System.out.print(\"Col \" + j + \" : \");\n            for(int i=0;i<N;i++) {\n                System.out.print(mat[i][j] + \" \");\n            }\n            System.out.println(\"\\t\");\n        }\n }\n} import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        int N = scn.nextInt();\n        int[][] mat = new int[N][N];\n\n        for(int i=0;i<N;i++) {\n            for(int j=0;j<N;j++) {\n                mat[i][j] = scn.nextInt();\n            }\n        }\n\n        //Display Row wise\n        for(int i=0;i<N;i++) {\n            System.out.print(\"Row \" + i + \" : \");\n            for(int j=0;j<N;j++) {\n                System.out.print(mat[i][j] + \" \");\n            }\n            System.out.println(\"\\t\");\n        }\n\n        System.out.println();\n\n        //Display Col wise\n        for(int j=0;j<N;j++) {\n            System.out.print(\"Col \" + j + \" : \");\n            for(int i=0;i<N;i++) {\n                System.out.print(mat[i][j] + \" \");\n            }\n            System.out.println(\"\\t\");\n        }\n }\n} import class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here new int int new int for int 0 for int 0 //Display Row wise for int 0 \"Row \" \" : \" for int 0 \" \" \"\\t\" //Display Col wise for int 0 \"Col \" \" : \" for int 0 \" \" \"\\t\" Sample Output Sample Output Input:\n\n3\n1 2 3\n4 5 6\n7 8 9\n\nOutput:\n\nRow 0 : 1 2 3     \nRow 1 : 4 5 6     \nRow 2 : 7 8 9\n     \nCol 0 : 1 4 7     \nCol 1 : 2 5 8     \nCol 2 : 3 6 9 Input:\n\n3\n1 2 3\n4 5 6\n7 8 9\n\nOutput:\n\nRow 0 : 1 2 3     \nRow 1 : 4 5 6     \nRow 2 : 7 8 9\n     \nCol 0 : 1 4 7     \nCol 1 : 2 5 8     \nCol 2 : 3 6 9 3 1 2 3 4 5 6 7 8 9 0 1 2 3 1 4 5 6 2 7 8 9 0 1 4 7 1 2 5 8 2 3 6 9 Time Complexity: O(N to the power 2) as we traverse the 2-D array to print it.\nAuxiliary Space: O(1) as we have not used any extra space. Time Complexity: O(N to the power 2) as we traverse the 2-D array to print it. Time Complexity: Auxiliary Space: O(1) as we have not used any extra space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "8. Write a program to find the index of first occurrence and last occurrence of an element in the array in a single iteration.",
        "answer": "You cannot use extra space. The first index of occurrence and the last index of occurrence will be -1, if the element is not present inside the array. We will keep three variables. The 2 variables (that are) firstIndex and lastIndex will be initialized to -1. The third will be a boolean type variable found which will be initially false. If the element is found, we will make it true, and store the current index in firstIndex and lastIndex variables. If the element is found further, only the lastIndex variable will change. The fact that the number has already been found in the array will be denoted by the found boolean variable. Java Program to find the First and Last Occurrence of an element in the Array Java Program to find the First and Last Occurrence of an element in the Array import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        int[] arr = new int[n];\n\n        // input the array\n        for(int i=0;i<n;i++) {\n            arr[i] = scn.nextInt();\n        }\n\n        int target = scn.nextInt();\n        int fIndex = -1, lIndex = -1;\n        boolean found = false;\n\n        for(int i=0;i<n;i++) {\n            if(arr[i] == target) {\n                if(!found) {\n                    fIndex = i;\n                    lIndex = i;\n                    found = true; //found for the first time \n                } else {\n                    lIndex = i;\n                }\n            }\n        }\n\n        if(found == false) {\n            System.out.println(\"The element does not exist in the array\");\n        } else {\n            System.out.println(\"First Index = \" + fIndex + \" Last Index = \" + lIndex); \n        }\n }\n} import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        int[] arr = new int[n];\n\n        // input the array\n        for(int i=0;i<n;i++) {\n            arr[i] = scn.nextInt();\n        }\n\n        int target = scn.nextInt();\n        int fIndex = -1, lIndex = -1;\n        boolean found = false;\n\n        for(int i=0;i<n;i++) {\n            if(arr[i] == target) {\n                if(!found) {\n                    fIndex = i;\n                    lIndex = i;\n                    found = true; //found for the first time \n                } else {\n                    lIndex = i;\n                }\n            }\n        }\n\n        if(found == false) {\n            System.out.println(\"The element does not exist in the array\");\n        } else {\n            System.out.println(\"First Index = \" + fIndex + \" Last Index = \" + lIndex); \n        }\n }\n} import class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here new int int new int // input the array for int 0 int int 1 1 boolean false for int 0 if if true //found for the first time else if false \"The element does not exist in the array\" else \"First Index = \" \" Last Index = \" Sample Output Sample Output When element exists Input:\n5\n1 2 3 2 5\n2\n\nOutput: First Index = 1 Last Index = 3 Input:\n5\n1 2 3 2 5\n2\n\nOutput: First Index = 1 Last Index = 3 5 1 2 3 2 5 2 1 3 When the element does not exist Input:\n5\n1 2 3 2 5\n2\n\nOutput:The element does not exist in the array. Input:\n5\n1 2 3 2 5\n2\n\nOutput:The element does not exist in the array. 5 1 2 3 2 5 2 Corner Cases, You might Miss: The corner case of elements not present in the array is something that should be taken care of separately. In our code, we use the boolean variable found to do so. Otherwise, we can directly see if the values of fIndex and lIndex variables are -1 or not.\nTime Complexity: O(N) as we are traversing the array.\nAuxiliary Space: O(1) as we have not used any extra space to solve the problem. Corner Cases, You might Miss: The corner case of elements not present in the array is something that should be taken care of separately. In our code, we use the boolean variable found to do so. Otherwise, we can directly see if the values of fIndex and lIndex variables are -1 or not. Corner Cases, You might Miss: Time Complexity: O(N) as we are traversing the array. Time Complexity: Auxiliary Space: O(1) as we have not used any extra space to solve the problem. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "9. Write a program in Java to Reverse an Array without using extra space.",
        "answer": "We keep to variables i and j at both the ends of the array as shown below.    Now, swap the element at index i with the element at index j increment the i variable, and decrement the j variable. Keep doing this till i is less than j. This is shown in the image below.   import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        int[] arr = new int[n];\n\n        for(int i=0;i<n;i++) {\n            arr[i] = scn.nextInt();\n        }\n\n        System.out.println(\"The reversed array is\");\n        int i = 0;\n        int j = arr.length - 1;\n\n        while(i < j) {\n            //swapping ith and jth index elements\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n\n        //displaying the array\n        for(int it=0;it<arr.length;it++) {\n            System.out.print(arr[it] + \" \");\n        }\n }\n} import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        int[] arr = new int[n];\n\n        for(int i=0;i<n;i++) {\n            arr[i] = scn.nextInt();\n        }\n\n        System.out.println(\"The reversed array is\");\n        int i = 0;\n        int j = arr.length - 1;\n\n        while(i < j) {\n            //swapping ith and jth index elements\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n\n        //displaying the array\n        for(int it=0;it<arr.length;it++) {\n            System.out.print(arr[it] + \" \");\n        }\n }\n} import class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here new int int new int for int 0 \"The reversed array is\" int 0 int 1 while //swapping ith and jth index elements int //displaying the array for int 0 \" \" Sample Output Sample Output Input:\n5\n1 2 3 4 5\n\nOutput:\nThe reversed array is\n5 4 3 2 1 Input:\n5\n1 2 3 4 5\n\nOutput:\nThe reversed array is\n5 4 3 2 1 5 1 2 3 4 5 5 4 3 2 1 Time complexity: O(N) as we are traversing the array.\nAuxiliary Space: O(1) as we have not used any extra space. Time complexity: O(N) as we are traversing the array. Time complexity: Auxiliary Space: O(1) as we have not used any extra space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "10. Write a program in Java to prove that the strings are immutable in Java.",
        "answer": "Strings are immutable in Java. This can be proven by making changes to a string and comparing them with the == operator. Since this operator compares only the references, i.e. the addresses of the objects, it will be able to tell us if the changes are made to the same object or not. If after making changes to a string we compare it by == and we get no equals, this means that the strings are immutable. Java program to prove Strings are Immutable Java program to prove Strings are Immutable class Main {\n public static void main(String args[]) {\n  // Your code goes here\n  String s1 = \"InterviewBit\";\n  String s2 = s1;\n\n  System.out.println(s1 == s2); //they are equal\n\n  s1 += \"Scaler\";\n\n  System.out.println(s1 == s2); //not equal\n }\n} class Main {\n public static void main(String args[]) {\n  // Your code goes here\n  String s1 = \"InterviewBit\";\n  String s2 = s1;\n\n  System.out.println(s1 == s2); //they are equal\n\n  s1 += \"Scaler\";\n\n  System.out.println(s1 == s2); //not equal\n }\n} class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here \"InterviewBit\" //they are equal \"Scaler\" //not equal Output Output true\nfalse true\nfalse true false So, let us now discuss an array of programs related to Java interviews.",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "11. Write a program to print all the unique characters in a String. For instance, if the input string is “abcb”, the output will be the characters ‘a’ and ‘c’ as they are unique. The character ‘b’ repeats twice and so it will not be printed.",
        "answer": "We can use a HashSet in order to store the characters of the String. When we arrive at a character in the String, if it is already present in the HashSet, we remove it from the HashSet as that character is not unique. If it is not present inside the HashSet, we add it to it. After traversing the entire string, we print the elements inside the HashMap. Java Code to Print All Unique Characters in a String. Java Code to Print All Unique Characters in a String. import java.util.*;\nclass Main {\n    \n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        String str = scn.nextLine();\n        \n        HashSet<Character> unique = new HashSet<>();\n\n        for(int i=0;i<str.length();i++) {\n            char ch = str.charAt(i);\n            if(unique.contains(ch) == true) {\n                //this character has already occured\n                unique.remove(ch);\n            } else {\n                unique.add(ch);\n            }\n        }\n\n        if(unique.size() == 0) {\n            System.out.println(\"There are no unique characters\");\n        }\n\n        for(Character ch : unique) {\n            System.out.print(ch + \"  \");\n        }\n\n    }\n} import java.util.*;\nclass Main {\n    \n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        String str = scn.nextLine();\n        \n        HashSet<Character> unique = new HashSet<>();\n\n        for(int i=0;i<str.length();i++) {\n            char ch = str.charAt(i);\n            if(unique.contains(ch) == true) {\n                //this character has already occured\n                unique.remove(ch);\n            } else {\n                unique.add(ch);\n            }\n        }\n\n        if(unique.size() == 0) {\n            System.out.println(\"There are no unique characters\");\n        }\n\n        for(Character ch : unique) {\n            System.out.print(ch + \"  \");\n        }\n\n    }\n} import class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here new new for int 0 char if true //this character has already occured else if 0 \"There are no unique characters\" for \"  \" Sample Output Sample Output Input: abcab\nOutput: c Input: abcab\nOutput: c Corner Cases, You Might Miss: What if such a string is passed that has all the duplicate characters? Also, it might happen that an empty string is passed as the input. So, in such a case, the size of the HashSet will remain 0 after processing the String. Hence, we have handled the case of a hashset having 0 sizes separately.\nTime Complexity: The time complexity is O(N) where N is the length of the string as we are traversing the entire string.\nAuxiliary Space: O(N) as it might happen that all the N characters are unique so, we might generate a HashSet of size N. Corner Cases, You Might Miss: What if such a string is passed that has all the duplicate characters? Also, it might happen that an empty string is passed as the input. So, in such a case, the size of the HashSet will remain 0 after processing the String. Hence, we have handled the case of a hashset having 0 sizes separately. Corner Cases, You Might Miss: Time Complexity: The time complexity is O(N) where N is the length of the string as we are traversing the entire string. Time Complexity: Auxiliary Space: O(N) as it might happen that all the N characters are unique so, we might generate a HashSet of size N. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "12. Write a program in Java to count the total number of vowels and consonants in a String. The string can contain all the alphanumeric and other special characters as well. However, only the lowercase English alphabets are allowed in the String.",
        "answer": "We just have to traverse the string. If we get any vowel (a,e,i,o,u), we increment the variable corresponding to the vowel count and if we get a consonant, we increment the variable corresponding to the consonant count. Java Code to Count Vowels and Consonants in a String Java Code to Count Vowels and Consonants in a String import java.util.*;\nclass Main {\n    \n    public static boolean isVowel(char ch) {\n        if(ch == 'a' || ch =='e' || ch =='i' || ch =='o' || ch =='u')\n            return true;\n        \n        return false;\n    }\n\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        String str = scn.nextLine();\n\n        int vowelCount = 0;\n        int consCount = 0;\n\n        for(int i=0;i<str.length();i++) {\n            char ch = str.charAt(i);\n            if(isVowel(ch) == true) vowelCount++;\n            else if(ch >='a' && ch<='z' && isVowel(ch) == false) consCount++;\n        }\n\n        System.out.println(\"Number of vowels are: \" + vowelCount);\n        System.out.println(\"Number of consonants are: \" + consCount);\n        System.out.println(\"Number of other characters are: \" + (int)(str.length() - vowelCount -consCount));\n }\n} import java.util.*;\nclass Main {\n    \n    public static boolean isVowel(char ch) {\n        if(ch == 'a' || ch =='e' || ch =='i' || ch =='o' || ch =='u')\n            return true;\n        \n        return false;\n    }\n\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        String str = scn.nextLine();\n\n        int vowelCount = 0;\n        int consCount = 0;\n\n        for(int i=0;i<str.length();i++) {\n            char ch = str.charAt(i);\n            if(isVowel(ch) == true) vowelCount++;\n            else if(ch >='a' && ch<='z' && isVowel(ch) == false) consCount++;\n        }\n\n        System.out.println(\"Number of vowels are: \" + vowelCount);\n        System.out.println(\"Number of consonants are: \" + consCount);\n        System.out.println(\"Number of other characters are: \" + (int)(str.length() - vowelCount -consCount));\n }\n} import class Main class Main public static boolean isVowel(char ch) public static boolean isVowel (char ch) char if 'a' 'e' 'i' 'o' 'u' return true return false public static void main(String args[]) public static void main (String args[]) // Your code goes here new int 0 int 0 for int 0 char if true else if 'a' 'z' false \"Number of vowels are: \" \"Number of consonants are: \" \"Number of other characters are: \" int Sample Output Sample Output Input: ae#zyu*\n\nOutput: \nThe number of vowels is: 3\nThe number of consonants is: 2\nThe number of other characters is: 2 Input: ae#zyu*\n\nOutput: \nThe number of vowels is: 3\nThe number of consonants is: 2\nThe number of other characters is: 2 3 2 2 Corner Cases, You Might Miss: In order to check whether a character is a vowel or not, we have a function. However, it is not right to say that if it is not a vowel then it will be a consonant as it can also be any other character. So, we have to make sure that it is an alphabet and then make sure that it is not a vowel. The same is done in the code.\nTime Complexity: O(N) where N is the length of the input string as we have to traverse the entire string once.\nAuxiliary Space: O(1) as we have not used any extra space. Corner Cases, You Might Miss: In order to check whether a character is a vowel or not, we have a function. However, it is not right to say that if it is not a vowel then it will be a consonant as it can also be any other character. So, we have to make sure that it is an alphabet and then make sure that it is not a vowel. The same is done in the code. Corner Cases, You Might Miss: Time Complexity: O(N) where N is the length of the input string as we have to traverse the entire string once. Time Complexity: Auxiliary Space: O(1) as we have not used any extra space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "13. Write a program in Java to Toggle the case of every character of a string. For instance, if the input string is “ApPLe”, the output should be “aPplE”.",
        "answer": "We know that in Java, we cannot make changes to the same string as it is immutable. So, we have to return a new String. The lowercase ASCII characters differ from the uppercase ASCII characters by 32. This means ‘a’ - 32 = ‘A’. So, we will use this concept to Toggle the String cases. Java Code to Toggle Cases Java Code to Toggle Cases import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        String str = scn.nextLine();\n        StringBuilder res = new StringBuilder(\"\");\n\n        for(int i=0;i<str.length();i++) {\n            char ch = str.charAt(i); //current character\n            if(ch >='A' && ch <= 'Z') {\n                res.append((char)(ch + 32));\n            } else if(ch >='a' && ch<='z'){\n                res.append((char)(ch - 32));\n            } else { \n                res.append(ch);\n            }\n        }\n\n        String ans = res.toString();\n        System.out.println(\"The string after toggling becomes: \" + ans);\n }\n} import java.util.*;\nclass Main {\n public static void main(String args[]) {\n  // Your code goes here\n        Scanner scn = new Scanner(System.in);\n        String str = scn.nextLine();\n        StringBuilder res = new StringBuilder(\"\");\n\n        for(int i=0;i<str.length();i++) {\n            char ch = str.charAt(i); //current character\n            if(ch >='A' && ch <= 'Z') {\n                res.append((char)(ch + 32));\n            } else if(ch >='a' && ch<='z'){\n                res.append((char)(ch - 32));\n            } else { \n                res.append(ch);\n            }\n        }\n\n        String ans = res.toString();\n        System.out.println(\"The string after toggling becomes: \" + ans);\n }\n} import class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here new new \"\" for int 0 char //current character if 'A' 'Z' char 32 else if 'a' 'z' char 32 else \"The string after toggling becomes: \" Sample Output: Sample Output: Input: Ab#$Cd\nOutput: aB#$cD Input: Ab#$Cd\nOutput: aB#$cD Corner Cases, You Might Miss: The String can contain other characters apart from the alphabet. So, in that case, we do not have to change those characters that are not alphabets, while we have to toggle the alphabets. Hence, in the code, after the if condition, we have an else-if condition and not the else condition; otherwise it would have subtracted 32 from every character that is not an uppercase alphabet. In the else condition, we have added the character as it is. This is also seen in the output shown above.\nTime Complexity: Since we have used a StringBuilder in place of a String, the time complexity of inserting a character in a StringBuilder is O(1). Since we are inserting N characters, the time complexity is O(N). {Here N is the length of the input string}\nAuxiliary Space: O(1) as we have not used any extra space to solve the problem. The string ans and StringBuilder res are the output spaces and not the auxiliary space. Corner Cases, You Might Miss: The String can contain other characters apart from the alphabet. So, in that case, we do not have to change those characters that are not alphabets, while we have to toggle the alphabets. Hence, in the code, after the if condition, we have an else-if condition and not the else condition; otherwise it would have subtracted 32 from every character that is not an uppercase alphabet. In the else condition, we have added the character as it is. This is also seen in the output shown above. Corner Cases, You Might Miss: Time Complexity: Since we have used a StringBuilder in place of a String, the time complexity of inserting a character in a StringBuilder is O(1). Since we are inserting N characters, the time complexity is O(N). {Here N is the length of the input string} Time Complexity: Auxiliary Space: O(1) as we have not used any extra space to solve the problem. The string ans and StringBuilder res are the output spaces and not the auxiliary space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "14. Write a program in Java to calculate pow(x,n) using recursion. The expected time complexity is O(log2N) where N is the power. You cannot use any extra space apart from the recursion call stack space.",
        "answer": "We have seen how we can calculate the pow(x,n) in linear time. We can optimize our approach by changing the recurrence relation. Let us understand this with the help of an example shown below:   So, we can see that if the power is even, we can divide the power by 2 and can multiply x to the power n/2 by itself to get our answer. What if the power of the number is odd?   In that case, we multiply the number x once to the term x to the power n/2 multiplied by itself. Here, n/2 will be the floor value of (n/2). You can verify this for any pair of x and n. So, doing this will reduce the time complexity from O(N) to O(log2N). This happens because of the change in recurrence relation and the recursion tree as shown below.   Solving these recurrence relations gives us the respective time complexities. So, the code for O(log2N) approach is shown below Java Code for (x to the power N) in Logarithmic Time Complexity Java Code for (x to the power N) in Logarithmic Time Complexity import java.util.*;\nclass Main {\n \n public static double power(double x, int n) {\n        if(n == 0) return 1.0;\n        \n        double xpnby2 = power(x,n/2); //xpnby2 = x power n by 2 \n\n  if(n % 2 == 0) return xpnby2 * xpnby2; //if power is even\n\n        return x * xpnby2 * xpnby2; //if power is odd\n    }\n    \n    public static double pow(double x, int n) {\n        if(n < 0) {\n            return 1.0 / power(x,-n);\n        }\n        \n        return power(x,n);\n    }\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  double x = scn.nextDouble();\n  int n = scn.nextInt();\n\n        System.out.println(pow(x,n));\n }\n} import java.util.*;\nclass Main {\n \n public static double power(double x, int n) {\n        if(n == 0) return 1.0;\n        \n        double xpnby2 = power(x,n/2); //xpnby2 = x power n by 2 \n\n  if(n % 2 == 0) return xpnby2 * xpnby2; //if power is even\n\n        return x * xpnby2 * xpnby2; //if power is odd\n    }\n    \n    public static double pow(double x, int n) {\n        if(n < 0) {\n            return 1.0 / power(x,-n);\n        }\n        \n        return power(x,n);\n    }\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  double x = scn.nextDouble();\n  int n = scn.nextInt();\n\n        System.out.println(pow(x,n));\n }\n} import class Main class Main public static double power(double x, int n) public static double power (double x, int n) double int if 0 return 1.0 double 2 //xpnby2 = x power n by 2 if 2 0 return //if power is even return //if power is odd public static double pow(double x, int n) public static double pow (double x, int n) double int if 0 return 1.0 return public static void main(String args[]) public static void main (String args[]) // Your code goes here new double int Sample Output: Sample Output: For positive Power For positive Power Input: \n1.10\n3\n\nOutput: 1.3676310000000003 Input: \n1.10\n3\n\nOutput: 1.3676310000000003 1.10 3 1.3676310000000003 For negative Power For negative Power Input:\n1.110\n-3\n\nOutput:\n0.7311913813009502 Input:\n1.110\n-3\n\nOutput:\n0.7311913813009502 1.110 3 0.7311913813009502 Corner Cases, You Might Miss: The power of a number can be negative too. So, we know that x-n = (1/xn). In this way, we can handle the corner test case of a power being negative.\nTime Complexity: As already discussed, Time Complexity is O(log2N).\nAuxiliary Space: The auxiliary space is O(1) as we have not used any extra space. Corner Cases, You Might Miss: The power of a number can be negative too. So, we know that x-n = (1/xn). In this way, we can handle the corner test case of a power being negative. Corner Cases, You Might Miss: Time Complexity: As already discussed, Time Complexity is O(log2N). Time Complexity: Auxiliary Space: The auxiliary space is O(1) as we have not used any extra space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "15. Write a Java Program to calculate xn (x to the power n) using Recursion. You can use O(N) time but can’t use any extra space apart from the Recursion Call Stack Space.",
        "answer": "In a recursive function, we need to find a relation between the smaller problem and the larger problem. Here, we have a clear mathematical relationship between the large problem xn and the problem that is smaller than it i.e. x to the power (n-1). The relation is: x\nn\n =\n x\n *\n x\nn\n-\n1 x\nn\n =\n x\n *\n x\nn\n-\n1 x\nn\n =\n x\n *\n x\nn\n-\n1                                           x\nn\n =\n x\n *\n x\nn\n-\n1 x\nn\n =\n x\n *\n x\nn\n-\n1 x\nn\n =\n x\n *\n x\nn\n-\n1 x\nn\n =\n x\n *\n x\nn\n-\n1 x\nn x n  =  x  *  x\nn\n-\n1 x n\n-\n1 n - 1  The relation is: (x to the power n)  = x * x to the power(n-1) (x to the power n)  = x * x to the power(n-1) In terms of programming (using functions), we can write this relation as: power(x,n) = x * power(x,n-1) power(x,n) = x * power(x,n-1) For example, 2 to the power 5 = 32. This can be calculated as 2 * (2 to the power 4) = 2 * 16 = 32. So, we have found the recurrence relation in the above equation. Now, what will be the base case? 2 to the power 5 = 32 2 * (2 to the power 4) = 2 * 16 = 32 The base case will be the smallest such problem that we can solve. So, the smallest problem is calculating the power of 0 to any number. We know that any number to the power 0 gives the result as 1. So, this will be our base case. We know that any number to the power 0 gives the result as 1. base case Now, let us write the code for the same. Java Code to Calculate x to the power n Java Code to Calculate x to the power n import java.util.*;\nclass Main {\n \n public static double power(double x, int n) {\n        if(n == 0) return 1.0;\n        \n        double xpnm1 = power(x,n-1); //x power n-1 (xpnm1)\n\n  return x * xpnm1; \n    }\n    \n    public static double pow(double x, int n) {\n        if(n < 0) {\n            return 1.0 / power(x,-n);\n        }\n        \n        return power(x,n);\n    }\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  double x = scn.nextDouble();\n  int n = scn.nextInt();\n\n        System.out.println(pow(x,n));\n }\n} import java.util.*;\nclass Main {\n \n public static double power(double x, int n) {\n        if(n == 0) return 1.0;\n        \n        double xpnm1 = power(x,n-1); //x power n-1 (xpnm1)\n\n  return x * xpnm1; \n    }\n    \n    public static double pow(double x, int n) {\n        if(n < 0) {\n            return 1.0 / power(x,-n);\n        }\n        \n        return power(x,n);\n    }\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  double x = scn.nextDouble();\n  int n = scn.nextInt();\n\n        System.out.println(pow(x,n));\n }\n} import class Main class Main public static double power(double x, int n) public static double power (double x, int n) double int if 0 return 1.0 double 1 //x power n-1 (xpnm1) return public static double pow(double x, int n) public static double pow (double x, int n) double int if 0 return 1.0 return public static void main(String args[]) public static void main (String args[]) // Your code goes here new double int Sample Output: Sample Output: For positive Power For positive Power Input: \n1.10\n3\n\nOutput: 1.3676310000000003 Input: \n1.10\n3\n\nOutput: 1.3676310000000003 1.10 3 1.3676310000000003 For negative Power For negative Power Input:\n1.110\n-3\n\nOutput:\n0.7311913813009502 Input:\n1.110\n-3\n\nOutput:\n0.7311913813009502 1.110 3 0.7311913813009502 Corner Cases You Might Miss: The power of a number can be negative too. So, we know that (x to the power -n) = [1/(x to the power n)]. In this way, we can handle the corner test case of a power being negative. What if the number is negative? Is our code handling that case? Yes, it does. Why? Try to think about this.\nTime Complexity: The time complexity of this code is O(N) where N is the power. We see that the time complexity does not depend on X i.e. the number. It only depends on the power of the number.\nAuxiliary Space: The auxiliary space is O(1) as we have not used any extra space. Corner Cases You Might Miss: The power of a number can be negative too. So, we know that (x to the power -n) = [1/(x to the power n)]. In this way, we can handle the corner test case of a power being negative. What if the number is negative? Is our code handling that case? Yes, it does. Why? Try to think about this. Corner Cases You Might Miss: Time Complexity: The time complexity of this code is O(N) where N is the power. We see that the time complexity does not depend on X i.e. the number. It only depends on the power of the number. Time Complexity: Auxiliary Space: The auxiliary space is O(1) as we have not used any extra space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "16. Write a program in Java to calculate the number of times a digit ‘D’ appears in a number N. You have to take N and D as inputs from the user.",
        "answer": "This is the follow-up question to the previous question. In the previous question, we discussed how you can check the value of a digit using the modulus (%) operator. So, we will just use the previous code and in every iteration, we will check whether the digit is “D” or not. If it is D, increment the counter. The program for the same is shown below: Java Code for Calculating Frequency of a Digit D in a Number N Java Code for Calculating Frequency of a Digit D in a Number N import java.util.*;\nclass Main {\n\n    public static int countDigitFreq(int n,int D) {\n  if(n == 0 && D == 0) return 1; //number 0 has 1 frequency of 0\n\n  //if a negative number is entered\n  if(n < 0) n = -n;\n\n  int counter = 0;\n  while(n != 0) {\n   int digit = n % 10; //calculate the digit\n   if(digit == D) counter++; \n   n = n/10;\n  }\n\n  return counter;\n }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt(); //input the number\n  int d = scn.nextInt(); //input the digit\n\n        int x = countDigitFreq(n,d);\n  System.out.println(\"The digit \" + d + \" occurs \" + x + \" times in \" + n);\n }\n} import java.util.*;\nclass Main {\n\n    public static int countDigitFreq(int n,int D) {\n  if(n == 0 && D == 0) return 1; //number 0 has 1 frequency of 0\n\n  //if a negative number is entered\n  if(n < 0) n = -n;\n\n  int counter = 0;\n  while(n != 0) {\n   int digit = n % 10; //calculate the digit\n   if(digit == D) counter++; \n   n = n/10;\n  }\n\n  return counter;\n }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt(); //input the number\n  int d = scn.nextInt(); //input the digit\n\n        int x = countDigitFreq(n,d);\n  System.out.println(\"The digit \" + d + \" occurs \" + x + \" times in \" + n);\n }\n} import class Main class Main public static int countDigitFreq(int n,int D) public static int countDigitFreq (int n,int D) int int if 0 0 return 1 //number 0 has 1 frequency of 0 //if a negative number is entered if 0 int 0 while 0 int 10 //calculate the digit if 10 return public static void main(String args[]) public static void main (String args[]) // Your code goes here new int //input the number int //input the digit int \"The digit \" \" occurs \" \" times in \" Sample Input/Output Sample Input/Output Input: 142454\nOutput: The digit 4 occurs 3 times in 142454 Input: 142454\nOutput: The digit 4 occurs 3 times in 142454 142454 4 3 142454 Corner Cases You Might Miss: If the input number is 0 and the digit is also 0, it becomes a crucial corner case. This is because the number 0 has 1 frequency of digit 0 but it will not be handled correctly by our loop. So, we do this separately. Also, we have converted the negative numbers to positive ones to solve this problem.\nTime Complexity: O(log10N) where N is the input number. This is because we keep dividing the number by 10.\nAuxiliary Space: We have not used any auxiliary Space here. So, it is O(1). Corner Cases You Might Miss: If the input number is 0 and the digit is also 0, it becomes a crucial corner case. This is because the number 0 has 1 frequency of digit 0 but it will not be handled correctly by our loop. So, we do this separately. Also, we have converted the negative numbers to positive ones to solve this problem. Corner Cases You Might Miss: Time Complexity: O(log10N) where N is the input number. This is because we keep dividing the number by 10. Time Complexity: Auxiliary Space: We have not used any auxiliary Space here. So, it is O(1). Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "17. Write a program in Java to count the digits in a number.",
        "answer": "Let us consider the number 12345. This is a 5 digit number. The number of digits can be counted as follows:   In the image above, we have shown the way of extracting the digits of a number. However, in our questions, we just need to count the digits in the number. So, we have to count the number of times we can divide our input number by 10 before it becomes 0. Let us write the code based on the above algorithm. Java Program to Count the Number of Digits in a Number. Java Program to Count the Number of Digits in a Number. import java.util.*;\nclass Main {\n\n    public static int countDigits(int n) {\n  if(n == 0) return 1;\n\n  //if a negative number is entered\n  if(n < 0) n = -n;\n\n        int res = 0;\n  while(n != 0) {\n   n = n/10;\n   res++;\n  }\n  return res;\n }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt(); //input the number\n  System.out.println(\"The number of digits in \" + n + \" are: \" + countDigits(n));\n }\n} import java.util.*;\nclass Main {\n\n    public static int countDigits(int n) {\n  if(n == 0) return 1;\n\n  //if a negative number is entered\n  if(n < 0) n = -n;\n\n        int res = 0;\n  while(n != 0) {\n   n = n/10;\n   res++;\n  }\n  return res;\n }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt(); //input the number\n  System.out.println(\"The number of digits in \" + n + \" are: \" + countDigits(n));\n }\n} import class Main class Main public static int countDigits(int n) public static int countDigits (int n) int if 0 return 1 //if a negative number is entered if 0 int 0 while 0 10 return public static void main(String args[]) public static void main (String args[]) // Your code goes here new int //input the number \"The number of digits in \" \" are: \" Output Output For Positive Number For Positive Number Input: 1234\nOutput: The number of digits in 1234 is: 4 Input: 1234\nOutput: The number of digits in 1234 is: 4 1234 1234 4 For 0 For 0 Input: 0\nOutput: The number of digits in 0 is: 1 Input: 0\nOutput: The number of digits in 0 is: 1 0 0 1 For Negative Number For Negative Number Input: -12345\nOutput: The number of digits in -12345 is: 5 Input: -12345\nOutput: The number of digits in -12345 is: 5 12345 12345 5 Corner Cases You Might Miss: We have used the loop and carried on iterations till the number becomes 0. What if the number was already 0? It still has 1 digit. So, we have handled that separately. Also, to avoid any confusion, the negative numbers are converted to positive in our function and then we calculate their number of digits.\nTime Complexity: O(log10N) where N is the input number. This is because we keep dividing the number by 10.\nAuxiliary Space: O(1) as we have not used any extra space. Corner Cases You Might Miss: We have used the loop and carried on iterations till the number becomes 0. What if the number was already 0? It still has 1 digit. So, we have handled that separately. Also, to avoid any confusion, the negative numbers are converted to positive in our function and then we calculate their number of digits. Corner Cases You Might Miss: Time Complexity: O(log10N) where N is the input number. This is because we keep dividing the number by 10. Time Complexity: Auxiliary Space: O(1) as we have not used any extra space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "1. Write a program in Java to show Thread Synchronization.",
        "answer": "Here, you can create any 2 threads and synchronize them by using the synchronized keyword. An example program is given below. synchronized Java Program to show Thread Synchronization Java Program to show Thread Synchronization class Table {\n public synchronized void display(int n) {\n  for (int i = 1; i <= 10; i++) {\n   System.out.println(n * i);\n  }\n }\n}\n\nclass Thread1 extends Thread {\n  Table t; \n  \n  public Thread1(Table t) {\n    this.t = t;\n  }\n  public void run() {\n    t.display(5);\n  }\n}\n\nclass Thread2 extends Thread {\n Table t;\n public Thread2(Table t) {\n this.t = t;\n }\n public void run() {\n t.display(6);\n }\n}\n\npublic class Main {\n public static void main(String[] args) {\n   Table table = new Table();\n   Thread1 th1 = new Thread1(table);\n   Thread2 th2 = new Thread2(table);\n   th1.start();\n   th2.start();\n }\n} class Table {\n public synchronized void display(int n) {\n  for (int i = 1; i <= 10; i++) {\n   System.out.println(n * i);\n  }\n }\n}\n\nclass Thread1 extends Thread {\n  Table t; \n  \n  public Thread1(Table t) {\n    this.t = t;\n  }\n  public void run() {\n    t.display(5);\n  }\n}\n\nclass Thread2 extends Thread {\n Table t;\n public Thread2(Table t) {\n this.t = t;\n }\n public void run() {\n t.display(6);\n }\n}\n\npublic class Main {\n public static void main(String[] args) {\n   Table table = new Table();\n   Thread1 th1 = new Thread1(table);\n   Thread2 th2 = new Thread2(table);\n   th1.start();\n   th2.start();\n }\n} class Table class Table public synchronized void display(int n) public synchronized void display (int n) int for int 1 10 class Thread1 extends Thread class Thread1 extends Thread public Thread1(Table t) public Thread1 (Table t) this public void run() public void run () 5 class Thread2 extends Thread class Thread2 extends Thread public Thread2(Table t) public Thread2 (Table t) this public void run() public void run () 6 public class Main class Main public static void main(String[] args) public static void main (String[] args) new new new Output Output 5\n10\n15\n20\n25\n30\n35\n40\n45\n50\n6\n12\n18\n24\n30\n36\n42\n48\n54\n60 5\n10\n15\n20\n25\n30\n35\n40\n45\n50\n6\n12\n18\n24\n30\n36\n42\n48\n54\n60 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 Additional Resources Java Cheat Sheet\nJava Compiler to Practice\nJava Interview Questions for 5 Years Experience\nAll Technical Interview Questions\nJava vs Python\nJava Projects\nJava Developer Salary Java Cheat Sheet Java Cheat Sheet Java Compiler to Practice Java Compiler to Practice Java Interview Questions for 5 Years Experience Java Interview Questions for 5 Years Experience All Technical Interview Questions All Technical Interview Questions Java vs Python Java vs Python Java Projects Java Projects Java Developer Salary Java Developer Salary",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "2. Write a program in Java to show isAlive() and join() operations in multithreading.",
        "answer": "The isAlive() method tells whether a thread is alive or terminated. These alive and terminated are the states of a thread in Java. Also, the join() operation joins a thread to another. This means that the thread will wait for the complete execution of the thread to which it is joined even if its own work is completed. Then, they both will terminate together. Java Code to show isAlive() and join() operations Java Code to show isAlive() and join() operations class DemoThread extends Thread {\n\n   public DemoThread(String name) {\n      super(name);\n      setPriority(MAX_PRIORITY);\n   }\n}\n\nclass DemoThread2 extends Thread {\n\n public void run() {\n  int count = 1;\n  while (true) {\n    System.out.println(count);\n    count++;\n    try {\n      Thread.sleep(100);\n    } catch (InterruptedException e) {\n      System.out.println(e);\n    }\n  }\n  }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n\n  DemoThread t = new DemoThread(\"Thread 1\");\n\n  System.out.println(\"ID \" + t.getId());\n  System.out.println(\"NAME \" + t.getName());\n  System.out.println(\"PRIORITY \" + t.getPriority());\n  t.start();\n  System.out.println(\"STATE \" + t.getState());\n  System.out.println(\"ALIVE \" + t.isAlive());\n\n  DemoThread2 t2 = new DemoThread2();\n  try {\n   Thread.sleep(100);\n  } catch (Exception e) {\n  }\n\n  t2.setDaemon(true);\n  t2.start();\n  // t2.interrupt();\n\n  Thread mainThread = Thread.currentThread();\n  try {\n    mainThread.join(); // Now main will not terminate till the daemon thread is terminated\n  } catch (Exception e) {\n\n  }\n   }\n} class DemoThread extends Thread {\n\n   public DemoThread(String name) {\n      super(name);\n      setPriority(MAX_PRIORITY);\n   }\n}\n\nclass DemoThread2 extends Thread {\n\n public void run() {\n  int count = 1;\n  while (true) {\n    System.out.println(count);\n    count++;\n    try {\n      Thread.sleep(100);\n    } catch (InterruptedException e) {\n      System.out.println(e);\n    }\n  }\n  }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n\n  DemoThread t = new DemoThread(\"Thread 1\");\n\n  System.out.println(\"ID \" + t.getId());\n  System.out.println(\"NAME \" + t.getName());\n  System.out.println(\"PRIORITY \" + t.getPriority());\n  t.start();\n  System.out.println(\"STATE \" + t.getState());\n  System.out.println(\"ALIVE \" + t.isAlive());\n\n  DemoThread2 t2 = new DemoThread2();\n  try {\n   Thread.sleep(100);\n  } catch (Exception e) {\n  }\n\n  t2.setDaemon(true);\n  t2.start();\n  // t2.interrupt();\n\n  Thread mainThread = Thread.currentThread();\n  try {\n    mainThread.join(); // Now main will not terminate till the daemon thread is terminated\n  } catch (Exception e) {\n\n  }\n   }\n} class DemoThread extends Thread class DemoThread extends Thread public DemoThread(String name) public DemoThread (String name) super class DemoThread2 extends Thread class DemoThread2 extends Thread public void run() public void run () int 1 while true try 100 catch public class Main class Main public static void main(String[] args) public static void main (String[] args) new \"Thread 1\" \"ID \" \"NAME \" \"PRIORITY \" \"STATE \" \"ALIVE \" new try 100 catch true // t2.interrupt(); try // Now main will not terminate till the daemon thread is terminated catch Output Output ID 13\nNAME Thread 1\nPRIORITY 10\nSTATE RUNNABLE\nALIVE false\n1\n2\n3\n4\n5\n6\n7 ID 13\nNAME Thread 1\nPRIORITY 10\nSTATE RUNNABLE\nALIVE false\n1\n2\n3\n4\n5\n6\n7 13 1 10 false 1 2 3 4 5 6 7",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "3. Write a program in Java to show the Diamond Problem.",
        "answer": "The Diamond Problem is a problem of Multiple inheritance. It is one of the major reasons why multiple inheritance is not supported in Java. Have a look at the diagram given below.   Here, class D extends from classes B and C and they extend from Class A. Let us say that class A has a function called print(). This function is overridden in Class B and C respectively. Now, when class D extends B and C both, say it calls super.print(). Which function should be called? This is an anomaly called the diamond problem or deadly diamond of death. diamond problem deadly diamond of death Java Code for Diamond Problem Java Code for Diamond Problem class A {\n public void print() {\n  System.out.println(\"Class A print method\");\n }\n}\n\nclass B extends A {\n @Override\n public void print() {\n  System.out.println(\"Class B print method\");\n }\n}\n\nclass C extends A {\n @Override\n public void print() {\n  System.out.println(\"Class C print method\");\n }\n}\n\n//multiple inheritance not allowed in Java\nclass D extends A,B {\n @Override \n public void print() {\n  System.out.println(\"Class D print method\");\n }\n}\n\nclass Main {\n\n public static void main(String args[]) {\n  // Your code goes here\n  D obj = new D();\n  obj.print();\n }\n} class A {\n public void print() {\n  System.out.println(\"Class A print method\");\n }\n}\n\nclass B extends A {\n @Override\n public void print() {\n  System.out.println(\"Class B print method\");\n }\n}\n\nclass C extends A {\n @Override\n public void print() {\n  System.out.println(\"Class C print method\");\n }\n}\n\n//multiple inheritance not allowed in Java\nclass D extends A,B {\n @Override \n public void print() {\n  System.out.println(\"Class D print method\");\n }\n}\n\nclass Main {\n\n public static void main(String args[]) {\n  // Your code goes here\n  D obj = new D();\n  obj.print();\n }\n} class A class A public void print() public void print () \"Class A print method\" class B extends A class B extends A @Override public void print() public void print () \"Class B print method\" class C extends A class C extends A @Override public void print() public void print () \"Class C print method\" //multiple inheritance not allowed in Java class D extends A,B class D extends A B @Override public void print() public void print () \"Class D print method\" class Main class Main public static void main(String args[]) public static void main (String args[]) // Your code goes here new Output Output This compilation error occurs because multiple inheritance is not allowed in Java.",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "4. Write a program in Java, to show nesting of classes.",
        "answer": "Nesting of classes means writing a class inside another class. The inner classes in Java are usually static. This happens when we don’t want to use the variable of the outer class in the inner class. This helps to create an instance/object of the inner class without creating an instance of the Outer class. Following is a program to show the nesting of classes in Java. Java Code Java Code public class Main {\n     \n     public static void main(String[] args) {\n         Outer obj1 = new Outer(10, 20);\n        \n         Outer.Inner2 obj2 = new Outer.Inner2(40);\n         obj2.showData();\n        \n         Outer.Inner3.z = 100;\n         System.out.println(Outer.Inner3.z);\n     }\n \n}\n\nclass Outer {\n\n     private int x, y;\n     \n     Outer() {\n        System.out.println(\"Outer class default constructor called\");\n     }\n    \n     Outer(int x, int y) {\n         this.x = x;\n         this.y = y;\n     }\n\n     void showData() {\n         System.out.println(\"the value of x is:\" + x + \" and the value of y is: \" + y);\n     }\n\n class Inner1 {\n\n     int z = 0;\n    \n     Inner1() {\n       System.out.println(\"Inner class default constructor called\");\n     }\n    \n     Inner1(int z) {\n        this.z = z;\n     }\n    \n     void showData() {\n        System.out.println(\"The value of x is: \" + x + \" the value of y is: \" + y + \" and z is: \" + z);\n     }\n }\n\n static class Inner2 {\n\n          int z = 0;\n    \n          Inner2() {\n            System.out.println(\"Inner class default constructor called\");\n          }\n    \n          Inner2(int z) {\n            this.z = z;\n          }\n    \n          void showData() {\n            System.out.println(\"The value of z is: \" + z);\n          }\n }\n    \n    static class Inner3 {\n    \n         static int z = 0;\n    \n         Inner3() {\n            System.out.println(\"Inner class default constructor called\");\n         }\n    \n         Inner3(int a) {\n            z = a;\n         }\n    \n         void showData() {\n           System.out.println(\"The value of z is: \" + z);\n         }\n    }\n} public class Main {\n     \n     public static void main(String[] args) {\n         Outer obj1 = new Outer(10, 20);\n        \n         Outer.Inner2 obj2 = new Outer.Inner2(40);\n         obj2.showData();\n        \n         Outer.Inner3.z = 100;\n         System.out.println(Outer.Inner3.z);\n     }\n \n}\n\nclass Outer {\n\n     private int x, y;\n     \n     Outer() {\n        System.out.println(\"Outer class default constructor called\");\n     }\n    \n     Outer(int x, int y) {\n         this.x = x;\n         this.y = y;\n     }\n\n     void showData() {\n         System.out.println(\"the value of x is:\" + x + \" and the value of y is: \" + y);\n     }\n\n class Inner1 {\n\n     int z = 0;\n    \n     Inner1() {\n       System.out.println(\"Inner class default constructor called\");\n     }\n    \n     Inner1(int z) {\n        this.z = z;\n     }\n    \n     void showData() {\n        System.out.println(\"The value of x is: \" + x + \" the value of y is: \" + y + \" and z is: \" + z);\n     }\n }\n\n static class Inner2 {\n\n          int z = 0;\n    \n          Inner2() {\n            System.out.println(\"Inner class default constructor called\");\n          }\n    \n          Inner2(int z) {\n            this.z = z;\n          }\n    \n          void showData() {\n            System.out.println(\"The value of z is: \" + z);\n          }\n }\n    \n    static class Inner3 {\n    \n         static int z = 0;\n    \n         Inner3() {\n            System.out.println(\"Inner class default constructor called\");\n         }\n    \n         Inner3(int a) {\n            z = a;\n         }\n    \n         void showData() {\n           System.out.println(\"The value of z is: \" + z);\n         }\n    }\n} public class Main class Main public static void main(String[] args) public static void main (String[] args) new 10 20 new 40 100 class Outer class Outer private int \"Outer class default constructor called\" int int this this void showData() void showData () \"the value of x is:\" \" and the value of y is: \" class Inner1 class Inner1 int 0 \"Inner class default constructor called\" int this void showData() void showData () \"The value of x is: \" \" the value of y is: \" \" and z is: \" static class Inner2 class Inner2 int 0 \"Inner class default constructor called\" int this void showData() void showData () \"The value of z is: \" static class Inner3 class Inner3 static int 0 \"Inner class default constructor called\" int void showData() void showData () \"The value of z is: \" Output Output The value of z is: 40\n100 The value of z is: 40\n100 40 100",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "5. Write a program in Java to show multiple inheritance.",
        "answer": "Multiple inheritance is not possible in Java. So, we can use Interfaces in Java to create a scenario of multiple inheritance. In our example below, we have a class called Phone and a class called SmartPhone. We know that a SmartPhone is a Phone, however, it has various other features as well. For instance, a SmartPhone has a camera, a music player, etc. Notice that a SmartPhone is a Phone and has a camera and has a Music Player. So, there is one is-A relationship and multiple has-A relationships. The is-A relationship denotes extending the features and the has-A relationship denotes implementing the features. This means that a SmartPhone is a Phone i.e. it extends the features of a Phone however, it just implements the features of a Music Player and a Camera. It itself is not a music player or a camera. Following is the code for the above discussion. is a has a has a is-A has-A is-A has-A Java Code for Multiple Inheritance Java Code for Multiple Inheritance public class Main {\n public static void main(String[] args) {\n\n   SmartPhone sp1 = new SmartPhone();\n   Phone p1 = new SmartPhone();\n\n   ICamera c1 = new SmartPhone();\n   IMusicplayer m1 = new SmartPhone();\n\n   sp1.videocall();\n   p1.call();\n   p1.message();\n   c1.click();\n   c1.record();\n   m1.play();\n   m1.pause();\n     m1.stop();\n  \n  }\n}\n\nclass Phone {\n\n void call() {\n    System.out.println(\"call\");\n    }\n\n  void message() {\n       System.out.println(\"Message\");\n    }\n}\n\ninterface ICamera {\n\n    void click();\n\n    void record();\n}\n\ninterface IMusicplayer {\n    void play();\n\n    void pause();\n\n    void stop();\n}\n\nclass SmartPhone extends Phone implements ICamera, IMusicplayer {\n\n   void videocall() {\n     System.out.println(\"Video call\");\n   }\n\n   @Override\n   public void click() {\n      System.out.println(\"Picture click\");\n   }\n\n    @Override\n    public void record() {\n      System.out.println(\"Record video\");\n    }\n\n   @Override\n   public void play() {\n      System.out.println(\"Play music\");\n   }\n\n @Override\n    public void pause() {\n      System.out.println(\"Pause Music\");\n    }\n    @Override\n    public void stop() {\n      System.out.println(\"Stop music\");\n    }\n} public class Main {\n public static void main(String[] args) {\n\n   SmartPhone sp1 = new SmartPhone();\n   Phone p1 = new SmartPhone();\n\n   ICamera c1 = new SmartPhone();\n   IMusicplayer m1 = new SmartPhone();\n\n   sp1.videocall();\n   p1.call();\n   p1.message();\n   c1.click();\n   c1.record();\n   m1.play();\n   m1.pause();\n     m1.stop();\n  \n  }\n}\n\nclass Phone {\n\n void call() {\n    System.out.println(\"call\");\n    }\n\n  void message() {\n       System.out.println(\"Message\");\n    }\n}\n\ninterface ICamera {\n\n    void click();\n\n    void record();\n}\n\ninterface IMusicplayer {\n    void play();\n\n    void pause();\n\n    void stop();\n}\n\nclass SmartPhone extends Phone implements ICamera, IMusicplayer {\n\n   void videocall() {\n     System.out.println(\"Video call\");\n   }\n\n   @Override\n   public void click() {\n      System.out.println(\"Picture click\");\n   }\n\n    @Override\n    public void record() {\n      System.out.println(\"Record video\");\n    }\n\n   @Override\n   public void play() {\n      System.out.println(\"Play music\");\n   }\n\n @Override\n    public void pause() {\n      System.out.println(\"Pause Music\");\n    }\n    @Override\n    public void stop() {\n      System.out.println(\"Stop music\");\n    }\n} public class Main class Main public static void main(String[] args) public static void main (String[] args) new new new new class Phone class Phone void call() void call () \"call\" void message() void message () \"Message\" interface ICamera interface ICamera void click() void click () void record() void record () interface IMusicplayer interface IMusicplayer void play() void play () void pause() void pause () void stop() void stop () class SmartPhone extends Phone implements ICamera, IMusicplayer class SmartPhone extends Phone implements ICamera IMusicplayer void videocall() void videocall () \"Video call\" @Override public void click() public void click () \"Picture click\" @Override public void record() public void record () \"Record video\" @Override public void play() public void play () \"Play music\" @Override public void pause() public void pause () \"Pause Music\" @Override public void stop() public void stop () \"Stop music\" Output Output Video call\nCall\nMessage\nPicture click\nRecord Video\nPlay music\nPause Music\nStop music Video call\nCall\nMessage\nPicture click\nRecord Video\nPlay music\nPause Music\nStop music",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "6. Write a program in Java to create a user defined exception and also show it working means when it throws an exception.",
        "answer": "Here, you have to explain and write a user-defined exception of your own. This code is just for reference purposes. So, we are going to create an exception called LowBalanceException for a bank. So, whenever a person comes to the bank to create a bank account, the minimum account balance should be 5000. So, if the balance is less than 5000, the exception will be thrown. Let us write the code for the same. Java Code for User-Defined Exception Java Code for User-Defined Exception public class Main {\n   public static void main(String[] args) {\n  Account a1 = new Account(500);\n  Account a2 = new Account();\n  a2.setBalance(500);\n \n  Account a3 = new Account(10000);\n \n  System.out.println(\"a1 balance = \" + a1.getBalance() + \" a2 balance = \" + a2.getBalance() + \" a3 balance = \" + a3.getBalance());\n   }\n}\n\nclass Account {\n private int balance;\n Account() {\n \n     balance = 5000;\n }\n \n Account(int balance) {\n  try {\n   if(balance>=5000) {\n     this.balance = balance;\n     System.out.println(\"The account is created and the balance is set to: \"+ balance);\n   } else {\n     this.balance=0;\n     System.out.println(\"Account can not be created\");\n     throw new LowBalanceException();\n   }\n  } catch(LowBalanceException e) {\n    System.out.println(e);\n  }\n  \n}\n \n void setBalance(int balance) {\n  try {\n  if(balance>=5000) {\n   this.balance = balance;\n   System.out.println(\"The account is created and the balance is set to: \"+ balance);\n  } else {\n   this.balance=0;\n   System.out.println(\"Account can not be created\");\n   throw new LowBalanceException();\n  }\n\n } catch(LowBalanceException e) {\n     System.out.println(e);\n   }\n}\n \n int getBalance() {\n  return balance;\n }\n}\nclass LowBalanceException extends Exception {\n \n  public String toString() {\n    return \"Low Balance: The balance cannot be less than Rs.5000/-\";\n  }\n} public class Main {\n   public static void main(String[] args) {\n  Account a1 = new Account(500);\n  Account a2 = new Account();\n  a2.setBalance(500);\n \n  Account a3 = new Account(10000);\n \n  System.out.println(\"a1 balance = \" + a1.getBalance() + \" a2 balance = \" + a2.getBalance() + \" a3 balance = \" + a3.getBalance());\n   }\n}\n\nclass Account {\n private int balance;\n Account() {\n \n     balance = 5000;\n }\n \n Account(int balance) {\n  try {\n   if(balance>=5000) {\n     this.balance = balance;\n     System.out.println(\"The account is created and the balance is set to: \"+ balance);\n   } else {\n     this.balance=0;\n     System.out.println(\"Account can not be created\");\n     throw new LowBalanceException();\n   }\n  } catch(LowBalanceException e) {\n    System.out.println(e);\n  }\n  \n}\n \n void setBalance(int balance) {\n  try {\n  if(balance>=5000) {\n   this.balance = balance;\n   System.out.println(\"The account is created and the balance is set to: \"+ balance);\n  } else {\n   this.balance=0;\n   System.out.println(\"Account can not be created\");\n   throw new LowBalanceException();\n  }\n\n } catch(LowBalanceException e) {\n     System.out.println(e);\n   }\n}\n \n int getBalance() {\n  return balance;\n }\n}\nclass LowBalanceException extends Exception {\n \n  public String toString() {\n    return \"Low Balance: The balance cannot be less than Rs.5000/-\";\n  }\n} public class Main class Main public static void main(String[] args) public static void main (String[] args) new 500 new 500 new 10000 \"a1 balance = \" \" a2 balance = \" \" a3 balance = \" class Account class Account private int 5000 int try if 5000 this \"The account is created and the balance is set to: \" else this 0 \"Account can not be created\" throw new catch void setBalance(int balance) void setBalance (int balance) int try if 5000 this \"The account is created and the balance is set to: \" else this 0 \"Account can not be created\" throw new catch int getBalance() int getBalance () return class LowBalanceException extends Exception class LowBalanceException extends Exception public String toString() public toString () return \"Low Balance: The balance cannot be less than Rs.5000/-\" Output Output The account can not be created\nLow Balance: The balance cannot be less than Rs.5000/-\nThe account can not be created\nLow Balance: The balance cannot be less than Rs.5000/-\nThe account is created and the balance is set to 10000\na1 balance = 0 a2 balance = 0 a3 balance =10000 The account can not be created\nLow Balance: The balance cannot be less than Rs.5000/-\nThe account can not be created\nLow Balance: The balance cannot be less than Rs.5000/-\nThe account is created and the balance is set to 10000\na1 balance = 0 a2 balance = 0 a3 balance =10000 .5000 .5000 10000 0 0 10000",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "7. Write a program in Java to search an element in a row-wise and column-wise sorted 2-D matrix of size M x N.",
        "answer": "You have to search the element in O(N + M) time complexity without using any extra space. Print “true” if the element exists in the matrix else print “false”. The normal searching technique will take O(N2) time complexity as we will search every element in the matrix and see if it matches our target or not. The other approach uses the fact that the elements are sorted row-wise. We can apply binary search on every row. Hence, the time complexity will be O(Nlog2N)\nSince we want the solution in O(N + M), this approach is not the one we will use. We will use the Staircase Search Algorithm. See, we know that the elements are sorted column-wise and row-wise. So, we start from the last element of the first row as shown below  Staircase Search Algorithm   Let us say we want to search for 21. We know that 21 is larger than 15. Since the matrix is row-wise sorted, element 15 is the largest element of this row. So, we are not going to find 21 in this row. So, we move directly to the last element of the next row. The Same is the case here as well. So, we move to the next row. Here, the element is 22. So, 21 might be present in this row. So, we move one step backwards in this row only.   On moving one step backwards, we see that we reach 16. Since this number is smaller than our target of 21, we know that we will not find our target in this row. Hence, we move to the last element of the next row and the same happens here too. Now, we are in the last row. We know that element might exist in this row. So, we keep on moving back in this row and find element 21.   So, we will implement this same algorithm. This is called staircase search. Java Code for Staircase Search Java Code for Staircase Search import java.util.*;\nclass Main {\n \n public static boolean staircaseSearch(int[][] matrix, int target) {\n        \n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;\n        \n        int j = matrix[0].length - 1 ;\n        int i = 0;\n        \n        while(i < matrix.length && j>=0) {\n            if(matrix[i][j] == target) return true;\n            else if(matrix[i][j] < target) {\n                i++;\n            } else {\n                j--;\n            }\n        }\n        \n        return false;\n    }\n \n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  int N = scn.nextInt();\n  int M = scn.nextInt();\n\n  int[][] mat = new int[N][M];\n\n  for(int i=0;i<N;i++) {\n   for(int j=0;j<M;j++) {\n    mat[i][j] = scn.nextInt();\n   }\n  }\n\n  int target = scn.nextInt();\n  \n  System.out.println(staircaseSearch(mat,target));\n }\n} import java.util.*;\nclass Main {\n \n public static boolean staircaseSearch(int[][] matrix, int target) {\n        \n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;\n        \n        int j = matrix[0].length - 1 ;\n        int i = 0;\n        \n        while(i < matrix.length && j>=0) {\n            if(matrix[i][j] == target) return true;\n            else if(matrix[i][j] < target) {\n                i++;\n            } else {\n                j--;\n            }\n        }\n        \n        return false;\n    }\n \n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  int N = scn.nextInt();\n  int M = scn.nextInt();\n\n  int[][] mat = new int[N][M];\n\n  for(int i=0;i<N;i++) {\n   for(int j=0;j<M;j++) {\n    mat[i][j] = scn.nextInt();\n   }\n  }\n\n  int target = scn.nextInt();\n  \n  System.out.println(staircaseSearch(mat,target));\n }\n} import class Main class Main public static boolean staircaseSearch(int[][] matrix, int target) public static boolean staircaseSearch (int[][] matrix, int target) int int if null 0 0 0 return false int 0 1 int 0 while 0 if return true else if else return false public static void main(String args[]) public static void main (String args[]) // Your code goes here new int int int new int for int 0 for int 0 int Sample Output Sample Output 5 5\n1  2  3  4  5\n6  7  8  9  10\n11 12 13 14 15 \n16 17 18 19 20\n21 22 23 24 25\n21\n\nOutput: true 5 5\n1  2  3  4  5\n6  7  8  9  10\n11 12 13 14 15 \n16 17 18 19 20\n21 22 23 24 25\n21\n\nOutput: true 5 5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 21 true Time Complexity: O(N + M) is the time complexity of staircase search. This is because we will have to search for a maximum of one row and one column.\nAuxiliary Space: O(1) as we have not used any extra space. Time Complexity: O(N + M) is the time complexity of staircase search. This is because we will have to search for a maximum of one row and one column. Time Complexity: Auxiliary Space: O(1) as we have not used any extra space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "8. You are given a 2-D array of size N x N. You have to print the elements of the array in diagonal order as shown below",
        "answer": "So, we have travelled the upper triangular half of the matrix diagonally. We can clearly see that the first diagonal has row = col i.e. the gap between them is 0. In the next diagonal, the column index is always greater than the row index by 1. The max gap up to which we can go is N-1, where N is the number of columns. So, we will use this gap strategy to traverse the matrix diagonally as shown below.   Java Code for Diagonal Traversal Java Code for Diagonal Traversal import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        // write your code here\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        \n        int[][] mat = new int[n][n];\n        \n        for(int i=0;i<n;i++) {\n            for(int j=0;j<n;j++) {\n                mat[i][j] = scn.nextInt();\n            }\n        }\n        \n        diagonalTraversal(mat);\n    }\n    \n    public static void diagonalTraversal(int[][] mat) {\n        \n        int maxGap = mat[0].length - 1;\n        \n        for(int gap=0;gap<=maxGap;gap++) {\n            \n            for(int i=0,j=gap;i<mat.length && j<mat[0].length;i++,j++) {\n                System.out.print(mat[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n} import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        // write your code here\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        \n        int[][] mat = new int[n][n];\n        \n        for(int i=0;i<n;i++) {\n            for(int j=0;j<n;j++) {\n                mat[i][j] = scn.nextInt();\n            }\n        }\n        \n        diagonalTraversal(mat);\n    }\n    \n    public static void diagonalTraversal(int[][] mat) {\n        \n        int maxGap = mat[0].length - 1;\n        \n        for(int gap=0;gap<=maxGap;gap++) {\n            \n            for(int i=0,j=gap;i<mat.length && j<mat[0].length;i++,j++) {\n                System.out.print(mat[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n} import public class Main class Main public static void main(String[] args) throws Exception public static void main (String[] args) throws // write your code here new int int new int for int 0 for int 0 public static void diagonalTraversal(int[][] mat) public static void diagonalTraversal (int[][] mat) int int 0 1 for int 0 for int 0 0 \" \" Sample Output Sample Output Input:\n5\n1  2  3  4  5\n6  7  8  9  10\n11 12 13 14 15\n16 17 18 19 20\n21 22 23 24 25\n\nOutput:\n1 7 13 19 25\n2 8 14 20\n3 9 15\n4 10\n5 Input:\n5\n1  2  3  4  5\n6  7  8  9  10\n11 12 13 14 15\n16 17 18 19 20\n21 22 23 24 25\n\nOutput:\n1 7 13 19 25\n2 8 14 20\n3 9 15\n4 10\n5 5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 1 7 13 19 25 2 8 14 20 3 9 15 4 10 5 Time Complexity: O(N2) as we have to traverse half matrix of size N x N.\nAuxiliary Space: O(1) is the auxiliary space. Time Complexity: O(N2) as we have to traverse half matrix of size N x N. Time Complexity: Auxiliary Space: O(1) is the auxiliary space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "9. You are given an array of integers. Your task is to Wave sort the array. For example, let us say the array is arr = {9,8,6,3,4,7,2}. Currently, the graph for the array of elements looks like this:",
        "answer": "  We want the graph to look like this:   It is not necessary that you print the same order of elements as shown above. You can print any other order but the shape of the graph of elements of the array should look like a wave. The graph should always start with the peak and not a valley. You are not allowed to use any extra space and you have to solve this problem in O(N) time complexity. One basic approach to solve this problem is to sort the array and then swap the adjacent elements. The time complexity for which is O(NLog2N). Since we have to solve the problem in O(N) time complexity, we can solve it using the Wave Sort algorithm. Our aim is to generate the Wave Graph. The aim can be accomplished by aiming at generating the peaks in the array or aiming at generating the valleys in the array. So, let us try to generate peaks in the array. Since we want the first array to be the peak, we will leave it as it is and start from the index = 2. Here, since we want to generate a peak, we need to have the previous and next elements smaller than our current elements. So, we will check that if our previous element is larger than our element, we will swap them. Again, at the same position, we will also check that the next element should be smaller than our current element. If it is not, swap these 2 elements. This is shown below.   So, we have to take a jump of 2 indices every time till we reach the end of the array. Hence, we will be able to wave sort the array in O(N) time and O(1) space. Java Code for Wave Sort Java Code for Wave Sort import java.util.*;\nclass Main {\n\n public static void swap(int[] arr, int i, int j) {\n  int temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n }\n\n public static void waveSort(int[] arr) {\n  for(int i=0;i<arr.length;i=i+2) {\n   if(i>0 && arr[i-1] > arr[i]) {\n    swap(arr,i-1,i);\n   }\n\n   if(i<arr.length-1 && arr[i+1] > arr[i]) {\n    swap(arr,i,i+1);\n   }\n  }\n }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  int n = scn.nextInt();\n  int[] arr = new int[n];\n\n  for(int i=0;i<n;i++) {\n   arr[i] = scn.nextInt();\n  }\n\n  waveSort(arr);\n\n  System.out.println(\"After wave sort\");\n\n  for(int i=0;i<arr.length;i++) {\n   System.out.print(arr[i] + \" \");\n  }\n }\n} import java.util.*;\nclass Main {\n\n public static void swap(int[] arr, int i, int j) {\n  int temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n }\n\n public static void waveSort(int[] arr) {\n  for(int i=0;i<arr.length;i=i+2) {\n   if(i>0 && arr[i-1] > arr[i]) {\n    swap(arr,i-1,i);\n   }\n\n   if(i<arr.length-1 && arr[i+1] > arr[i]) {\n    swap(arr,i,i+1);\n   }\n  }\n }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  int n = scn.nextInt();\n  int[] arr = new int[n];\n\n  for(int i=0;i<n;i++) {\n   arr[i] = scn.nextInt();\n  }\n\n  waveSort(arr);\n\n  System.out.println(\"After wave sort\");\n\n  for(int i=0;i<arr.length;i++) {\n   System.out.print(arr[i] + \" \");\n  }\n }\n} import class Main class Main public static void swap(int[] arr, int i, int j) public static void swap (int[] arr, int i, int j) int int int int public static void waveSort(int[] arr) public static void waveSort (int[] arr) int for int 0 2 if 0 1 1 if 1 1 1 public static void main(String args[]) public static void main (String args[]) // Your code goes here new int int new int for int 0 \"After wave sort\" for int 0 \" \" Sample Output Sample Output Input:\n7\n9 8 6 3 4 7 2\n\nOutput:\nAfter wave sort\n9 6 8 3 7 2 4 Input:\n7\n9 8 6 3 4 7 2\n\nOutput:\nAfter wave sort\n9 6 8 3 7 2 4 7 9 8 6 3 4 7 2 9 6 8 3 7 2 4 Corner Cases, You Might Miss: Since we are swapping the previous element and the next element with the current element, we have to take care of the Index out of bounds condition. This is done in the code above.\nTime Complexity: O(N) as we are traversing the array.\nAuxiliary Space: O(1) as we have not used any extra space. Corner Cases, You Might Miss: Since we are swapping the previous element and the next element with the current element, we have to take care of the Index out of bounds condition. This is done in the code above. Corner Cases, You Might Miss: Time Complexity: O(N) as we are traversing the array. Time Complexity: Auxiliary Space: O(1) as we have not used any extra space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "10. You are given a sorted array of integers. It is given that each element in the array is unique.",
        "answer": "You have to find the index where the element is located in the array. If it is not located in the array, you have to return the index at which it should be inserted in the array so that the array remains sorted. You can’t use extra space and the expected time complexity is O(log2N) where N is the number of elements in the array. Since the array is sorted, we will use Binary Search to find the element. If the element is not found, the index at which we insert an element is always the ceil Index. So, what is the ceil index? At the end of the binary search, ceil index is where the low (or left) pointer points. So, the code for the same is shown below. Java Code to Search Element/Insert Position Java Code to Search Element/Insert Position import java.util.*;\nclass Main {\n\n public static int ceilIndex(int[] nums, int target) {\n        int lo = 0;\n        int hi = nums.length-1;\n        \n        while(lo <= hi) {\n            int mid = lo + (hi-lo)/2;\n            \n            if(nums[mid] == target) {\n                return mid;\n            } else if(nums[mid] < target) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        \n        return lo; //ceil\n    }\n    \n    public static int search(int[] nums, int target) {\n        //insert position is actually the ceil of the element\n        return ceilIndex(nums,target);\n    }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  int n = scn.nextInt();\n  int[] arr = new int[n];\n\n  for(int i=0;i<n;i++) {\n   arr[i] = scn.nextInt();\n  }\n\n  int target = scn.nextInt();\n\n  System.out.println(search(arr,target));\n\n }\n} import java.util.*;\nclass Main {\n\n public static int ceilIndex(int[] nums, int target) {\n        int lo = 0;\n        int hi = nums.length-1;\n        \n        while(lo <= hi) {\n            int mid = lo + (hi-lo)/2;\n            \n            if(nums[mid] == target) {\n                return mid;\n            } else if(nums[mid] < target) {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n        \n        return lo; //ceil\n    }\n    \n    public static int search(int[] nums, int target) {\n        //insert position is actually the ceil of the element\n        return ceilIndex(nums,target);\n    }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  int n = scn.nextInt();\n  int[] arr = new int[n];\n\n  for(int i=0;i<n;i++) {\n   arr[i] = scn.nextInt();\n  }\n\n  int target = scn.nextInt();\n\n  System.out.println(search(arr,target));\n\n }\n} import class Main class Main public static int ceilIndex(int[] nums, int target) public static int ceilIndex (int[] nums, int target) int int int 0 int 1 while int 2 if return else if 1 else 1 return //ceil public static int search(int[] nums, int target) public static int search (int[] nums, int target) int int //insert position is actually the ceil of the element return public static void main(String args[]) public static void main (String args[]) // Your code goes here new int int new int for int 0 int Sample Output Sample Output When the element is present in the array Input: \n4\n1 3 5 6\n5\n\nOutput: 2 Input: \n4\n1 3 5 6\n5\n\nOutput: 2 4 1 3 5 6 5 2 When the element is not present in the array Input: \n4\n1 3 5 6\n4\n\nOutput: 2 Input: \n4\n1 3 5 6\n4\n\nOutput: 2 4 1 3 5 6 4 2 Time Complexity: The time complexity is O(log2N) where N is the number of elements in the array.\nAuxiliary Space: O(1) as we have not used any extra space. Time Complexity: The time complexity is O(log2N) where N is the number of elements in the array. Time Complexity: Auxiliary Space: O(1) as we have not used any extra space. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "11. You are given 2 strings as input. You have to check whether they are anagrams or not.",
        "answer": "Anagrams are those strings that have the same characters occurring an equal number of times in both the strings. However, the order can be different. For example “anagram” and “nagrama” are Anagrams. We will use HashMap to store the frequency of each character of the first string. Then, we will traverse the second string and keep on decrementing the frequency in the HashMap. If for any character in the second string, either the character is not present in the HashMap or its frequency is already 0, we will return false. Else, if we have scanned the entire second String and there are no discrepancies, the two strings will be anagrams. Java Code to check Anagrams Java Code to check Anagrams import java.util.*;\nclass Main {\n \n public static boolean isAnagram(String s1, String s2) {\n         \n        if(s1.length() != s2.length()) return false;\n        \n        HashMap<Character,Integer> fmap = new HashMap<>();\n        \n        for(int i=0;i<s1.length();i++) {\n            int ofreq = fmap.getOrDefault(s1.charAt(i),0);\n            fmap.put(s1.charAt(i),ofreq+1);\n        }\n        \n        for(int i=0;i<s2.length();i++) {\n            if(!fmap.containsKey(s2.charAt(i)) || fmap.get(s2.charAt(i)) == 0) {\n                return false;\n            } else {\n                int ofreq = fmap.get(s2.charAt(i));\n                fmap.put(s2.charAt(i),ofreq-1);\n            }\n        }\n        \n        return true;\n    }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  String str1 = scn.nextLine();\n  String str2 = scn.nextLine();\n\n  if(isAnagram(str1,str2)) System.out.println(true);\n  else System.out.println(false);\n }\n} import java.util.*;\nclass Main {\n \n public static boolean isAnagram(String s1, String s2) {\n         \n        if(s1.length() != s2.length()) return false;\n        \n        HashMap<Character,Integer> fmap = new HashMap<>();\n        \n        for(int i=0;i<s1.length();i++) {\n            int ofreq = fmap.getOrDefault(s1.charAt(i),0);\n            fmap.put(s1.charAt(i),ofreq+1);\n        }\n        \n        for(int i=0;i<s2.length();i++) {\n            if(!fmap.containsKey(s2.charAt(i)) || fmap.get(s2.charAt(i)) == 0) {\n                return false;\n            } else {\n                int ofreq = fmap.get(s2.charAt(i));\n                fmap.put(s2.charAt(i),ofreq-1);\n            }\n        }\n        \n        return true;\n    }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  String str1 = scn.nextLine();\n  String str2 = scn.nextLine();\n\n  if(isAnagram(str1,str2)) System.out.println(true);\n  else System.out.println(false);\n }\n} import class Main class Main public static boolean isAnagram(String s1, String s2) public static boolean isAnagram (String s1, String s2) if return false new for int 0 int 0 1 for int 0 if 0 return false else int 1 return true public static void main(String args[]) public static void main (String args[]) // Your code goes here new if true else false Sample Output Sample Output When the strings are anagrams Input:\nanagram\nnagrama\n\nOutput:  true Input:\nanagram\nnagrama\n\nOutput:  true true Input: \nanagram\nnagrame\n\nOutput: false Input: \nanagram\nnagrame\n\nOutput: false false Corner Cases, You Might Miss: Is there any need to check the strings if the length of the strings is not equal? The answer is NO as they don’t have an equal number of characters so, they can never be anagrams. So, a separate check for the length of the strings will be beneficial.\nTime Complexity: O(N + M) where N and M are the lengths of the two strings. This is because we have traversed both the strings separately.\nAuxiliary Space: O(N) where N is the length of the first string. This is because it might happen that all the N characters in the first String are unique. Corner Cases, You Might Miss: Is there any need to check the strings if the length of the strings is not equal? The answer is NO as they don’t have an equal number of characters so, they can never be anagrams. So, a separate check for the length of the strings will be beneficial. Corner Cases, You Might Miss: Time Complexity: O(N + M) where N and M are the lengths of the two strings. This is because we have traversed both the strings separately. Time Complexity: Auxiliary Space: O(N) where N is the length of the first string. This is because it might happen that all the N characters in the first String are unique. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "12. Add two Binary Strings and return a Binary String as a result. The addition should be performed as per the rules of binary addition.",
        "answer": "So, the question is basically to add 2 binary numbers given in the form of strings. We should know the basic rules of binary addition: 0 + 0 = 0 0 + 1 = 1 1 + 0 = 1 1 + 1 = 0 and Carry = 1 This shows that whenever the result exceeds 1, the answer of addition becomes 0 and carry becomes 1. So, using these rules, we will add 2 binary strings starting from their LSBs i.e. from the last index of each string moving towards the first index. Java Code for Binary Addition of Strings Java Code for Binary Addition of Strings import java.util.*;\nclass Main {\n\n public static String add(String a, String b) {\n  String ans = \"\";\n        \n        if(a.equals(\"0\") && b.equals(\"0\")) return \"0\";\n        \n        int i = a.length() -1;\n        int j = b.length() -1;\n        \n        int ca = 0;\n        \n        while(i >=0 || j>=0 || ca >0) {\n            \n            int d1 = (i >= 0) ? (a.charAt(i) - '0') : 0;\n            int d2 = (j >= 0) ? (b.charAt(j) - '0') : 0;\n            \n            int digit = 0;\n            if(d1 + d2 + ca >= 2) {\n                digit = (d1 + d2 + ca) % 2;\n                ca = (d1 + d2 + ca) / 2;\n            } else {\n                digit = d1 + d2 + ca;\n                ca = 0;\n            }\n            \n            i--;\n            j--;\n            ans  = digit + ans;\n        }\n        \n        return ans;\n }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  String a = scn.nextLine();\n  String b = scn.nextLine();\n\n  System.out.println(\"The sum is: \" + add(a,b));  \n }\n} import java.util.*;\nclass Main {\n\n public static String add(String a, String b) {\n  String ans = \"\";\n        \n        if(a.equals(\"0\") && b.equals(\"0\")) return \"0\";\n        \n        int i = a.length() -1;\n        int j = b.length() -1;\n        \n        int ca = 0;\n        \n        while(i >=0 || j>=0 || ca >0) {\n            \n            int d1 = (i >= 0) ? (a.charAt(i) - '0') : 0;\n            int d2 = (j >= 0) ? (b.charAt(j) - '0') : 0;\n            \n            int digit = 0;\n            if(d1 + d2 + ca >= 2) {\n                digit = (d1 + d2 + ca) % 2;\n                ca = (d1 + d2 + ca) / 2;\n            } else {\n                digit = d1 + d2 + ca;\n                ca = 0;\n            }\n            \n            i--;\n            j--;\n            ans  = digit + ans;\n        }\n        \n        return ans;\n }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  String a = scn.nextLine();\n  String b = scn.nextLine();\n\n  System.out.println(\"The sum is: \" + add(a,b));  \n }\n} import class Main class Main public static String add(String a, String b) public static add (String a, String b) \"\" if \"0\" \"0\" return \"0\" int 1 int 1 int 0 while 0 0 0 int 0 '0' 0 int 0 '0' 0 int 0 if 2 2 2 else 0 return public static void main(String args[]) public static void main (String args[]) // Your code goes here new \"The sum is: \" Sample Output Sample Output Input: \n1 \n0111\n\nOutput: The sum is: 1000 Input: \n1 \n0111\n\nOutput: The sum is: 1000 1 0111 1000 Corner Cases, You Might Miss: It is very important to address that the numbers might not be of equal length. As in the example shown above, the first number is 1 and the second is 0111. So, the first number is smaller than the second number. The second number can also be smaller than the first number. Also, even if the numbers of equal lengths are passed, the result of addition can exceed one bit. As in the example shown above, the larger number was a 3-bit number 111 and the output is a 4-bit number 1000.\nTime Complexity: O(N) where N is the length of the longer string among the 2 input binary strings.\nAuxiliary Space: O(1) as we have not used any extra space to solve our problem. Corner Cases, You Might Miss: It is very important to address that the numbers might not be of equal length. As in the example shown above, the first number is 1 and the second is 0111. So, the first number is smaller than the second number. The second number can also be smaller than the first number. Also, even if the numbers of equal lengths are passed, the result of addition can exceed one bit. As in the example shown above, the larger number was a 3-bit number 111 and the output is a 4-bit number 1000. Corner Cases, You Might Miss: Time Complexity: O(N) where N is the length of the longer string among the 2 input binary strings. Time Complexity: Auxiliary Space: O(1) as we have not used any extra space to solve our problem. Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    },
    {
        "question": "13. A sentence is said to be a palindrome if we convert all its alphabets to lowercase, include the numerics but exclude all the spaces, whitespaces, and other special characters and it reads the same from left to right and right to left.",
        "answer": "For instance, consider the following sentence: “2 Race, e cAr 2”. This sentence will be converted to “2raceecar2”. The string is a palindrome, hence this sentence is a palindrome. You have to take a sentence input from the user and print “true” if it is a palindrome, or else print “false”. A sentence is said to be a palindrome if we convert all its alphabets to lowercase, include the numerics but exclude all the spaces, whitespaces, and other special characters and it reads the same from left to right and right to left. So, the approach is pretty simple. We convert the sentence into a string by including all the alphanumeric characters and excluding all the other characters. The alphabets will be included only in their lowercase format. Then, we simply have to check whether a string is a palindrome or not. For this, we keep a pointer “lo” at the beginning of the string and a pointer “hi” at the end of the string. We keep incrementing lo and decrementing hi while checking whether the characters at these indices are equal or not. If at any place, we find that the characters are not equal, the string is not a palindrome. If lo becomes greater than hi and the characters at lo and hi were the same throughout, the string is a palindrome. Java Code to check Palindromic Sentence Java Code to check Palindromic Sentence import java.util.*;\nclass Main {\n \n public static boolean isStrPalindrome(String str) {\n        \n        int lo = 0;\n        int hi = str.length()-1;\n        \n        while(lo < hi) {\n            char ch1 = str.charAt(lo);\n            char ch2 = str.charAt(hi);\n            \n            if(ch1 != ch2) return false;\n            lo++;\n            hi--;\n        }\n        \n        return true;\n    }\n    \n    public static boolean isSentencePalindrome(String s) {\n       String res = \"\";\n        \n       for(int i=0;i<s.length();i++) {\n           char ch = s.charAt(i);\n           \n           if((ch >='a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >='0' && ch<='9')) {\n                if(ch >='A' && ch <= 'Z') res += (char)(ch + 32);\n                else res += ch;\n           } else continue;\n       }\n       \n       if(isStrPalindrome(res)) return true;\n        return false;\n    }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  String sentence = scn.nextLine();\n\n  if(isSentencePalindrome(sentence)) System.out.println(true);\n  else System.out.println(false);\n }\n} import java.util.*;\nclass Main {\n \n public static boolean isStrPalindrome(String str) {\n        \n        int lo = 0;\n        int hi = str.length()-1;\n        \n        while(lo < hi) {\n            char ch1 = str.charAt(lo);\n            char ch2 = str.charAt(hi);\n            \n            if(ch1 != ch2) return false;\n            lo++;\n            hi--;\n        }\n        \n        return true;\n    }\n    \n    public static boolean isSentencePalindrome(String s) {\n       String res = \"\";\n        \n       for(int i=0;i<s.length();i++) {\n           char ch = s.charAt(i);\n           \n           if((ch >='a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >='0' && ch<='9')) {\n                if(ch >='A' && ch <= 'Z') res += (char)(ch + 32);\n                else res += ch;\n           } else continue;\n       }\n       \n       if(isStrPalindrome(res)) return true;\n        return false;\n    }\n\n public static void main(String args[]) {\n  // Your code goes here\n  Scanner scn = new Scanner(System.in);\n  String sentence = scn.nextLine();\n\n  if(isSentencePalindrome(sentence)) System.out.println(true);\n  else System.out.println(false);\n }\n} import class Main class Main public static boolean isStrPalindrome(String str) public static boolean isStrPalindrome (String str) int 0 int 1 while char char if return false return true public static boolean isSentencePalindrome(String s) public static boolean isSentencePalindrome (String s) \"\" for int 0 char if 'a' 'z' 'A' 'Z' '0' '9' if 'A' 'Z' char 32 else else continue if return true return false public static void main(String args[]) public static void main (String args[]) // Your code goes here new if true else false Sample Output Sample Output When the sentence is a palindrome Input: 2 Race, e cAr 2\nOutput: true Input: 2 Race, e cAr 2\nOutput: true 2 2 true When the sentence is not a palindrome Input: 2 Race, a cAr 2\nOutput: false Input: 2 Race, a cAr 2\nOutput: false 2 2 false Corner cases, You Might Miss: It is very important to convert all the alphabets in the String to lowercase. If this is not done, our answer will not be correct. Also, the special case of the string being empty is not handled separately as the program automatically covers this test case by not including any character of the string. So, according to our program, an empty string will be a palindrome.\nIf you want that the answer should be false in the case of an empty string, you can apply this condition in the isStrPalindrome() function.\nTime Complexity: O(N) where N is the length of the input string.\nAuxiliary Space: O(1) as we have not used any extra space. Corner cases, You Might Miss: It is very important to convert all the alphabets in the String to lowercase. If this is not done, our answer will not be correct. Also, the special case of the string being empty is not handled separately as the program automatically covers this test case by not including any character of the string. So, according to our program, an empty string will be a palindrome. Corner cases, You Might Miss: If you want that the answer should be false in the case of an empty string, you can apply this condition in the isStrPalindrome() function. Time Complexity: O(N) where N is the length of the input string.\nAuxiliary Space: O(1) as we have not used any extra space. Time Complexity:  Auxiliary Space:",
        "reference": "interviewbit.com",
        "role": "java-programming"
    }
]