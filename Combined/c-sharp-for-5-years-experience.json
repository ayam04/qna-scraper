[
    {
        "question": "1. What is the use of the method \"hiding\" in inheritance?",
        "answer": "Method hiding or Method shadowing is used to hide the implementation of the base class method under the shadow of the child class method, with the help of a new keyword. This is done to clear the ambiguity when the child class has a method with the same name as that of the base class and hence helps in abstraction. // C# program to illustrate the\n// concept of method hiding\nusing System;\n// Base Class\npublic class Parent {\npublic void member()\n{\n Console.WriteLine(\"Parent method\");\n}\n}\n// Derived Class\npublic class Child : Parent {\n// Reimplement the method of the base class\n// Using new keyword\n// It hides the method of the base class\npublic new void member()\n{\n Console.WriteLine(\"Child method\");\n}\n}\n// Driver Class\nclass DriverClass {\n// Main method\nstatic public void Main()\n{\n // Creating the object of the derived class\n Child obj = new Child();\n // Access the method of derived class\n obj.member();\n}\n} // C# program to illustrate the\n// concept of method hiding\nusing System;\n// Base Class\npublic class Parent {\npublic void member()\n{\n Console.WriteLine(\"Parent method\");\n}\n}\n// Derived Class\npublic class Child : Parent {\n// Reimplement the method of the base class\n// Using new keyword\n// It hides the method of the base class\npublic new void member()\n{\n Console.WriteLine(\"Child method\");\n}\n}\n// Driver Class\nclass DriverClass {\n// Main method\nstatic public void Main()\n{\n // Creating the object of the derived class\n Child obj = new Child();\n // Access the method of derived class\n obj.member();\n}\n} // C# program to illustrate the // concept of method hiding using // Base Class public class Parent public void member() public void member  \"Parent method\" // Derived Class public class Child Parent // Reimplement the method of the base class // Using new keyword // It hides the method of the base class public new void member() public new void member  \"Child method\" // Driver Class class DriverClass // Main method static public void Main() static public void Main  // Creating the object of the derived class new // Access the method of derived class",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "2. What is Serialization in C#?",
        "answer": "When we want to store any object to a memory, a database, or a file, it needs a special process known as Serialization. Serialization is the process of converting an object into a different form to store it on to a file, database, or memory. The purpose of Serialization is to transfer the object and its state across the network and recreate it successfully when needed. The reverse of Serialization is known as Deserialization.   There are many types of serialization in C#, such as: Binary serialization: To save the state of the object in binary format.  This is done using classes defined in the System.Runtime.Serialization namespace.\nSoap Serialization: To save the state of the object in binary format, with the use of network-related communication.\nXML Serialization: To save the state of the object in XML format. This is done using classes defined in the System.Xml.Serialization namespace.\nJSON Serialization: To save the state of the object in JSON format.  This is done using classes defined in the System.Text.Json namespace. Binary serialization: To save the state of the object in binary format.  This is done using classes defined in the System.Runtime.Serialization namespace. Binary serialization: Soap Serialization: To save the state of the object in binary format, with the use of network-related communication. Soap Serialization: XML Serialization: To save the state of the object in XML format. This is done using classes defined in the System.Xml.Serialization namespace. XML Serialization: JSON Serialization: To save the state of the object in JSON format.  This is done using classes defined in the System.Text.Json namespace. JSON Serialization: There are some third-party serialization formats as well that are supported in C#, such as MessagePack (msgpack). Conclusion: If you are planning to go for an interview in C# with 5+ years of experience, then you will need to be ready for some aggressive, in-depth, and out-of-the-box questions. However, with proper knowledge, brush up on your experience and expertise, and proper preparation, you can easily crack any interview. Useful Resources: Useful Resources: OOPs Interview Questions\n.NET Interview Questions\nASP.NET Interview Questions\nMVC Interview Questions\nSelenium Interview Questions for Experienced OOPs Interview Questions OOPs Interview Questions .NET Interview Questions .NET Interview Questions ASP.NET Interview Questions ASP.NET Interview Questions MVC Interview Questions MVC Interview Questions Selenium Interview Questions for Experienced Selenium Interview Questions for Experienced",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "3. What are sealed classes in C#?",
        "answer": "If we want to prevent any class from being inherited, it can be done with the help of a sealed keyword. So using a sealed keyword, a class denies the ability to create any child entity of this class, thereby calling itself a sealed class. If by mistake, a child of a sealed class is tried to be made, a compile-time error will occur. using System;  \n// Sealed class  \nsealed class SealedClass  \n{  \n   public int Add(int x, int y)  \n   {  \n       return x + y;  \n   }  \n}  \nclass Class1: SealedClass\n{  \n   static void Main(string[] args)  \n   {  \n       SealedClass sealedCls = new SealedClass();  \n       int total = sealedCls.Add(4, 5);  \n       Console.WriteLine(\"Total = \" + total.ToString());  \n   }  \n} using System;  \n// Sealed class  \nsealed class SealedClass  \n{  \n   public int Add(int x, int y)  \n   {  \n       return x + y;  \n   }  \n}  \nclass Class1: SealedClass\n{  \n   static void Main(string[] args)  \n   {  \n       SealedClass sealedCls = new SealedClass();  \n       int total = sealedCls.Add(4, 5);  \n       Console.WriteLine(\"Total = \" + total.ToString());  \n   }  \n} using // Sealed class sealed class SealedClass public int Add(int x, int y) public int Add int x, int y int int return class Class1 SealedClass static void Main(string[] args) static void Main string[] args string new int 4 5 \"Total = \" Compilation error: prog.cs(12,7): error CS0509: `Class1': cannot derive from sealed type `SealedClass'\nprog.cs(4,14): (Location of the symbol related to previous error)\nCompilation failed: 1 error(s), 0 warnings prog.cs(12,7): error CS0509: `Class1': cannot derive from sealed type `SealedClass'\nprog.cs(4,14): (Location of the symbol related to previous error)\nCompilation failed: 1 error(s), 0 warnings 12 7 ': cannot derive from sealed type `SealedClass' 4 14 1 0",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "4. What is the lock statement in C#?",
        "answer": "During multi-threading, when a thread is inside a critical section, it must not be removed or stopped until it is completed. To implement this feature, lock statements are used in C# which prevents other threads from entering a locked code (currently in the critical section), until the object is released. static object obj = new object();\n\npublic static void LockDemo()\n{\n   lock(obj)\n   {\n       Console.WriteLine(\"Demonstrating use of Lock statement in C#\");\n   }\n} static object obj = new object();\n\npublic static void LockDemo()\n{\n   lock(obj)\n   {\n       Console.WriteLine(\"Demonstrating use of Lock statement in C#\");\n   }\n} static object new object public static void LockDemo() public static void LockDemo  lock \"Demonstrating use of Lock statement in C#\"",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "5. Show an example of how the Mutex synchronization mechanism works.",
        "answer": "This example shows how a local Mutex object is used to synchronize access to a protected resource. using System;  \nusing System.Collections;  \nusing System.Threading;\nnamespace MutexDemo\n{  \nclass MutexDemoClass  \n   {  \n       private static Mutex mutex = new Mutex();  \n       private const int countOfHits = 1;  \n       private const int countOfThreads = 3;  \n       private static void ThreadProcess()  \n       {  \n           for (int i = 0; i < countOfHits; i++)  \n           {  \n               showMutexDemo();  \n           }  \n       }  \n       \n       private static void showMutexDemo()  \n       {  \n           // Wait until it is safe to enter.  \n           mutex.WaitOne();\n           \n           Console.WriteLine(\"{0} has got the access of resource\",  \n           Thread.CurrentThread.Name);  \n           \n           // Code to access the resource mutually exclusively  \n           \n           // Wait until it is safe to enter.  \n           Thread.Sleep(100);\n           Console.WriteLine(\"{0}'s access of the resource has been revoked\",            \n           Thread.CurrentThread.Name);  \n           // Once the work is done, release the resource from Mutex\n           mutex.ReleaseMutex();\n       }  \n       \n       // Driver code\n       static void Main(string[] args)  \n       {  \n           for (int i = 0; i < countOfThreads; i++)  \n           {  \n               Thread thread = new Thread(new ThreadStart(ThreadProcess));  \n               thread.Name = String.Format(\"Thread{0}\", i + 1);  \n               thread.Start();  \n           }  \n       }  \n   }  \n} using System;  \nusing System.Collections;  \nusing System.Threading;\nnamespace MutexDemo\n{  \nclass MutexDemoClass  \n   {  \n       private static Mutex mutex = new Mutex();  \n       private const int countOfHits = 1;  \n       private const int countOfThreads = 3;  \n       private static void ThreadProcess()  \n       {  \n           for (int i = 0; i < countOfHits; i++)  \n           {  \n               showMutexDemo();  \n           }  \n       }  \n       \n       private static void showMutexDemo()  \n       {  \n           // Wait until it is safe to enter.  \n           mutex.WaitOne();\n           \n           Console.WriteLine(\"{0} has got the access of resource\",  \n           Thread.CurrentThread.Name);  \n           \n           // Code to access the resource mutually exclusively  \n           \n           // Wait until it is safe to enter.  \n           Thread.Sleep(100);\n           Console.WriteLine(\"{0}'s access of the resource has been revoked\",            \n           Thread.CurrentThread.Name);  \n           // Once the work is done, release the resource from Mutex\n           mutex.ReleaseMutex();\n       }  \n       \n       // Driver code\n       static void Main(string[] args)  \n       {  \n           for (int i = 0; i < countOfThreads; i++)  \n           {  \n               Thread thread = new Thread(new ThreadStart(ThreadProcess));  \n               thread.Name = String.Format(\"Thread{0}\", i + 1);  \n               thread.Start();  \n           }  \n       }  \n   }  \n} using using using namespace MutexDemo class MutexDemoClass private static new private const int 1 private const int 3 private static void ThreadProcess() private static void ThreadProcess  for int 0 private static void showMutexDemo() private static void showMutexDemo  // Wait until it is safe to enter. \"{0} has got the access of resource\" // Code to access the resource mutually exclusively // Wait until it is safe to enter. 100 \"{0}'s access of the resource has been revoked\" // Once the work is done, release the resource from Mutex // Driver code static void Main(string[] args) static void Main string[] args string for int 0 new new \"Thread{0}\" 1 The above code is a simple example to show how Mutex locks a resource and only that thread can release the Mutex. Thread1 has got the access of resource\nThread1's access of the resource has been revoked\nThread2 has got the access of resource\nThread2's access of the resource has been revoked\nThread2 has got the access of resource\nThread3's access of the resource has been revoked Thread1 has got the access of resource\nThread1's access of the resource has been revoked\nThread2 has got the access of resource\nThread2's access of the resource has been revoked\nThread2 has got the access of resource\nThread3's access of the resource has been revoked 's access of the resource has been revoked\nThread2 has got the access of resource\nThread2' 's access of the resource has been revoked",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "6. What is Mutex and how is it different from other Synchronization mechanisms?",
        "answer": "MuTex refers to Mutual Exclusion and as the name suggests, Mutex works on the mutual exclusion principle to lock out any other thread requesting for a resource whose access is already given to some thread. Mutex acts as a flag mechanism that prevents any second thread from accessing a resource, except for the thread which is currently working on it. Unlike other synchronization mechanisms in C#, such as Auto Reset Event which can give the exclusive access of a resource to any thread that calls the set() method, Mutex remembers the thread that gets the resource access, and only that same thread can reset it, thereby giving the true mutual exclusion synchronization. If the thread differs, a mutex exception is thrown.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "7. What is AutoResetEvent and how is it different from ManualResetEvent?",
        "answer": "AutoResetEvent is used to unlock a single thread when multiple threads are in a waiting blocked state, whereas ManualResetEvent is used to unlock multiple threads at once during similar instances. AutoResetEvent also calls the Reset() method by itself to unblock the thread under consideration, whereas while using ManualResetEvent, the Reset() method has to be called manually after the use of set() method.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "8. What are Interlocked functions?",
        "answer": "Shared variables in C# are not thread-safe. It means that any operation on a variable can be corrupted due to multiple threads. To prevent these dirty reads, C# allows the use of interlocked functions to change the value of shared variables in multithreading code. Interlocked functions only support int, long, double and float data types, as shown by some of the examples below: double and float 1) Add(ref int address1, int value): Interlocked function to add a value into an int variable safely. 1) Add(ref int address1, int value): 2) Increment(ref int address1): Interlocked function to increment value of an int variable safely by 1. 2) Increment(ref int address1): 3) Decrement(ref int address1): Interlocked function to decrement value of an int variable safely by 1. 3) Decrement(ref int address1): 4) Exchange(ref int address1, int value): Interlocked function to replace the value of an int variable safely. 4) Exchange(ref int address1, int value): 5) CompareExchange(ref int address1, int newValue, int toBeValue): Interlocked function to replace the value of an int variable safely only if the existing value is equal to passed toBeValue. 5) CompareExchange(ref int address1, int newValue, int toBeValue):",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "9. What is enum in C#?",
        "answer": "Enum is a primitive data type in C# used to define numeric constants in the .NET framework. Starting from 0, all the elements of the enum are given constant values, each increasing by 1. For example, if we declare an enum for days of the week, the first element (Sunday) will get the value 0, the next element (Monday) will get the value 1, and so on till Saturday, which will get the value 6. enum daysOfWeek { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday }; enum daysOfWeek { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday }; enum To access any element, all you need to do is just pass the value of the element alongside enum’s variable, such as: daysOfWeek[5]; // Will give the value Friday daysOfWeek[5]; // Will give the value Friday 5 // Will give the value Friday",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "10. What is the difference between dispose() and finalize() methods in C#?",
        "answer": "Both dispose() and finalize() methods are used for unallocating and freeing up resources but: dispose() method is called explicitly by the user, whereas finalize() method is called the system’s garbage collector at the end of execution.\ndispose() method is defined in the IDisposable interface, whereas the finalize() method is defined in the Object class.\ndispose() method is a part of the developer’s code, whereas finalize() method is a system-defined default method and not a part of the developer’s code. dispose() method is called explicitly by the user, whereas finalize() method is called the system’s garbage collector at the end of execution. dispose() method is defined in the IDisposable interface, whereas the finalize() method is defined in the Object class. dispose() method is a part of the developer’s code, whereas finalize() method is a system-defined default method and not a part of the developer’s code. BASIS FOR COMPARISON DISPOSE( ) FINALIZE( )\nDefinition dispose() method is defined in IDisposable interface. finalize() method is defined in java.lang.object class.\nSyntax\npublic void dispose( ){\n// Dispose code here\n} \nprotected void finalize( ){\n// finalization code here\n}\nInvoked dispose() method is invoked by the user. finalize() method is invoked by the garbage collector.\nPurpose dispose() method is used to free unmanaged resources upon invoking. finalize() method is used to free the unmanaged resources when invoked by the garbage collector.\nImplementation dispose() method is implemented whenever there is a close( ) method. Unlike dispose(), the finalize() method is implemented for freeing up unmanaged resources.\nAccess Specifier dispose() method is declared as public. finalize() method is declared as private.\nPerformance dispose() method happens instantly and hence is faster. finalize() method is slower in comparison with dispose() method and can affect the performance. BASIS FOR COMPARISON DISPOSE( ) FINALIZE( )\nDefinition dispose() method is defined in IDisposable interface. finalize() method is defined in java.lang.object class.\nSyntax\npublic void dispose( ){\n// Dispose code here\n} \nprotected void finalize( ){\n// finalization code here\n}\nInvoked dispose() method is invoked by the user. finalize() method is invoked by the garbage collector.\nPurpose dispose() method is used to free unmanaged resources upon invoking. finalize() method is used to free the unmanaged resources when invoked by the garbage collector.\nImplementation dispose() method is implemented whenever there is a close( ) method. Unlike dispose(), the finalize() method is implemented for freeing up unmanaged resources.\nAccess Specifier dispose() method is declared as public. finalize() method is declared as private.\nPerformance dispose() method happens instantly and hence is faster. finalize() method is slower in comparison with dispose() method and can affect the performance. BASIS FOR COMPARISON DISPOSE( ) FINALIZE( ) BASIS FOR COMPARISON DISPOSE( ) FINALIZE( ) BASIS FOR COMPARISON DISPOSE( ) FINALIZE( ) Definition dispose() method is defined in IDisposable interface. finalize() method is defined in java.lang.object class.\nSyntax\npublic void dispose( ){\n// Dispose code here\n} \nprotected void finalize( ){\n// finalization code here\n}\nInvoked dispose() method is invoked by the user. finalize() method is invoked by the garbage collector.\nPurpose dispose() method is used to free unmanaged resources upon invoking. finalize() method is used to free the unmanaged resources when invoked by the garbage collector.\nImplementation dispose() method is implemented whenever there is a close( ) method. Unlike dispose(), the finalize() method is implemented for freeing up unmanaged resources.\nAccess Specifier dispose() method is declared as public. finalize() method is declared as private.\nPerformance dispose() method happens instantly and hence is faster. finalize() method is slower in comparison with dispose() method and can affect the performance. Definition dispose() method is defined in IDisposable interface. finalize() method is defined in java.lang.object class. Definition dispose() method is defined in IDisposable interface. finalize() method is defined in java.lang.object class. Syntax\npublic void dispose( ){\n// Dispose code here\n} \nprotected void finalize( ){\n// finalization code here\n} Syntax public void dispose( ){\n// Dispose code here\n} public void dispose( ){\n// Dispose code here\n} public void dispose( ){\n// Dispose code here\n} public void dispose( ) public void dispose  // Dispose code here protected void finalize( ){\n// finalization code here\n} protected void finalize( ){\n// finalization code here\n} protected void finalize( ){\n// finalization code here\n} protected void finalize( ) protected void finalize  // finalization code here Invoked dispose() method is invoked by the user. finalize() method is invoked by the garbage collector. Invoked dispose() method is invoked by the user. finalize() method is invoked by the garbage collector. Purpose dispose() method is used to free unmanaged resources upon invoking. finalize() method is used to free the unmanaged resources when invoked by the garbage collector. Purpose dispose() method is used to free unmanaged resources upon invoking. finalize() method is used to free the unmanaged resources when invoked by the garbage collector. Implementation dispose() method is implemented whenever there is a close( ) method. Unlike dispose(), the finalize() method is implemented for freeing up unmanaged resources. Implementation dispose() method is implemented whenever there is a close( ) method. Unlike dispose(), the finalize() method is implemented for freeing up unmanaged resources. Access Specifier dispose() method is declared as public. finalize() method is declared as private. Access Specifier dispose() method is declared as public. finalize() method is declared as private. Performance dispose() method happens instantly and hence is faster. finalize() method is slower in comparison with dispose() method and can affect the performance. Performance dispose() method happens instantly and hence is faster. finalize() method is slower in comparison with dispose() method and can affect the performance.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "11. What is the difference between a struct and a class in C#?",
        "answer": "Struct Class\nStructs are value-type entities stored in stack memory. Class is a reference type entity stored in heap memory.\nAllocation and de-allocation of Structs are cheaper when the size of the Structure is small. Allocation and de-allocation of Classes are costlier when the size of the class is small.\nAllocation and de-allocation of Structs are costlier as compared to classes when the size of a struct is large. Allocation and de-allocation of Classes are cheaper as compared to Structs when the size of the class is large.\nStructs can contain limited kind of entities like variables, structs, etc, and hence is used to create smaller codes. Classes can contain all kind of entities like variables, functions, constructors, structs, etc, and hence is used to create large codes efficiently.\nStructures are not allowed to contain parameterless constructors or destructors, but only parameterized constructors and static constructors. Classes can contain any kind of constructors or destructors.\nAn instance of a struct can be created by using the new keyword, as well as without using a new keyword. To create an instance of a class, a new keyword is used.\nA Struct cannot implement Inheritance and hence cannot inherit another struct or class. A Class can implement Inheritance and can inherit from another class.\nThe attributes of a struct cannot be specified as protected. The attributes of a class can be specified as protected.\nA struct can neither have a virtual method nor an abstract method. A class can have virtual methods as well as abstract methods. Struct Class\nStructs are value-type entities stored in stack memory. Class is a reference type entity stored in heap memory.\nAllocation and de-allocation of Structs are cheaper when the size of the Structure is small. Allocation and de-allocation of Classes are costlier when the size of the class is small.\nAllocation and de-allocation of Structs are costlier as compared to classes when the size of a struct is large. Allocation and de-allocation of Classes are cheaper as compared to Structs when the size of the class is large.\nStructs can contain limited kind of entities like variables, structs, etc, and hence is used to create smaller codes. Classes can contain all kind of entities like variables, functions, constructors, structs, etc, and hence is used to create large codes efficiently.\nStructures are not allowed to contain parameterless constructors or destructors, but only parameterized constructors and static constructors. Classes can contain any kind of constructors or destructors.\nAn instance of a struct can be created by using the new keyword, as well as without using a new keyword. To create an instance of a class, a new keyword is used.\nA Struct cannot implement Inheritance and hence cannot inherit another struct or class. A Class can implement Inheritance and can inherit from another class.\nThe attributes of a struct cannot be specified as protected. The attributes of a class can be specified as protected.\nA struct can neither have a virtual method nor an abstract method. A class can have virtual methods as well as abstract methods. Struct Class Struct Class Struct Class Structs are value-type entities stored in stack memory. Class is a reference type entity stored in heap memory.\nAllocation and de-allocation of Structs are cheaper when the size of the Structure is small. Allocation and de-allocation of Classes are costlier when the size of the class is small.\nAllocation and de-allocation of Structs are costlier as compared to classes when the size of a struct is large. Allocation and de-allocation of Classes are cheaper as compared to Structs when the size of the class is large.\nStructs can contain limited kind of entities like variables, structs, etc, and hence is used to create smaller codes. Classes can contain all kind of entities like variables, functions, constructors, structs, etc, and hence is used to create large codes efficiently.\nStructures are not allowed to contain parameterless constructors or destructors, but only parameterized constructors and static constructors. Classes can contain any kind of constructors or destructors.\nAn instance of a struct can be created by using the new keyword, as well as without using a new keyword. To create an instance of a class, a new keyword is used.\nA Struct cannot implement Inheritance and hence cannot inherit another struct or class. A Class can implement Inheritance and can inherit from another class.\nThe attributes of a struct cannot be specified as protected. The attributes of a class can be specified as protected.\nA struct can neither have a virtual method nor an abstract method. A class can have virtual methods as well as abstract methods. Structs are value-type entities stored in stack memory. Class is a reference type entity stored in heap memory. Structs are value-type entities stored in stack memory. Class is a reference type entity stored in heap memory. Allocation and de-allocation of Structs are cheaper when the size of the Structure is small. Allocation and de-allocation of Classes are costlier when the size of the class is small. Allocation and de-allocation of Structs are cheaper when the size of the Structure is small. Allocation and de-allocation of Classes are costlier when the size of the class is small. Allocation and de-allocation of Structs are costlier as compared to classes when the size of a struct is large. Allocation and de-allocation of Classes are cheaper as compared to Structs when the size of the class is large. Allocation and de-allocation of Structs are costlier as compared to classes when the size of a struct is large. Allocation and de-allocation of Classes are cheaper as compared to Structs when the size of the class is large. Structs can contain limited kind of entities like variables, structs, etc, and hence is used to create smaller codes. Classes can contain all kind of entities like variables, functions, constructors, structs, etc, and hence is used to create large codes efficiently. Structs can contain limited kind of entities like variables, structs, etc, and hence is used to create smaller codes. Classes can contain all kind of entities like variables, functions, constructors, structs, etc, and hence is used to create large codes efficiently. Structures are not allowed to contain parameterless constructors or destructors, but only parameterized constructors and static constructors. Classes can contain any kind of constructors or destructors. Structures are not allowed to contain parameterless constructors or destructors, but only parameterized constructors and static constructors. Classes can contain any kind of constructors or destructors. An instance of a struct can be created by using the new keyword, as well as without using a new keyword. To create an instance of a class, a new keyword is used. An instance of a struct can be created by using the new keyword, as well as without using a new keyword. To create an instance of a class, a new keyword is used. A Struct cannot implement Inheritance and hence cannot inherit another struct or class. A Class can implement Inheritance and can inherit from another class. A Struct cannot implement Inheritance and hence cannot inherit another struct or class. A Class can implement Inheritance and can inherit from another class. The attributes of a struct cannot be specified as protected. The attributes of a class can be specified as protected. The attributes of a struct cannot be specified as protected. The attributes of a class can be specified as protected. A struct can neither have a virtual method nor an abstract method. A class can have virtual methods as well as abstract methods. A struct can neither have a virtual method nor an abstract method. A class can have virtual methods as well as abstract methods.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "12. How to declare a property in a class in C#?",
        "answer": "class ABC\n{\n// Declare the attribute\nprivate int id;\n// Declare id’s property\npublic int ID\n{\n// read-only getter property\nget      { return id; }\nset      { id = value; }\n}\n} class ABC\n{\n// Declare the attribute\nprivate int id;\n// Declare id’s property\npublic int ID\n{\n// read-only getter property\nget      { return id; }\nset      { id = value; }\n}\n} class ABC // Declare the attribute private int // Declare id’s property public int // read-only getter property get return set value",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "13. How do you give a C# Autoproperty a default value?",
        "answer": "For C# 5: For C# 5: class Car()\n{\npublic Car()\n{\nCarName=\"default car name\";\n}\npublic string CarName{get;set;}\n} class Car()\n{\npublic Car()\n{\nCarName=\"default car name\";\n}\npublic string CarName{get;set;}\n} class Car public Car() public Car  \"default car name\" public string get set For C# 6.0: For C# 6.0: public string CarName {get;set}=\"default car name\"; public string CarName {get;set}=\"default car name\"; public string get set \"default car name\"",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "14. How to specify what version of the framework your application is targeting?",
        "answer": "In the configuration file, just use the targetFramework attribute to specify the version of ASP.NET that your application is targeting. targetFramework Below is the syntax used: <?xml version=”1.0”?>\n<configuration>\n<system.web>\n<compilation targetFramework=4.0>\n</configuration> <?xml version=”1.0”?>\n<configuration>\n<system.web>\n<compilation targetFramework=4.0>\n</configuration> 1.0 4.0",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "15. What is Framework targeting in C# and what is the use of it?",
        "answer": "Framework targeting in C# is used to mention the version of the .NET framework that the project is intended to run upon. Framework targeting helps guarantee that the application uses only functionality that is available in the specified framework version.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "16. State the uses of Reflection in C#",
        "answer": "Reflection is the process of describing the metadata of types, methods, and fields in a code. Some of the major use of Reflection in C#: Load assemblies at the given runtime\nHelp to learn about the definition of entities like class, or enumeration by groups\nGet to know about fields, properties, constructors, events, and methods in a Class\nHelps to learn about the properties of entities such as their types, read-only status, etc.\nHelps in getting and setting a property’s value\nHelps to learn about an entity’s attributes. Load assemblies at the given runtime Help to learn about the definition of entities like class, or enumeration by groups Get to know about fields, properties, constructors, events, and methods in a Class Helps to learn about the properties of entities such as their types, read-only status, etc. Helps in getting and setting a property’s value Helps to learn about an entity’s attributes.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "17. What is C#?",
        "answer": "C# is a simple, modern, general-purpose, object-oriented programming language developed by Microsoft. It is type-safe and managed language that is compiled by the Roslyn .NET compiler to generate Microsoft intermediate language (machine code). C# C#",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "18. What can be the output of the following program?",
        "answer": "public class Program\n{\n    public static void Main(string[] args)\n    {\n                   var values = new List<int>() { 1, 2, 3, 4 };\n                   var funcs = new List<Func<int>>();\n                   foreach(var v in values)\n                       funcs.Add( ()=>v );\n                   foreach(var f in funcs)\n                       Console.WriteLine(f());\n    }\n} public class Program\n{\n    public static void Main(string[] args)\n    {\n                   var values = new List<int>() { 1, 2, 3, 4 };\n                   var funcs = new List<Func<int>>();\n                   foreach(var v in values)\n                       funcs.Add( ()=>v );\n                   foreach(var f in funcs)\n                       Console.WriteLine(f());\n    }\n} public class Program public static void Main(string[] args) public static void Main string[] args string var new int 1 2 3 4 var new int foreach var in foreach var in The output will be: The output will be: 4\n4\n4\n4 4\n4\n4\n4 4 4 4 4 Explanation: Explanation: The correct value of the above code will be “4 4 4 4” and not “1 2 3 4”. Let us see why. We are creating a delegate of functions using statement foreach(var v in values)\nfuncs.Add( ()=>v ); foreach(var v in values)\nfuncs.Add( ()=>v ); foreach var in So the loop will traverse for all values as v, i.e. 1, 2, 3, till 4. Now when ()=>v is used, it means to return the latest value of variable v, and not the value when delegate was created. Therefore when the methods run, the last value assigned to v was 4, so the methods will be called using value 4 each time, and hence the output will be “4\n4\n4\n4”   ",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "19. What are Access Modifiers in C# And Why are they important?",
        "answer": "As the name suggests, access modifiers are keywords that define the scope of entities in a C# code, as to which point an entity can be accessed from its point of creation. In particular, there are 4 access modifiers in C#: public, protected, internal, and private.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "20. How will you implement Encapsulation?",
        "answer": "Encapsulation is done with the help of access modifiers in C#: public, private, protected, and default. Scope of an element with the access specifier / Access specifiers public protected internal protected internal private private protected\nEntire program Yes No No No No No\nContaining class Yes Yes Yes Yes Yes Yes\nCurrent assembly Yes No Yes Yes No No\nDerived types Yes Yes No Yes No No\nDerived types within the current assembly Yes Yes Yes Yes No Yes Scope of an element with the access specifier / Access specifiers public protected internal protected internal private private protected\nEntire program Yes No No No No No\nContaining class Yes Yes Yes Yes Yes Yes\nCurrent assembly Yes No Yes Yes No No\nDerived types Yes Yes No Yes No No\nDerived types within the current assembly Yes Yes Yes Yes No Yes Scope of an element with the access specifier / Access specifiers public protected internal protected internal private private protected Scope of an element with the access specifier / Access specifiers public protected internal protected internal private private protected Scope of an element with the access specifier / Access specifiers public protected internal protected internal private private protected Entire program Yes No No No No No\nContaining class Yes Yes Yes Yes Yes Yes\nCurrent assembly Yes No Yes Yes No No\nDerived types Yes Yes No Yes No No\nDerived types within the current assembly Yes Yes Yes Yes No Yes Entire program Yes No No No No No Entire program Yes No No No No No Containing class Yes Yes Yes Yes Yes Yes Containing class Yes Yes Yes Yes Yes Yes Current assembly Yes No Yes Yes No No Current assembly Yes No Yes Yes No No Derived types Yes Yes No Yes No No Derived types Yes Yes No Yes No No Derived types within the current assembly Yes Yes Yes Yes No Yes Derived types within the current assembly Yes Yes Yes Yes No Yes",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "21. What is the need for Encapsulation?",
        "answer": "Encapsulation is the process of binding an entity with its implementation with the aim of data hiding. It is done to hide the irrelevant details from a user, and show only the process which the user needs. By doing so, we hide the implementation details of entities and thereby help users to understand the higher-level design of the code easily, without getting bothered about the implementation details. Encapsulation has some hidden advantages as well which make it the need of the hour for every software developer such as preventing accidental corruption, unauthorized access to entities, etc. software developer",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "22. Why are strings in c# immutable?",
        "answer": "In C# Arrays have a fixed size, which means that once an array is created of some size, it cannot be dynamically increased or decreased in size. The CLR (Common Language Runtime) in C#, stores the strings as an array of characters. So whenever we delete or add a character or characters to a string, the original arrays of characters are fixed, and hence a new array of characters is created to accommodate the change. This is known as the immutability of strings in C#.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "23. What is the difference between ref and out keywords?",
        "answer": "ref keyword is used to pass an already initialized variable to a method as a reference type, facilitating bi-directional data passing. ref keyword is used to pass an already initialized variable to a method as a reference type, facilitating bi-directional data passing. ref Example 1: // C# program to illustrate the concept of out parameter\nusing System;\nclass GFG {\n// Main method\nstatic public void Main()\n{\n       // Lets declare a string\n       string str3 = \"Scaler\";\n // Pass variable str3 to the method using ref keyword\n initializeString(ref str3);\n // Display the value str3 now\n // Since initially we declared value \"Scaler\" in str3,\n // normally below statement must print \"Hello Scaler\"\n // But due to the use of ref keyword,\n // the value will be overwritten in the initializeString() Method\n // So now the value printed will be \"Hello InterviewBit\" instead\n Console.WriteLine(\"Hello {0}\", str3);\n}\n \n \n// Method in which ref parameter is passed and a value is written into this variable\npublic static void initializeString(ref string str1)\n{\n    \n    // Since ref keyword supports bi-directional data flow,\n       // This check statement will be validated and output will be printed\n       if (str1 == \"Scaler\") {\n           Console.WriteLine(\"Hello Scaler\");\n       }\n       \n       // Now lets try to change the value of ref parameter str1\n       // The value \"InterviewBit\" will be overwritten in reference variable str3 \n       str1 = \"InterviewBit\";\n \n}\n} // C# program to illustrate the concept of out parameter\nusing System;\nclass GFG {\n// Main method\nstatic public void Main()\n{\n       // Lets declare a string\n       string str3 = \"Scaler\";\n // Pass variable str3 to the method using ref keyword\n initializeString(ref str3);\n // Display the value str3 now\n // Since initially we declared value \"Scaler\" in str3,\n // normally below statement must print \"Hello Scaler\"\n // But due to the use of ref keyword,\n // the value will be overwritten in the initializeString() Method\n // So now the value printed will be \"Hello InterviewBit\" instead\n Console.WriteLine(\"Hello {0}\", str3);\n}\n \n \n// Method in which ref parameter is passed and a value is written into this variable\npublic static void initializeString(ref string str1)\n{\n    \n    // Since ref keyword supports bi-directional data flow,\n       // This check statement will be validated and output will be printed\n       if (str1 == \"Scaler\") {\n           Console.WriteLine(\"Hello Scaler\");\n       }\n       \n       // Now lets try to change the value of ref parameter str1\n       // The value \"InterviewBit\" will be overwritten in reference variable str3 \n       str1 = \"InterviewBit\";\n \n}\n} // C# program to illustrate the concept of out parameter using class GFG // Main method static public void Main() static public void Main  // Lets declare a string string \"Scaler\" // Pass variable str3 to the method using ref keyword ref // Display the value str3 now // Since initially we declared value \"Scaler\" in str3, // normally below statement must print \"Hello Scaler\" // But due to the use of ref keyword, // the value will be overwritten in the initializeString() Method // So now the value printed will be \"Hello InterviewBit\" instead \"Hello {0}\" // Method in which ref parameter is passed and a value is written into this variable public static void initializeString(ref string str1) public static void initializeString ref string str1 ref string // Since ref keyword supports bi-directional data flow, // This check statement will be validated and output will be printed if \"Scaler\" \"Hello Scaler\" // Now lets try to change the value of ref parameter str1 // The value \"InterviewBit\" will be overwritten in reference variable str3 \"InterviewBit\" The above program will generate the below output: Hello Scaler\nHello InterviewBit Hello Scaler\nHello InterviewBit Whereas out keyword is used to pass a variable as an empty container that can store multiple values to a method as a reference type. out keyword allows uni-directional data passing, as the container passed using out keyword doesn’t need to be initialized beforehand. Whereas out keyword is used to pass a variable as an empty container that can store multiple values to a method as a reference type. out keyword allows uni-directional data passing, as the container passed using out keyword doesn’t need to be initialized beforehand. out Example 2: Let’s see if and how the data flows when out keyword is used: // C# program to illustrate the concept of out parameter\nusing System;\nclass GFG {\n// Main method\nstatic public void Main()\n{\n     // Declaring a string variable\n    // Since we are going to use out parameter\n   // We do not need to assign any value to it\n\nstring str1;\n  // Pass variable str1 to the method using out keyword\n  // Normally it should pass the default value, but due to use of out keyword\n  // An empty container will be passed instead, leading to error\n\n  checkIfScaler(out str1);\n       // Lets try again with another value\n     \n         string str2 = \"Scaler\";\n // Pass variable str2 to the method using out keyword\n // Now you must think that the value \"Scaler\" will be passed\n // But due to use of out keyword,\n // again an empty container will be passed instead, leading to error\n\n checkIfScaler(out str2);\n}\n \n   // Method in which out parameter is passed and checked\n   // if the current string value is Scaler or not\n\npublic static void checkIfScaler(out string str1)\n{\n       \n       // Check parameter value\n       // Since we are using out parameter, this will lead to error\n       // as no data is passed when into this method when out keyword is used\n       // This is because out keyword onlu facilitates uni-direction data transfer\n      \n        if (str1 == \"Scaler\") {\n           Console.WriteLine(\"Hello!!Scaler\");\n       }\n \n}\n\n} // C# program to illustrate the concept of out parameter\nusing System;\nclass GFG {\n// Main method\nstatic public void Main()\n{\n     // Declaring a string variable\n    // Since we are going to use out parameter\n   // We do not need to assign any value to it\n\nstring str1;\n  // Pass variable str1 to the method using out keyword\n  // Normally it should pass the default value, but due to use of out keyword\n  // An empty container will be passed instead, leading to error\n\n  checkIfScaler(out str1);\n       // Lets try again with another value\n     \n         string str2 = \"Scaler\";\n // Pass variable str2 to the method using out keyword\n // Now you must think that the value \"Scaler\" will be passed\n // But due to use of out keyword,\n // again an empty container will be passed instead, leading to error\n\n checkIfScaler(out str2);\n}\n \n   // Method in which out parameter is passed and checked\n   // if the current string value is Scaler or not\n\npublic static void checkIfScaler(out string str1)\n{\n       \n       // Check parameter value\n       // Since we are using out parameter, this will lead to error\n       // as no data is passed when into this method when out keyword is used\n       // This is because out keyword onlu facilitates uni-direction data transfer\n      \n        if (str1 == \"Scaler\") {\n           Console.WriteLine(\"Hello!!Scaler\");\n       }\n \n}\n\n} // C# program to illustrate the concept of out parameter using class GFG // Main method static public void Main() static public void Main  // Declaring a string variable // Since we are going to use out parameter // We do not need to assign any value to it string // Pass variable str1 to the method using out keyword // Normally it should pass the default value, but due to use of out keyword // An empty container will be passed instead, leading to error out // Lets try again with another value string \"Scaler\" // Pass variable str2 to the method using out keyword // Now you must think that the value \"Scaler\" will be passed // But due to use of out keyword, // again an empty container will be passed instead, leading to error out // Method in which out parameter is passed and checked // if the current string value is Scaler or not public static void checkIfScaler(out string str1) public static void checkIfScaler out string str1 out string // Check parameter value // Since we are using out parameter, this will lead to error // as no data is passed when into this method when out keyword is used // This is because out keyword onlu facilitates uni-direction data transfer if \"Scaler\" \"Hello!!Scaler\" The above program will generate the below error: prog.cs(39,13): error CS0269: Use of unassigned out parameter `str1' prog.cs(39,13): error CS0269: Use of unassigned out parameter `str1' 39 13 out ' Example 3: Now let us try to see what happens when we initialize some value to an out parameter. // C# program to illustrate the concept of out parameter\nusing System;\nclass GFG {\n// Main method\nstatic public void Main()\n{\n       // Lets declare a string\n       string str3 = \"Scaler\";\n // Pass variable str3 to the method using out keyword\n // Now you must think that the value \"Scaler\" will be passed\n // But due to use of out keyword,\n // again an empty container will be passed instead\n initializeString(out str3);\n // Display the value str1 now\n // Since initially we declared value \"Scaler\" in str3,\n // normally below statement must print \"Hello Scaler\"\n // But due to the use of out keyword,\n // the value will be overwritten in the initializeString() Method\n // So now the value printed will be \"Hello InterviewBit\" instead\n Console.WriteLine(\"Hello {0}\", str3);\n}\n \n \n// Method in which out parameter is passed and a value is written into this variable\npublic static void initializeString(out string str1)\n{\n    \n    // Since out keyword supports uni-directional data flow,\n    // the value \"InterviewBit\" will be written in reference variable str3 \n       \n       str1 = \"InterviewBit\";\n       \n       // Check parameter value\n       if (str1 == \"InterviewBit\") {\n           Console.WriteLine(\"InterviewBit value assigned successfully\");\n       }\n \n}\n} // C# program to illustrate the concept of out parameter\nusing System;\nclass GFG {\n// Main method\nstatic public void Main()\n{\n       // Lets declare a string\n       string str3 = \"Scaler\";\n // Pass variable str3 to the method using out keyword\n // Now you must think that the value \"Scaler\" will be passed\n // But due to use of out keyword,\n // again an empty container will be passed instead\n initializeString(out str3);\n // Display the value str1 now\n // Since initially we declared value \"Scaler\" in str3,\n // normally below statement must print \"Hello Scaler\"\n // But due to the use of out keyword,\n // the value will be overwritten in the initializeString() Method\n // So now the value printed will be \"Hello InterviewBit\" instead\n Console.WriteLine(\"Hello {0}\", str3);\n}\n \n \n// Method in which out parameter is passed and a value is written into this variable\npublic static void initializeString(out string str1)\n{\n    \n    // Since out keyword supports uni-directional data flow,\n    // the value \"InterviewBit\" will be written in reference variable str3 \n       \n       str1 = \"InterviewBit\";\n       \n       // Check parameter value\n       if (str1 == \"InterviewBit\") {\n           Console.WriteLine(\"InterviewBit value assigned successfully\");\n       }\n \n}\n} // C# program to illustrate the concept of out parameter using class GFG // Main method static public void Main() static public void Main  // Lets declare a string string \"Scaler\" // Pass variable str3 to the method using out keyword // Now you must think that the value \"Scaler\" will be passed // But due to use of out keyword, // again an empty container will be passed instead out // Display the value str1 now // Since initially we declared value \"Scaler\" in str3, // normally below statement must print \"Hello Scaler\" // But due to the use of out keyword, // the value will be overwritten in the initializeString() Method // So now the value printed will be \"Hello InterviewBit\" instead \"Hello {0}\" // Method in which out parameter is passed and a value is written into this variable public static void initializeString(out string str1) public static void initializeString out string str1 out string // Since out keyword supports uni-directional data flow, // the value \"InterviewBit\" will be written in reference variable str3 \"InterviewBit\" // Check parameter value if \"InterviewBit\" \"InterviewBit value assigned successfully\" The above program will generate the below output: InterviewBit value assigned successfully\nHello InterviewBit InterviewBit value assigned successfully\nHello InterviewBit value",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "24. Give examples of I/O classes?",
        "answer": "Some of the important input-output classes are: I/O Class Description\nFileStream For input-output in a file.\nBinaryReader For reading data from a binary stream.\nBinaryWriter For writing data in binary format.\nFile For manipulating files.\nStreamReader For reading characters from a stream.\nStreamWriter For writing characters into a stream.\nStringReader For reading characters from a string buffer.\nStringWriter For writing characters into a string buffer.\nDirectory For manipulating a directory structure.\nDirectoryInfo For performing operations on directories. I/O Class Description\nFileStream For input-output in a file.\nBinaryReader For reading data from a binary stream.\nBinaryWriter For writing data in binary format.\nFile For manipulating files.\nStreamReader For reading characters from a stream.\nStreamWriter For writing characters into a stream.\nStringReader For reading characters from a string buffer.\nStringWriter For writing characters into a string buffer.\nDirectory For manipulating a directory structure.\nDirectoryInfo For performing operations on directories. I/O Class Description I/O Class Description I/O Class Description FileStream For input-output in a file.\nBinaryReader For reading data from a binary stream.\nBinaryWriter For writing data in binary format.\nFile For manipulating files.\nStreamReader For reading characters from a stream.\nStreamWriter For writing characters into a stream.\nStringReader For reading characters from a string buffer.\nStringWriter For writing characters into a string buffer.\nDirectory For manipulating a directory structure.\nDirectoryInfo For performing operations on directories. FileStream For input-output in a file. FileStream For input-output in a file. BinaryReader For reading data from a binary stream. BinaryReader For reading data from a binary stream. BinaryWriter For writing data in binary format. BinaryWriter For writing data in binary format. File For manipulating files. File For manipulating files. StreamReader For reading characters from a stream. StreamReader For reading characters from a stream. StreamWriter For writing characters into a stream. StreamWriter For writing characters into a stream. StringReader For reading characters from a string buffer. StringReader For reading characters from a string buffer. StringWriter For writing characters into a string buffer. StringWriter For writing characters into a string buffer. Directory For manipulating a directory structure. Directory For manipulating a directory structure. DirectoryInfo For performing operations on directories. DirectoryInfo For performing operations on directories.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "25. How to declare a private constructor in C#?",
        "answer": "In C#, if you don’t specify any access specifier against a constructor, that constructor is by default specified as a public constructor by the compiler. If you want to create a Private constructor explicitly, it can be declared in C# with the help of a private keyword placed before the constructor name in its signature, as shown below: private constructor_name\n{\n  // Code\n} private constructor_name\n{\n  // Code\n} private // Code However, to create an instance of a class with a private constructor is a tricky thing. To do so, the Singleton class is used. Singleton class is a class that has only one instance. Below is the example to create an instance of a class with a private constructor, with the help of the Singleton class. using System;\npublic class SingletonDemo  \n{  \n   private static string CreatedOn;  \n   private static SingletonDemo instance = null;  \n \n   private SingletonDemo()  \n   {  \n       CreatedOn = DateTime.Now.ToLongTimeString();  \n   }  \n \n   public static SingletonDemo getInstance()  \n   {  \n       if (instance == null)  \n       {  \n           instance = new SingletonDemo();  \n       }  \n       Console.WriteLine(CreatedOn);  \n       return instance;  \n   }  \n} using System;\npublic class SingletonDemo  \n{  \n   private static string CreatedOn;  \n   private static SingletonDemo instance = null;  \n \n   private SingletonDemo()  \n   {  \n       CreatedOn = DateTime.Now.ToLongTimeString();  \n   }  \n \n   public static SingletonDemo getInstance()  \n   {  \n       if (instance == null)  \n       {  \n           instance = new SingletonDemo();  \n       }  \n       Console.WriteLine(CreatedOn);  \n       return instance;  \n   }  \n} using public class SingletonDemo private static string private static null private SingletonDemo() private SingletonDemo  public static SingletonDemo getInstance() public static getInstance  if null new return",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "26. What is a namespace?",
        "answer": "Namespace in C# can be considered as a container in which you can define classes, methods, interfaces, structures, or other child namespaces, such that classes with the same name but different namespaces won’t cause any error. In C#, namespaces are an efficient entity to organize codes for larger applications. The major advantages of Namespace are: Namespaces help in effectively organizing large C# code projects.\nTo use any entity in a namespace, simply use <namespace name>.<entity name>\nNo two classes with the same name in a different namespace will cause any error. Namespaces help in effectively organizing large C# code projects. To use any entity in a namespace, simply use <namespace name>.<entity name> No two classes with the same name in a different namespace will cause any error.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "27. How many types of constructors can a class have?",
        "answer": "Like functions, a class can have any number of constructors. But unlike functions, all the constructors will have the same name, the name of the class, but different parameter signatures. In other words, you can create as many valid overloads of a constructor, as you want.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "28. Which constructor is called first in C#?",
        "answer": "Base Constructor is always called first in C#, followed by Derived class constructor.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "29. Can we override a constructor?",
        "answer": "No, in C#, it is necessary to define properly which constructor you are trying to call to instantiate a class and what arguments are being passed. So you cannot override a constructor in C#. Example: Below example will lead to a compilation error. Example: // C# program to show constructor overriding is not allowed in C#\nusing System;\n// Base class\nclass Parent {\n   Parent ()\n   {\n       Console.WriteLine(\"Parent constructor\");\n   }\n}\n// Derived class\nclass Child : Parent\n{\n   Parent()\n   {\n       Console.WriteLine(\"Child constructor\");\n   }\n}\n// Driver Class\nclass GFG {\n// Main Method\nstatic void Main()\n{\n // Create an object of Child class\n var obj = new Child();\n}\n} // C# program to show constructor overriding is not allowed in C#\nusing System;\n// Base class\nclass Parent {\n   Parent ()\n   {\n       Console.WriteLine(\"Parent constructor\");\n   }\n}\n// Derived class\nclass Child : Parent\n{\n   Parent()\n   {\n       Console.WriteLine(\"Child constructor\");\n   }\n}\n// Driver Class\nclass GFG {\n// Main Method\nstatic void Main()\n{\n // Create an object of Child class\n var obj = new Child();\n}\n} // C# program to show constructor overriding is not allowed in C# using // Base class class Parent \"Parent constructor\" // Derived class class Child Parent \"Child constructor\" // Driver Class class GFG // Main Method static void Main() static void Main  // Create an object of Child class var new However, you can overload a constructor in C#, for sure.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "30. What is a delegate?",
        "answer": "A delegate is a reference type entity that is used to store the reference of a method. So whenever you need to call a method, you can easily use the delegate by initializing a pointer to that method, thereby helping to implement Encapsulation. // C# program to show the use of Delegates\nusing System;\nnamespace DelegateExample {\n\n   // Declare class \"DelegateExampleClass\"\n   class DelegateExampleClass {\n   \n       // Declaring the delegates -\n       // \"addTwoNumbers\", and \"substractTwoNumbers\"\n       \n       // The return type and parameter type of the\n       // delegates must be the same of the methods\n       public delegate void addTwoNumbers(int a, int b);\n       public delegate void substractTwoNumbers(int a, int b);\n       \n        // Method sumOf2Nums having same return type\n        // and parameter type as that of delegate\n        public void sumOf2Nums(int a, int b)\n        {\n         Console.WriteLine(\"({0} + {1}) = {2}\", a, b, a + b);\n        }\n       \n        // Method differenceOf2Nums having same return type\n        // and parameter type as that of delegate\n        public void differenceOf2Nums(int a, int b)\n        {\n         Console.WriteLine(\"({0} - {1}) = {2}\", a, b, a - b);\n        }\n       \n       // Main Method\n       public static void Main(String []args)\n       {\n        \n        // Creating object of class \"DelegateExampleClass\"\n        DelegateExampleClass obj = new DelegateExampleClass();\n       \n        // creating object of delegate, name as \"del_obj1\"\n        // for method \"sum\" and \"del_obj2\" for method \"subtract\" &\n        // pass the parameter as the two methods by class object \"obj\"\n        // instantiating the delegates\n        \n        // Create objects of declared Delegates and pass\n        // the methods of class DelegateExampleClass\n        // using the objects thereby implementing Encapsulation\n        addTwoNumbers delegateObj1 = new addTwoNumbers(obj.sumOf2Nums);\n        substractTwoNumbers delegateObj2 = new substractTwoNumbers(obj.differenceOf2Nums);\n       \n        // Call the methods of the class DelegateExampleClass\n        // using the delegate objects using appropriate values\n        delegateObj1(50, 40);\n        delegateObj2(50, 40);\n       }\n   }\n} // C# program to show the use of Delegates\nusing System;\nnamespace DelegateExample {\n\n   // Declare class \"DelegateExampleClass\"\n   class DelegateExampleClass {\n   \n       // Declaring the delegates -\n       // \"addTwoNumbers\", and \"substractTwoNumbers\"\n       \n       // The return type and parameter type of the\n       // delegates must be the same of the methods\n       public delegate void addTwoNumbers(int a, int b);\n       public delegate void substractTwoNumbers(int a, int b);\n       \n        // Method sumOf2Nums having same return type\n        // and parameter type as that of delegate\n        public void sumOf2Nums(int a, int b)\n        {\n         Console.WriteLine(\"({0} + {1}) = {2}\", a, b, a + b);\n        }\n       \n        // Method differenceOf2Nums having same return type\n        // and parameter type as that of delegate\n        public void differenceOf2Nums(int a, int b)\n        {\n         Console.WriteLine(\"({0} - {1}) = {2}\", a, b, a - b);\n        }\n       \n       // Main Method\n       public static void Main(String []args)\n       {\n        \n        // Creating object of class \"DelegateExampleClass\"\n        DelegateExampleClass obj = new DelegateExampleClass();\n       \n        // creating object of delegate, name as \"del_obj1\"\n        // for method \"sum\" and \"del_obj2\" for method \"subtract\" &\n        // pass the parameter as the two methods by class object \"obj\"\n        // instantiating the delegates\n        \n        // Create objects of declared Delegates and pass\n        // the methods of class DelegateExampleClass\n        // using the objects thereby implementing Encapsulation\n        addTwoNumbers delegateObj1 = new addTwoNumbers(obj.sumOf2Nums);\n        substractTwoNumbers delegateObj2 = new substractTwoNumbers(obj.differenceOf2Nums);\n       \n        // Call the methods of the class DelegateExampleClass\n        // using the delegate objects using appropriate values\n        delegateObj1(50, 40);\n        delegateObj2(50, 40);\n       }\n   }\n} // C# program to show the use of Delegates using namespace DelegateExample // Declare class \"DelegateExampleClass\" class DelegateExampleClass // Declaring the delegates - // \"addTwoNumbers\", and \"substractTwoNumbers\" // The return type and parameter type of the // delegates must be the same of the methods public delegate void addTwoNumbers(int a, int b) public delegate void addTwoNumbers int a, int b int int public delegate void substractTwoNumbers(int a, int b) public delegate void substractTwoNumbers int a, int b int int // Method sumOf2Nums having same return type // and parameter type as that of delegate public void sumOf2Nums(int a, int b) public void sumOf2Nums int a, int b int int \"({0} + {1}) = {2}\" // Method differenceOf2Nums having same return type // and parameter type as that of delegate public void differenceOf2Nums(int a, int b) public void differenceOf2Nums int a, int b int int \"({0} - {1}) = {2}\" // Main Method public static void Main(String []args) public static void Main String []args // Creating object of class \"DelegateExampleClass\" new // creating object of delegate, name as \"del_obj1\" // for method \"sum\" and \"del_obj2\" for method \"subtract\" & // pass the parameter as the two methods by class object \"obj\" // instantiating the delegates // Create objects of declared Delegates and pass // the methods of class DelegateExampleClass // using the objects thereby implementing Encapsulation new new // Call the methods of the class DelegateExampleClass // using the delegate objects using appropriate values 50 40 50 40 Delegates in C# are similar to function pointers in C/C++ and can be used to pass methods as arguments to other methods, chained together, or even can be used to call methods on events.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "31. What is an object pool?",
        "answer": "An object pool is a container built to keep the most used objects for faster access and use.\nAn object pool is based on the object pool design pattern in which instead of every time creating objects when needed, commonly used objects are created beforehand and kept in an easily accessible location. This is done to reduce the cost of the application as creating objects can use a lot of resources and can sometimes lead to the slowness of the .NET application. \nThe objects of the pool are returned to the pool, once the use is over, thus making it efficient to reuse them. If the object is not in the pool, it is then created when needed as a normal object. An object pool is a container built to keep the most used objects for faster access and use. An object pool is based on the object pool design pattern in which instead of every time creating objects when needed, commonly used objects are created beforehand and kept in an easily accessible location. This is done to reduce the cost of the application as creating objects can use a lot of resources and can sometimes lead to the slowness of the .NET application. The objects of the pool are returned to the pool, once the use is over, thus making it efficient to reuse them. If the object is not in the pool, it is then created when needed as a normal object.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    },
    {
        "question": "32. Differentiate between static and public?",
        "answer": "The public access modifier in C# states the compiler that the element is accessible by any other element in the same or other class. When a member in C# has the Static access modifier in front of it, such as static method, static variable, or static parameters,  it means that the element has global access and any other element can access it using class directly. You don't need to create an instance of the class to access that element. The compiler stores the address of the method as the entry point and uses this information to begin execution before any objects are created.",
        "reference": "interviewbit.com",
        "role": "c-sharp-for-5-years-experience"
    }
]