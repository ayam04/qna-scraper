[
    {
        "question": "1. Where are 88 levels utilized in COBOL?",
        "answer": "They are most commonly used declarations for implying restrictive factors which let to take decisions under specific program conditions. They are also used for improving program readability. They are also used for giving names to conditions which is why they are also known as “Condition Names”.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "2. What is COBOL?",
        "answer": "COBOL expands to Common Business Oriented Language. This is an object-oriented, procedural, and imperative language that was developed as a result of research and work from the US Department of Defence in the 1950s to develop common means of communicating across different mainframes. Following are the features of COBOL: Common Business Oriented Language COBOL was one of the first high-level programming languages developed which is meant to be user-friendly due to its English-like syntax.\nIt is widely used as a self-documenting language.\nIt is capable of handling, processing, and outputting huge data.\nIt has effective support for error messages which helps to resolve bugs easily. COBOL was one of the first high-level programming languages developed which is meant to be user-friendly due to its English-like syntax. It is widely used as a self-documenting language. It is capable of handling, processing, and outputting huge data. It has effective support for error messages which helps to resolve bugs easily.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "3. Define DRDA.",
        "answer": "DRDA represents Distributed Relational Database Architecture that behaves as a connection protocol meant for processing of local database. This is mainly used by vendors such as IBM. The architecture consists of rules that aid in the communication of applications and databases. Distributed Relational Database Architecture  ",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "4. What do you understand by self-referencing constraints?",
        "answer": "Self-referencing constraints are used for restricting changes that can be possibly made to a primary key using a foreign key. For achieving this, the foreign keys need to define the DELETE-CASCADE rule which states that in case the relationship for DELETE rule is defined as CASCADE, if one row is changed or deleted, then other rows in the table are recursively deleted.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "5. What is a spool?",
        "answer": "Spool stands for Simultaneous Peripheral Operations On-Line which is used as buffering mechanism where data would be stored temporarily, processed and executed later. Simultaneous Peripheral Operations On-Line",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "6. Differentiate between SEARCH and SEARCH ALL.",
        "answer": "SEARCH and SEARCH ALL is used for finding if a record is present in a table or not. SEARCH SEARCH ALL\nUses linear search for finding record(s) in the table. This is also called a sequential search. Uses Binary Search for finding record(s) in the table.\nHere, the table does not require data to be available in sorted order. Here, the data in the table needs to be present in sorted order (either ascending or descending).\nThe syntax for SEARCH is: \nSEARCH TABLE-NAME [VARYING {identifier1/index1}] [AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH.\nThe syntax for SEARCH ALL is:\nSEARCH ALL TABLE-NAME  \n[AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH. SEARCH SEARCH ALL\nUses linear search for finding record(s) in the table. This is also called a sequential search. Uses Binary Search for finding record(s) in the table.\nHere, the table does not require data to be available in sorted order. Here, the data in the table needs to be present in sorted order (either ascending or descending).\nThe syntax for SEARCH is: \nSEARCH TABLE-NAME [VARYING {identifier1/index1}] [AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH.\nThe syntax for SEARCH ALL is:\nSEARCH ALL TABLE-NAME  \n[AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH. SEARCH SEARCH ALL SEARCH SEARCH ALL SEARCH SEARCH ALL Uses linear search for finding record(s) in the table. This is also called a sequential search. Uses Binary Search for finding record(s) in the table.\nHere, the table does not require data to be available in sorted order. Here, the data in the table needs to be present in sorted order (either ascending or descending).\nThe syntax for SEARCH is: \nSEARCH TABLE-NAME [VARYING {identifier1/index1}] [AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH.\nThe syntax for SEARCH ALL is:\nSEARCH ALL TABLE-NAME  \n[AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH. Uses linear search for finding record(s) in the table. This is also called a sequential search. Uses Binary Search for finding record(s) in the table. Uses linear search for finding record(s) in the table. This is also called a sequential search. Uses Binary Search for finding record(s) in the table. Here, the table does not require data to be available in sorted order. Here, the data in the table needs to be present in sorted order (either ascending or descending). Here, the table does not require data to be available in sorted order. Here, the data in the table needs to be present in sorted order (either ascending or descending). The syntax for SEARCH is: \nSEARCH TABLE-NAME [VARYING {identifier1/index1}] [AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH.\nThe syntax for SEARCH ALL is:\nSEARCH ALL TABLE-NAME  \n[AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH. The syntax for SEARCH is: \nSEARCH TABLE-NAME [VARYING {identifier1/index1}] [AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH. The syntax for SEARCH is: SEARCH TABLE-NAME [VARYING {identifier1/index1}] [AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH. SEARCH TABLE-NAME [VARYING {identifier1/index1}] [AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH. The syntax for SEARCH ALL is:\nSEARCH ALL TABLE-NAME  \n[AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH. The syntax for SEARCH ALL is: SEARCH ALL TABLE-NAME  \n[AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH. SEARCH ALL TABLE-NAME  \n[AT END Statement]\n{WHEN ConditionPasses  \n{statement/NEXT SENTENCE/CONTINUE}\n…\n}  \nEND-SEARCH.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "7. Define COPYBOOK in COBOL.",
        "answer": "COPYBOOK is used for storing the record format whose design can be used by another program too. One COPYBOOK can be used for multiple documents or programs by using REPLACING choice in case the formats are the same.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "8. What is index cardinality in DB2?",
        "answer": "Index cardinality represents the number of discrete values or entries in a table column. DB2 has a utility called RUNSTATS which is used for examining column entry redundancy for finding whether an index scan is needed to search the data.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "9. What is the importance of DBCTL?",
        "answer": "DBCTL stands for Database Control and is an address space and is used for accessing IMS (Information Management System) files for CICS (Customer Information Control System) transactions. It is used to access IMS files for CICS Transactions and it is address space. For more information, you can refer here. here",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "10. Define UPDATE cursor.",
        "answer": "UPDATE cursor is a pointer that permits us to modify or delete the current recently fetched row. UPDATE Keyword lets the information server know that the instruction would modify or delete any row it fetches from the database.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "11. What are Mainframe computers?",
        "answer": "Mainframe computers are a combination of different processors and RAM (memory). They work as a CPU for multiple workstations and terminals associated with it. They are used for performing huge data operations of the range of petabytes which would allow processing requests for thousands of users. The term ‘Mainframe’ represents a frame to hold main memory and multiple processors. These computers are used for processing requests in real-time in e-commerce, banking, education. government and various other applications. The following diagram represents the view of the Mainframe system.  ",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "12. Define JCL.",
        "answer": "JCL expands to Job Control Language and is a scripting language that is used for providing required specifications for processing a job. It consists of a set of control statements and acts as an interface between the IBM Mainframe Operating System and COBOL programs. JCL statements also do the task of notifying the OS for finding required input data and provide instructions on what operations need to be performed on that input and what needs to be done with the result. Job Control Language",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "13. What are the types of JCL statements available for running a job?",
        "answer": "There are majorly 3 types of JCL statements: The first type consists of statements meant for identifying units of work that are to be performed by the Operating System.\nThe second type of statement is the EXEC statement which depends on the number of steps involved in running a job.\nThe third type of statements are called DD (Data Definition) statements that are meant for identifying input and output data sets. The first type consists of statements meant for identifying units of work that are to be performed by the Operating System. The second type of statement is the EXEC statement which depends on the number of steps involved in running a job. The third type of statements are called DD (Data Definition) statements that are meant for identifying input and output data sets.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "14. What is COMP SYNC?",
        "answer": "SYNC is a Keyword in COBOL used for aligning the storage area (data) to a word boundary that represents any address that is multiple of 4. This is done to ensure computations are efficient when data is read from word boundary by the Mainframe server.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "15. How are static and dynamic linking achieved?",
        "answer": "Static linking requires a calling program to call the subroutine links.\nIn dynamic linking, the calling program and the subroutine links can exist as different modules.\nBoth types of linking can be done by choosing either NODYNAM or DYNAM link edit options. Static linking requires a calling program to call the subroutine links. In dynamic linking, the calling program and the subroutine links can exist as different modules. Both types of linking can be done by choosing either NODYNAM or DYNAM link edit options.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "16. How are global and external variables different from each other?",
        "answer": "Global variables are those variables that are available only to batch programs whereas external variables are those variables that are accessible by any batch programs in the same system library.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "17. What are the different types of conditional statements present in COBOL?",
        "answer": "Conditional statements are used for changing the flow of execution based on conditions specified. The conditions always must evaluate as true or false. Following are the different types of conditional statements: IF Condition\nRelation Condition\nClass Condition\nSign Condition\nNegated Condition\nCondition-Name Condition\nCombined Condition. IF Condition Relation Condition Class Condition Sign Condition Negated Condition Condition-Name Condition Combined Condition.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "1. What are the different stages of processing a job?",
        "answer": "JCL is used for processing work by the z/OS system by defining which program needs to be executed, what resources need to be allocated, etc. The description of work specified is called a job. z/OS system makes use of JES (Job Entry Subsystem) that receives jobs into the OS, schedules them and processes them, and controls their output. Following are the phases of job processing:   Input Phase: This is a phase for inputting the jobs utilizing using input devices like remote terminals, card readers, job entry networks, etc. We can also use internal readers that can be used by other programs for submitting the job, providing commands and control statements to JES2.\nWhenever JES2 reads the input stream, a job identifier is assigned to each job and places every job’s JCL, control statements, SYSIN data etc onto DASD datasets which are called spool data sets. The spool has direct access to the datasets and provides the capability to perform simultaneous job processing and also provides a temporary storage area for incomplete jobs. JES2, later on, selects jobs from this spool and processes them. Input Phase: This is a phase for inputting the jobs utilizing using input devices like remote terminals, card readers, job entry networks, etc. We can also use internal readers that can be used by other programs for submitting the job, providing commands and control statements to JES2.\nWhenever JES2 reads the input stream, a job identifier is assigned to each job and places every job’s JCL, control statements, SYSIN data etc onto DASD datasets which are called spool data sets. The spool has direct access to the datasets and provides the capability to perform simultaneous job processing and also provides a temporary storage area for incomplete jobs. JES2, later on, selects jobs from this spool and processes them. Input Phase Whenever JES2 reads the input stream, a job identifier is assigned to each job and places every job’s JCL, control statements, SYSIN data etc onto DASD datasets which are called spool data sets. The spool has direct access to the datasets and provides the capability to perform simultaneous job processing and also provides a temporary storage area for incomplete jobs. JES2, later on, selects jobs from this spool and processes them. Whenever JES2 reads the input stream, a job identifier is assigned to each job and places every job’s JCL, control statements, SYSIN data etc onto DASD datasets which are called spool data sets. The spool has direct access to the datasets and provides the capability to perform simultaneous job processing and also provides a temporary storage area for incomplete jobs. JES2, later on, selects jobs from this spool and processes them.   Conversion Phase: This phase involves the usage of a converter program for analyzing every JCL statement and does the task of checking program syntax.\nJES can also determine if JCL has any procedure calls. If there are any, then the convertor does the task of taking the job’s JCL, merges it with JCL by making use of the procedural library like SYS1.PROCLIB and converts composite JCL to internal text which is then stored in a spool.\nDuring this conversion, if any errors are identified, then JES2 sends out appropriate error messages and queues them for output processing.\nIn case there are no errors in the job, then the job is queued for further processing based on the priority of its class.\nExecution Phase: In this phase, the initiators are started either automatically or employing an operator at the time of system initialization. Once the initiator is ready, a job is requested from JES2 for execution.\nJES2 selects the job and assigns it to the initiator based on the priority assigned for the order of execution.\nThe initiator invokes the interpreter for building the control blocks from the internal text created in the earlier step. It also allocates resources that are required for running the job.\nOnce sufficient resources are allocated, the program starts its execution as requested in the JCL EXEC statement.\nOutput Phase: Post the execution of the program, output processing is done for sending out system messages to the user. The job’s output characteristics are analyzed by JES2 based on the requirements and then queues for printing or punch processing. This queue is called an output queue which can contain records that require local or remote processing.\nOnce the output processing is complete, the jobs are sent to the purge queue and made ready for the purge phase.\nPurge Phase: Post-processing of the job, JES2 picks it from the purge queue and releases the resources and spool space of the job to make it available for upcoming jobs. The purge indicator message will then be sent to the OS from the system. Conversion Phase: This phase involves the usage of a converter program for analyzing every JCL statement and does the task of checking program syntax.\nJES can also determine if JCL has any procedure calls. If there are any, then the convertor does the task of taking the job’s JCL, merges it with JCL by making use of the procedural library like SYS1.PROCLIB and converts composite JCL to internal text which is then stored in a spool.\nDuring this conversion, if any errors are identified, then JES2 sends out appropriate error messages and queues them for output processing.\nIn case there are no errors in the job, then the job is queued for further processing based on the priority of its class. Conversion Phase JES can also determine if JCL has any procedure calls. If there are any, then the convertor does the task of taking the job’s JCL, merges it with JCL by making use of the procedural library like SYS1.PROCLIB and converts composite JCL to internal text which is then stored in a spool.\nDuring this conversion, if any errors are identified, then JES2 sends out appropriate error messages and queues them for output processing.\nIn case there are no errors in the job, then the job is queued for further processing based on the priority of its class. JES can also determine if JCL has any procedure calls. If there are any, then the convertor does the task of taking the job’s JCL, merges it with JCL by making use of the procedural library like SYS1.PROCLIB and converts composite JCL to internal text which is then stored in a spool. During this conversion, if any errors are identified, then JES2 sends out appropriate error messages and queues them for output processing. In case there are no errors in the job, then the job is queued for further processing based on the priority of its class. Execution Phase: In this phase, the initiators are started either automatically or employing an operator at the time of system initialization. Once the initiator is ready, a job is requested from JES2 for execution.\nJES2 selects the job and assigns it to the initiator based on the priority assigned for the order of execution.\nThe initiator invokes the interpreter for building the control blocks from the internal text created in the earlier step. It also allocates resources that are required for running the job.\nOnce sufficient resources are allocated, the program starts its execution as requested in the JCL EXEC statement. Execution Phase JES2 selects the job and assigns it to the initiator based on the priority assigned for the order of execution.\nThe initiator invokes the interpreter for building the control blocks from the internal text created in the earlier step. It also allocates resources that are required for running the job.\nOnce sufficient resources are allocated, the program starts its execution as requested in the JCL EXEC statement. JES2 selects the job and assigns it to the initiator based on the priority assigned for the order of execution. The initiator invokes the interpreter for building the control blocks from the internal text created in the earlier step. It also allocates resources that are required for running the job. Once sufficient resources are allocated, the program starts its execution as requested in the JCL EXEC statement. Output Phase: Post the execution of the program, output processing is done for sending out system messages to the user. The job’s output characteristics are analyzed by JES2 based on the requirements and then queues for printing or punch processing. This queue is called an output queue which can contain records that require local or remote processing.\nOnce the output processing is complete, the jobs are sent to the purge queue and made ready for the purge phase. Output Phase Once the output processing is complete, the jobs are sent to the purge queue and made ready for the purge phase. Once the output processing is complete, the jobs are sent to the purge queue and made ready for the purge phase. Purge Phase: Post-processing of the job, JES2 picks it from the purge queue and releases the resources and spool space of the job to make it available for upcoming jobs. The purge indicator message will then be sent to the OS from the system. Purge Phase",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "2. What happens if both STEPLIB and JOBLIB statements are specified?",
        "answer": "JOBLIB is a DD statement that determines the program location that is called EXEC statement. The statement applies to all the steps of the entire job but can not be used for catalogued procedures.\nSTEPLIB is similar to JOBLIB and is used for determining the dataset where the program is present. It applies only to the step that it is part of and not the whole job. This can be used at any step in the job and also in catalogued procedures.\nIf both STEPLIB and JOBLIB are used, then priority is given to STEPLIB thereby ignoring JOBLIB by the system. JOBLIB is a DD statement that determines the program location that is called EXEC statement. The statement applies to all the steps of the entire job but can not be used for catalogued procedures. STEPLIB is similar to JOBLIB and is used for determining the dataset where the program is present. It applies only to the step that it is part of and not the whole job. This can be used at any step in the job and also in catalogued procedures. If both STEPLIB and JOBLIB are used, then priority is given to STEPLIB thereby ignoring JOBLIB by the system.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "3. How to handle deadlock (-911 Error) in DB2 program?",
        "answer": "Deadlock occurs in the case where two or more mainframe programs get an exclusive lock on the resource which cant execute until the data is accessed. In case the error occurs, we can roll back the current work unit of any one of the programs after a specified preset deadlock time interval and thereby terminating the program.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "4. How will you repair the SOC-7 error?",
        "answer": "The most common cause of SOC-7 error is problematic data associated with an uninitialized numeric item. We can get hold of dumps of run-time abends by performing some setups like invoking Operating System Services using assembly languages. Using these dumps, we can get the exact location of instruction where the abend has occurred. Using this, we can verify the XREF output that lists the compilation to get the line number and verb of the source code of the instruction error offset. Runtime dumps can be captured by defining datasets as Sysabout (for example) in JCL. We can also make use of the debugging utilities provided by the setups. When none of the methods is working, we need to find the error location by making use of good judgement and understanding of the system developed.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "5. What are the various forms of Evaluate Statements?",
        "answer": "EVALUATE Statements are of different types: Simple EVALUATE: This type of EVALUATE has only one condition for validation. It does so by validating the item in the WHEN phrase, if the item matches, then the statement below the WHEN phrase would get executed. Simple EVALUATE: This type of EVALUATE has only one condition for validation. It does so by validating the item in the WHEN phrase, if the item matches, then the statement below the WHEN phrase would get executed. Simple EVALUATE EVALUATE DAY\n   WHEN 01\n       DISPLAY 'MONDAY'\n   WHEN 03\n       DISPLAY 'WEDNESDAY'\n   WHEN 05\n       DISPLAY 'FRIDAY'\n   WHEN OTHER\n       DISPLAY 'Not alternate'\nEND-EVALUATE EVALUATE DAY\n   WHEN 01\n       DISPLAY 'MONDAY'\n   WHEN 03\n       DISPLAY 'WEDNESDAY'\n   WHEN 05\n       DISPLAY 'FRIDAY'\n   WHEN OTHER\n       DISPLAY 'Not alternate'\nEND-EVALUATE EVALUATE TRUE: This type has boolean expressions and the WHEN phrases had logical expressions. If EVALUATE condition is True, then statements under WHEN where logical expression evaluates to TRUE is executed. If none of the WHEN evaluates to TRUE, then WHEN OTHER is executed. EVALUATE TRUE: This type has boolean expressions and the WHEN phrases had logical expressions. If EVALUATE condition is True, then statements under WHEN where logical expression evaluates to TRUE is executed. If none of the WHEN evaluates to TRUE, then WHEN OTHER is executed. EVALUATE TRUE EVALUATE TRUE\n   WHEN WEEKDAY EQUAL 01\n       DISPLAY 'MONDAY'\n   WHEN WEEKDAY EQUAL 03\n       DISPLAY 'WEDNESDAY'\n   WHEN WEEKDAY EQUAL 05\n       DISPLAY 'FRIDAY'\n   WHEN OTHER\n       DISPLAY 'NOT ALTERNATIVE'\nEND-EVALUATE EVALUATE TRUE\n   WHEN WEEKDAY EQUAL 01\n       DISPLAY 'MONDAY'\n   WHEN WEEKDAY EQUAL 03\n       DISPLAY 'WEDNESDAY'\n   WHEN WEEKDAY EQUAL 05\n       DISPLAY 'FRIDAY'\n   WHEN OTHER\n       DISPLAY 'NOT ALTERNATIVE'\nEND-EVALUATE EVALUATE having THRU: EVALUATE THRU type is used for validating data where values are from a given range in contiguous and ascending order. The data item in the EVALUATE statement should belong to a range of values specified in the WHEN phrase to execute the statements. If values do not belong to the range, then statements under WHEN OTHER gets executed. EVALUATE having THRU: EVALUATE THRU type is used for validating data where values are from a given range in contiguous and ascending order. The data item in the EVALUATE statement should belong to a range of values specified in the WHEN phrase to execute the statements. If values do not belong to the range, then statements under WHEN OTHER gets executed. EVALUATE having THRU EVALUATE TOTAL-MARKS\n   WHEN 70 THRU 100\n       DISPLAY 'DISTINCTION'\n   WHEN 50 THRU 69\n       DISPLAY 'FIRST CLASS'\n   WHEN 30 THRU 49\n       DISPLAY 'SECOND CLASS'\n   WHEN OTHER\n       DISPLAY 'DID NOT PASS'\nEND-EVALUATE EVALUATE TOTAL-MARKS\n   WHEN 70 THRU 100\n       DISPLAY 'DISTINCTION'\n   WHEN 50 THRU 69\n       DISPLAY 'FIRST CLASS'\n   WHEN 30 THRU 49\n       DISPLAY 'SECOND CLASS'\n   WHEN OTHER\n       DISPLAY 'DID NOT PASS'\nEND-EVALUATE EVALUATE having multiple WHEN conditions: This type is used for validating data items with a set of different values which require the same action to be performed. The WHEN statements are grouped and a set of steps to be executed is written. If anyone WHEN phrase gets matched, then the statements are executed. EVALUATE having multiple WHEN conditions: This type is used for validating data items with a set of different values which require the same action to be performed. The WHEN statements are grouped and a set of steps to be executed is written. If anyone WHEN phrase gets matched, then the statements are executed. EVALUATE having multiple WHEN conditions EVALUATE TOTAL-GRADE\n   WHEN 'A'\n   WHEN 'B'\n   WHEN 'C'\n       DISPLAY 'PASS'\n   WHEN OTHER\n       DISPLAY 'DID NOT PASS'\nEND-EVALUATE EVALUATE TOTAL-GRADE\n   WHEN 'A'\n   WHEN 'B'\n   WHEN 'C'\n       DISPLAY 'PASS'\n   WHEN OTHER\n       DISPLAY 'DID NOT PASS'\nEND-EVALUATE EVALUATE having MULTIPLE conditions: This type of EVALUATE is used for validating a set of multiple conditions which are combined by using ALSO. The number of objects in the WHEN phrase should be equal to the number of subjects in EVALUATE. If all expressions specified in WHEN is satisfied, then the statements below that WHEN is executed. EVALUATE having MULTIPLE conditions: This type of EVALUATE is used for validating a set of multiple conditions which are combined by using ALSO. The number of objects in the WHEN phrase should be equal to the number of subjects in EVALUATE. If all expressions specified in WHEN is satisfied, then the statements below that WHEN is executed. EVALUATE having MULTIPLE conditions EVALUATE TRUE ALSO TRUE\n   WHEN AGE > 018 ALSO GENDER = 'M'\n       DISPLAY 'Man can Vote'\n   WHEN AGE > 018 ALSO GENDER = 'F'\n       DISPLAY 'Woman can Vote'\n   WHEN AGE > 018 ALSO GENDER = 'U'\n       DISPLAY 'Person can vote'\n   WHEN OTHER\n       DISPLAY 'Cant vote'\nEND-EVALUATE EVALUATE TRUE ALSO TRUE\n   WHEN AGE > 018 ALSO GENDER = 'M'\n       DISPLAY 'Man can Vote'\n   WHEN AGE > 018 ALSO GENDER = 'F'\n       DISPLAY 'Woman can Vote'\n   WHEN AGE > 018 ALSO GENDER = 'U'\n       DISPLAY 'Person can vote'\n   WHEN OTHER\n       DISPLAY 'Cant vote'\nEND-EVALUATE",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "6. What steps do you follow to create a COBOL program?",
        "answer": "Create all necessary tables in the database.\nCreate DCLGEN (Declaration Generator). This is an optional step. Perform it only if needed.\nPre-compile the program.\nCompile the program and perform Link Edit.\nPerform DB2 BIND.\nExecute the Program. Create all necessary tables in the database. Create DCLGEN (Declaration Generator). This is an optional step. Perform it only if needed. Pre-compile the program. Compile the program and perform Link Edit. Perform DB2 BIND. Execute the Program.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "7. What is the importance of coding COMMITS in batch programs?",
        "answer": "COMMIT statements are used for releasing locks that are needed for that particular work unit and then allow new work units. In case, COMMITS are not part of the program, then during processing of the program, it has to go back to the inserts that were made during the program run instead of going back to few inserts near the most recent commit. This process takes 2 or 3 times extra time than the time taken for program execution.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "8. How does paging work in the memory?",
        "answer": "Whenever data is requested from the memory, the CPU first hits the primary memory, i.e RAM, and checks if the requested data is present on that page in the memory. If it is not present, then the CPU performs paging on secondary memory, i.e reads data from hard disk in equal blocks of memories called pages. During paging, a frame constitutes a single page of physical memory and it need not be physically contiguous. This ensures faster memory access and ensures data is fetched faster from secondary memory.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "9. How will you understand if your module is called statically or dynamically?",
        "answer": "We can understand it by looking at the linkage editor output or from the load module. In case the module is called dynamically, then that will not be part of the main module. If it is called, statically, then we can see the details of the module in the load module. There is one more type of module calling known as an IMPLICIT calling which identifies the module name by getting implications from the content of the storage variable consisting of the program name.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "10. What are the differences between external and internal sort? What are their syntaxes?",
        "answer": "Internal sort is handled by the COBOL program by making use of input file, work file, and output file. Here, recompiling of the COBOL program is needed when any kind of processing is done. Internal Sort uses two types of syntaxes:\nUSING, GIVING sorts use no extra file processing.\nINPUT PROCEDURE, OUTPUT PROCEDURE sorts allow data manipulation before or after sort.\nExternal sort is not based on COBOL and utilizes direct use of SORT utility and is performed by making use of JCL and PGM=SORT. Internal sort is handled by the COBOL program by making use of input file, work file, and output file. Here, recompiling of the COBOL program is needed when any kind of processing is done. Internal Sort uses two types of syntaxes:\nUSING, GIVING sorts use no extra file processing.\nINPUT PROCEDURE, OUTPUT PROCEDURE sorts allow data manipulation before or after sort. USING, GIVING sorts use no extra file processing.\nINPUT PROCEDURE, OUTPUT PROCEDURE sorts allow data manipulation before or after sort. USING, GIVING sorts use no extra file processing. INPUT PROCEDURE, OUTPUT PROCEDURE sorts allow data manipulation before or after sort. External sort is not based on COBOL and utilizes direct use of SORT utility and is performed by making use of JCL and PGM=SORT.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "11. What needs to be done to ensure the program executes above 16 Meg Line?",
        "answer": "We need to do the following steps: Ensure the link option is set to AMODE=31 and RMODE=ANY.\nCompile option does not have SIZE(MAX).\nFor efficiency, BUFSIZE can be 2K. Ensure the link option is set to AMODE=31 and RMODE=ANY. AMODE=31 RMODE=ANY Compile option does not have SIZE(MAX). SIZE(MAX) For efficiency, BUFSIZE can be 2K.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "12. How do you pass incentives from JCL to COBOL?",
        "answer": "This can be done by making use of the RETURN-CODE keyword which can be used for passing information to the JCL from the COBOL program. We can use it for identifying the outcome of any operation. Generally, the program activity returns 0,4,8 or 12 in cases of success or irregularities. We can change it by making use of this keyword which also ensures that the information is passed from COBOL to JCL.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "13. How do you avoid deadlocks while reading data in Mainframe?",
        "answer": "We can do the following steps in order to avoid deadlocks: Use FOR UPDATE clause which ensures that U lock is set when a process tries reading data during select operation. This clause does not allow row-blocking.\nUse the following clauses in queries that ensure U lock is set when a process tries to read the data and allows row-blocking:\nWITH RR or WITH RS\nUSE AND KEEP UPDATE LOCKS Use FOR UPDATE clause which ensures that U lock is set when a process tries reading data during select operation. This clause does not allow row-blocking. FOR UPDATE Use the following clauses in queries that ensure U lock is set when a process tries to read the data and allows row-blocking:\nWITH RR or WITH RS\nUSE AND KEEP UPDATE LOCKS WITH RR or WITH RS\nUSE AND KEEP UPDATE LOCKS WITH RR or WITH RS WITH RR WITH RS USE AND KEEP UPDATE LOCKS USE AND KEEP UPDATE LOCKS",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "14. Difference between index and subscript.",
        "answer": "Index Subscript\nIndex represents the number of displacement positions of the array. Subscript is the number of occurrences of the array.\nIndex does not require a separate declaration. INDEX BY is used to declare index. Subscript requires separate declaration with S9(04) COMP in WORKING-STORAGE SECTION.\nHelps in faster access of data in the table. Is slower in accessing data items.\nUses SET statement to initialize index. Uses MOVE statement to initialize subscript.\nCan decrease by using SET DOWN BY statement and SET UP BY statement is used to increase index. ADD statement is used to increase subscript and SUBTRACT is used to decrease it. Index Subscript\nIndex represents the number of displacement positions of the array. Subscript is the number of occurrences of the array.\nIndex does not require a separate declaration. INDEX BY is used to declare index. Subscript requires separate declaration with S9(04) COMP in WORKING-STORAGE SECTION.\nHelps in faster access of data in the table. Is slower in accessing data items.\nUses SET statement to initialize index. Uses MOVE statement to initialize subscript.\nCan decrease by using SET DOWN BY statement and SET UP BY statement is used to increase index. ADD statement is used to increase subscript and SUBTRACT is used to decrease it. Index Subscript Index Subscript Index Subscript Index represents the number of displacement positions of the array. Subscript is the number of occurrences of the array.\nIndex does not require a separate declaration. INDEX BY is used to declare index. Subscript requires separate declaration with S9(04) COMP in WORKING-STORAGE SECTION.\nHelps in faster access of data in the table. Is slower in accessing data items.\nUses SET statement to initialize index. Uses MOVE statement to initialize subscript.\nCan decrease by using SET DOWN BY statement and SET UP BY statement is used to increase index. ADD statement is used to increase subscript and SUBTRACT is used to decrease it. Index represents the number of displacement positions of the array. Subscript is the number of occurrences of the array. Index represents the number of displacement positions of the array. Subscript is the number of occurrences of the array. Index does not require a separate declaration. INDEX BY is used to declare index. Subscript requires separate declaration with S9(04) COMP in WORKING-STORAGE SECTION. Index does not require a separate declaration. INDEX BY is used to declare index. INDEX BY Subscript requires separate declaration with S9(04) COMP in WORKING-STORAGE SECTION. Helps in faster access of data in the table. Is slower in accessing data items. Helps in faster access of data in the table. Is slower in accessing data items. Uses SET statement to initialize index. Uses MOVE statement to initialize subscript. Uses SET statement to initialize index. Uses MOVE statement to initialize subscript. Can decrease by using SET DOWN BY statement and SET UP BY statement is used to increase index. ADD statement is used to increase subscript and SUBTRACT is used to decrease it. Can decrease by using SET DOWN BY statement and SET UP BY statement is used to increase index. ADD statement is used to increase subscript and SUBTRACT is used to decrease it.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "15. How many types of locks are there and what are their functions?",
        "answer": "There are 3 types of locks. Shared lock: – This lock can ensure that two or more mainframe programs can read from the locked resource at a time but modifying is not allowed.\nThis lock is also called a read lock as it is used only for reading data items.\nSince these are read locks, they support read integrity and ensures that when a record is being read, that won't be updated.\nShared locks can also be used to prevent any kind of updates of record.\nConsider a scenario where we have A=100 initially and we have 2 transactions that want to read A. If one among them wants to update or modify A, then there are chances where the other transaction would read the wrong value. Here, if we use a shared lock, the data updation would be prevented until the transaction has completed reading.\nUpdate lock: – This lock allows the program to use the shared or locked resource to change it.\nThis lock requires TABLESPACE OR LOCKSIZE TABLE along with cursor-based SELECT having FOR UPDATE OF clause.\nA table with this lock allows data read but does not allow modification of the locked data. Whenever the application tries to update the data, the U lock will be promoted to Exclusive Lock.\nExclusive lock: – This lock restricts all user types to access locked space.\nConsider an example where A=100 initially, and we have a transaction that wants to deduct some value say 25 from A. This can be allowed by placing an exclusive lock on A so that whenever any other transaction wants to read or write from it, the lock prevents it. Shared lock: – This lock can ensure that two or more mainframe programs can read from the locked resource at a time but modifying is not allowed.\nThis lock is also called a read lock as it is used only for reading data items.\nSince these are read locks, they support read integrity and ensures that when a record is being read, that won't be updated.\nShared locks can also be used to prevent any kind of updates of record.\nConsider a scenario where we have A=100 initially and we have 2 transactions that want to read A. If one among them wants to update or modify A, then there are chances where the other transaction would read the wrong value. Here, if we use a shared lock, the data updation would be prevented until the transaction has completed reading. Shared lock: This lock is also called a read lock as it is used only for reading data items.\nSince these are read locks, they support read integrity and ensures that when a record is being read, that won't be updated.\nShared locks can also be used to prevent any kind of updates of record.\nConsider a scenario where we have A=100 initially and we have 2 transactions that want to read A. If one among them wants to update or modify A, then there are chances where the other transaction would read the wrong value. Here, if we use a shared lock, the data updation would be prevented until the transaction has completed reading. This lock is also called a read lock as it is used only for reading data items. Since these are read locks, they support read integrity and ensures that when a record is being read, that won't be updated. Shared locks can also be used to prevent any kind of updates of record. Consider a scenario where we have A=100 initially and we have 2 transactions that want to read A. If one among them wants to update or modify A, then there are chances where the other transaction would read the wrong value. Here, if we use a shared lock, the data updation would be prevented until the transaction has completed reading. Update lock: – This lock allows the program to use the shared or locked resource to change it.\nThis lock requires TABLESPACE OR LOCKSIZE TABLE along with cursor-based SELECT having FOR UPDATE OF clause.\nA table with this lock allows data read but does not allow modification of the locked data. Whenever the application tries to update the data, the U lock will be promoted to Exclusive Lock. Update lock: This lock requires TABLESPACE OR LOCKSIZE TABLE along with cursor-based SELECT having FOR UPDATE OF clause.\nA table with this lock allows data read but does not allow modification of the locked data. Whenever the application tries to update the data, the U lock will be promoted to Exclusive Lock. This lock requires TABLESPACE OR LOCKSIZE TABLE along with cursor-based SELECT having FOR UPDATE OF clause. FOR UPDATE OF A table with this lock allows data read but does not allow modification of the locked data. Whenever the application tries to update the data, the U lock will be promoted to Exclusive Lock. Exclusive lock: – This lock restricts all user types to access locked space.\nConsider an example where A=100 initially, and we have a transaction that wants to deduct some value say 25 from A. This can be allowed by placing an exclusive lock on A so that whenever any other transaction wants to read or write from it, the lock prevents it. Exclusive lock: Consider an example where A=100 initially, and we have a transaction that wants to deduct some value say 25 from A. This can be allowed by placing an exclusive lock on A so that whenever any other transaction wants to read or write from it, the lock prevents it. Consider an example where A=100 initially, and we have a transaction that wants to deduct some value say 25 from A. This can be allowed by placing an exclusive lock on A so that whenever any other transaction wants to read or write from it, the lock prevents it.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "16. What is the importance of the DCB parameter in DD statements?",
        "answer": "DCB stands for Data Control Block. DCB parameter in DD (Data definition) statements helps to detail out the physical characteristics of datasets that are newly created in the job step. Data Control Block LRECL: signifies what is the length of record that can be held within a dataset.\nRECFM: signifies record format type of the datasets. LRECL: signifies what is the length of record that can be held within a dataset. LRECL RECFM: signifies record format type of the datasets. RECFM",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "1. In case you have 1000 rows in the DB2 table, how will you update the column value of the first 100 records?",
        "answer": "In case our DB2 table has an identity column, then we can use the indexnum as follows: Update Table SET COLUMN_NAME=XXX where indexnum < 101 Update Table SET COLUMN_NAME=XXX where indexnum < 101",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "2. How will you define the sort file in JCL which runs the COBOL program?",
        "answer": "We can use SORTWK01, SORTWK02, and so on in the step. There needs to be a minimum of 3 datasets, but in general, the number of sort datasets is proportionate to the volume of a dataset that needs to be sorted.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "3. Is it possible to redefine X(100) field with X(200)? If yes, how?",
        "answer": "Yes, it is possible by making use of REDEFINES. We need to keep in mind that redefining just ensures fields start from the same location. REDEFINES 01 WS-TOP PIC X(100)\n01 WS-TOP-DOUBLE REDEFINES WS-TOP PIC X(200) 01 WS-TOP PIC X(100)\n01 WS-TOP-DOUBLE REDEFINES WS-TOP PIC X(200)",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "4. How will you copy data from one dataset to another dataset by using the SORT card?",
        "answer": "We can mention SYSIN and SYSOUT dataset names in the SORT step. Additionally, we need to mention SORT FIELDS = COPY in the sort card to copy data from one dataset to another.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "5. How will you inform other users about job completion?",
        "answer": "We can make use of NOTIFY statement which notifies the user about job completion along with the return code. NOTIFY = userid to whom status needs to be notified NOTIFY = userid to whom status needs to be notified It has to be noted that the job log of the spool would contain information under the job submitter’s id.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "6. How will you achieve auto restart when the job abends?",
        "answer": "We can make use of the RD parameter in JOB/EXEC statement by specifying for what abend codes RESTART needs to be performed in the SCHEDxx member of parmlib library of the IBM system.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "7. How will you check if a file is empty in JCL?",
        "answer": "In case the file is empty and is used as input in IDCAMS, then the job completes with return code 4. By verifying this return code, we can identify that the file is empty.",
        "reference": "interviewbit.com",
        "role": "mainframe"
    },
    {
        "question": "1) What is the Mainframe computer?",
        "answer": "A mainframe computer is a combination of many processors and memory (RAM). It works as a CPU for many workstations and terminals connected with it. A mainframe computer is used to perform a huge amount of data operations in petabytes. It can allow thousands of user to process. Its name 'Mainframe' stands for a frame for holding several processors and main memory. Mainframe computer plays a significant role in e-business where thousands of people connect to a server to precede their request in real-time. Similarly, in banking, government, education system mainframe computer plays a valuable role.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "2) What is DRDA?",
        "answer": "DRDA (Distributed Relational Database Architecture) is a set of protocols or rules that enables the user to access distributed data regardless of where it physically stored.\nADVERTISEMENT\nIt is an architecture developed by IBM.\nIt enables relational data to distribute among multiple platforms.\nIn DRDA, both like and unlike platforms can communicate with one another. Example DB2 subsystem can communicate with DB2 as well as RDBMS.\nIt provides an open, robust heterogeneous and distributed database environment.\nDRDA provides techniques of coordinating communication among distributed locations.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "3) Describe the benefits of DRDA?",
        "answer": "The key benefits of DRDA are as follows.\nDRDA is the only protocol that supports distributed RDBMS.\nOne significant benefits provided by DRDA is its clearly stated set of rules for supporting distributed data access.\nIt is available today, and many vendors are stepping up on the DRDA.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "4) What is IMS?",
        "answer": "The term IMS stands for Information Management System. It's a database and transaction management system for Mainframe. IBM introduced it in 1968. Since then, it has gone through several upgradations and adapt some new programming tools and environments. IMS is one of two key legacy databases and transaction management subsystems from IBM that run on mainframe operating systems, and other is CICS.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "5) Name the versions of IBM mainframes have introduced in the market?",
        "answer": "Have a look at the History of IBM mainframes (1952-present).\nMarket name\n700/7000 series\nSystem/360\nSystem/370\nIBM 308X\nIBM 3090\nSystem/390\nzSeries 900, 800, 990, and 890\nSystem z9\nSystem z10\nzEnterprise System (z196, zEC12, z13, z14)\nArchitecture\nSystem/360\nSystem/370\nS/370-XA\nESA/370\nESA/390\nz/Architecture",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "6) What is the need for a secondary index in IMS?",
        "answer": "The secondary index is a substitute path into any IMS database. It can be used as a file to obtain the required data. A secondary index is also used to process a segment type in a sequence other than the one that is defined by the segment's key. A secondary index can also operate a segment type based on a requirement in a dependent segment.\nSecondary indexing provides an opportunity to meet the different processing requirements of various applications.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "7) What is CICS?",
        "answer": "The term CICS stands for Customer Information Control System. CICS was introduced in 1968 by IBM. CICS provides an MVS environment to develop and execute an online application. Nowadays, CICS has become the most generally used server for Internet applications. CICS is a transaction processing system which is also called as OLTP (Online Transaction Processing Software). CICS is a data communication system that supports a network that has hundreds of terminals.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "8) What are the CICS Transactions?",
        "answer": "CICS transactions perform multiple operations like defining CICS table entries, updating records, etc., in the CICS region.\nSome important CICS transactions supplied by IBM are as follows.\nCESN (CICS Execute Sign On)\nCEDA (CICS Execute Definition and Administration)\nCEMT (CICS Execute Master Terminal)\nCECI (CICS Execute Command Interpreter)\nCEDF (CICS Execute Debug Facility)\nCMAC (CICS Messages for Abend Codes)\nCESF (CICS Execute Sign Off)\nCEBR (CICS Execute Temporary storage Browse)",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "9) Define CICS interface block?",
        "answer": "Any application program needs an interface to interact with the CICS. EIB (Execute Interface Block) is an interface for application programs that allowed communication with the CICS. EIB holds the necessary intermediate information for the execution of a program.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "10) Explain EIB?",
        "answer": "EIB stands for Execute Interface block. It is a control block which is loaded automatically by the CICS for every program.\nThe EIB is unique for a task, and it exists till the duration of the task. It holds a set of system-related information related to the task.\nIt holds information about transaction identifier, time, date, etc., these identifier used by the CICS during the execution of an application program.\nEvery program that executes as a part of the task has access to the same EIB.\nThe runtime data in EIB can be viewed by executing the program in CEDF mode.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "11) What are the COBOL Coding Sheets?",
        "answer": "COBOL was introduced in the era of batch processing. So the COBOL program needed to be punched on the card and loaded in the punch card reader. For this process, there is a predefined structure of the coding area where the COBOL word is punched. That coding structure is called as the COBOL coding sheet.\nIn other words, the source code of a COBOL program must be written in a format that is supported by the compiler. These programs are written in Coding Sheets.\nThe Coding sheet contains 80 character position on each sheet.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "12) What is the utilization of COPYBOOK in COBOL? Could we utilize a similar COPYBOOK?",
        "answer": "COPYBOOK spares the format of any record and uses a similar design over any program. It is a selection of code that defines data structures.\nIf a particular data structure that repeatedly used in many programs, then we will avoid rewriting the same data structure and use copybooks. We will use a COPY statement to include a copybook in a program. The COPY statement is used in the Working Storage Section.\nTherefore, we can utilize a similar COPYBOOK.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "13) Describe the COBOL database components?",
        "answer": "A COBOL program requires the following components to interact with database DB2.\nEmbedded SQL\nDB2 Application Programming\nHost Variables\nSQLCA\nSQL Queries\nCursors",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "14) What are the rules for DB2 programming?",
        "answer": "The rules that are necessary for a COBOL-DB2 program are as follows.\nAll the SQL statements must be delimited between EXEC SQL and ENDEXEC.\nThe SQL statements must be written in Area B.\nAll the tables that are used in a program must be declared in the WorkingStorage Section. This is done by using the INCLUDE statement.\nAll SQL statements except INCLUDE and DECLARE TABLE must belong in the Procedure Division.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "15) Explain Host Variables?",
        "answer": "Host variables are data substances defined within a COBOL program. They are used to forward values to and receive values from a database. It can be determined under the File Section, Working-Storage Section, and Local-Storage Section or Linkage Section of COBOL program. It can have any level number up to 48. Level 49 is reserved for VARCHAR data items.\nThe data item name should begin with a colon (:) when a host variable name is used within an embedded SQL statement. It enables the Compiler to differentiate between host variables and tables or columns with the same name.\nHost variables can be used in one of the given two ways.\nInput host variables\n\nInput host variables are used to specify data that will be conveyed from the COBOL program to the database.\nOutput host variables\nOutput host variables are used to hold data that is returned to the COBOL program from the database.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "16) How to declare Host variables?",
        "answer": "Following syntax are used to declare host variables and include tables in the Working-Storage section:\nDATA DIVISION.  \nWORKING-STORAGE SECTION.  \nEXEC SQL  \nINCLUDE table-name  \nEND-EXEC.  \nEXEC SQL BEGIN DECLARE SECTION  \nEND-EXEC.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "17) Can we move alphanumeric incentive to the Numeric field?",
        "answer": "Yes, we can move alphanumeric incentive to the numeric field, and it won't make any issue. It can be done by a MOVE statement. But sometime the program may crash, in case the field is in utilized as a part of number-crunching computations.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "18) Define DB2 and its Databases?",
        "answer": "DB2 is a part of data management product, including database servers, developed by IBM. DB2 supports the relational model. Nowadays, some products have extended their functionality to support object-relational features and non-relational structure like JSON and XML.\n\nA DB2 database is a collection of different type of data like Tables, Schemas, Bufferpools, Logs, Storage groups, and Tablespaces. These data substances work together to handle database operations efficiently.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "19) How is a type of file defined in the JCL that executes the COBOL program?",
        "answer": "SORTWK01, SORTWK02, SORTWK03 ... dd Use the names in the step. The number of sorted data hang on the size of the sorted data, but at least three is required.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "20) What are some uses of the Evaluate statement? Explore the syntax of the evaluate statement?",
        "answer": "Some general uses of Evaluate statement are as follows.\nEvaluate supports multi-selection control during the program execution.\nEvaluate validate multiple conditions in a single slot.\nEvaluate statement in COBOL is similar to Case or Switch statements of other languages.\nEvaluate is an assessment is a case statement and can be used to replace local IFS.\nSyntax\nEVALUATE {Expression1}  \n    WHEN Cond-1  \n        Statement block-1  \n    WHEN Cond-2  \n        Statement block-2  \n        .  \n        .  \n        .  \n        .  \n    WHEN Cond-n  \n        Statement block-n  \n    WHEN other  \n        Statement block- other  \nEND-EVALUATE.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "21) How many types of Evaluate statements are available?",
        "answer": "Based on uses, we can divide the Evaluate statement into the following types.\nSimple EVALUATE\nEVALUATE TRUE\nEVALAUTE with THRU\nEVALUATE with multiple WHEN conditions\nEVALUATE with MULTIPLE conditions",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "22) What is JCL in mainframe, and how many types of JCL statements are there for a job?",
        "answer": "JCL stands for Job Control Language. JCL is a scripting language used on IBM mainframe operating system to instruct the system for the batch job. It is a set of statements that you code to tell the operating system about the task you want to perform. Sometimes this set of statements is quite large, but most jobs can be run using a very small subset.\nJCL statements notify OS where to find the required input, how to process that input, and what to do with the resulting output.\nThere are three main types of JCL statements for all jobs:\nFirst one is a statement to identify the unit of work that the operating system is to perform.\nThe second statement is EXEC statements, depending on the number of job steps within the job.\nThe third statement is DD statements to identify the input and output data sets.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "23) How do you access an uncatalogued dataset in a JCL?",
        "answer": "It can be done by using the UNIT and VOL serial parameters in the dataset DD statement",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "24) When the JOB statement is used?",
        "answer": "JOB statement gives the job identity to the Operating System (OS), in the spool and the scheduler. It is the first control statement in a JCL. The available parameters in the JOB statement help the OS in allocating the right scheduler. It is also useful for analyzing the required CPU time and issuing notifications to the user.\nSyntax\nThe basic syntax of a JCL JOB statement is below.\n//Job-name JOB Positional-param, Keyword-param",
        "reference": "javatpoint.com",
        "role": "mainframe"
    },
    {
        "question": "25) What is the mainframe testing? Categorize the mainframe manual testing?",
        "answer": "Mainframe Testing is testing of Mainframe Systems. Mainframe Testing is similar to web-based testing. The Mainframe application is tested against the test cases developed using requirements.\nMainframe Testing is generally performed on the deployed code using various data combinations set.\nWhile performing Mainframe testing, the tester only needs the navigations of the CICS screens.\nIf any changes made to the code in programs like COBOL, JCL, etc., then tester does not need the emulator to set up on the machine. The changes can be applied through one terminal emulator will act on others too.\nMainframe manual testing can be classified into two categories.\nBatch Job Testing\nIn batch testing, the testing process consists of executions of batch jobs for the functionality implemented in the current release.\nOnline Testing\nOnline Testing is known as testing of CICS screens, which is similar to testing of the web page.",
        "reference": "javatpoint.com",
        "role": "mainframe"
    }
]