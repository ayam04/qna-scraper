[
    {
        "question": "1. Why were client-side frameworks like Angular introduced?",
        "answer": "Back in the day, web developers used VanillaJS and jQuery to develop dynamic websites but, as the logic of one's website grew, the code became more and more tedious to maintain. For applications that use complex logic, developers had to put in extra effort to maintain the separation of concerns for the app. Also, jQuery did not provide facilities for data handling across views. For tackling the above problems, client-side frameworks like Angular came into the picture, which made life easier for the developers by handling the separation of concerns and dividing code into smaller bits of information (In the case of Angular, called Components). client-side frameworks like Angular client-side frameworks like Angular Client-side frameworks allow one to develop advanced web applications like Single-Page-Application. Not that we cannot develop SPAs using VanillaJS, but by doing so, the development process becomes slower.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "2. How does an Angular application work?",
        "answer": "Every Angular app consists of a file named angular.json. This file will contain all the configurations of the app. While building the app, the builder looks at this file to find the entry point of the application. Following is an image of the angular.json file: angular.json \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:browser\",\n        \"options\": {\n          \"outputPath\": \"dist/angular-starter\",\n          \"index\": \"src/index.html\",\n          \"main\": \"src/main.ts\",\n          \"polyfills\": \"src/polyfills.ts\",\n          \"tsConfig\": \"tsconfig.app.json\",\n          \"aot\": false,\n          \"assets\": [\n            \"src/favicon.ico\",\n            \"src/assets\"\n          ],\n          \"styles\": [\n            \"./node_modules/@angular/material/prebuilt-themes/deeppurple-amber.css\",\n            \"src/style.css\"\n          ]\n        }\n      } \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:browser\",\n        \"options\": {\n          \"outputPath\": \"dist/angular-starter\",\n          \"index\": \"src/index.html\",\n          \"main\": \"src/main.ts\",\n          \"polyfills\": \"src/polyfills.ts\",\n          \"tsConfig\": \"tsconfig.app.json\",\n          \"aot\": false,\n          \"assets\": [\n            \"src/favicon.ico\",\n            \"src/assets\"\n          ],\n          \"styles\": [\n            \"./node_modules/@angular/material/prebuilt-themes/deeppurple-amber.css\",\n            \"src/style.css\"\n          ]\n        }\n      } Inside the build section, the main property of the options object defines the entry point of the application which in this case is main.ts. main.ts The main.ts file creates a browser environment for the application to run, and, along with this, it also calls a function called bootstrapModule, which bootstraps the application. These two steps are performed in the following order inside the main.ts file: bootstrapModule import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; platformBrowserDynamic().bootstrapModule(AppModule) platformBrowserDynamic().bootstrapModule(AppModule) In the above line of code, AppModule is getting bootstrapped. AppModule The AppModule is declared in the app.module.ts file. This module contains declarations of all the components. Below is an example of app.module.ts file: import { BrowserModule } from '@angular/platform-browser';\n      import { NgModule } from '@angular/core';\n      import { AppComponent } from './app.component';\n\n      @NgModule({\n        declarations: [\n          AppComponent\n        ],\n        imports: [\n          BrowserModule\n        ],\n        providers: [],\n        entryComponents: [],\n        bootstrap: [AppComponent]\n      })\n      export class AppModule { } import { BrowserModule } from '@angular/platform-browser';\n      import { NgModule } from '@angular/core';\n      import { AppComponent } from './app.component';\n\n      @NgModule({\n        declarations: [\n          AppComponent\n        ],\n        imports: [\n          BrowserModule\n        ],\n        providers: [],\n        entryComponents: [],\n        bootstrap: [AppComponent]\n      })\n      export class AppModule { } As one can see in the above file, AppComponent is getting bootstrapped. AppComponent This component is defined in app.component.ts file. This file interacts with the webpage and serves data to it. app.component.ts Below is an example of app.component.ts file: import { Component } from '@angular/core';\n\n      @Component({\n        selector: 'app-root',\n        templateUrl: './app.component.html',\n        styleUrls: ['./app.component.css']\n      })\n      export class AppComponent {\n        title = 'angular';\n      } import { Component } from '@angular/core';\n\n      @Component({\n        selector: 'app-root',\n        templateUrl: './app.component.html',\n        styleUrls: ['./app.component.css']\n      })\n      export class AppComponent {\n        title = 'angular';\n      } Each component is declared with three properties: Selector - used for accessing the component\nTemplate/TemplateURL - contains HTML of the component\nStylesURL - contains component-specific stylesheets Selector - used for accessing the component Selector Template/TemplateURL - contains HTML of the component Template/TemplateURL StylesURL - contains component-specific stylesheets StylesURL After this, Angular calls the index.html file. This file consequently calls the root component that is app-root. The root component is defined in app.component.ts. This is how the index.html file looks: index.html app-root app.component.ts <!doctype html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"utf-8\">\n        <title>Angular</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n      </head>\n      <body>\n        <app-root></app-root>\n      </body>\n      </html> <!doctype html>\n      <html lang=\"en\">\n      <head>\n        <meta charset=\"utf-8\">\n        <title>Angular</title>\n        <base href=\"/\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n      </head>\n      <body>\n        <app-root></app-root>\n      </body>\n      </html> The HTML template of the root component is displayed inside the <app-root> tags. <app-root> This is how every angular application works.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "3. What are some of the advantages of Angular over other frameworks?",
        "answer": "Features that are provided out of the box - Angular provides a number of built-in features like routing, state management, rxjs library and http servicesstraight out of the box. This means that one does not need to look for the above-stated features separately. They are all provided with angular.\nDeclarative UI - Angular uses HTML to render the UI of an application. HTML is a declarative language and is much easier to use than JavaScript.\nLong-term Google support - Google announced Long-term support for Angular. This means that Google plans to stick with Angular and further scale up its ecosystem. Features that are provided out of the box - Angular provides a number of built-in features like routing, state management, rxjs library and http servicesstraight out of the box. This means that one does not need to look for the above-stated features separately. They are all provided with angular. Features that are provided out of the box - Declarative UI - Angular uses HTML to render the UI of an application. HTML is a declarative language and is much easier to use than JavaScript. Declarative UI - Long-term Google support - Google announced Long-term support for Angular. This means that Google plans to stick with Angular and further scale up its ecosystem. Long-term Google support -",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "4. What are the advantages of Angular over React?",
        "answer": "Angular vs React: Check out the differences Check out the differences Check out the differences Angular React\nAngular supports bidirectional data binding as well as mutable data. React only supports unidirectional and immutable data binding.\nThe biggest benefit of Angular is that it enables dependency injection. React allows us to either accomplish it ourselves or with the aid of a third-party library.\nAngular can be used in both mobile and web development. React can only be used in UI development only.\nAngular features a wide wide range of tools, libraries, frameworks, plugins, and so on that make development faster and more fun. In React we can use third-party libraries for any features.\nAngular uses Typescript. React uses Javascript. Angular React\nAngular supports bidirectional data binding as well as mutable data. React only supports unidirectional and immutable data binding.\nThe biggest benefit of Angular is that it enables dependency injection. React allows us to either accomplish it ourselves or with the aid of a third-party library.\nAngular can be used in both mobile and web development. React can only be used in UI development only.\nAngular features a wide wide range of tools, libraries, frameworks, plugins, and so on that make development faster and more fun. In React we can use third-party libraries for any features.\nAngular uses Typescript. React uses Javascript. Angular React Angular React Angular React Angular supports bidirectional data binding as well as mutable data. React only supports unidirectional and immutable data binding.\nThe biggest benefit of Angular is that it enables dependency injection. React allows us to either accomplish it ourselves or with the aid of a third-party library.\nAngular can be used in both mobile and web development. React can only be used in UI development only.\nAngular features a wide wide range of tools, libraries, frameworks, plugins, and so on that make development faster and more fun. In React we can use third-party libraries for any features.\nAngular uses Typescript. React uses Javascript. Angular supports bidirectional data binding as well as mutable data. React only supports unidirectional and immutable data binding. Angular supports bidirectional data binding as well as mutable data. React only supports unidirectional and immutable data binding. The biggest benefit of Angular is that it enables dependency injection. React allows us to either accomplish it ourselves or with the aid of a third-party library. The biggest benefit of Angular is that it enables dependency injection. React allows us to either accomplish it ourselves or with the aid of a third-party library. Angular can be used in both mobile and web development. React can only be used in UI development only. Angular can be used in both mobile and web development. React can only be used in UI development only. Angular features a wide wide range of tools, libraries, frameworks, plugins, and so on that make development faster and more fun. In React we can use third-party libraries for any features. Angular features a wide wide range of tools, libraries, frameworks, plugins, and so on that make development faster and more fun. In React we can use third-party libraries for any features. Angular uses Typescript. React uses Javascript. Angular uses Typescript. React uses Javascript.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "5. List out differences between AngularJS and Angular?",
        "answer": "Check out the differences between AngularJS and Angular below. For More Information, Click here. Click here Click here Features AngularJS Angular\nArchitecture AngularJS uses MVC or Model-View-Controller architecture, where the Model contains the business logic, the Controller processes information and the View shows the information present in the Model. Angular replaces controllers with Components. Components are nothing but directives with a predefined template.\nLanguage AngularJS uses JavaScript language, which is a dynamically typed language. Angular uses TypeScript language, which is a statically typed language and is a superset of JavaScript. By using statically typed language, Angular provides better performance while developing larger applications.\nMobile Support AngularJS does not provide mobile support. Angular is supported by all popular mobile browsers.\nStructure While developing larger applications, the process of maintaining code becomes tedious in the case of AngularJS. In the case of Angular, it is easier to maintain code for larger applications as it provides a better structure.\nExpression Syntax While developing an AngularJS application, a developer needs to remember the correct ng-directive for binding an event or a property.  Whereas in Angular, property binding is done using \"[ ]\" attribute and event binding is done using \"( )\" attribute. Features AngularJS Angular\nArchitecture AngularJS uses MVC or Model-View-Controller architecture, where the Model contains the business logic, the Controller processes information and the View shows the information present in the Model. Angular replaces controllers with Components. Components are nothing but directives with a predefined template.\nLanguage AngularJS uses JavaScript language, which is a dynamically typed language. Angular uses TypeScript language, which is a statically typed language and is a superset of JavaScript. By using statically typed language, Angular provides better performance while developing larger applications.\nMobile Support AngularJS does not provide mobile support. Angular is supported by all popular mobile browsers.\nStructure While developing larger applications, the process of maintaining code becomes tedious in the case of AngularJS. In the case of Angular, it is easier to maintain code for larger applications as it provides a better structure.\nExpression Syntax While developing an AngularJS application, a developer needs to remember the correct ng-directive for binding an event or a property.  Whereas in Angular, property binding is done using \"[ ]\" attribute and event binding is done using \"( )\" attribute. Features AngularJS Angular Features AngularJS Angular Features AngularJS Angular Architecture AngularJS uses MVC or Model-View-Controller architecture, where the Model contains the business logic, the Controller processes information and the View shows the information present in the Model. Angular replaces controllers with Components. Components are nothing but directives with a predefined template.\nLanguage AngularJS uses JavaScript language, which is a dynamically typed language. Angular uses TypeScript language, which is a statically typed language and is a superset of JavaScript. By using statically typed language, Angular provides better performance while developing larger applications.\nMobile Support AngularJS does not provide mobile support. Angular is supported by all popular mobile browsers.\nStructure While developing larger applications, the process of maintaining code becomes tedious in the case of AngularJS. In the case of Angular, it is easier to maintain code for larger applications as it provides a better structure.\nExpression Syntax While developing an AngularJS application, a developer needs to remember the correct ng-directive for binding an event or a property.  Whereas in Angular, property binding is done using \"[ ]\" attribute and event binding is done using \"( )\" attribute. Architecture AngularJS uses MVC or Model-View-Controller architecture, where the Model contains the business logic, the Controller processes information and the View shows the information present in the Model. Angular replaces controllers with Components. Components are nothing but directives with a predefined template. Architecture AngularJS uses MVC or Model-View-Controller architecture, where the Model contains the business logic, the Controller processes information and the View shows the information present in the Model. Angular replaces controllers with Components. Components are nothing but directives with a predefined template. Language AngularJS uses JavaScript language, which is a dynamically typed language. Angular uses TypeScript language, which is a statically typed language and is a superset of JavaScript. By using statically typed language, Angular provides better performance while developing larger applications. Language AngularJS uses JavaScript language, which is a dynamically typed language. Angular uses TypeScript language, which is a statically typed language and is a superset of JavaScript. By using statically typed language, Angular provides better performance while developing larger applications. Mobile Support AngularJS does not provide mobile support. Angular is supported by all popular mobile browsers. Mobile Support AngularJS does not provide mobile support. Angular is supported by all popular mobile browsers. Structure While developing larger applications, the process of maintaining code becomes tedious in the case of AngularJS. In the case of Angular, it is easier to maintain code for larger applications as it provides a better structure. Structure While developing larger applications, the process of maintaining code becomes tedious in the case of AngularJS. In the case of Angular, it is easier to maintain code for larger applications as it provides a better structure. Expression Syntax While developing an AngularJS application, a developer needs to remember the correct ng-directive for binding an event or a property.  Whereas in Angular, property binding is done using \"[ ]\" attribute and event binding is done using \"( )\" attribute. Expression Syntax While developing an AngularJS application, a developer needs to remember the correct ng-directive for binding an event or a property. Whereas in Angular, property binding is done using \"[ ]\" attribute and event binding is done using \"( )\" attribute.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "6. How are Angular expressions different from JavaScript expressions?",
        "answer": "The first and perhaps, the biggest difference is that Angular expressions allow us to write JavaScript in HTML which is not the case when it comes to JavaScript expressions. Next, Angular expressions are evaluated against a local scope object whereas JavaScript expressions are against a global window object. Let's understand that better with an example : local global Consider the following component named test: import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-test',\n        template: `\n            <h4>{{message}}</h4>\n        `,\n        styleUrls: ['./test.component.css']\n      })\n      export class TestComponent implements OnInit {\n        message:string = “Hello world”;\n        constructor() { }\n\n        ngOnInit() {\n        }\n      } import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-test',\n        template: `\n            <h4>{{message}}</h4>\n        `,\n        styleUrls: ['./test.component.css']\n      })\n      export class TestComponent implements OnInit {\n        message:string = “Hello world”;\n        constructor() { }\n\n        ngOnInit() {\n        }\n      } As one can see that Angular expression is used to display the message property of a component. Since we are using Angular expressions, in the present template, we cannot access a property outside of its local scope, which in this case is TestComponent. message TestComponent This proves that Angular expressions are always evaluated based on the scope object rather than the global object. scope The next difference is how Angular expressions handle null and undefined. null undefined Consider the following JavaScript example: <!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n          <meta charset=\"UTF-8\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n          <title>JavaScript Test</title>\n      </head>\n      <body>\n          <div id=\"foo\"><div>\n      </body>\n      <script>\n          'use strict';\n          let bar = {};\n          document.getElementById('foo').innerHTML = bar.x;\n      </script>\n      </html> <!DOCTYPE html>\n      <html lang=\"en\">\n      <head>\n          <meta charset=\"UTF-8\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n          <title>JavaScript Test</title>\n      </head>\n      <body>\n          <div id=\"foo\"><div>\n      </body>\n      <script>\n          'use strict';\n          let bar = {};\n          document.getElementById('foo').innerHTML = bar.x;\n      </script>\n      </html> <!DOCTYPE html> html <html lang=\"en\"> html lang \"en\" <head> head <meta charset=\"UTF-8\"> meta charset \"UTF-8\" <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> meta name \"viewport\" content \"width=device-width, initial-scale=1.0\" <title> title </title> title </head> head <body> body <div id=\"foo\"> div id \"foo\" <div> div </body> body <script> script 'use strict';\n          let bar = {};\n          document.getElementById('foo').innerHTML = bar.x; 'use strict' let document 'foo' </script> script </html> html If you run the above code, you will see undefined displayed on the screen. Although it’s not ideal to leave any property undefined, the user does not need to see this. undefined Now consider the following Angular example: import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-new',\n        template: `\n            <h4>{{message}}</h4>\n        `,\n        styleUrls: ['./new.component.css']\n      })\n      export class NewComponent implements OnInit {\n        message:object = {};\n        constructor() { }\n\n        ngOnInit() {\n        }\n\n      } import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-new',\n        template: `\n            <h4>{{message}}</h4>\n        `,\n        styleUrls: ['./new.component.css']\n      })\n      export class NewComponent implements OnInit {\n        message:object = {};\n        constructor() { }\n\n        ngOnInit() {\n        }\n\n      } If you render the above component, you will not see undefined being displayed on the screen. not Next, in Angular expressions, one cannot use loops, conditionals and exceptions. cannot The difference which makes Angular expressions quite beneficial is the use of pipes. Angular uses pipes(called filters in AngularJS), which can be used to format data before displaying it. Let’s see one predefined pipe in action: pipes import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-new',\n        template: `\n            <h4>{{message | lowercase}}</h4>\n        `,\n        styleUrls: ['./new.component.css']\n      })\n      export class NewComponent implements OnInit {\n        message:string = \"HELLO WORLD\";\n        constructor() { }\n\n        ngOnInit() {\n        }\n\n      } import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-new',\n        template: `\n            <h4>{{message | lowercase}}</h4>\n        `,\n        styleUrls: ['./new.component.css']\n      })\n      export class NewComponent implements OnInit {\n        message:string = \"HELLO WORLD\";\n        constructor() { }\n\n        ngOnInit() {\n        }\n\n      } In the above code, we have used a predefined pipe called lowercase, which transforms all the letters in lowercase. Therefore, if you render the above component, you will see “hello world” being displayed.\n\nIn contrast, JavaScript does not have the concept of pipes. lowercase   pipes.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "7. What are Single Page Applications (SPA)?",
        "answer": "Single page applications are web based applications that only need to be loaded once, with new functionality consisting of only minor changes to the user interface. It does not load new HTML pages to display the content of the new page, but rather generates it dynamically. This is made feasible by JavaScript's ability to alter DOM components on the current page. A Single Page Application method is speedier, resulting in a more consistent user experience.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "8. What are templates in Angular?",
        "answer": "A template is a kind of HTML that instructs Angular about how to display a component. An Angular HTML template, like conventional HTML, produces a view, or user interface, in the browser, but with far more capabilities. Angular API evaluates an HTML template of a component, creates HTML, and renders it. There are two ways to create a template in an Angular component: There are two ways to create a template in an Angular component: Inline Template\nLinked Template Inline Template Linked Template Inline Template: The component decorator's template config is used to specify an inline HTML template for a component. The Template will be wrapped inside the single or double quotes. Inline Template: Example: Example: @Component({\n    selector: \"app-greet\",\n    template: `<div>\n        <h1> Hello {{name}} how are you ? </h1>\n        <h2> Welcome to interviewbit ! </h2>\n    </div>`\n}) @Component({\n    selector: \"app-greet\",\n    template: `<div>\n        <h1> Hello {{name}} how are you ? </h1>\n        <h2> Welcome to interviewbit ! </h2>\n    </div>`\n}) Linked Template: A component may include an HTML template in a separate HTML file. As illustrated below, the templateUrl option is used to indicate the path of the HTML template file. Linked Template: Example: Example: @Component({\n    selector: \"app-greet\",\n    templateUrl: \"./component.html\"\n}) @Component({\n    selector: \"app-greet\",\n    templateUrl: \"./component.html\"\n})",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "9. What are directives in Angular?",
        "answer": "A directive is a class in Angular that is declared with a @Directive decorator. @Directive Every directive has its own behaviour and can be imported into various components of an application. When to use a directive? When to use a directive? Consider an application, where multiple components need to have similar functionalities. The norm thing to do is by adding this functionality individually to every component but, this task is tedious to perform. In such a situation, one can create a directive having the required functionality and then, import the directive to components which require this functionality. directive Types of directives: Types of directives: 1. Component directives 1. Component directives These form the main class in directives. Instead of @Directive decorator we use @Component decorator to declare these directives. These directives have a view, a stylesheet and a selector property. Instead @Component 2. Structural directives 2. Structural directives These directives are generally used to manipulate DOM elements.\nEvery structural directive has a ‘ * ’ sign before them.\nWe can apply these directives to any DOM element. These directives are generally used to manipulate DOM elements. Every structural directive has a ‘ * ’ sign before them. We can apply these directives to any DOM element. Let’s see some built-in structural directives in action: <div *ngIf=\"isReady\" class=\"display_name\">\n          {{name}}\n      </div>\n\n\n<div class=\"details\" *ngFor=\"let x of details\" >\n          <p>{{x.name}}</p>\n          <p> {{x.address}}</p>\n          <p>{{x.age}}</p>\n            </div> <div *ngIf=\"isReady\" class=\"display_name\">\n          {{name}}\n      </div>\n\n\n<div class=\"details\" *ngFor=\"let x of details\" >\n          <p>{{x.name}}</p>\n          <p> {{x.address}}</p>\n          <p>{{x.age}}</p>\n            </div> <div *ngIf=\"isReady\" class=\"display_name\"> div ngIf \"isReady\" class \"display_name\" </div> div <div class=\"details\" *ngFor=\"let x of details\" > div class \"details\" ngFor \"let x of details\" <p> p </p> p <p> p </p> p <p> p </p> p </div> div In the above example, we can *ngIf and *ngFor directives being used. *ngIf is used to check a boolean value and if it’s truthy,the div element will be displayed. *ngFor is used to iterate over a list and display each item of the list. 3. Attribute Directives 3. Attribute Directives These directives are used to change the look and behaviour of a DOM element. Let’s understand attribute directives by creating one: How to create a custom directive? How to create a custom directive? We’re going to create an attribute directive: In the command terminal, navigate to the directory of the angular app and type the following command to generate a directive: ng g directive blueBackground ng g directive blueBackground The following directive will be generated. Manipulate the directive to look like this: import { Directive, ElementRef } from '@angular/core';\n\n      @Directive({\n       selector: '[appBlueBackground]'\n      })\n      export class BlueBackgroundDirective {\n       constructor(el:ElementRef) {\n         el.nativeElement.style.backgroundColor = \"blue\";\n       }\n      } import { Directive, ElementRef } from '@angular/core';\n\n      @Directive({\n       selector: '[appBlueBackground]'\n      })\n      export class BlueBackgroundDirective {\n       constructor(el:ElementRef) {\n         el.nativeElement.style.backgroundColor = \"blue\";\n       }\n      } Now we can apply the above directive to any DOM element:  <p appBlueBackground>Hello World!</p> <p appBlueBackground>Hello World!</p>",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "10. Explain Components, Modules and Services in Angular",
        "answer": "For better understanding, I would like you to create an Angular application by running the following inside the command terminal: ng new angularApp ng new angularApp The above command will create an angular application in the directory. Next, let's move on to understand Components, Modules, and Services. Components Components Components In Angular, components are the basic building blocks, which control a part of the UI for any application. A component is defined using the @Component decorator. Every component consists of three parts, the template which loads the view for the component, a stylesheet which defines the look and feel for the component, and a class that contains the business logic for the component. @Component For creating a component, inside the command terminal, navigate to the directory of the application created, and run the following command: ng generate component testOr ng g c test ng generate component test ng g c test One can see the generated component inside src/app/test folder. The component will be defined inside test.component.ts and this is how it looks: import { Component, OnInit } from '@angular/core';\n     @Component({\n       selector: 'app-test',\n       templateUrl: './test.component.html',\n       styleUrls: ['./test.component.css']\n     })\n     export lass TestComponent implements OnInit {\n       constructor() {}\n       ngOnInit() {\n       }\n     } import { Component, OnInit } from '@angular/core';\n     @Component({\n       selector: 'app-test',\n       templateUrl: './test.component.html',\n       styleUrls: ['./test.component.css']\n     })\n     export lass TestComponent implements OnInit {\n       constructor() {}\n       ngOnInit() {\n       }\n     } As we can see in the above image, our component is defined with @Component decorator. @Component Modules Modules Modules A module is a place where we can group components, directives, services, and pipes. Module decides whether the components, directives, etc can be used by other modules, by exporting or hiding these elements. Every module is defined with a @NgModule decorator. By default, modules are of two types: Root Module\nFeature Module Root Module Feature Module Every application can have only one root module whereas, it can have one or more feature modules. A root module imports BrowserModule, whereas a feature module imports CommonModule. BrowserModule CommonModule In the application that we created before, one can see that the root module is defined inside app.module.ts and this is how it looks: app.module.ts import { BrowserModule } from '@angular/platform-browser';\n      import { NgModule } from '@angular/core';\n\n      import { AppComponent } from './app.component';\n      import { TestComponent } from './test/text.component';\n\n      @NgModule({\n        declarations: [\n          AppComponent,\n          TestComponent\n        ],\n        imports: [\n          BrowserModule\n        ],\n        providers: [],\n        bootstrap: [AppComponent]\n      })\n      export class AppModule { } import { BrowserModule } from '@angular/platform-browser';\n      import { NgModule } from '@angular/core';\n\n      import { AppComponent } from './app.component';\n      import { TestComponent } from './test/text.component';\n\n      @NgModule({\n        declarations: [\n          AppComponent,\n          TestComponent\n        ],\n        imports: [\n          BrowserModule\n        ],\n        providers: [],\n        bootstrap: [AppComponent]\n      })\n      export class AppModule { } We can see in the above image that the component we created earlier is already imported in the declarations array. To create a feature module, run the following command: ng g m test-module ng g m test-module The module is created inside the src/app/test-module/test-module.module.ts file: import { NgModule } from '@angular/core';\n      import { CommonModule } from '@angular/common';\n\n      @NgModule({\n        declarations: [],\n        imports: [\n          CommonModule\n        ]\n      })\n      export class TestModuleModule { } import { NgModule } from '@angular/core';\n      import { CommonModule } from '@angular/common';\n\n      @NgModule({\n        declarations: [],\n        imports: [\n          CommonModule\n        ]\n      })\n      export class TestModuleModule { } As one can see, CommonModule is imported since this is a feature module. CommonModule Services Services Services Services are objects which get instantiated only once during the lifetime of an application. The main objective of a service is to share data, functions with different components of an Angular application. A service is defined using a @Injectable decorator. A function defined inside a service can be invoked from any component or directive. @Injectable To create a service, run the following command: ng g s test-service ng g s test-service The service will be created inside src/app/test-service.service.ts: import { Injectable } from '@angular/core';\n\n      @Injectable({\n        providedIn: 'root'\n      })\n      export class TestServiceService {\n\n        constructor() { }\n\n      } import { Injectable } from '@angular/core';\n\n      @Injectable({\n        providedIn: 'root'\n      })\n      export class TestServiceService {\n\n        constructor() { }\n\n      } Any method/function defined inside the TestServiceService class can be directly used inside any component by just importing the service.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "11. What is the scope?",
        "answer": "In Angular, a scope is an object that refers to the application model. It is a context in which expressions can be executed. These scopes are grouped hierarchically, comparable to the DOM structure of the application. A scope aids in the propagation of various events and the monitoring of expressions.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "12. What is data binding in Angular?",
        "answer": "Data binding is one of the most significant and effective elements for creating communication between the DOM and the component. It makes designing interactive apps easier by reducing the need to worry about data pushing and pulling between the component and the template. There are Four types of Data binding in Angular: There are Four types of Data binding in Angular: Property Binding\nEvent Binding\nString Interpolation\nTwo way data binding Property Binding Event Binding String Interpolation Two way data binding Property Binding: One method of data binding is called property binding. In property binding, we connect a DOM element's property to a field that is a declared property in our TypeScript component code. In reality, Angular transforms string interpolation into property binding internally. Property Binding: Event Binding: Using event binding, you may respond to DOM events like button clicks and mouse movements. When a DOM event (such as a click, change, or keyup) occurs, the component's designated method is called. Event Binding: String Interpolation: In order to export data from TypeScript code to an HTML template( view ), String Interpolation is a one way data binding approach. The data from the component is shown to the view using the template expression enclosed in double curly braces. The value of a component property is added by using string interpolation. String Interpolation:",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "13. What is two way data binding in Angular?",
        "answer": "Data sharing between a component class and its template is referred to as two-way data binding. If you alter data in one area, it will immediately reflate at the other end. This happens instantly and automatically, ensuring that the HTML template and TypeScript code are always up to date. Property binding and event binding are coupled in two-way data binding.   Example: Example: app.component.ts app.component.ts import { Component } from \"@angular/core\";\n \n@Component({\n  selector: \"app\",\n  templateUrl: \"./app.component.html\",\n})\nexport class AppComponent {\n  data = \"This is an example component of two way data binding.\";\n} import { Component } from \"@angular/core\";\n \n@Component({\n  selector: \"app\",\n  templateUrl: \"./app.component.html\",\n})\nexport class AppComponent {\n  data = \"This is an example component of two way data binding.\";\n} app.component.html app.component.html <input [(ngModel)]=\"data\"  type=\"text\">\n  <br> <br>\n  <h2> You entered the data:  {{data}}</h2> <input [(ngModel)]=\"data\"  type=\"text\">\n  <br> <br>\n  <h2> You entered the data:  {{data}}</h2> app.module.ts app.module.ts import { NgModule } from \"@angular/core\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { FormsModule } from \"@angular/forms\";\n \nimport { AppComponent } from \"./app.component\";\n \n@NgModule({\n  imports: [BrowserModule, FormsModule],\n  declarations: [AppComponent],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {} import { NgModule } from \"@angular/core\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { FormsModule } from \"@angular/forms\";\n \nimport { AppComponent } from \"./app.component\";\n \n@NgModule({\n  imports: [BrowserModule, FormsModule],\n  declarations: [AppComponent],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "14. What are Decorators and their types in Angular?",
        "answer": "Decorators are a fundamental concept in TypeScript, and because Angular heavily relies on TypeScript, decorators have become an important element of Angular as well. Decorators are methods or design patterns that are labeled with a prefixed @ symbol and preceded by a class, method, or property. They enable the modification of a service, directive, or filter before it is utilized. A decorator, in essence, provides configuration metadata that specifies how a component, class, or method should be processed, constructed, and used at runtime. Angular includes a number of decorators which attach various types of metadata to classes, allowing the system to understand what all these classes signify and how they should function. Types of decorators: Types of decorators: Method Decorator: Method decorators, as the name implies, are used to add functionality to the methods defined within our class.\nClass Decorator: Class Decorators are the highest-level decorators that determine the purpose of the classes. They indicate to Angular that a specific class is a component or module. And the decorator enables us to declare this effect without having to write any code within the class.\nParameter Decorator: The arguments of your class constructors are decorated using parameter decorators.\nProperty Decorator: These are the second most popular types of decorators. They enable us to enhance some of the properties in our classes. Method Decorator: Method decorators, as the name implies, are used to add functionality to the methods defined within our class. Method Decorator: Class Decorator: Class Decorators are the highest-level decorators that determine the purpose of the classes. They indicate to Angular that a specific class is a component or module. And the decorator enables us to declare this effect without having to write any code within the class. Class Decorator: Parameter Decorator: The arguments of your class constructors are decorated using parameter decorators. Parameter Decorator: Property Decorator: These are the second most popular types of decorators. They enable us to enhance some of the properties in our classes. Property Decorator:",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "15. What are annotations in Angular ?",
        "answer": "These are language features that are hard-coded. Annotations are merely metadata that is set on a class to reflect the metadata library. When a user annotates a class, the compiler adds an annotations property to the class, saves an annotation array in it, and then attempts to instantiate an object with the same name as the annotation, providing the metadata into the constructor. Annotations in AngularJs are not predefined, therefore we can name them ourselves.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "16. What are pure Pipes?",
        "answer": "These are pipelines that only employ pure functions. As a result, a pure pipe does not employ any internal state, and the output remains constant as long as the parameters provided remain constant. Angular calls the pipe only when the parameters being provided change. A single instance of the pure pipe is utilized in all components.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "17. What are impure pipes?",
        "answer": "Angular calls an impure pipe for each change detection cycle, independent of the change in the input fields. For each of these pipes, several pipe instances are produced. These pipes' inputs can be altered. By default, all pipelines are pure. However, as demonstrated below, you can specify impure pipes using the pure property. Example: Example: @Pipe({\n    name: 'impurePipe',\n    pure: false/true    \n})\nexport class ImpurePipe {} @Pipe({\n    name: 'impurePipe',\n    pure: false/true    \n})\nexport class ImpurePipe {}",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "18. What is Pipe transform Interface in Angular?",
        "answer": "An interface used by pipes to accomplish a transformation. Angular calls the transform function with the value of a binding as the first argument and any arguments as the second parameter in list form. This interface is used to implement custom pipes. Example: Example: import { Pipe, PipeTransform } from '@angular/core';\n @Pipe({\n  name: 'tranformpipe'\n})\nexport class TranformpipePipe implements PipeTransform {\n  transform(value: unknown, ...args: unknown[]): unknown {\n    return null;\n  }\n} import { Pipe, PipeTransform } from '@angular/core';\n @Pipe({\n  name: 'tranformpipe'\n})\nexport class TranformpipePipe implements PipeTransform {\n  transform(value: unknown, ...args: unknown[]): unknown {\n    return null;\n  }\n}",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "19. Write a code where you have to share data from the Parent to Child Component?",
        "answer": "You have to share the data amongst the components in numerous situations. It may consist of unrelated, parent-child, or child-parent components. The @Input decorator allows any data to be sent from parent to child. // parent component\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-parent',\n  template: `\n<app-child [childMessage]=\"parentMessage\"></app-child>\n`,\n  styleUrls: ['./parent.component.css']\n})\nexport class ParentComponent{\n  parentMessage = \"message from parent\"\n  constructor() { }\n}\n// child component\nimport { Component, Input } from '@angular/core';\n@Component({\n  selector: 'app-child',\n  template: `Say {{ childMessage }}`,\n  styleUrls: ['./child.component.css']\n})\nexport class ChildComponent {\n  @Input() childMessage: string;\n  constructor() { }\n} // parent component\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-parent',\n  template: `\n<app-child [childMessage]=\"parentMessage\"></app-child>\n`,\n  styleUrls: ['./parent.component.css']\n})\nexport class ParentComponent{\n  parentMessage = \"message from parent\"\n  constructor() { }\n}\n// child component\nimport { Component, Input } from '@angular/core';\n@Component({\n  selector: 'app-child',\n  template: `Say {{ childMessage }}`,\n  styleUrls: ['./child.component.css']\n})\nexport class ChildComponent {\n  @Input() childMessage: string;\n  constructor() { }\n}",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "20. Create a TypeScript class with a constructor and a function.",
        "answer": "class IB {\n    name: string;\n    constructor(message: string) {\n      this.name = message;\n    }\n    greet() {\n      return \"Hello, \" + this.name + \"How are you\";\n    }\n  }\n  let msg = new IB(\"IB\"); class IB {\n    name: string;\n    constructor(message: string) {\n      this.name = message;\n    }\n    greet() {\n      return \"Hello, \" + this.name + \"How are you\";\n    }\n  }\n  let msg = new IB(\"IB\");",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "1. Explain MVVM architecture",
        "answer": "MVVM architecture consists of three parts: Model\nView\nViewModel Model View ViewModel   Model contains the structure of an entity. In simple terms it contains data of an object.\nView is the visual layer of the application. It displays the data contained inside the Model. In angular terms, this will be the HTML template of a component.\nViewModel is an abstract layer of the application. A viewmodel handles the logic of the application. It manages the data of a model and displays it in the view. Model contains the structure of an entity. In simple terms it contains data of an object. Model View is the visual layer of the application. It displays the data contained inside the Model. In angular terms, this will be the HTML template of a component. View ViewModel is an abstract layer of the application. A viewmodel handles the logic of the application. It manages the data of a model and displays it in the view. ViewModel View and ViewModel are connected with data-binding (two-way data-binding in this case). Any change in the view, the viewmodel takes a note and changes the appropriate data inside the model. View and ViewModel",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "2. What is a bootstrapping module?",
        "answer": "Every application contains at least one Angular module, which is referred to as the bootstrapping module. AppModule is the most popular name for it. Example: The following is the default structure of an AngularCLI-generated AppModule: Example: import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpClientModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { } import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpClientModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "3. What is Change Detection, and how does the Change Detection Mechanism work?",
        "answer": "The process of synchronizing a model with a view is known as Change Detection. Even when utilizing the ng Model to implement two-way binding, which is syntactic sugar on top of a unidirectional flow. Change detection is incredibly fast, but as an app's complexity and the number of components increase, change detection will have to do more and more work. Change Detection Mechanism-moves only ahead and never backward, beginning with the root component and ending with the last component. This is what one-way data flow entails. The tree of components is the architecture of an Angular application. Each component is a child, but the child is not a parent. A $digest loop is no longer required with the one-way flow.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "4. What is AOT compilation? What are the advantages of AOT?",
        "answer": "Every Angular application consists of components and templates that the browser cannot understand. Therefore, all the Angular applications need to be compiled first before running inside the browser. Angular provides two types of compilation: JIT(Just-in-Time) compilation\nAOT(Ahead-of-Time) compilation JIT(Just-in-Time) compilation AOT(Ahead-of-Time) compilation   In JIT compilation, the application compiles inside the browser during runtime. Whereas in the AOT compilation, the application compiles during the build time. The advantages of using AOT compilation are: Since the application compiles before running inside the browser, the browser loads the executable code and renders the application immediately, which leads to faster rendering.\nIn AOT compilation, the compiler sends the external HTML and CSS files along with the application, eliminating separate AJAX requests for those source files, which leads to fewer ajax requests.\nDevelopers can detect and handle errors during the building phase, which helps in minimizing errors.\nThe AOT compiler adds HTML and templates into the JS files before they run inside the browser. Due to this, there are no extra HTML files to be read, which provide better security to the application. Since the application compiles before running inside the browser, the browser loads the executable code and renders the application immediately, which leads to faster rendering. faster rendering In AOT compilation, the compiler sends the external HTML and CSS files along with the application, eliminating separate AJAX requests for those source files, which leads to fewer ajax requests. fewer ajax requests Developers can detect and handle errors during the building phase, which helps in minimizing errors. minimizing errors The AOT compiler adds HTML and templates into the JS files before they run inside the browser. Due to this, there are no extra HTML files to be read, which provide better security to the application. better security By default, angular builds and serves the application using JIT compiler: ng build\nng serve ng build\nng serve For using AOT compiler following changes should be made: ng build --aot\nng serve --aot ng build --aot\nng serve --aot",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "5. What are HTTP interceptors ?",
        "answer": "Using the HttpClient, interceptors allow us to intercept incoming and outgoing HTTP requests. They are capable of handling both HttpRequest and HttpResponse. We can edit or update the value of the request by intercepting the HTTP request, and we can perform some specified actions on a specific status code or message by intercepting the answer. Example: In the following example we will set the Authorization header Bearer for all the requests: Example: token.interceptor.ts\nimport { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\nimport { Observable } from 'rxjs/Observable';\n\n@Injectable()\nexport class TokenInterceptor implements HttpInterceptor {\n    public intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const token = localStorage.getItem('token') as string;\n        if (token) {\n        req = req.clone({\n            setHeaders: {\n            'Authorization': `Bearer ${token}`\n            }\n        });\n        }\n        return next.handle(req);\n    }\n} token.interceptor.ts\nimport { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\nimport { Observable } from 'rxjs/Observable';\n\n@Injectable()\nexport class TokenInterceptor implements HttpInterceptor {\n    public intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const token = localStorage.getItem('token') as string;\n        if (token) {\n        req = req.clone({\n            setHeaders: {\n            'Authorization': `Bearer ${token}`\n            }\n        });\n        }\n        return next.handle(req);\n    }\n} We have to register the interceptor as singleton in the module providers app.module.ts\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { AppComponent } from './app.component';\nimport { TokenInterceptor } from './token.interceptor';\n\n@NgModule({\nimports: [\n    BrowserModule\n],\ndeclarations: [\n    AppComponent\n],\nbootstrap: [AppComponent],\nproviders: [{\n    provide: HTTP_INTERCEPTORS,\n    useClass: TokenInterceptor,\n    multi: true\n}]\n})\nexport class AppModule {} app.module.ts\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { AppComponent } from './app.component';\nimport { TokenInterceptor } from './token.interceptor';\n\n@NgModule({\nimports: [\n    BrowserModule\n],\ndeclarations: [\n    AppComponent\n],\nbootstrap: [AppComponent],\nproviders: [{\n    provide: HTTP_INTERCEPTORS,\n    useClass: TokenInterceptor,\n    multi: true\n}]\n})\nexport class AppModule {}",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "6. What is transpiling in Angular ?",
        "answer": "Transpiling is the process of transforming the source code of one programming language into the source code of another. Typically, in Angular, this implies translating TypeScript to JavaScript. TypeScript (or another language like as Dart) can be used to develop code for your Angular application, which is subsequently transpiled to JavaScript. This occurs naturally and internally.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "7. What is ngOnInit?",
        "answer": "ngOnInit is a lifecycle hook and callback function used by Angular to mark the creation of a component. It accepts no arguments and returns a void type. Example: Example: export class MyComponent implements OnInit {\nconstructor() { }\n    ngOnInit(): void {\n        //....\n    }\n} export class MyComponent implements OnInit {\nconstructor() { }\n    ngOnInit(): void {\n        //....\n    }\n}",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "8. What does Angular Material means?",
        "answer": "Angular Material is a user interface component package that enables professionals to create a uniform, appealing, and fully functioning websites, web pages, and web apps. It does this by adhering to contemporary web design concepts such as gentle degradation and browser probability.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "9. What exactly is the router state?",
        "answer": "RouterState is a route tree. This tree's nodes are aware of the \"consumed\" URL segments, retrieved arguments, and processed data. You may use the Router service and the routerState property to get the current RouterState from anywhere in the application. Example: Example: @Component({templateUrl:'example.html'})\nclass MyComponent {\n  constructor(router: Router) {\n    const state: RouterState = router.routerState;\n    const root: ActivatedRoute = state.root;\n    const child = root.firstChild;\n    const id: Observable<string> = child.params.map(p => p.id);\n    //...\n  }\n} @Component({templateUrl:'example.html'})\nclass MyComponent {\n  constructor(router: Router) {\n    const state: RouterState = router.routerState;\n    const root: ActivatedRoute = state.root;\n    const child = root.firstChild;\n    const id: Observable<string> = child.params.map(p => p.id);\n    //...\n  }\n}",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "10. What are router links?",
        "answer": "RouterLink is an anchor tag directive that gives the router authority over those elements. Because the navigation routes are set. Example: As seen below, you may pass string values to the router-link directive. Example: <h1>Example of an Angular Router</h1>\n<nav>\n  <a routerLink=\"/home\" >Home Page of our website</a>\n  <a routerLink=\"/about-us\" >About us</a>\n</nav>\n<router-outlet></router-outlet> <h1>Example of an Angular Router</h1>\n<nav>\n  <a routerLink=\"/home\" >Home Page of our website</a>\n  <a routerLink=\"/about-us\" >About us</a>\n</nav>\n<router-outlet></router-outlet>",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "11. What are lifecycle hooks in Angular? Explain a few lifecycle hooks.",
        "answer": "Every component in Angular has a lifecycle, and different phases it goes through from the time of creation to the time it's destroyed. Angular provides hooks to tap into these phases and trigger changes at specific phases in a lifecycle. hooks   ngOnChanges( ) This hook/method is called before ngOnInit and whenever one or more input properties of the component change.\nThis method/hook receives a SimpleChanges object which contains the previous and current values of the property.\nngOnInit( ) This hook gets called once, after the ngOnChanges hook.\nIt initializes the component and sets the input properties of the component.\nngDoCheck( ) It gets called after ngOnChanges and ngOnInit and is used to detect and act on changes that cannot be detected by Angular.\nWe can implement our change detection algorithm in this hook. ngAfterContentInit( ) It gets called after the first ngDoCheck hook. This hook responds after the content gets projected inside the component.\nngAfterContentChecked( ) It gets called after ngAfterContentInit and every subsequent ngDoCheck. It responds after the projected content is checked.\nngAfterViewInit( ) It responds after a component's view, or a child component's view is initialized.\nngAfterViewChecked( ) It gets called after ngAfterViewInit, and it responds after the component's view, or the child component's view is checked.\nngOnDestroy( ) It gets called just before Angular destroys the component. This hook can be used to clean up the code and detach event handlers. ngOnChanges( ) This hook/method is called before ngOnInit and whenever one or more input properties of the component change.\nThis method/hook receives a SimpleChanges object which contains the previous and current values of the property. ngOnChanges( )  ngOnInit( ) This hook gets called once, after the ngOnChanges hook.\nIt initializes the component and sets the input properties of the component. ngOnInit( )  ngDoCheck( ) It gets called after ngOnChanges and ngOnInit and is used to detect and act on changes that cannot be detected by Angular.\nWe can implement our change detection algorithm in this hook. ngAfterContentInit( ) It gets called after the first ngDoCheck hook. This hook responds after the content gets projected inside the component. ngDoCheck( ) ngOnInit  ngAfterContentInit( ) ngDoCheck ngAfterContentChecked( ) It gets called after ngAfterContentInit and every subsequent ngDoCheck. It responds after the projected content is checked. ngAfterContentChecked( ) ngAfterContentInit ngDoCheck ngAfterViewInit( ) It responds after a component's view, or a child component's view is initialized. ngAfterViewInit( ) ngAfterViewChecked( ) It gets called after ngAfterViewInit, and it responds after the component's view, or the child component's view is checked. ngAfterViewChecked( ) ngAfterViewInit ngOnDestroy( ) It gets called just before Angular destroys the component. This hook can be used to clean up the code and detach event handlers. ngOnDestroy( ) Let’s understand how to use ngOnInit hook, since it’s the most often used hook. If one has to process a lot of data during component creation, it’s better to do it inside ngOnInit hook rather than the constructor: ngOnInit ngOnInit import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-test',\n        templateUrl: './test.component.html',\n        styleUrls: ['./test.component.css']\n      })\n      export class TestComponent implements OnInit {\n        constructor() { }\n\n        ngOnInit() {\n          this.processData();\n        }\n\n        processData(){\n          // Do something..\n        }\n\n      } import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-test',\n        templateUrl: './test.component.html',\n        styleUrls: ['./test.component.css']\n      })\n      export class TestComponent implements OnInit {\n        constructor() { }\n\n        ngOnInit() {\n          this.processData();\n        }\n\n        processData(){\n          // Do something..\n        }\n\n      } As you can see we have imported OnInit but we have used ngOnInit function. This principle should be used with the rest of the hooks as well. ngOnInit",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "12. What is the Component Decorator in Angular?",
        "answer": "TypeScript classes are used to create components. This class genre is then decorated with the \"@Component\" decorator. The decorator's function is to take a metadata object holding component information and decorate it. A Decorator is always preceded by @. The Decorator must come before the class definition. We can also make our own decorators. Example: The example below shows us a Class decorated with the @Component decorator. Example: import {Component} from '@angular/core';\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n    title = 'Example component';\n} import {Component} from '@angular/core';\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n    title = 'Example component';\n} The metadata object received by the decorator has values such as templateUrl, selector, and others, with the templateUrL property pointing to an HTML file that defines what you see on the application.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "13. What are property decorators?",
        "answer": "These are the second most popular types of decorators. They enable us to enhance some of the properties in our classes. We can certainly understand why we utilize any certain class property by using a property decorator. There are many property decorators available for example @Input(), @Output, @ReadOnly(), @Override() Example: Example: import { Component, Input } from '@angular/core';  \n@Component({  \n  selector: 'prop-component',  \n  template: '<div> This is a test component ! </div>'  \n})  \nexport class PropComponent {  \n  @Input()  \n  exampleProperty: string;  \n} import { Component, Input } from '@angular/core';  \n@Component({  \n  selector: 'prop-component',  \n  template: '<div> This is a test component ! </div>'  \n})  \nexport class PropComponent {  \n  @Input()  \n  exampleProperty: string;  \n} The input binding would be sent via a component property binding: <prop-component  \n  [propProperty]=\"propData\">  \n</prop-component> <prop-component  \n  [propProperty]=\"propData\">  \n</prop-component>",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "14. What are Method decorators?",
        "answer": "Method decorators, as the name implies, are used to add functionality to the methods defined within our class. Example: @HostListener, is a good example of method decorators. Example: import { Component, HostListener } from '@angular/core';  \n@Component({  \n  selector: 'method-component',  \n  template: '<div> This is a test method component ! </div>',  \n})  \nexport class MethodComponent {  \n  @HostListener('click', ['$event'])\n    onHostClick(event: Event) {\n    console.log('clicked now this event is available !');  \n    }\n} import { Component, HostListener } from '@angular/core';  \n@Component({  \n  selector: 'method-component',  \n  template: '<div> This is a test method component ! </div>',  \n})  \nexport class MethodComponent {  \n  @HostListener('click', ['$event'])\n    onHostClick(event: Event) {\n    console.log('clicked now this event is available !');  \n    }\n} The @HostListener decorator is used before the onHostClick () method in the above example code.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "15. What are class decorators?",
        "answer": "Class Decorators are the highest-level decorators that determine the purpose of the classes. They indicate to Angular that a specific class is a component or module. And the decorator enables us to declare this effect without having to write any code within the class. Example: Example: import { NgModule, Component } from '@angular/core';  \n@Component({  \n  selector: 'class-component',  \n  template: '<div> This is a class component ! </div>',  \n})  \nexport class ClassComponent {  \n  constructor() {  \n    console.log('This is a class component!');  \n  }  \n}  \n@NgModule({  \n  imports: [],  \n  declarations: [],  \n})  \nexport class ClassModule {  \n  constructor() {  \n    console.log('This is a class module!');  \n  }  \n} import { NgModule, Component } from '@angular/core';  \n@Component({  \n  selector: 'class-component',  \n  template: '<div> This is a class component ! </div>',  \n})  \nexport class ClassComponent {  \n  constructor() {  \n    console.log('This is a class component!');  \n  }  \n}  \n@NgModule({  \n  imports: [],  \n  declarations: [],  \n})  \nexport class ClassModule {  \n  constructor() {  \n    console.log('This is a class module!');  \n  }  \n} It is a component or module in which no code in the class is required to tell Angular. We only need to design it, and Angular will take care of the rest.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "16. What exactly is a parameterized pipe?",
        "answer": "To fine-tune its output, a pipe can receive any number of optional parameters. The parameterized pipe is constructed by first stating the pipe name followed by a colon (:) and then the parameter value. If the pipe supports several arguments, use colons to separate the values. Example: Let's look at a birthday with a certain format (dd/MM/yyyy): Example: import { Component } from '@angular/core';\n    @Component({\n      selector: 'app-example',\n      template: `<p>Birthday is {{ birthday | date:'dd/MM/yyyy'}}</p>`\n    })\n    export class ExampleComponent {\n      birthday = new Date(2000, 7, 15);\n    } import { Component } from '@angular/core';\n    @Component({\n      selector: 'app-example',\n      template: `<p>Birthday is {{ birthday | date:'dd/MM/yyyy'}}</p>`\n    })\n    export class ExampleComponent {\n      birthday = new Date(2000, 7, 15);\n    }",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "17. What are pipes in Angular explain with an example?",
        "answer": "Pipes are functions that simplify the process of wiring up your JavaScript expressions and transforming them into their desired output. They can be compared to, say, string functions in other programming languages. Pipes also allow you to combine multiple expressions together, whether they're all values or some values and some declarations. For example: For example: var css = myTheme.color | \"red\" ; var css = myTheme.color | \"red\" ; This line would assign a value to css , and it's equivalent to writing out the following code: css Pipes have several built-in functions that allow you to transform data, such as value and extract. We can also create our own custom pipes. Pipes are data transformers that execute on an Angular Component's output. They take in data and return transformed data. For example, if you have an expression such as number | 1000, the number pipe will take data from the output and transform it into 1000. In Angular, there are many built-in pipes that you can use. You can also create your own custom pipes by implementing the PipeTransform interface in a class. Pipes receive an input which can be a value expression, a function returning an expression, or even a component property., that outputs a number with a value of 1,000. With a pipe, you can transform this output into a formatted string of \"1,000\" or \"1.000\".   Example: Example: import { Component } from '@angular/core';\n\n@Component({\nselector: 'app-root',\ntemplate: `{{ title | uppercase}}`,\nstyleUrls: ['./app.component.css']\n})\nexport class AppComponent {\ntitle = 'this is an example of custom pies in angular';\n} import { Component } from '@angular/core';\n\n@Component({\nselector: 'app-root',\ntemplate: `{{ title | uppercase}}`,\nstyleUrls: ['./app.component.css']\n})\nexport class AppComponent {\ntitle = 'this is an example of custom pies in angular';\n} Output: Output: THIS IS AN EXAMPLE OF CUSTOM PIPES IN ANGULAR THIS IS AN EXAMPLE OF CUSTOM PIPES IN ANGULAR",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "18. Explain the concept of Dependency Injection?",
        "answer": "Dependency injection is an application design pattern which is implemented by Angular. It also forms one of the core concepts of Angular. So what is dependency injection in simple terms? So what is dependency injection in simple terms? Let’s break it down, dependencies in angular are nothing but services which have functionality. The functionality of a service, can be needed by various components and directives in an application. Angular provides a smooth mechanism by which we can inject these dependencies into our components and directives. So basically, we are just making dependencies which are injectable across all components of an application.   Let’s understand how DI (Dependency Injection) works: Consider the following service, which can be generated using: ng g service test ng g service test import { Injectable } from '@angular/core';\n     @Injectable({\n       providedIn: 'root'\n     })\n     export class TestService {\n       importantValue:number = 42;\n       constructor() { }\n       returnImportantValue(){\n         return this.importantValue;\n       }\n     } import { Injectable } from '@angular/core';\n     @Injectable({\n       providedIn: 'root'\n     })\n     export class TestService {\n       importantValue:number = 42;\n       constructor() { }\n       returnImportantValue(){\n         return this.importantValue;\n       }\n     } As one can notice, we can create injectable dependencies by adding the @Injectable decorator to a class. @Injectable We inject the above dependency inside the following component: import { TestService } from './../test.service';\n      import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-test',\n        templateUrl: './test.component.html',\n        styleUrls: ['./test.component.css']\n      })\n      export class TestComponent implements OnInit {\n        value:number;\n        constructor(private testService:TestService) { }\n\n        ngOnInit() {\n          this.value = this.testService.returnImportantValue();\n        }\n      } import { TestService } from './../test.service';\n      import { Component, OnInit } from '@angular/core';\n\n      @Component({\n        selector: 'app-test',\n        templateUrl: './test.component.html',\n        styleUrls: ['./test.component.css']\n      })\n      export class TestComponent implements OnInit {\n        value:number;\n        constructor(private testService:TestService) { }\n\n        ngOnInit() {\n          this.value = this.testService.returnImportantValue();\n        }\n      } One can see we have imported our TestService at the top of the page. Then, we created an instance inside the constructor of the component and implemented the returnImportantValue function of the service. returnImportantValue From the above example, we can observe how angular provides a smooth way to inject dependencies in any component.",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "19. How are observables different from promises?",
        "answer": "The first difference is that an Observable is lazy whereas a Promise is eager. lazy eager Promise Observable\nEmits a single value Emits multiple values over a period of time\nNot Lazy Lazy. An observable is not called until we subscribe to the observable\nCannot be cancelled Can be cancelled by using the unsubscribe() method\n  Observable provides operators like map, forEach, filter, reduce, retry, retryWhen etc. Promise Observable\nEmits a single value Emits multiple values over a period of time\nNot Lazy Lazy. An observable is not called until we subscribe to the observable\nCannot be cancelled Can be cancelled by using the unsubscribe() method\n  Observable provides operators like map, forEach, filter, reduce, retry, retryWhen etc. Promise Observable Promise Observable Promise Observable Emits a single value Emits multiple values over a period of time\nNot Lazy Lazy. An observable is not called until we subscribe to the observable\nCannot be cancelled Can be cancelled by using the unsubscribe() method\n  Observable provides operators like map, forEach, filter, reduce, retry, retryWhen etc. Emits a single value Emits multiple values over a period of time Emits a single value Emits multiple values over a period of time Not Lazy Lazy. An observable is not called until we subscribe to the observable Not Lazy Lazy. An observable is not called until we subscribe to the observable Cannot be cancelled Can be cancelled by using the unsubscribe() method Cannot be cancelled Can be cancelled by using the unsubscribe() method Observable provides operators like map, forEach, filter, reduce, retry, retryWhen etc.  Observable provides operators like map, forEach, filter, reduce, retry, retryWhen etc. Consider the following Observable: const observable = rxjs.Observable.create(observer => {\n       console.log('Text inside an observable');\n       observer.next('Hello world!');\n       observer.complete();\n     });\n     console.log('Before subscribing an Observable');\n     observable.subscribe((message)=> console.log(message)); const observable = rxjs.Observable.create(observer => {\n       console.log('Text inside an observable');\n       observer.next('Hello world!');\n       observer.complete();\n     });\n     console.log('Before subscribing an Observable');\n     observable.subscribe((message)=> console.log(message)); When you run the above Observable, you can see messages being displayed in the following order: Before subscribing an Observable\nText inside an observable\nHello world! Before subscribing an Observable\nText inside an observable\nHello world! As you can see, observables are lazy. Observable runs only when someone subscribes to them hence, the message “Before subscribing…” is displayed ahead of the message inside the observable. Now let’s consider a Promise: const promise = new Promise((resolve, reject) => {\n       console.log('Text inside promise');\n       resolve('Hello world!');\n     });\n     console.log('Before calling then method on Promise');\n     greetingPoster.then(message => console.log(message)); const promise = new Promise((resolve, reject) => {\n       console.log('Text inside promise');\n       resolve('Hello world!');\n     });\n     console.log('Before calling then method on Promise');\n     greetingPoster.then(message => console.log(message)); Running the above promise, the messages will be displayed in the following order: Text inside promise\nBefore calling then method on Promise\nHello world! Text inside promise\nBefore calling then method on Promise\nHello world! As you can see the message inside Promise is displayed first. This means that a promise runs before the then method is called. Therefore, promises are eager. then eager The next difference is that Promises are always asynchronous. Even when the promise is immediately resolved. Whereas an Observable, can be both synchronous and asynchronous. asynchronous synchronous asynchronous The above example of an observable is the case to show that an observable is synchronous. Let’s see the case where an observable can be asynchronous: const observable = rxjs.Observable.create(observer => {\n       setTimeout(()=>{\n           observer.next('Hello world');\n           observer.complete();\n       },3000)\n     });\n     console.log('Before calling subscribe on an Observable');\n     observable.subscribe((data)=> console.log(data));\n     console.log('After calling subscribe on an Observable'); const observable = rxjs.Observable.create(observer => {\n       setTimeout(()=>{\n           observer.next('Hello world');\n           observer.complete();\n       },3000)\n     });\n     console.log('Before calling subscribe on an Observable');\n     observable.subscribe((data)=> console.log(data));\n     console.log('After calling subscribe on an Observable'); The messages will be displayed in the following order: Before calling subscribe on an Observable\nAfter calling subscribe on an Observable\nHello world! Before calling subscribe on an Observable\nAfter calling subscribe on an Observable\nHello world! You can see in this case, observable runs asynchronously. The next difference is that Observables can emit multiple values whereas Promises can emit only one value. multiple The biggest feature of using observables is the use of operators. We can use multiple operators on an observable whereas, there is no such feature in a promise. operators",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "20. Explain string interpolation and property binding in Angular.",
        "answer": "String interpolation and property binding are parts of data-binding in Angular.\nData-binding is a feature in angular, which provides a way to communicate between the component(Model) and its view(HTML template).\nData-binding can be done in two ways, one-way binding and two-way binding.\nIn Angular, data from the component can be inserted inside the HTML template. In one-way binding, any changes in the component will directly reflect inside the HTML template but, vice-versa is not possible. Whereas, it is possible in two-way binding.\nString interpolation and property binding allow only one-way data binding.\nString interpolation uses the double curly braces {{ }} to display data from the component. Angular automatically runs the expression written inside the curly braces, for example, {{ 2 + 2 }} will be evaluated by Angular and the output 4, will be displayed inside the HTML template. Using property binding, we can bind the DOM properties of an HTML element to a component's property. Property binding uses the square brackets [ ] syntax. String interpolation and property binding are parts of data-binding in Angular. data-binding Data-binding is a feature in angular, which provides a way to communicate between the component(Model) and its view(HTML template). Data-binding can be done in two ways, one-way binding and two-way binding. one-way two-way In Angular, data from the component can be inserted inside the HTML template. In one-way binding, any changes in the component will directly reflect inside the HTML template but, vice-versa is not possible. Whereas, it is possible in two-way binding. String interpolation and property binding allow only one-way data binding. String interpolation uses the double curly braces {{ }} to display data from the component. Angular automatically runs the expression written inside the curly braces, for example, {{ 2 + 2 }} will be evaluated by Angular and the output 4, will be displayed inside the HTML template. Using property binding, we can bind the DOM properties of an HTML element to a component's property. Property binding uses the square brackets [ ] syntax. {{ }} [ ]",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "21. What are RxJs in Angular ?",
        "answer": "RxJS is an acronym that stands for Reactive Extensions for JavaScript. It is used to enable the use of observables in our JavaScript project, allowing us to do reactive programming. RxJS is utilized in many popular frameworks, including Angular since it allows us to compose our asynchronous or callback-based code into a sequence of operations executed on a data stream that releases values from a publisher to a subscriber. Other programming languages, such as Java and Python, offer packages that allow them to develop reactive programs utilizing observables. Most of the time, rxJs is used in HTTP calls with angular. Because http streams are asynchronous data, we can subscribe to them and apply filters to them. Example: The following is a simple example of how RxJs can be utilized with HTTP calls. Example: let  stream1 = httpc.get(\"https://www.example.com/somedata\");\n let stream2 = stream1.pipe(filter(x=>x>3));\n stream2.subscribe(res=>this.Success(res),res=>this.Error(res)); let  stream1 = httpc.get(\"https://www.example.com/somedata\");\n let stream2 = stream1.pipe(filter(x=>x>3));\n stream2.subscribe(res=>this.Success(res),res=>this.Error(res));",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "22. What is view encapsulation in Angular?",
        "answer": "View encapsulation specifies if the component's template and styles can impact the entire program or vice versa. Angular offers three encapsulation methods: Angular offers three encapsulation methods: Native: The component does not inherit styles from the main HTML. Styles defined in this component's @Component decorator are only applicable to this component.\nEmulated (Default): The component inherits styles from the main HTML. Styles set in the @Component decorator are only applicable to this component.\nNone: The component's styles are propagated back to the main HTML and therefore accessible to all components on the page. Be wary of programs that have None and Native components. Styles will be repeated in all components with Native encapsulation if they have No encapsulation. Native: The component does not inherit styles from the main HTML. Styles defined in this component's @Component decorator are only applicable to this component. Native: Emulated (Default): The component inherits styles from the main HTML. Styles set in the @Component decorator are only applicable to this component. Emulated (Default): None: The component's styles are propagated back to the main HTML and therefore accessible to all components on the page. Be wary of programs that have None and Native components. Styles will be repeated in all components with Native encapsulation if they have No encapsulation. None:",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "23. What is Eager and Lazy loading?",
        "answer": "Loading: The eager loading technique is the default module-loading strategy. Eager loading feature modules are loaded before the program begins. This is primarily utilized for small-scale applications.\nLazy Loading: Lazy loading loads the feature modules dynamically as needed. This speeds up the application. It is utilized for larger projects where all of the modules are not required at the start. Loading: The eager loading technique is the default module-loading strategy. Eager loading feature modules are loaded before the program begins. This is primarily utilized for small-scale applications. Loading: Lazy Loading: Lazy loading loads the feature modules dynamically as needed. This speeds up the application. It is utilized for larger projects where all of the modules are not required at the start. Lazy Loading:",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "24. Angular by default, uses client-side rendering for its applications.",
        "answer": "Can one make an angular application to render on the server-side? Yes, angular provides a technology called Angular Universal, which can be used to render applications on the server-side. Angular Universal The advantages of using Angular Universal are: First time users can instantly see a view of the application. This benefits in providing better user experience.\nMany search engines expect pages in plain HTML, thus, Universal can make sure that your content is available on every search engine, which leads to better SEO.\nAny server-side rendered application loads faster since rendered pages are available to the browser sooner. First time users can instantly see a view of the application. This benefits in providing better user experience. better user experience Many search engines expect pages in plain HTML, thus, Universal can make sure that your content is available on every search engine, which leads to better SEO. better SEO Any server-side rendered application loads faster since rendered pages are available to the browser sooner. loads faster",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "1. What happens when you use the script tag within a template?",
        "answer": "Angular detects the value as unsafe and sanitizes it automatically, removing the script tag but retaining safe material such as the script tag's text content. This reduces the potential of script injection attacks. If you continue to use it, it will be disregarded, and a warning will display in the browser console. Example: Consider the case of innerHtml property binding, which results in an XSS vulnerability. Example: export class InnerHtmlBindingComponent {\n    // For example, a attacker-controlled value from a URL using malicious scripts.\n    htmlSnippet = 'Template <script>alert(\"You are hacked !!!!\")</script> <b>Syntax</b>';\n} export class InnerHtmlBindingComponent {\n    // For example, a attacker-controlled value from a URL using malicious scripts.\n    htmlSnippet = 'Template <script>alert(\"You are hacked !!!!\")</script> <b>Syntax</b>';\n} Conclusion For new applicants for the role of Angular developer, theoretical and fundamental ideas are required, but for an experienced individual, both applied and practical concepts are essential. Many of the Angular interview questions for experienced candidates will be about your prior project. This article contains a collection of frequently asked job interview questions that apply to all of Angular's modules. An applicant who hopes to land a position as an Angular developer should review these questions once again before arriving at their interview. Additional Interview Resources Angular 8 Interview Questions\nAngularjs Interview Questions\nFull Stack Developer Interview Questions\nTypeScript Interview Questions\nReact Interview Questions\nIonic Interview Questions\nAngular Js Projects\nBest Front End Frameworks\nWeb Development Frameworks\nAngular MCQ\nJavascript vs Typescript Differences Angular 8 Interview Questions Angular 8 Interview Questions Angularjs Interview Questions Angularjs Interview Questions Full Stack Developer Interview Questions Full Stack Developer Interview Questions TypeScript Interview Questions TypeScript Interview Questions React Interview Questions React Interview Questions Ionic Interview Questions Ionic Interview Questions Angular Js Projects Angular Js Projects Best Front End Frameworks Best Front End Frameworks Web Development Frameworks Web Development Frameworks Angular MCQ Angular MCQ Javascript vs Typescript Differences Javascript vs Typescript Differences",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "2. How can I include SASS into an Angular project?",
        "answer": "You may use the ng new command while building your project using angular CLI. All of your components are generated using preset sass files. ng new <Your_Project_Name> --style = sass ng new <Your_Project_Name> --style = sass If you want to change the style of your project, use the ng set command. ng set defaults.styleExt scss ng set defaults.styleExt scss",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "3. How do you deal with errors in observables?",
        "answer": "Instead of depending on try/catch, which is useless in an asynchronous context, you may manage problems by setting an error callback on the observer. Example: You may create an error callback as shown below. Example: myObservable.subscribe({\n    next(number) { console.log('Next number: ' + number)},\n    error(err) { console.log('An error received ' + err)}\n  }); myObservable.subscribe({\n    next(number) { console.log('Next number: ' + number)},\n    error(err) { console.log('An error received ' + err)}\n  });",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "4. How does one share data between components in Angular?",
        "answer": "Following are the commonly used methods by which one can pass data between components in angular:   Parent to child using @Input decorator Parent to child using @Input decorator Parent to child using @Input decorator Consider the following parent component: @Component({\n       selector: 'app-parent',\n       template: `\n         <app-child [data]=data></app-child>\n       ` ,\n       styleUrls: ['./parent.component.css']\n     })\n     export class ParentComponent{\n       data:string = \"Message from parent\";\n       constructor() { }\n     } @Component({\n       selector: 'app-parent',\n       template: `\n         <app-child [data]=data></app-child>\n       ` ,\n       styleUrls: ['./parent.component.css']\n     })\n     export class ParentComponent{\n       data:string = \"Message from parent\";\n       constructor() { }\n     } In the above parent component, we are passing “data” property to the following child component: import { Component, Input} from '@angular/core';\n     @Component({\n       selector: 'app-child',\n       template:`\n         <p>{{data}}</p>\n       `,\n       styleUrls: ['./child.component.css']\n     })\n     export class ChildComponent {\n       @Input() data:string\n       constructor() { }\n     } import { Component, Input} from '@angular/core';\n     @Component({\n       selector: 'app-child',\n       template:`\n         <p>{{data}}</p>\n       `,\n       styleUrls: ['./child.component.css']\n     })\n     export class ChildComponent {\n       @Input() data:string\n       constructor() { }\n     } In the child component, we are using @Input decorator to capture data coming from a parent component and using it inside the child component’s template.   Child to parent using @ViewChild decorator Child to parent using @ViewChild decorator Child to parent using @ViewChild decorator Child component: Child component: import {Component} from '@angular/core';\n     @Component({\n       selector: 'app-child',\n       template:`\n         <p>{{data}}</p>\n       `,\n       styleUrls: ['./child.component.css']\n     })\n     export class ChildComponent {\n       data:string = \"Message from child to parent\";\n       constructor() { }\n     } import {Component} from '@angular/core';\n     @Component({\n       selector: 'app-child',\n       template:`\n         <p>{{data}}</p>\n       `,\n       styleUrls: ['./child.component.css']\n     })\n     export class ChildComponent {\n       data:string = \"Message from child to parent\";\n       constructor() { }\n     } Parent Component Parent Component import { Component,ViewChild, AfterViewInit} from '@angular/core';\n     import { ChildComponent } from './../child/child.component';\n     @Component({\n       selector: 'app-parent',\n       template: `\n         <p>{{dataFromChild}}</p>\n       ` ,\n       styleUrls: ['./parent.component.css']\n     })\n     export class ParentComponent implements AfterViewInit {\n       dataFromChild: string;\n       @ViewChild(ChildComponent,{static:false}) child;\n       ngAfterViewInit(){\n         this.dataFromChild = this.child.data;\n       }\n       constructor() { }\n     } import { Component,ViewChild, AfterViewInit} from '@angular/core';\n     import { ChildComponent } from './../child/child.component';\n     @Component({\n       selector: 'app-parent',\n       template: `\n         <p>{{dataFromChild}}</p>\n       ` ,\n       styleUrls: ['./parent.component.css']\n     })\n     export class ParentComponent implements AfterViewInit {\n       dataFromChild: string;\n       @ViewChild(ChildComponent,{static:false}) child;\n       ngAfterViewInit(){\n         this.dataFromChild = this.child.data;\n       }\n       constructor() { }\n     } In the above example, a property named “data” is passed from the child component to the parent component. @ViewChild decorator is used to reference the child component as “child” property. @ViewChild Using the ngAfterViewInit hook, we assign the child’s data property to the messageFromChild property and use it in the parent component’s template. ngAfterViewInit Child to parent using @Output and EventEmitter Child to parent using @Output and EventEmitter Child to parent using @Output and EventEmitter In this method, we bind a DOM element inside the child component, to an event ( click event for example ) and using this event we emit data that will captured by the parent component: click Child Component: Child Component: import {Component, Output, EventEmitter} from '@angular/core';\n     @Component({\n       selector: 'app-child',\n       template:`\n         <button (click)=\"emitData()\">Click to emit data</button>\n       `,\n       styleUrls: ['./child.component.css']\n     })\n     export class ChildComponent {\n       data:string = \"Message from child to parent\";\n       @Output() dataEvent = new EventEmitter<string>();\n       constructor() { }\n       emitData(){\n         this.dataEvent.emit(this.data);\n       }\n     } import {Component, Output, EventEmitter} from '@angular/core';\n     @Component({\n       selector: 'app-child',\n       template:`\n         <button (click)=\"emitData()\">Click to emit data</button>\n       `,\n       styleUrls: ['./child.component.css']\n     })\n     export class ChildComponent {\n       data:string = \"Message from child to parent\";\n       @Output() dataEvent = new EventEmitter<string>();\n       constructor() { }\n       emitData(){\n         this.dataEvent.emit(this.data);\n       }\n     } As you can see in the child component, we have used @Output property to bind an EventEmitter. This event emitter emits data when the button in the template is clicked. @Output EventEmitter In the parent component’s template we can capture the emitted data like this: <app-child (dataEvent)=\"receiveData($event)\"></app-child> <app-child (dataEvent)=\"receiveData($event)\"></app-child> Then inside the receiveData function we can handle the emitted data: receiveData($event){\n       this.dataFromChild = $event;\n     } receiveData($event){\n       this.dataFromChild = $event;\n     }",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "5. How do you choose an element from a component template?",
        "answer": "To directly access items in the view, use the @ViewChild directive. Consider an input item with a reference. <input #example> <input #example> and construct a view child directive that is accessed in the ngAfterViewInit lifecycle hook @ViewChild('example') input;\n\nngAfterViewInit() {\n  console.log(this.input.nativeElement.value);\n} @ViewChild('example') input;\n\nngAfterViewInit() {\n  console.log(this.input.nativeElement.value);\n}",
        "reference": "interviewbit.com",
        "role": "angular"
    },
    {
        "question": "1) What is Angular? / What do you know about Angular?",
        "answer": "Angular is one of the most popular JavaScript frameworks developed and maintained by Google. It is an open-source front-end web framework based on TypeScript. It is most suited for developing enterprise web applications because its code is reusable and maintainable.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "2) What are some powerful features integrated into Angular?",
        "answer": "Angular integrates some powerful features like declarative templates, end to end tooling, dependency injection and various other best practices that smoothens the development path.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "3) What is the main purpose of Angular?",
        "answer": "The main purpose of using Angular is to create fast, dynamic and scalable web applications. We can create these applications very easily with Angular using components and directives.\nAngular was started as a SPA (Single-Page-Application) framework, and now it supports dynamic content based on different users through dependency injection. It provides a platform for easy development of web-based applications and empowers the front end developers in curating cross-platform applications. YouTubeTV is the most popular example that uses Angular.\nADVERTISEMENT",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "4) What is the difference between AngularJS and Angular?",
        "answer": "Let's compare the features of AngularJS and Angular in a tabular form:\nA list of differences between AngularJS and Angular-\nFeature AngularJS Angular\nVersion AngularJS was the very first version initially released in 2010. It was a browser-side JavaScript used within HTML code and created a revolution in web application development. It is popularly known as AngularJS. The later Angular versions were a complete rewrite of AngularJS. For example, Angular 2 was initially released in 2016. There is nothing common between Angular2 and AngularJS except the core developer's team. After that, Angular 6, Angular 7, Angular 8, Angular 9, and Angular 10 were released that are very similar to each other. These later versions are known as Angular.\nArchitecture AngularJS supports the MVC design model. Angular uses components and directives.\nSupported Language The recommended and supported language of AngularJS is JavaScript. The recommended and supported language of Angular is TypeScript.\nExpression Syntax In AngularJS, a specific ng directive is required for the image/property and an event. Angular uses () for event binding and [] for property binding.\nMobile Support AngularJS doesn't provide any mobile support. Angular provides mobile support.\nDependency Injection There is no concept of Dependency Injection in AngularJS. Angular supports hierarchical Dependency Injection with uni-directional tree-based change detection.\nRouting In AngularJS, $routeprovider.when() is used for routing configs. In Angular, @RouteConfig{(?)} is used for the routing config.\nStructure It is the first and basic version, so it is very easy to manage. It has a very simplified structure that makes the development and maintenance of large applications very easy.\nSpeed It is slower because of its limited features. It is faster than AngularJS because of its upgraded features.\nSupport It doesn't provide support or new updates anymore. It provides active support, and frequent new updates are made.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "5) What are the biggest advantages of using Angular?",
        "answer": "Following is the list of the biggest advantages of using the Angular framework:\nADVERTISEMENT\nAngular supports two-way data-binding.\nIt follows MVC pattern architecture.\nIt supports static templates and Angular template.\nIt facilitates you to add a custom directive.\nIt also supports RESTfull services.\nValidations are supported in Angular.\nAngular provides client and server communication.\nIt provides support for dependency injection.\nIt provides powerful features like Event Handlers, Animation, etc.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "6) What do you understand by Angular expressions? How are Angular expressions different from JavaScript expressions?",
        "answer": "Angular expressions are code snippets that are used to bind application data to HTML. Angular resolves the expressions, and the result is returned to where the expression is written. Angular expressions are usually written in double braces: {{ expression }} similar to JavaScript.\nSyntax:\n{{ expression }}\nFollowing is a list of some differences between Angular expressions and JavaScript expressions:\n1. The most crucial difference between Angular expressions and JavaScript expressions is that the Angular expressions allow us to write JavaScript in HTML. On the other hand, the JavaScript expressions don't allow.\n2. The Angular expressions are evaluated against a local scope object. On the other hand, the JavaScript expressions are evaluated against the global window object. We can understand it better with an example. Suppose we have a component named test:\nimport { Component, OnInit } from '@angular/core';  \n@Component({  \nselector: 'app-test',  \ntemplate: `  \n<h4>{{message}}</h4>,  \nstyleUrls: ['./test.component.css']  \n})  \nexport class TestComponent implements OnInit {  \nmessage:string = ?Hello world?;  \nconstructor() { }  \nngOnInit() {  \n}  \n}  \nIn the above example, we can see that the Angular expression is used to display the message property. In the present template, we are using Angular expressions, so we cannot access a property outside its local scope (in this case, TestComponent). This proves that Angular expressions are always evaluated based on the scope object rather than the global object.\n3. The Angular expressions can handle null and undefined, whereas JavaScript expressions cannot.\nSee the following JavaScript example:\n<!DOCTYPE html>  \n<html lang=\"en\">  \n<head>  \n    <meta charset=\"UTF-8\">  \n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">  \n    <title>JavaScript Test</title>  \n</head>  \n<body>  \n    <div id=\"foo\"><div>  \n</body>  \n<script>  \n    'use strict';  \n    let bar = {};  \n    document.getElementById('foo').innerHTML = bar.x;  \n</script>  \n</html>  \nAfter running the above code, you see undefined displayed on the screen. Although it's not ideal to leave any property undefined, the user does not need to see this.\nNow see the following Angular example:\nimport { Component, OnInit } from '@angular/core';  \n@Component({  \n  selector: 'app-new',  \n  template: `  \n      <h4>{{message}}</h4>       `,  \n  styleUrls: ['./new.component.css']  \n})  \nexport class NewComponent implements OnInit {  \n  message:object = {};  \n  constructor() { }  \n  ngOnInit() {  \n  }  \n}  \nIn the above example, you will not see undefined being displayed on the screen.\n4. In Angular expressions, we cannot use loops, conditionals, and exceptions. The difference which makes Angular expressions quite beneficial is the use of pipes. Angular uses pipes (known as filters in AngularJS) to format data before displaying it.\nSee this example:\nimport { Component, OnInit } from '@angular/core';  \n      @Component({  \n        selector: 'app-new',  \n        template: `  \n            <h4>{{message | lowercase}}</h4>,  \n        styleUrls: ['./new.component.css']  \n      })  \n      export class NewComponent implements OnInit {  \n        message:string = \"HELLO JAVATPOINT\";  \n        constructor() { }  \n        ngOnInit() {  \n        }  \n      }   \nIn the above example, we have used a predefined pipe called lowercase, which transforms all the letters in lowercase. If you run the above example, you will see the output displayed as \"hello javatpoint\".\n\nOn the other hand, JavaScript does not have the concept of pipes.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "7) What are templates in Angular?",
        "answer": "In Angular, templates contain Angular-specific elements and attributes. These are written with HTML and combined with information coming from the model and controller, which are further rendered to provide the user's dynamic view.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "8) What is the difference between an Annotation and a Decorator in Angular?",
        "answer": "In Angular, annotations are the \"only\" metadata set of the class using the Reflect Metadata library. They are used to create an \"annotation\" array. On the other hand, decorators are the design patterns used for separating decoration or modification of a class without actually altering the original source code.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "9) Why was Angular introduced as a client-side framework?",
        "answer": "Before the introduction of Angular, web developers used VanillaJS and jQuery to develop dynamic websites. Later, when the websites became more complex with added features and functionality, it was hard for them to maintain the code. Along with this, there were no provisions of data handling facilities across the views by jQuery. The need for a client-side framework like Angular was obvious that can make life easier for the developers by handling separation of concerns and dividing code into smaller bits of information (components).\nClient-side frameworks like Angular facilitate developers to develop advanced web applications like Single-Page-Application. These applications can also be developed using VanillaJS, but the development process becomes slower by doing so.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "10) How does an Angular application work?",
        "answer": "Every Angular app contains a file named angular.json. This file contains all the configurations of the app. While building the app, the builder looks at this file to find the application's entry point. See the structure of the angular.json file:\n\"build\": {  \n  \"builder\": \"@angular-devkit/build-angular:browser\",  \n  \"options\": {  \n    \"outputPath\": \"dist/angular-starter\",  \n    \"index\": \"src/index.html\",  \n    \"main\": \"src/main.ts\",  \n    \"polyfills\": \"src/polyfills.ts\",  \n    \"tsConfig\": \"tsconfig.app.json\",  \n    \"aot\": false,  \n    \"assets\": [  \n      \"src/favicon.ico\",  \n      \"src/assets\"  \n    ],  \n    \"styles\": [  \n      \"./node_modules/@angular/material/prebuilt-themes/deeppurple-amber.css\",  \n      \"src/style.css\"  \n    ]  \n  }  \n}  \n\nWhen the application enters the build section, the options object's main property defines the entry point of the application. The application's entry point is main.ts, which creates a browser environment for the application to run and calls a function called bootstrapModule, which bootstraps the application.\nThese two steps are performed in the following order inside the main.ts file:\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';  \nplatformBrowserDynamic().bootstrapModule(AppModule)   \nIn the above line of code, AppModule is getting bootstrapped.\nThe AppModule is declared in the app.module.ts file. This module contains declarations of all the components.\nBelow is an example of app.module.ts file:\nimport { BrowserModule } from '@angular/platform-browser';  \n     import { NgModule } from '@angular/core';  \n     import { AppComponent } from './app.component';  \n     @NgModule({  \n       declarations: [  \n         AppComponent  \n       ],  \n       imports: [  \n         BrowserModule  \n       ],  \n       providers: [],  \n       entryComponents: [],  \n       bootstrap: [AppComponent]  \n     })  \n     export class AppModule { }  \nIn the above file, you can see that AppComponent is getting bootstrapped. It is defined in app.component.ts file. This file interacts with the webpage and serves data to it.\nBelow is an example of app.component.ts file:\nimport { Component } from '@angular/core';  \n      @Component({  \n        selector: 'app-root',  \n        templateUrl: './app.component.html',  \n        styleUrls: ['./app.component.css']  \n      })  \n      export class AppComponent {  \n        title = 'angular';  \n      }  \nEach component is declared with three properties:\nSelector - It is used to access the component.\nTemplate/TemplateURL - It contains HTML of the component.\nStylesURL - It contains component-specific stylesheets.\nNow, Angular calls the index.html file. This file consequently calls the root component that is app-root. The root component is defined in app.component.ts.\nSee how the index.html file looks like:\n<!doctype html>  \n  <html lang=\"en\">  \n  <head>  \n    <meta charset=\"utf-8\">  \n    <title>Angular</title>  \n    <base href=\"/\">  \n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">  \n  </head>  \n  <body>  \n    <app-root></app-root>  \n  </body>  \n  </html>  \nThe HTML template of the root component is displayed inside the <app-root> tags.This is the way how every angular application works.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "11) Why is Angular preferred over other frameworks? / What are some advantages of Angular over other frameworks?",
        "answer": "Due to the following features, Angular is preferred over other frameworks:\nExtraordinary Built-in Features: Angular provides several out of the box built-in features like routing, state management, RxJS library, Dependency Injection, HTTP services, etc. That's why the developers do not need to look for the above-stated features separately.\nDeclarative UI: Angular has declarative UI. It uses HTML to render the UI of an application as it is a declarative language. It is much easier to use than JavaScript.\nLong-term Google Support: Angular is developed and maintained by Google. Google has a long term plan to stick with Angular and provide support.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "",
        "answer": "When the Angular components are created, they enter their lifecycle and remain when they are destroyed. Angular Lifecycle hooks are used to check the phases and trigger changes at specific phases during the entire duration.\n\nngOnChanges( ): This method is called when one or more input properties of the component are changed. The hook receives a SimpleChanges object containing the previous and current values of the property.\nngOnInit( ): This is the second lifecycle hook. It is called once, after the ngOnChanges hook. It is used to initialize the component and sets the input properties of the component.\nngDoCheck( ): This hook is called after ngOnChanges and ngOnInit and is used to detect and act on changes that Angular cannot detect. In this hook, we can implement our change detection algorithm.\nngAfterContentInit( ): This hook is called after the first ngDoCheck hook. This hook responds after the content gets projected inside the component.\nngAfterContentChecked( ): This hook is called after ngAfterContentInit and every subsequent ngDoCheck. It responds after the projected content is checked.\nngAfterViewInit( ): This hook is called after a component's view or initializing a child component's view.\nngAfterViewChecked( ): This hook is called after ngAfterViewInit. It responds after the component's view or when the child component's view is checked.\nngOnDestroy( ): This hook is called just before Angular destroys the component. This is used to clean up the code and detach event handlers.\nIn the above hooks we have described, the ngOnInit hook is the most often used hook. Let's see how to use the ngOnInit hook. If you have to process a lot of data during component creation, it's better to do it inside the ngOnInit hook rather than the constructor:\nSee the example:\nimport { Component, OnInit } from '@angular/core';  \n@Component({  \n  selector: 'app-test',  \n  templateUrl: './test.component.html',  \n  styleUrls: ['./test.component.css']  \n})  \nexport class TestComponent implements OnInit {  \n  constructor() { }  \n  ngOnInit() {  \n    this.processData();  \n  }  \n  processData(){  \n    // Do something..  \n  }  \n}  \nIn the above code, you can see that we have imported OnInit, but we have used the ngOnInit function. This is how we can use the rest of the hooks as well.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "13) What is AOT in Angular?",
        "answer": "In Angular, AOT stands for Ahead-Of-Time compiler. It is used to convert your Angular HTML and TypeScript code into efficient JavaScript code during the build phase before the browser downloads and runs that code. By compiling the application during the build process provides a faster rendering in the browser.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "14) What is the reason for using the AOT compiler in Angular?",
        "answer": "An Angular application is made of several components and their HTML templates. Because of these Angular components and templates, the browsers are not able to understand them directly. So, Angular applications require a compilation process before they run in a browser. That's why AOT compilers are required.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "15) What are the biggest advantages of AOT in Angular?",
        "answer": "Following are the advantages of using the AOT compiler in Angular:\nThe rendering is faster: When we use the AOT compiler, the browser gets a pre-compiled version of the application to download. Here, the browser loads executable code to render the application immediately, without waiting to compile the app first.\nThe Angular framework's download size is smaller: AOT facilitates you not to download the Angular compiler if the app is already compiled. The compiler is roughly half of Angular itself, so omitting it dramatically reduces the application payload.\nFewer asynchronous requests: The compiler is used to inline external HTML templates and CSS style sheets within the application JavaScript so, it eliminates separate AJAX requests for those source files.\nDetect template errors earlier: While using the AOT compiler, developers can easily detect and report template binding errors during the build step before users can see them.\nBetter security: AOT provides better security because it compiles HTML templates and components into JavaScript files before they are served to the client. Because there are no templates to read and no risky client-side HTML or JavaScript evaluation, so the chances for injection attacks are very rare.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "16) What is JIT in Angular?",
        "answer": "In Angular, JIT stands for Just-in-Time compiler. The JIT compiler provides a dynamic translation or run-time compilation, which provides a way of executing computer code that involves compilation during the execution of a program at run time rather than before execution.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "17) What is the main difference between JIT and AOT in Angular?",
        "answer": "Following are the main differences between JIT and AOT compiler in Angular:\nJust-in-Time (JIT) compiler compiles our app in the browser at run-time while Ahead-of-Time (AOT) compiler is used to compile your app at build time on the server.\nThe JIT compilation runs by default when you run the ng build (build only), or ng serve (build and serve locally) CLI commands. This is used for development. On the other hand, we have to include the --aot option with the ng build or ng serve command for AOT compilation.\nJIT and AOT are both two ways used to compile code in an Angular project. JIT compiler is used in development mode while AOT is used for production mode.\nJIT is easy to use. We can easily implement features and debug in JIT mode because here we have a map file while AOT does not. On the other hand, the biggest advantage of using AOT for production is that it reduces the bundle size for faster rendering.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "18) What is the concept of scope hierarchy in Angular?",
        "answer": "Angular provides the $scope objects into a hierarchy that is typically used by views. This is called the scope hierarchy in Angular. It has a root scope that can further contain one or several scopes called child scopes.\nIn a scope hierarchy, each view has its own $scope. Hence, the variables set by a view's view controller will remain hidden to other view controllers.\nFollowing is the typical representation of a Scope Hierarchy:\nRoot $scope  \n$scope for Controller 1  \n$scope for Controller 2  \n...  \n..  \n.  \n$scope for Controller n",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "",
        "answer": "Following are the main building blocks of an Angular application. You can see them in the following picture:",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "20) What is the difference between Observables and Promises in Angular?",
        "answer": "In Angular, as soon as we make a promise, the execution takes place, but this is not the case with observables because they are lazy. It means nothing happens until a subscription is made.\nPromise Observable\nIt emits a single value. It emits multiple values over a period of time.\nNot Lazy Lazy. An observable is not called until we subscribe to the observable.\nWe can not cancel\nit. We can cancel it by using the unsubscribe() method.\nObservable provides operators like map, forEach, filter, reduce, retry, retryWhen etc.\nLet's understand it by an example:\nconst observable = rxjs.Observable.create(observer => {  \n        console.log('This is what inside an observable');  \n        observer.next('Hello JavaTpoint');  \n        observer.complete();  \n      });  \n      console.log('Before subscribing an Observable');  \n      observable.subscribe((message)=> console.log(message));   \nWhen you run the above Observable, you can see the following messages displayed in the following order:\n\nBefore subscribing an Observable  \nThis is what inside an observable  \nHello JavaTpoint  \nHere, you can see that observables are lazy. Observable runs only when someone subscribes to them. That's why the message \"Before subscribing an Observable\" is displayed ahead of the message inside the observable.\nNow see the example of a Promise:\nconst promise = new Promise((resolve, reject) => {  \n        console.log('This is what written inside promise');  \n        resolve('Hello JavaTpoint');  \n      });  \n      console.log('Before calling then method on Promise');  \n      greetingPoster.then(message => console.log(message));   \nWhen you run the above Promise, you will see the messages displayed in the following order:\nThis is what written inside Promise  \nBefore calling then method on Promise  \nHello JavaTpoint  \nHere, you can see that the message inside Promise is displayed first. This means that the Promise runs first, and then the method is called.\nThe next difference between them is that Promises are always asynchronous; even when the Promise is immediately resolved. On the other hand, an Observable can be both synchronous and asynchronous.\nIn the case of the above example, observable is synchronous. Let's see the case where an observable can be asynchronous:\nconst observable = rxjs.Observable.create(observer => {  \n  setTimeout(()=>{  \n      observer.next('Hello JavaTpoint');  \n      observer.complete();  \n  },3000)  \n});  \nconsole.log('Before calling subscribe on an Observable');  \nobservable.subscribe((data)=> console.log(data));  \nconsole.log('After calling subscribe on an Observable');   \nWhen you run the above observable, you will see the messages in the following order:\nBefore calling subscribe on an Observable  \nAfter calling subscribe on an Observable  \nHello JavaTpoint",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "22) What are directives in Angular?",
        "answer": "A directive is a class in Angular that is declared with a @Directive decorator. Every directive has its own behavior, and you can import them into various components of an application.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "23) What were the main reasons behind introducing client-side frameworks like Angular?",
        "answer": "Before Angular was introduced, the web developers used VanillaJS and jQuery to develop dynamic websites, but the biggest drawback of these technologies is that as the logic of the website grew, the code became more and more complex to maintain. For websites and applications that use complex logic, developers had to put in extra effort to maintain the separation of concerns for the app. Also, jQuery did not provide facilities for data handling across views.\nThe client-side frameworks like Angular were introduced to overcome the above problems. It provides developers many benefits over VanilaJS and jQuery by providing a new feature called components for handling separation of concerns and dividing code into smaller bits of information.\nClient-side frameworks such as Angular facilitate developers to develop advanced web applications like Single-Page-Applications. So, the main reasons behind introducing Angular were to create fast, dynamic, and scalable web applications easily.\nNote: We can also develop dynamic websites and SPAs (Single Page Applications) using VanillaJS, and jQuery but by doing so, the development process becomes slower.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "24) What is Angular CLI?",
        "answer": "Angular CLI is a short form for Angular Command Line Interface. It is a command-line interface to scaffold and build angular apps using node.js style modules.\nTo use Angular CLI, we have to install it by using the following npm command:\nnpm install @angular/cli@latest  \nFollowing is a list of some useful commands which would be very helpful while creating angular projects:\nCreating New Project: ng new\nGenerating Components, Directives & Services: ng generate/g\nRunning the Project: ng serve",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "25) What is lazy loading in Angular?",
        "answer": "Lazy loading is one of the most powerful and useful concepts of Angular Routing. It makes the web pages easy to download by downloading them in chunks instead of downloading everything in a big bundle. Lazy loading facilitates asynchronously loading the feature module for routing whenever required using the property loadChildren.\nSee the following example where we are going to load both Employee and Order feature modules lazily.\nSee the example:\nconst routes: Routes = [  \n  {  \n    path: 'employees',  \n    loadChildren: () => import('./employees/employees.module').then(module => module.EmployeesModule)  \n  },  \n  {  \n    path: 'orders',  \n    loadChildren: () => import('./orders/orders.module').then(module => module.OrdersModule)  \n  },  \n  {  \n    path: '',  \n    redirectTo: '',  \n    pathMatch: 'full'  \n  }  \n];",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "26) What is Angular Router?",
        "answer": "Angular Router is a mechanism that facilitates users to navigate from one view to the next as users perform application tasks. It follows the concept model of browser's application navigation.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "27) What do you understand by the router imports?",
        "answer": "The Angular Router, representing a particular component view for a given URL, is not part of Angular Core. It is available in a library named @angular/router, and we have to import the required router components. This process is called router imports.\nSee the following example of how we can import them in the app module:\nimport { RouterModule, Routes } from '@angular/router';",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "28) What do you understand by RouterOutlet and RouterLink?",
        "answer": "A RouterOutlet is a directive from the router library that acts as a placeholder. It marks the spot in the template where the Router should display the components for that outlet. Router outlet is used as a component.\nSyntax:\n<router-outlet></router-outlet>  \nOn the other hand, a RouterLink is a directive on the anchor tags that gives the router control over those elements. Since the navigation paths are fixed, you can assign string values to router-link directive as below,\nSyntax:\n<h1>Angular Router</h1>  \n<nav>  \n  <a routerLink=\"/todosList\" >List of todos</a>  \n  <a routerLink=\"/completed\" >Completed todos</a>  \n</nav>  \n<router-outlet></router-outlet>",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "29) What are the different router events used in Angular Router?",
        "answer": "During each navigation, the Router emits navigation events through the Router.events property. It allows us to track the lifecycle of the route.\nFollowing is the list of different router events in sequence:\nNavigationStart\nRouteConfigLoadStart\nRouteConfigLoadEnd\nRoutesRecognized\nGuardsCheckStart\nChildActivationStart\nActivationStart\nGuardsCheckEnd\nResolveStart\nResolveEnd\nActivationEnd\nChildActivationEnd\nNavigationEnd\nNavigationCancel\nNavigationError",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "30) What do you understand by the RouterLinkActive?",
        "answer": "The RouterLinkActive is a directive used to toggle CSS classes for active RouterLink bindings based on the current RouterState. i.e., the Router will add CSS classes when this link is active and remove them when the link is inactive.\nFor example, you can add them to RouterLinks as follows:\n<h1>Angular Router</h1>  \n<nav>  \n  <a routerLink=\"/todosList\" routerLinkActive=\"active\">List of todos</a>  \n  <a routerLink=\"/completed\" routerLinkActive=\"active\">Completed todos</a>  \n</nav>  \n<router-outlet></router-outlet>",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "31) What do you understand by the RouterState?",
        "answer": "The RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL segments, the extracted parameters, and the resolved data. We can access the current RouterState from anywhere in the application by using the Router service and the routerState property.\n@Component({templateUrl:'template.html'})  \nclass MyComponent {  \n  constructor(router: Router) {  \n    const state: RouterState = router.routerState;  \n    const root: ActivatedRoute = state.root;  \n    const child = root.firstChild;  \n    const id: Observable<string> = child.params.map(p => p.id);  \n    //...  \n  }  \n}",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "32) What is HttpClient, and what are the advantages of it?",
        "answer": "Most front-end applications use either XMLHttpRequest interface or the fetch() API to communicate with backend services over HTTP protocol. For the same purpose, Angular provides a simplified client HTTP API known as HttpClient. This is based on top of XMLHttpRequest interface. This HttpClient is available in the @angular/common/http package, which you can import in your root module as follows:\nimport { HttpClientModule } from '@angular/common/http';  \nFollowing are some of the crucial advantages of HttpClient:\nHttpClient contains testability features.\nIt provides typed request and response objects.\nIt can intercept requests and responses.\nIt supports Observalbe APIs.\nHttpClient also supports streamlined error handling.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "Is it possible to make an Angular application to render on the server-side?",
        "answer": "Yes, it is possible to make an Angular application to render on the server-side. Angular provides a technology called Angular Universal that can be used to render applications on the server-side.\nThe crucial advantages of using Angular Universal are as follows:\nMaking an Angular application render on the server-side can provide a better user experience. By using this, first-time users can instantly see a view of the application. So, it can be used to provide better UI.\nIt can lead to a better SEO for your application. The reason is that many search engines expect pages in plain HTML. So, Angular Universal can ensure that your content is available on every search engine, and it is good for better SEO.\nThe server-side rendered applications load faster than normal pages. It is because the rendered pages are available to the browser sooner.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "34) What is the best way to perform Error handling in Angular?",
        "answer": "Error is when the request fails on the server or fails to reach the server due to network issues. In this condition, HttpClient returns an error object instead of a successful response. To resolve this issue, we must handle the component by passing the error object as a second callback to the subscribe() method.\nSee the following example to understand how we handle in the component:\nfetchUser() {  \n  this.userService.getProfile()  \n    .subscribe(  \n      (data: User) => this.userProfile = { ...data }, // success path  \n      error => this.error = error // error path  \n    );  \n}  \nYou can write an error message to give the user some meaningful feedback instead of displaying the raw error object returned from HttpClient.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "35) What do you understand by Angular bootstrapping?",
        "answer": "Angular bootstrapping is nothing but to allow developers to initialize or start the Angular application. Angular supports two types of bootstrapping:\nManual bootstrapping\nAutomatic bootstrapping\nManual bootstrapping: Manual bootstrapping provides more control to developers and facilitates them regarding how and when they need to initialize the Angular app. It is useful when professionals wish to perform other tasks and operations before Angular compiles the page.\nAutomatic bootstrapping: As the name specifies, automatic bootstrapping is started automatically to start the Angular app. The developers need to add the ng-app directive to the application's root if they want Angular to bootstrap the application automatically. Angular loads the associated module once it finds the ng-app directive and, further, compiles the DOM.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "36) What is the digest cycle process in Angular?",
        "answer": "The digest cycle process in Angular is the process that is used to monitor the watchlist to track changes in the watch variable value. There is a comparison between the present and the previous versions of the scope model values in each digest cycle.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "37) What are the key differences between a Component and a Directive in Angular?",
        "answer": "A Component is a directive that uses shadow DOM to create encapsulated visual behavior. Usually, components are used to create UI widgets by breaking up the application into smaller parts. In short, we can say that a component (@component) is a directive-with-a-template.\nA list of the major differences between a Component and a Directive in Angular:\nComponent Directive\nComponents are generally used for creating UI widgets. Directives are generally used for adding behavior to an existing DOM element.\nWe use @Component meta-data annotation attributes to register a component. We use @Directive meta-data annotation attributes to register directives.\nIt is used to break up the application into smaller parts called components. It is used to design re-usable components.\nOnly one component is allowed to be used per DOM element. Multiple directives are allowed to be used per DOM element.\n@View decorator or templateurl/template is mandatory in a component. A Directive doesn't use View.\nA component is used to define pipes. In a directive, it is not possible to define Pipes.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "38) What do you understand by Angular MVVM architecture?",
        "answer": "The MVVM architecture or Model-View-ViewModel architecture is a software architectural pattern that provides a facility to developers to separate the development of the graphical user interface (the View) from the development of the business logic or back-end logic (the Model). By using this architecture, the view is not dependent on any specific model platform.\nThe Angular MVVM architecture consists of the following three parts:\nModel\nView\nViewModel\n\nModel: The Model consists of the structure of an entity and specifies the approach. In simple words, we can say that the model contains data of an object.\nView: The View is the visual layer of the application. It specifies the structure, layout, and appearance of what a user sees on the screen. It displays the data inside the Model, represents the model, and receives the user's interaction with the view in the form of mouse clicks, keyboard input, screen tap gestures, etc., and forwards these to the ViewModel via the data binding properties. In Angular terms, the View contains the HTML template of a component.\nViewModel: The ViewModel is an abstract layer of the application. It is used to handle the logic of the application. It also manages the data of a model and displays it in the view. View and ViewModel are connected with two-way data-binding. If you make any changes in the view, the ViewModel takes a note and changes the appropriate data inside the model.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "39) What is the purpose of AsyncPipe in Angular?",
        "answer": "The AsyncPipe is used to subscribe to an observable or promise and return the latest value it has emitted. When a new value is emitted, the pipe marks the component that has been checked for changes.\nSee the following example where a time observable continuously updates the view for every 2 seconds with the current time.\nExample:\n@Component({  \n  selector: 'async-observable-pipe',  \n  template: `<div><code>observable|async</code>:  \n       Time: {{ time | async }}</div>`  \n})  \nexport class AsyncObservablePipeComponent {  \n  time = new Observable(observer =>  \n    setInterval(() => observer.next(new Date().toString()), 2000)  \n  );  \n}",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "40) What do you understand by services in Angular?",
        "answer": "In Angular, services are singleton objects that get instantiated only once during the lifetime of an application. An Angular service contains methods that are used to maintain the data throughout the life of an application. Angular services are used to organize as well as share business logic, models, or data and functions with various components of an Angular application.\nAngular services offer some functions that can be invoked from an Angular component, such as a controller or directive.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "41) What is the key difference between a constructor and ngOnInit?",
        "answer": "Constructor is a default method in TypeScript classes that are normally used for the initialization purpose. On the other hand, the ngOnInit is specifically an Angular method and is used to define Angular bindings. Even though constructors are getting called first, it is always preferred to move all of your Angular bindings to the ngOnInit method.\nSee the following example how we can use ngOnInit by implementing OnInit interface as follows:\nexport class App implements OnInit{  \n  constructor(){  \n     //called first time before the ngOnInit()  \n  }  \n  ngOnInit(){  \n     //called after the constructor and called  after the first ngOnChanges()  \n  }  \n}",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "42) What do you understand by observable and observer in Angular?",
        "answer": "Observable: An observable is a unique object just like a promise that that is used to manage async code. Observables are not part of the JavaScript language so the developers have to rely on a popular Observable library called RxJS. The observables are created using the new keyword.\nSee a simple example of observable to understand it better:\nimport { Observable } from 'rxjs';  \nconst observable = new Observable(observer => {  \n  setTimeout(() => {  \n    observer.next('This is a message from Observable!');  \n  }, 1000);  \n});   \nObserver: Any object that has to be notified when the state of another object changes is called an observer. An observer is an interface for push-based notifications delivered by an Observable.\nSee the structure of an observer:\ninterface Observer<T> {  \n  closed?: boolean;  \n  next: (value: T) => void;  \n  error: (err: any) => void;  \n  complete: () => void;  \n}   \nThe handler that implements the observer interface for receiving observable notifications is passed as a parameter for observable as follows:\nmyObservable.subscribe(myObserver);  \nNote: If you don't use a handler for a notification type, the observer ignores notifications of that type.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "43) How do you categorize data binding types in Angular?",
        "answer": "In Angular, we can categorize data binding types in three categories distinguished by the direction of data flow. These data binding categories are:\nFrom the source-to-view\nFrom view-to-source\nView-to-source-to-view\nLet's see their possible binding syntax:\nData direction Syntax Type\nFrom the source-to-view(One-way data binding) 1. {{expression}}\n2. [target]=\"expression\"\n3. bind-target=\"expression\" Interpolation, Property, Attribute, Class, Style\nFrom view-to-source(One-way data binding) 1. (target)=\"statement\"\n2. on-target=\"statement\" Event\nView-to-source-to-view(Two-way data binding) 1. [(target)]=\"expression\"\n2. bindon-target=\"expression\" Two-way data binding",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "44) What is multicasting in Angular?",
        "answer": "Multicasting or Multi-casting is the practice of broadcasting to a list of multiple subscribers in a single execution.\nLet's take a simple example to demonstrate the multi-casting feature:\nvar source = Rx.Observable.from([1, 2, 3]);  \nvar subject = new Rx.Subject();  \nvar multicasted = source.multicast(subject);  \n// These are, under the hood, `subject.subscribe({...})`:  \nmulticasted.subscribe({  \n  next: (v) => console.log('observerA: ' + v)  \n});  \nmulticasted.subscribe({  \n  next: (v) => console.log('observerB: ' + v)  \n});",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "45) What do you understand by Angular Material?",
        "answer": "Angular Material is a UI component library that is used by professionals to develop consistent, attractive, and completely functional websites, web pages, and web applications. It follows the modern principles of web designing, such as graceful degradation and browser probability, and is capable of doing a lot of fascinating things in website and application development.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "46) What is lazy loading in Angular? Why is it used?",
        "answer": "In Angular, the by default tendency of NgModules is eagerly loaded. It means that as soon as the app loads, all the NgModules are loaded, whether or not they are immediately necessary. That's why lazy loading is required. Lazy loading is mandatory for large apps with lots of routes. This design pattern makes the app load NgModules when they are only required. Lazy loading helps keep initial bundle sizes smaller, which in turn helps decrease load times.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "47) What is the use of Angular filters? What are its distinct types?",
        "answer": "Filters are an essential part of Angular that helps in formatting the expression value to show it to the users. We can easily add filters to services, directives, templates, or controllers. We can also create personalized filters as per requirements. These filters allow us to organize the data in such a way that only the data that meets the respective criteria are displayed. Filters are placed after the pipe symbol ( | ) while used in expressions.\nA list of various types of filters used in Angular:\ncurrency: It is used to convert numbers to the currency format.\nfilter: It is used to select a subset containing items from the given array.\ndate: It is used to convert a date into a necessary format.\nlowercase: It is used to convert the given string into lowercase.\nuppercase: It is used to convert the given string into uppercase.\norderBy: It is used to arrange an array by the given expression.\njson: It is used to format any object into a JSON string.\nnumber: It is used to convert a numeric value into a string.\nlimitTo: It is used to restrict the limit of a given string or array to a particular number of elements or strings.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "48) When do we use a directive in Angular?",
        "answer": "If you create an Angular application where multiple components need to have similar functionalities, you have to do it by adding this functionality individually to every component. This is not a very easy task. Directives are used to cope up with this situation. Here, we can create a directive with the required functionality and then import the directive to components that require this functionality.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "49) What are the different types of directives in Angular?",
        "answer": "There are mainly three types of directives in Angular:\nComponent Directives: The component directives are used to form the main class in directives. To declare these directives, we have to use the @Component decorator instead of @Directive decorator. These directives have a view, a stylesheet and a selector property.\nStructural directives: These directives are generally used to manipulate DOM elements. The structural directive has a ' * ' sign before them. We can apply these directives to any DOM element.\nFollowing are some example of built-in structural directives:\n*ngIf Structural Directive: *ngIf is used to check a Boolean value and if it's truthy, the div element will be displayed.\n<div *ngIf=\"isReady\" class=\"display_name\">  \n          {{name}}  \n      </div>  \n*ngFor Structural Directive: *ngFor is used to iterate over a list and display each item of the list.\n<div class=\"details\" *ngFor=\"let x of details\" >  \n    <p>{{x.name}}</p>  \n    <p> {{x.address}}</p>  \n    <p>{{x.age}}</p>  \n</div>  \nAttribute Directives: The attribute directives are used to change the look and behavior of a DOM element. Let's create an attribute directive to understand it well:\nThis is how we can create a custom directive:\nGo to the command terminal, navigate to the directory of the angular app and type the following command to generate a directive:\nng g directive yellowBackground   \nThis will generate the following directive. Manipulate the directive to look like this:\nimport { Directive, ElementRef } from '@angular/core';  \n@Directive({  \n selector: '[appYellowBackground]'  \n})  \nexport class YellowBackgroundDirective {  \n constructor(el:ElementRef) {  \n   el.nativeElement.style.backgroundColor = \"yellow\";  \n }  \n}  \nNow, you can easily apply the above directive to any DOM element:\n<p appYellowBackground>Hello JavaTpoint</p>",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "50) What are string interpolation and property binding in Angular?",
        "answer": "String interpolation and property binding are parts of data-binding in Angular. Data-binding is a feature of Angular, which is used to provide a way to communicate between the component (Model) and its view (HTML template). There are two ways of data-binding, one-way data binding and two-way data binding. In Angular, data from the component can be inserted inside the HTML template. Any changes in the component will directly reflect inside the HTML template in one-way binding, but vice-versa is not possible. On the other hand, it is possible in two-way binding.\nString interpolation and property binding both are examples of one-way data binding. They allow only one-way data binding.\nString Interpolation: String interpolation uses the double curly braces {{ }} to display data from the component. Angular automatically runs the expression written inside the curly braces. For example, {{ 5+5 }} will be evaluated by Angular, and the output will be 10. This output will be displayed inside the HTML template.\nProperty Binding: Property binding is used to bind the DOM properties of an HTML element to a component's property. In property binding, we use the square brackets [ ] syntax.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "51) Is it possible to make an angular application to render on the server-side?",
        "answer": "Yes, we can make an angular application to render on the server-side. Angular provides a technology Angular Universal that makes you able to render applications on the server-side.\nFollowing are the benefits of using Angular Universal:\nBetter User Experience: It enables users to see the view of the application instantly.\nBetter SEO: Angular Universal ensures that the content is available on every search engine leading to better SEO.\nLoad Faster: Angular Universal ensures that the render pages available to the browsers sooner to make the loading faster server-side application loads faster.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "52) What is Dependency Injection in Angular?",
        "answer": "Dependency injection is an application design pattern that is implemented by Angular. It is used to form the core concepts of Angular. Dependencies are services in Angular which have some specific functionality. Various components and directives in an application can need these functionalities of the service. Angular provides a smooth mechanism by which these dependencies are injected into components and directives.",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "53) Can you demonstrate navigation between different routes in an Angular application?",
        "answer": "You can demonstrate the navigation between different routes in an Angular app in the following way. See the following code to demonstrate navigation in an Angular app named \"My First App.\"\nimport from \"@angular/router\";  \n.  \n.  \n.  \n@Component({  \n  selector: 'app-header',  \n  template: `  \n<nav class=\"navbar navbar-light bg-faded\">  \n  <a class=\"navbar-brand\" (click)=\"goHome()\">My First App</a>   \n  <ul class=\"nav navbar-nav\">  \n    <li class=\"nav-item\">  \n      <a class=\"nav-link\" (click)=\"goHome()\">Home</a>   \n    </li>  \n    <li class=\"nav-item\">  \n      <a class=\"nav-link\" (click)=\"goSearch()\">Search</a>   \n    </li>  \n  </ul>  \n</nav>  \n})  \nclass HeaderComponent {  \n  constructor(private router: Router) {}   \n  goHome() {  \n    this.router.navigate(['']);   \n  }  \n  goSearch() {  \n    this.router.navigate(['search']);   \n  }  \n}",
        "reference": "javatpoint.com",
        "role": "angular"
    },
    {
        "question": "js?",
        "answer": "Following are the various notable differences between Angular and Backbone.js:\nComparison Parameter Angular Backbone.js\nArchitecture Angular works on the MVC architecture and makes use of two-way data binding for driving application activity. Backbone.js makes use of the MVP architecture and doesn't provide any data binding process.\nType Angular is an open-source JavaScript-based front-end web application framework that extends HTML with new attributes. Backbone.js is a lightweight JavaScript library that uses a RESTful JSON interface and MVP framework.\nData Binding Angular is a little bit complex because it uses a two-way data binding process. On the other hand, Backbone.js has a simple API because it doesn't have any data binding process.\nDOM Angular's main focus is on valid HTML and dynamic elements that imitate the underlying data for rebuilding the DOM as per the specified rules and then work on the updated data records. Backbone.js follows the direct DOM manipulation approach for representing data and application architecture changes.\nPerformance Because of its two-way data binding functionality, Angular provides powerful performance for both small and large projects. Backbone.js is quite a significant upper hand in performance over Angular in small data sets or small web pages. It is not recommended for larger web pages or large data sets due to the absence of any data binding process.\nTemplating Angular supports templating via dynamic HTML attributes. You can add them to the document to develop an easy to understand application at a functional level. Backbone.js uses Underscore.js templates that aren't fully-featured as Angular templates.\nTesting Approach The testing approach is lengthy for Angular because it is preferred for building large applications.\nIt uses unit testing. The testing approach is completely different for Backbone.js because it is ideal for developing smaller webpages or applications.\nCommunity Support The angular framework is developed and maintained by Google, so it receives great community support. Here, extensive documentation is available. Backbone.js also receives a good level of community support, but it only documents on Underscore.js templates, not much else.",
        "reference": "javatpoint.com",
        "role": "angular"
    }
]