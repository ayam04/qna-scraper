[
    {
        "question": "1. What is Hibernate?",
        "answer": "Hibernate is an Object-Relational Mapping (ORM) tool for Java. It provides a high-level abstraction layer that allows developers to interact with databases in a Java-centric way. This makes it easier to develop database-driven applications.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "2. What is Object-Relational Mapping (ORM) and how does Hibernate provide it?",
        "answer": "Object-Relational Mapping (ORM) is a technique for mapping objects in an object-oriented programming language to relational database tables. Hibernate is an ORM framework for Java that simplifies database interactions by automatically generating SQL queries and handling object-to-table mappings based on the defined entity classes and their associations.\nFor example, if you have a Java class called Customer with properties for the customer’s name, address, and phone number, Hibernate can automatically generate SQL queries to insert, update, and delete customers from a database table. Hibernate can also map relationships between entities, such as one-to-one, one-to-many, and many-to-many relationships.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "3. Explain Hibernate architecture.",
        "answer": "Hibernate is an open-source object-relational mapping (ORM) framework for Java applications.\nIt simplifies mapping Java classes to database tables and enables object-oriented database operations.\nKey components of the Hibernate architecture:\nApplication: Represents the Java application utilizing Hibernate.\nConfiguration: Provides necessary settings and properties for Hibernate.\nSessionFactory: Central factory class for creating and managing Hibernate Sessions.\nSession: Represents a unit of work with the database, bridging the application and database.\nTransaction: Ensures data consistency and integrity for logical units of work.\nORM: Maps Java classes to database tables, enabling CRUD operations.\nQuery: Allows writing HQL or Criteria queries to retrieve data.\nCaching: Improves performance with session-level and application-level caching.\nConnection Pool: Efficiently manages database connections through pooling.\nDialect: Handles database-specific differences in SQL syntax and data types.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "4. What are the benefits of using Hibernate in a project?",
        "answer": "There are several advantages of using Hibernate in a project, including:\nImproved productivity: Hibernate eliminates the need to write manual SQL queries, which can save developers a lot of time.\nDatabase portability: Hibernate provides an abstraction layer that makes it easy to move applications to different databases.\nTransparent persistence: Hibernate automatically manages the persistence of objects, which makes it easy to develop applications that interact with databases.\nSupport for caching and performance optimization: Hibernate supports caching of objects and query results, which can improve performance.\nSimplified management of transactions and connections: Hibernate provides a simplified API for managing transactions and connections, which can make it easier to develop robust and scalable applications.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "5. What are some of the challenges of using Hibernate?",
        "answer": "Some of the notable challenges of using Hibernate are mentioned below:\nUsing Hibernate presents a number of difficulties, including:\nLearning curve: For developers who are unfamiliar with ORM technologies, Hibernate might have a challenging learning curve.\nHibernate is a complicated framework with many features. Because of this, it could be challenging to identify faults and comprehend how things operate.\nHibernate’s impact on performance, particularly for programs that do a lot of database queries, can be negative",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "6. Explain the difference between a transient object, a persistent object, and a detached object in Hibernate.",
        "answer": "In the world of Hibernate, we classify objects into three categories: transient, persistent, and detached. A transient object lacks an association with a database session. On the other hand, a persistent object is linked to an active database session. Finally, a detached object is a persistent object that has been disconnected from its session.\nWhen an object is initially created, it falls into the transient category. To make it persistent, you need to add it to a session using either the save() or persist() method. Once an object becomes persistent, any modifications made to it will be automatically synchronized with the database.\nIf you find yourself needing to eliminate an object from the database, the delete() method comes in handy. It performs two tasks: detaching the object from the session and removing it from the database.\nGet 100% Hike!\nMaster Most in Demand Skills Now!\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "7. What is the purpose of the Hibernate SessionFactory, and how is it created?",
        "answer": "The Hibernate SessionFactory is a factory for creating Hibernate sessions. It is typically created during application startup by reading the configuration files, which include mappings between entity classes and database tables.\nThe SessionFactory is responsible for managing the first-level cache, connection pooling, and other Hibernate-related configurations.\nTo create a SessionFactory, you need to provide the following information:\nThe location of the Hibernate configuration file.\nThe database driver class.\nThe database connection URL.\nThe database user name and password.\nOnce you have created a SessionFactory, you can use it to create Hibernate sessions.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "8. Describe the process of persisting an object using Hibernate.",
        "answer": "To persist an object with Hibernate, the following steps are typically followed:\nBegin by creating a fresh instance of the object you wish to persist.\nPopulate the object with the necessary data.\nObtain a Hibernate Session from the SessionFactory. This session serves as a connection to the database.\nInvoke the save() or persist() method on the Session, passing in the object you want to persist. This action instructs Hibernate to save the object to the database.\nComplete the transaction by committing it. This step ensures that the changes are permanently stored in the database.\nSo, to summarize:\nInstantiate the object.\nPopulate the object with data.\nAcquire a Hibernate Session.\nUse the save() or persist() method on the Session to persist the object.\nCommit the transaction.\nThe following code shows an example of how to persist an object using Hibernate:\nCode snippet\n\nSession session = sessionFactory.openSession();\n\nCustomer customer = new Customer();\ncustomer.setName(\"karan k\");\ncustomer.setAddress(\"12345 domain Street\");\ncustomer.setPhone(\"123-456-7890\");\n\nsession.save(customer);\n\nsession.getTransaction().commit();",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "9. What is the purpose of the @Id annotation in Hibernate, and how is it used?",
        "answer": "The @Id annotation is used to mark a property as the identifier (primary key) of an entity in Hibernate. It can be applied to a field or a getter method. By specifying the @Id annotation, Hibernate knows which property to use as the unique identifier when performing database operations.\nThe following code shows an example of how to use the @Id annotation:\nCode snippet\n@Entity\npublic class Customer\n{   \n\n}",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "10. What is Hibernate Query Language (HQL) and how is it used?",
        "answer": "Hibernate Query Language (HQL) is a powerful object-oriented query language used in Hibernate, an Object-Relational Mapping (ORM) framework for Java. HQL is designed to work with Hibernate’s object model, allowing developers to perform database operations using object-oriented concepts rather than writing raw SQL queries.\nHQL syntax closely resembles SQL, but it operates on persistent objects and their associated intermediaries. Instead of directly referring to database tables and columns, HQL uses the names of mapped Java classes and their properties. This makes it easier to work with complex object graphs and relationships.\n\nHibernate Interview Questions for Experienced\nBelow are some of the intermediate-level Java Hibernate interview questions for learners:",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "11. What is Hibernate tuning?",
        "answer": "Hibernate tuning involves optimizing database interactions, SQL queries, and caching strategies. It aims to enhance application performance, reduce resource consumption, and manage memory efficiently.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "12. What is hibernate caching?",
        "answer": "Hibernate caching refers to:\nHibernate caching is a performance enhancement technique.\nIt stores frequently accessed data in memory.\nReduces the need for repeated database queries, improving response times.\nTwo levels: first-level cache (session-specific) and second-level cache (application-wide).\nFirst-level cache is session-specific; second-level cache is shared.\nEffective for minimizing database load and optimizing Hibernate-based application performance.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "13. Is it possible to perform collection mapping with One-to-One and Many-to-One?",
        "answer": "Collection mapping in Hibernate links entities with Java collections (e.g., List, Set, Map) and corresponding database tables. It establishes one-to-one and many-to-one relationships, enhancing data model flexibility. This feature is essential for creating efficient and comprehensive data models in Hibernate-based applications.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "14. How does Hibernate handle database transactions?",
        "answer": "Hibernate provides robust support for managing database transactions. It follows the widely accepted approach of using a Unit of Work pattern to track and control the changes made to persistent objects within a transaction.\nWhen working with Hibernate, you typically interact with the database through a Session object. A Session represents a single database connection and acts as a gateway for all database operations. It serves as a context for managing and coordinating transactions.\nHibernate employs a transactional write-behind mechanism, meaning that changes made to persistent objects within a transactional context are not immediately propagated to the database. Instead, Hibernate tracks these changes and applies them in a controlled manner when the transaction is committed.\nThe transaction management in Hibernate can be achieved using two main approaches:\nProgrammatic Transaction Management: In this approach, you explicitly manage transactions in your code using the Hibernate API. You start a transaction by invoking the beginTransaction() method on the Session object. Once the transaction is active, you perform your database operations (such as saving, updating, or deleting objects). Finally, you commit the transaction using the commit() method, or you can roll it back if an error occurs.\nSession session = sessionFactory.openSession();\n\nTransaction transaction = session.beginTransaction();\ntry {\n\n    // Perform database operations within the transaction\n\n     session.saveOrUpdate(entity1);\n    session.delete(entity2);\n\n    // Commit the transaction\n    transaction.commit();\n} catch (Exception e) {\n   // Handle exceptions and roll back the transaction if needed\n    transaction.rollback();\n} finally {\n    session.close();\n}\nDeclarative Transaction Management: This approach involves leveraging external transaction management frameworks such as Java Transaction API (JTA) or Spring Framework’s declarative transaction management. These frameworks handle the transaction management aspects, allowing you to focus on the business logic. They typically provide annotations or configuration to specify transaction boundaries, and Hibernate seamlessly integrates with them",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "15. What is the purpose of Hibernate caching, and what are the different levels of caching supported by Hibernate?",
        "answer": "Hibernate employs caching as a means to enhance application performance by minimizing the necessity of frequent database data retrieval. Within Hibernate, there are three levels of caching supported:\nFirst-level cache (Session cache): It is the default cache and operates at the session level. It stores persistent objects within the session, allowing fast retrieval and reducing database round-trips for subsequent accesses within the same session.\nSecond-level cache (SessionFactory cache): It is a shared cache that spans multiple sessions. It stores data that is frequently accessed across sessions, such as entity objects or query results. It helps minimize database hits and benefits applications with high read-intensive workloads.\nQuery cache: It caches the results of queries executed through Hibernate’s query APIs. It can significantly improve the performance of frequently executed queries by avoiding unnecessary re-evaluation.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "16. How do you create an immutable class in hibernate?",
        "answer": "To create an immutable class in Hibernate, follow these steps. First, ensure all class fields are marked as “final” and initialized via the constructor. Second, exclude setter methods for these fields. Third, employ the “mutable=”false”” attribute in the Hibernate mapping file to specify immutability. Finally, implement equals() and hashCode() methods based on immutable fields. By adhering to these principles, the class becomes immutable, guaranteeing data integrity and consistent behavior during Hibernate operations, making it suitable for scenarios where data should not be altered once persisted.\n\nInterview Questions for 5 Years Experience",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "17. What is the difference between an eager fetch and a lazy fetch in Hibernate?",
        "answer": "In Hibernate, eager fetching and lazy fetching are two strategies for retrieving associated entities:\nEager fetching loads all associated entities immediately when the parent entity is fetched from the database. This can result in more database queries upfront but avoids additional queries when accessing associated entities later.\nLazy fetching loads associated entities only when they are explicitly accessed, either directly or through a getter method. This strategy minimizes the initial data retrieval but may trigger additional queries if lazy-loaded associations are accessed after the session is closed.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "18. How does Hibernate handle database transactions in a multi-threaded environment?",
        "answer": "In a multi-threaded environment, Hibernate provides different strategies for managing database transactions:\nThread-bound session: Each thread has its own session associated with it. Transactions are managed separately within each thread, ensuring thread-safety and isolation.\nSession-per-request: A new session is created for each incoming request, and a transaction is initiated for that session. This approach allows the concurrent processing of multiple requests with their own isolated sessions and transactions.\nManaged transactions: In a container-managed environment (such as Java EE), transactions can be managed by the application server using declarative transaction demarcation. Hibernate integrates with the transaction management capabilities provided by the application server.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "19. What are the different ways to define entity mappings in Hibernate?",
        "answer": "Hibernate supports two main approaches for defining entity mappings:\nXML mappings: Entities can be mapped using XML configuration files, where each entity class is associated with a corresponding XML file defining its mapping information. XML mappings offer flexibility and allow customization of various mapping details.\nAnnotation mappings: Entities can be annotated using Hibernate-specific annotations, such as @Entity, @Table, and @Column, to define the mapping information directly within the entity class. Annotation mappings provide a more compact and readable way of defining mappings and are commonly used in modern Hibernate projects.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "20. How does Hibernate handle database schema generation and synchronization?",
        "answer": "Hibernate provides several mechanisms to handle database schema generation and synchronization:\nHibernate can automatically generate the database schema based on the entity mappings. It can create tables, columns, constraints, and other database artifacts as defined in the mappings.\nSchema updates can be performed by Hibernate using the hbm2ddl.auto configuration property. Hibernate can validate and update the schema based on changes made to the entity mappings.\nHibernate also supports the use of database schema migration tools, such as Liquibase or Flyway, to manage and evolve the database schema over time while preserving existing data.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "21. How does Hibernate handle caching of query results, and what are the benefits of using it?",
        "answer": "Hibernate provides query result caching, which allows the caching of the results of queries executed through Hibernate’s query APIs. When a cached query is executed again with the same parameters, Hibernate retrieves the result directly from the cache instead of re-executing the query. Query result caching can significantly improve the performance of frequently executed queries, as it avoids the overhead of query evaluation and database round-trips. It is especially beneficial for read-intensive applications with complex or expensive queries.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "22. What is the purpose of Hibernate interceptors, and how are they implemented?",
        "answer": "Hibernate interceptors provide a way to intercept and customize Hibernate’s behavior at various stages of the object lifecycle. Interceptors can be used to perform actions such as auditing, logging, or modifying data before it is persisted or retrieved. To implement a Hibernate interceptor, developers need to create a class that implements the org.hibernate.Interceptor interface. The interceptor class can override methods that correspond to different events in the object lifecycle, such as onSave(), onDelete(), or onLoad(), and add custom logic to be executed during those events.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "23. What are the options for integrating Hibernate with the Spring Framework, and what are the benefits of using this combination?",
        "answer": "Hibernate and the Spring Framework can be integrated in different ways, with the most common approach being through Spring’s support for ORM integration. The benefits of using Hibernate with Spring include:\nSimplified configuration and dependency management through Spring’s IoC (Inversion of Control) container.\nSeamless transaction management with Spring’s declarative transaction support, allowing for consistent and automatic handling of database transactions.\nIntegration with Spring’s powerful features, such as AOP (Aspect-Oriented Programming), dependency injection, and transactional testing.\nEnhanced testability and maintainability of the application codebase.\nAbility to leverage Spring’s broader ecosystem for additional features like security, caching, and distributed systems.\n\nAdvanced Interview Questions\nBelow is the list of advanced-level Hibernate interview questions:",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "24. How does Hibernate handle inheritance mapping, and what are the supported strategies?",
        "answer": "Hibernate supports different strategies for inheritance mapping hierarchies to database tables:\nTable per class hierarchy: All classes in the inheritance hierarchy are mapped to a single table, which includes columns for properties of all subclasses. Discriminator columns are used to differentiate between different subclass types.\nTable per subclass: Each class in the inheritance hierarchy is mapped to its own table. Common properties are mapped to the superclass table, while subclass-specific properties are mapped to individual subclass tables.\nTable per concrete class: Each concrete class in the inheritance hierarchy is mapped to its own table, including both superclass and subclass properties. This strategy avoids the use of inheritance-related joins but can lead to redundant columns in the database schema.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "25. What are the different types of associations supported by Hibernate, and how are they implemented?",
        "answer": "Hibernate supports various types of associations between entities, including one-to-one, one-to-many, many-to-one, and many-to-many associations. These associations are implemented with the utilization of annotations or XML mappings in Hibernate. For example, a one-to-many association can be represented by adding a collection property in one entity class and using the @OneToMany annotation to establish the relationship. Hibernate takes care of generating the necessary foreign key constraints and SQL queries to maintain the association between entities.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "26. How does Hibernate handle optimistic concurrency control, and what are the benefits of using it?",
        "answer": "Hibernate supports optimistic concurrency control, a mechanism that ensures data consistency in concurrent environments without acquiring locks. It relies on versioning to detect conflicts during updates. Each entity involved in optimistic locking has a version attribute that is checked during updates. If the version of an entity has changed since it was loaded, Hibernate throws an exception, indicating a concurrent modification. Optimistic concurrency control improves application scalability by allowing multiple transactions to work concurrently and reducing the chances of contention and deadlock compared to pessimistic locking.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "27. What are the considerations for optimizing performance in Hibernate applications?",
        "answer": "Optimizing performance in Hibernate applications involves various factors, including database schema design, caching strategies, query optimization, and efficient use of transactions. Some considerations include:\nCareful mapping of entities to database tables and columns, avoiding unnecessary joins and redundant data.\nEffective use of caching mechanisms, such as second-level caching for entities and query result caching.\nProper indexing of database tables to improve query performance.\nUse of pagination and lazy loading to retrieve and process data in smaller chunks.\nBatch processing for efficient database updates, reduces round-trips to the database.\nMonitoring and analyzing SQL query execution plans to identify and resolve performance bottlenecks.\nFine-tuning of Hibernate configuration settings, such as fetch strategies and transaction boundaries, based on application-specific requirements.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "28. What is the role of the Hibernate Session in database interactions, and how is it managed?",
        "answer": "The Hibernate Session serves as the main interface between the application and the underlying database. It represents a unit of work and provides methods for querying, persisting, and manipulating entities. The Session is responsible for managing the first-level cache (also known as the session-level cache), which stores loaded entities within its scope. The Session is typically obtained from the SessionFactory and should be used within a transactional context. It is recommended to manage the Session’s lifecycle within the boundaries of a single logical operation or business transaction to ensure consistent and predictable database interactions.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "29. What is lazy loading in Hibernate?",
        "answer": "Lazy loading is a technique used in Hibernate to defer the loading of associated entities or collections until the data is explicitly accessed or requested. It is an optimization strategy aimed at reducing unnecessary database queries and improving performance.\nWhen an entity is marked for lazy loading, Hibernate fetches only the basic attributes of the entity from the database when it is initially loaded. The associated entities or collections, known as lazy associations, are not loaded at that time. Instead, placeholder objects, or proxies, are created for these associations.\nWhen the application code attempts to access a lazy association, Hibernate intercepts the access and triggers a database query to fetch the associated data. This process is known as lazy loading. The data is then loaded and associated with the original entity, allowing seamless traversal of the object graph.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "30. What is the purpose of the Hibernate Configuration file, and what are the key elements it contains?",
        "answer": "The Hibernate Configuration file is an XML or properties file that provides essential configuration information to Hibernate. It specifies the database connection details, mappings between entity classes and database tables, and various Hibernate settings. Key elements in the Hibernate Configuration file include:\nDatabase connection settings: Such as the JDBC URL, driver class name, username, and password.\nMapping configurations: Specifies the mapping between entity classes and database tables, including associations, inheritance hierarchies, and custom mapping options.\nHibernate properties: Allows customization of various Hibernate settings, such as caching, fetching strategies, naming conventions, and transaction management.\nAdditional configurations: These can include settings related to connection pooling, second-level caching, and other vendor-specific features.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "31. How does Hibernate handle database schema generation and evolution?",
        "answer": "Here are the two commonly used approaches: Hibernate’s Automatic Schema Generation and Database Schema Migration.\nAutomatic Schema Generation: Hibernate provides a feature called “Automatic Schema Generation,” which allows you to automatically generate the database schema based on your entity mappings. This feature is particularly useful during the development and testing phases.\nBy configuring Hibernate with appropriate properties, it can automatically generate the necessary tables, columns, constraints, and indexes in the database based on your entity definitions. This eliminates the need to write and maintain SQL scripts for creating the schema.\nAutomatic Schema Generation offers different modes, such as create, create-drop, update, and validate, each serving a specific purpose.Automatic Schema Generation is suitable for scenarios where you want Hibernate to manage the entire database schema automatically based on your entity definitions. However, it’s worth noting that this approach may not be ideal for production environments where more controlled schema management is desired.\nDatabase Schema Migration: Hibernate integrates well with third-party database migration tools, such as Flyway or Liquibase, which provide a more controlled approach to schema management. These tools allow for incremental and version-controlled database schema changes. With database schema migration, you create separate SQL or script files that define each version of the database schema. These files contain instructions for modifying the schema, such as creating or altering tables, columns, or constraints.\nHibernate can be configured to work alongside these migration tools. When your application starts up, Hibernate validates the current database schema against the expected version specified in the migration scripts. If there are any differences, it applies the necessary migrations to bring the schema up to date.\nThis approach provides greater flexibility and control over the database schema evolution process. It allows for collaborative schema management across multiple developers or teams and supports handling complex migration scenarios, such as data transformations or complex schema changes.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "32. What is the working mechanism of Lazy loading?",
        "answer": "Hibernate provides different mechanisms for implementing lazy loading:\nProxy Objects: When an entity is marked for lazy loading, Hibernate creates a proxy object that extends or implements the entity class/interface. This proxy object acts as a placeholder for the actual associated entity or collection. When a method or attribute of the lazy association is accessed, the proxy object triggers a database query to load the associated data.\nBytecode Enhancement: Hibernate also offers bytecode enhancement as an alternative to proxy-based lazy loading. By enhancing the bytecode of entity classes, Hibernate is able to insert bytecode instructions that enable lazy loading without the need for proxy objects. This approach provides more efficient lazy loading and avoids potential issues related to proxy object serialization.\nFetching Strategies: Hibernate provides various fetching strategies to control the loading behavior of associations. These strategies determine when and how the associated entities or collections are loaded. For example, you can choose to load associations eagerly (at the time of the initial query) or lazily (on demand). The fetching strategy can be configured at the entity or association level using annotations or XML mappings.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "33. Differentiate between get() and load() in Hibernate session.",
        "answer": "Characteristic get() load()\nObject Return Returns a fully initialized object or null. Returns a proxy object, a placeholder.\nDatabase Retrieval Immediate database retrieval. Delays database retrieval until accessed.\nException Handling Throws an exception if not found. Throws an exception upon access if not found.\nUse Case Suitable for immediate data needs. Useful for lazy loading and deferred retrieval.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "34. Differentiate between save() and saveOrUpdate() methods in hibernate session.",
        "answer": "save() saveOrUpdate()\nPersists a new object. Saves or updates based on object existence.\nAssumes object is new. Detects if object is transient or detached.\nAlways inserts a new row. Inserts new record or updates existing record.\nTypically used for new data. Suitable for uncertain new/existing cases.",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "35. How does Hibernate handle object associations, such as one-to-one and one-to-many relationships?",
        "answer": "Hibernate provides mechanisms to handle object associations between entities:\nOne-to-one relationship: Hibernate allows one-to-one associations between entities by defining a foreign key relationship between them. It can be mapped using the @OneToOne annotation, specifying the associated entity and the foreign key column.\nOne-to-many relationship: Hibernate supports one-to-many associations using collections, such as sets or lists, to represent the relationship between entities. It can be mapped using the @OneToMany annotation, specifying the associated entity, the collection type, and the foreign key column",
        "reference": "intellipaat.com",
        "role": "hibernate"
    },
    {
        "question": "1. What are the advantages of Hibernate over JDBC?",
        "answer": "- The advantages of Hibernate over JDBC are listed below: Clean Readable Code: Using hibernate, helps in eliminating a lot of JDBC API-based boiler-plate codes, thereby making the code look cleaner and readable.\nHQL (Hibernate Query Language): Hibernate provides HQL which is closer to Java and is object-oriented in nature. This helps in reducing the burden on developers for writing database independent queries. In JDBC, this is not the case. A developer has to know the database-specific codes.\nTransaction Management: JDBC doesn't support implicit transaction management. It is upon the developer to write transaction management code using commit and rollback methods. Whereas, Hibernate implicity provides this feature.\nException Handling: Hibernate wraps the JDBC exceptions and throws unchecked exceptions like JDBCException or HibernateException. This along with the built-in transaction management system helps developers to avoid writing multiple try-catch blocks to handle exceptions. In the case of JDBC, it throws a checked exception called SQLException thereby mandating the developer to write try-catch blocks to handle this exception at compile time.\nSpecial Features: Hibernate supports OOPs features like inheritance, associations and also supports collections. These are not available in JDBC. Clean Readable Code: Using hibernate, helps in eliminating a lot of JDBC API-based boiler-plate codes, thereby making the code look cleaner and readable. Clean Readable Code: HQL (Hibernate Query Language): Hibernate provides HQL which is closer to Java and is object-oriented in nature. This helps in reducing the burden on developers for writing database independent queries. In JDBC, this is not the case. A developer has to know the database-specific codes. HQL (Hibernate Query Language): Transaction Management: JDBC doesn't support implicit transaction management. It is upon the developer to write transaction management code using commit and rollback methods. Whereas, Hibernate implicity provides this feature. Transaction Management: Exception Handling: Hibernate wraps the JDBC exceptions and throws unchecked exceptions like JDBCException or HibernateException. This along with the built-in transaction management system helps developers to avoid writing multiple try-catch blocks to handle exceptions. In the case of JDBC, it throws a checked exception called SQLException thereby mandating the developer to write try-catch blocks to handle this exception at compile time. Exception Handling: Special Features: Hibernate supports OOPs features like inheritance, associations and also supports collections. These are not available in JDBC. Special Features:",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "2. What is ORM in Hibernate?",
        "answer": "Hibernate ORM stands for Object Relational Mapping. This is a mapping tool pattern mainly used for converting data stored in a relational database to an object used in object-oriented programming constructs. This tool also helps greatly in simplifying data retrieval, creation, and manipulation. Hibernate ORM Object Relational Mapping Object Relational Mapping  Object Relational Mapping",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "3. Is hibernate prone to SQL injection attack?",
        "answer": "SQL injection attack is a serious vulnerability in terms of web security wherein an attacker can interfere with the queries made by an application/website to its database thereby allowing the attacker to view sensitive data which are generally irretrievable. It can also give the attacker to modify/ remove the data resulting in damages to the application behavior. SQL injection attack Hibernate does not provide immunity to SQL Injection. However, following good practices avoids SQL injection attacks. It is always advisable to follow any of the below options: Incorporate Prepared Statements that use Parameterized Queries.\nUse Stored Procedures.\nEnsure data sanity by doing input validation. Incorporate Prepared Statements that use Parameterized Queries. Use Stored Procedures. Ensure data sanity by doing input validation.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "4. Can you explain the concept behind Hibernate Inheritance Mapping?",
        "answer": "Java is an Object-Oriented Programming Language and Inheritance is one of the most important pillars of object-oriented principles. To represent any models in Java, inheritance is most commonly used to simplify and simplify the relationship. But, there is a catch. Relational databases do not support inheritance. They have a flat structure. Hibernate’s Inheritance Mapping strategies deal with solving how to hibernate being an ORM tries to map this problem between the inheritance of Java and flat structure of Databases. Consider the example where we have to divide InterviewBitEmployee into Contract and Permanent Employees represented by IBContractEmployee and IBPermanentEmployee classes respectively. Now the task of hibernate is to represent these 2 employee types by considering the below restrictions: The general employee details are defined in the parent InterviewBitEmployee class. Contract and Permanent employee-specific details are stored in IBContractEmployee and IBPermanentEmployee classes respectively The class diagram of this system is as shown below: Hibernate’s Inheritance Mapping  Hibernate’s Inheritance Mapping  There are different inheritance mapping strategies available: Single Table Strategy\nTable Per Class Strategy\nMapped Super Class Strategy\nJoined Table Strategy Single Table Strategy Table Per Class Strategy Mapped Super Class Strategy Joined Table Strategy",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "5. How do you create an immutable class in hibernate?",
        "answer": "Immutable class in hibernate creation could be in the following way. If we are using the XML form of configuration, then a class can be made immutable by markingmutable=false. The default value is true there which indicating that the class was not created by default. In the case of using annotations, immutable classes in hibernate can also be created by using @Immutable annotation.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "6. What can you tell about Hibernate Configuration File?",
        "answer": "Hibernate Configuration File or hibernate.cfg.xml is one of the most required configuration files in Hibernate. By default, this file is placed under the src/main/resource folder.\nThe file contains database related configurations and session-related configurations.\nHibernate facilitates providing the configuration either in an XML file (like hibernate.cfg.xml) or a properties file (like hibernate.properties). Hibernate Configuration File hibernate.cfg.xml   This file is used to define the below information: This file is used to define the below information: Database connection details: Driver class, URL, username, and password.\nThere must be one configuration file for each database used in the application, suppose if we want to connect with 2 databases, then we must create 2 configuration files with different names.\nHibernate properties: Dialect, show_sql, second_level_cache, and mapping file names. Database connection details: Driver class, URL, username, and password. There must be one configuration file for each database used in the application, suppose if we want to connect with 2 databases, then we must create 2 configuration files with different names. Hibernate properties: Dialect, show_sql, second_level_cache, and mapping file names.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "7. Can you explain what is lazy loading in hibernate?",
        "answer": "Lazy loading is mainly used for improving the application performance by helping to load the child objects on demand. It is to be noted that, since Hibernate 3 version, this feature has been enabled by default. This signifies that child objects are not loaded until the parent gets loaded.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "8. What do you think about the statement - “session being a thread-safe object”?",
        "answer": "No, Session is not a thread-safe object which means that any number of threads can access data from it simultaneously.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "9. What is a SessionFactory?",
        "answer": "SessionFactory provides an instance of Session. It is a factory class that gives the Session objects based on the configuration parameters in order to establish the connection to the database.\nAs a good practice, the application generally has a single instance of SessionFactory. The internal state of a SessionFactory which includes metadata about ORM is immutable, i.e once the instance is created, it cannot be changed. Session objects  This also provides the facility to get information like statistics and metadata related to a class, query executions, etc. It also holds second-level cache data if enabled.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "10. What is a Session in Hibernate?",
        "answer": "A session is an object that maintains the connection between Java object application and database. Session also has methods for storing, retrieving, modifying or deleting data from database using methods like persist(), load(), get(), update(), delete(), etc. Additionally, It has factory methods to return Query, Criteria, and Transaction objects.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "11. What are some of the important interfaces of Hibernate framework?",
        "answer": "Hibernate core interfaces are: Configuration\nSessionFactory\nSession\nCriteria\nQuery\nTransaction Configuration SessionFactory Session Criteria Query Transaction",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "12. What is the difference between first level cache and second level cache?",
        "answer": "Hibernate has 2 cache types. First level and second level cache for which the difference is given below: First Level Cache Second Level Cache\nThis is local to the Session object and cannot be shared between multiple sessions. This cache is maintained at the SessionFactory level and shared among all sessions in Hibernate.\nThis cache is enabled by default and there is no way to disable it. This is disabled by default, but we can enable it through configuration.\nThe first level cache is available only until the session is open, once the session is closed, the first level cache is destroyed. The second-level cache is available through the application’s life cycle, it is only destroyed and recreated when an application is restarted. First Level Cache Second Level Cache\nThis is local to the Session object and cannot be shared between multiple sessions. This cache is maintained at the SessionFactory level and shared among all sessions in Hibernate.\nThis cache is enabled by default and there is no way to disable it. This is disabled by default, but we can enable it through configuration.\nThe first level cache is available only until the session is open, once the session is closed, the first level cache is destroyed. The second-level cache is available through the application’s life cycle, it is only destroyed and recreated when an application is restarted. First Level Cache Second Level Cache First Level Cache Second Level Cache First Level Cache Second Level Cache This is local to the Session object and cannot be shared between multiple sessions. This cache is maintained at the SessionFactory level and shared among all sessions in Hibernate.\nThis cache is enabled by default and there is no way to disable it. This is disabled by default, but we can enable it through configuration.\nThe first level cache is available only until the session is open, once the session is closed, the first level cache is destroyed. The second-level cache is available through the application’s life cycle, it is only destroyed and recreated when an application is restarted. This is local to the Session object and cannot be shared between multiple sessions. This cache is maintained at the SessionFactory level and shared among all sessions in Hibernate. This is local to the Session object and cannot be shared between multiple sessions. This cache is maintained at the SessionFactory level and shared among all sessions in Hibernate. This cache is enabled by default and there is no way to disable it. This is disabled by default, but we can enable it through configuration. This cache is enabled by default and there is no way to disable it. This is disabled by default, but we can enable it through configuration. The first level cache is available only until the session is open, once the session is closed, the first level cache is destroyed. The second-level cache is available through the application’s life cycle, it is only destroyed and recreated when an application is restarted. The first level cache is available only until the session is open, once the session is closed, the first level cache is destroyed. The second-level cache is available through the application’s life cycle, it is only destroyed and recreated when an application is restarted. If an entity or object is loaded by calling the get() method then Hibernate first checked the first level cache, if it doesn’t find the object then it goes to the second level cache if configured. If the object is not found then it finally goes to the database and returns the object, if there is no corresponding row in the table then it returns null.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "1. Explain hibernate mapping file",
        "answer": "Hibernate mapping file is an XML file that is used for defining the entity bean fields and corresponding database column mappings.\nThese files are useful when the project uses third-party classes where JPA annotations provided by hibernating cannot be used.  In the previous example, we have defined the mapping resource as “InterviewBitEmployee.hbm.xml” in the config file. Let us see what that sample hbm.xml file looks like: <?xml version = \"1.0\" encoding = \"utf-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n\"-//Hibernate/Hibernate Mapping DTD//EN\"\n\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\n<hibernate-mapping>\n   <!-- What class is mapped to what database table-->\n  <class name = \"InterviewBitEmployee\" table = \"InterviewBitEmployee\">\n\n     <meta attribute = \"class-description\">\n        This class contains the details of employees of InterviewBit. \n     </meta>\n\n     <id name = \"id\" type = \"int\" column = \"employee_id\">\n        <generator class=\"native\"/>\n     </id>\n\n     <property name = \"fullName\" column = \"full_name\" type = \"string\"/>\n     <property name = \"email\" column = \"email\" type = \"string\"/>\n\n  </class>\n</hibernate-mapping> <?xml version = \"1.0\" encoding = \"utf-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n\"-//Hibernate/Hibernate Mapping DTD//EN\"\n\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\n<hibernate-mapping>\n   <!-- What class is mapped to what database table-->\n  <class name = \"InterviewBitEmployee\" table = \"InterviewBitEmployee\">\n\n     <meta attribute = \"class-description\">\n        This class contains the details of employees of InterviewBit. \n     </meta>\n\n     <id name = \"id\" type = \"int\" column = \"employee_id\">\n        <generator class=\"native\"/>\n     </id>\n\n     <property name = \"fullName\" column = \"full_name\" type = \"string\"/>\n     <property name = \"email\" column = \"email\" type = \"string\"/>\n\n  </class>\n</hibernate-mapping> <?xml version = \"1.0\" encoding = \"utf-8\"?> <!DOCTYPE hibernate-mapping PUBLIC \n\"-//Hibernate/Hibernate Mapping DTD//EN\"\n\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"> hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\" <hibernate-mapping> hibernate-mapping <!-- What class is mapped to what database table--> <class name = \"InterviewBitEmployee\" table = \"InterviewBitEmployee\"> class name \"InterviewBitEmployee\" table \"InterviewBitEmployee\" <meta attribute = \"class-description\"> meta attribute \"class-description\" </meta> meta <id name = \"id\" type = \"int\" column = \"employee_id\"> id name \"id\" type \"int\" column \"employee_id\" <generator class=\"native\"/> generator class \"native\" </id> id <property name = \"fullName\" column = \"full_name\" type = \"string\"/> property name \"fullName\" column \"full_name\" type \"string\" <property name = \"email\" column = \"email\" type = \"string\"/> property name \"email\" column \"email\" type \"string\" </class> class </hibernate-mapping> hibernate-mapping",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "2. What are the most commonly used annotations available to support hibernate mapping?",
        "answer": "Hibernate framework provides support to JPA annotations and other useful annotations in the org.hibernate.annotations package. Some of them are as follows: javax.persistence.Entity: This annotation is used on the model classes by using “@Entity” and tells that the classes are entity beans.\njavax.persistence.Table: This annotation is used on the model classes by using “@Table” and tells that the class maps to the table name in the database.\njavax.persistence.Access: This is used as “@Access” and is used for defining the access type of either field or property. When nothing is specified, the default value taken is “field”.\njavax.persistence.Id: This is used as “@Id” and is used on the attribute in a class to indicate that attribute is the primary key in the bean entity.\njavax.persistence.EmbeddedId: Used as “@EmbeddedId” upon the attribute and indicates it is a composite primary key of the bean entity.\njavax.persistence.Column: “@Column” is used for defining the column name in the database table.\njavax.persistence.GeneratedValue: “@GeneratedValue” is used for defining the strategy used for primary key generation. This annotation is used along with javax.persistence.GenerationType enum.\njavax.persistence.OneToOne: “@OneToOne” is used for defining the one-to-one mapping between two bean entities. Similarly, hibernate provides OneToMany, ManyToOne and ManyToMany annotations for defining different mapping types.\norg.hibernate.annotations.Cascade: “@Cascade” annotation is used for defining the cascading action between two bean entities. It is used with org.hibernate.annotations.CascadeType enum to define the type of cascading.\nFollowing is a sample class where we have used the above listed annotations: javax.persistence.Entity: This annotation is used on the model classes by using “@Entity” and tells that the classes are entity beans. javax.persistence.Table: This annotation is used on the model classes by using “@Table” and tells that the class maps to the table name in the database. javax.persistence.Access: This is used as “@Access” and is used for defining the access type of either field or property. When nothing is specified, the default value taken is “field”. javax.persistence.Id: This is used as “@Id” and is used on the attribute in a class to indicate that attribute is the primary key in the bean entity. javax.persistence.EmbeddedId: Used as “@EmbeddedId” upon the attribute and indicates it is a composite primary key of the bean entity. javax.persistence.Column: “@Column” is used for defining the column name in the database table. javax.persistence.GeneratedValue: “@GeneratedValue” is used for defining the strategy used for primary key generation. This annotation is used along with javax.persistence.GenerationType enum. javax.persistence.OneToOne: “@OneToOne” is used for defining the one-to-one mapping between two bean entities. Similarly, hibernate provides OneToMany, ManyToOne and ManyToMany annotations for defining different mapping types.\norg.hibernate.annotations.Cascade: “@Cascade” annotation is used for defining the cascading action between two bean entities. It is used with org.hibernate.annotations.CascadeType enum to define the type of cascading.\nFollowing is a sample class where we have used the above listed annotations:   package com.dev.interviewbit.model;\nimport javax.persistence.Access;\nimport javax.persistence.AccessType;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.OneToOne;\nimport javax.persistence.Table;\n\nimport org.hibernate.annotations.Cascade;\n\n@Entity\n@Table(name = \"InterviewBitEmployee\")\n@Access(value=AccessType.FIELD)\npublic class InterviewBitEmployee {\n\n   @Id\n   @GeneratedValue(strategy = GenerationType.IDENTITY)\n   @Column(name = \"employee_id\")\n   private long id;\n\n   @Column(name = \"full_name\")\n   private String fullName;\n\n   @Column(name = \"email\")\n   private String email;\n   \n   @OneToOne(mappedBy = \"employee\")\n   @Cascade(value = org.hibernate.annotations.CascadeType.ALL)\n   private Address address;\n\n   //getters and setters methods\n} package com.dev.interviewbit.model;\nimport javax.persistence.Access;\nimport javax.persistence.AccessType;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.OneToOne;\nimport javax.persistence.Table;\n\nimport org.hibernate.annotations.Cascade;\n\n@Entity\n@Table(name = \"InterviewBitEmployee\")\n@Access(value=AccessType.FIELD)\npublic class InterviewBitEmployee {\n\n   @Id\n   @GeneratedValue(strategy = GenerationType.IDENTITY)\n   @Column(name = \"employee_id\")\n   private long id;\n\n   @Column(name = \"full_name\")\n   private String fullName;\n\n   @Column(name = \"email\")\n   private String email;\n   \n   @OneToOne(mappedBy = \"employee\")\n   @Cascade(value = org.hibernate.annotations.CascadeType.ALL)\n   private Address address;\n\n   //getters and setters methods\n}",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "3. Explain Hibernate architecture",
        "answer": "The Hibernate architecture consists of many objects such as a persistent object, session factory, session, query, transaction, etc. Applications developed using Hibernate is mainly categorized into 4 parts: Java Application\nHibernate framework - Configuration and Mapping Files\nInternal API -\nJDBC (Java Database Connectivity)\nJTA (Java Transaction API)\nJNDI (Java Naming Directory Interface).\nDatabase - MySQL, PostGreSQL, Oracle, etc Java Application Hibernate framework - Configuration and Mapping Files Internal API -\nJDBC (Java Database Connectivity)\nJTA (Java Transaction API)\nJNDI (Java Naming Directory Interface). JDBC (Java Database Connectivity)\nJTA (Java Transaction API)\nJNDI (Java Naming Directory Interface). JDBC (Java Database Connectivity) JTA (Java Transaction API) JNDI (Java Naming Directory Interface). Database - MySQL, PostGreSQL, Oracle, etc Hibernate Architecture  Hibernate Architecture  The main elements of Hibernate framework are: SessionFactory: This provides a factory method to get session objects and clients of ConnectionProvider. It holds a second-level cache (optional) of data.\nSession: This is a short-lived object that acts as an interface between the java application objects and database data.\nThe session can be used to generate transaction, query, and criteria objects.\nIt also has a mandatory first-level cache of data.\nTransaction: This object specifies the atomic unit of work and has methods useful for transaction management. This is optional.\nConnectionProvider: This is a factory of JDBC connection objects and it provides an abstraction to the application from the DriverManager. This is optional.\nTransactionFactory: This is a factory of Transaction objects. It is optional. SessionFactory: This provides a factory method to get session objects and clients of ConnectionProvider. It holds a second-level cache (optional) of data. Session: This is a short-lived object that acts as an interface between the java application objects and database data.\nThe session can be used to generate transaction, query, and criteria objects.\nIt also has a mandatory first-level cache of data. The session can be used to generate transaction, query, and criteria objects.\nIt also has a mandatory first-level cache of data. The session can be used to generate transaction, query, and criteria objects. It also has a mandatory first-level cache of data. Transaction: This object specifies the atomic unit of work and has methods useful for transaction management. This is optional. ConnectionProvider: This is a factory of JDBC connection objects and it provides an abstraction to the application from the DriverManager. This is optional. TransactionFactory: This is a factory of Transaction objects. It is optional. Hibernate Objects  Hibernate Objects",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "4. Can you tell the difference between getCurrentSession and openSession methods?",
        "answer": "Both the methods are provided by the Session Factory. The main differences are given below: getCurrentSession() openSession()\nThis method returns the session bound to the context. This method always opens a new session.\nThis session object scope belongs to the hibernate context and to make this work hibernate configuration file has to be modified by adding <property name = \"hibernate.current_session_context_class\"> thread </property>. If not added, then using the method would throw an HibernateException. A new session object has to be created for each request in a multi-threaded environment. Hence, you need not configure any property to call this method.\nThis session object gets closed once the session factory is closed. It's the developer’s responsibility to close this object once all the database operations are done.\nIn a single-threaded environment, this method is faster than openSession(). In single threaded environment, it is slower than getCurrentSession()single-threadeda getCurrentSession() openSession()\nThis method returns the session bound to the context. This method always opens a new session.\nThis session object scope belongs to the hibernate context and to make this work hibernate configuration file has to be modified by adding <property name = \"hibernate.current_session_context_class\"> thread </property>. If not added, then using the method would throw an HibernateException. A new session object has to be created for each request in a multi-threaded environment. Hence, you need not configure any property to call this method.\nThis session object gets closed once the session factory is closed. It's the developer’s responsibility to close this object once all the database operations are done.\nIn a single-threaded environment, this method is faster than openSession(). In single threaded environment, it is slower than getCurrentSession()single-threadeda getCurrentSession() openSession() getCurrentSession() openSession() getCurrentSession() openSession() This method returns the session bound to the context. This method always opens a new session.\nThis session object scope belongs to the hibernate context and to make this work hibernate configuration file has to be modified by adding <property name = \"hibernate.current_session_context_class\"> thread </property>. If not added, then using the method would throw an HibernateException. A new session object has to be created for each request in a multi-threaded environment. Hence, you need not configure any property to call this method.\nThis session object gets closed once the session factory is closed. It's the developer’s responsibility to close this object once all the database operations are done.\nIn a single-threaded environment, this method is faster than openSession(). In single threaded environment, it is slower than getCurrentSession()single-threadeda This method returns the session bound to the context. This method always opens a new session. This method returns the session bound to the context. This method always opens a new session. This session object scope belongs to the hibernate context and to make this work hibernate configuration file has to be modified by adding <property name = \"hibernate.current_session_context_class\"> thread </property>. If not added, then using the method would throw an HibernateException. A new session object has to be created for each request in a multi-threaded environment. Hence, you need not configure any property to call this method. This session object scope belongs to the hibernate context and to make this work hibernate configuration file has to be modified by adding <property name = \"hibernate.current_session_context_class\"> thread </property>. If not added, then using the method would throw an HibernateException. <property name = \"hibernate.current_session_context_class\"> thread </property> A new session object has to be created for each request in a multi-threaded environment. Hence, you need not configure any property to call this method. This session object gets closed once the session factory is closed. It's the developer’s responsibility to close this object once all the database operations are done. This session object gets closed once the session factory is closed. It's the developer’s responsibility to close this object once all the database operations are done. In a single-threaded environment, this method is faster than openSession(). In single threaded environment, it is slower than getCurrentSession()single-threadeda In a single-threaded environment, this method is faster than openSession(). In single threaded environment, it is slower than getCurrentSession()single-threadeda Apart from these two methods, there is another method openStatelessSession() and this method returns a stateless session object.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "5. Differentiate between save() and saveOrUpdate() methods in hibernate session.",
        "answer": "Both the methods save records to the table in the database in case there are no records with the primary key in the table. However, the main differences between these two are listed below: save() saveOrUpdate()\nsave() generates a new identifier and INSERT record into a database Session.saveOrUpdate() can either INSERT or UPDATE based upon existence of a record.\nThe insertion fails if the primary key already exists in the table. In case the primary key already exists, then the record is updated.\nThe return type is Serializable which is the newly generated identifier id value as a Serializable object. The return type of the saveOrUpdate() method is void.\nThis method is used to bring only a transient object to a persistent state. This method can bring both transient (new) and detached (existing) objects into a persistent state. It is often used to re-attach a detached object into a Session save() saveOrUpdate()\nsave() generates a new identifier and INSERT record into a database Session.saveOrUpdate() can either INSERT or UPDATE based upon existence of a record.\nThe insertion fails if the primary key already exists in the table. In case the primary key already exists, then the record is updated.\nThe return type is Serializable which is the newly generated identifier id value as a Serializable object. The return type of the saveOrUpdate() method is void.\nThis method is used to bring only a transient object to a persistent state. This method can bring both transient (new) and detached (existing) objects into a persistent state. It is often used to re-attach a detached object into a Session save() saveOrUpdate() save() saveOrUpdate() save() saveOrUpdate() save() generates a new identifier and INSERT record into a database Session.saveOrUpdate() can either INSERT or UPDATE based upon existence of a record.\nThe insertion fails if the primary key already exists in the table. In case the primary key already exists, then the record is updated.\nThe return type is Serializable which is the newly generated identifier id value as a Serializable object. The return type of the saveOrUpdate() method is void.\nThis method is used to bring only a transient object to a persistent state. This method can bring both transient (new) and detached (existing) objects into a persistent state. It is often used to re-attach a detached object into a Session save() generates a new identifier and INSERT record into a database Session.saveOrUpdate() can either INSERT or UPDATE based upon existence of a record. save() generates a new identifier and INSERT record into a database Session.saveOrUpdate() can either INSERT or UPDATE based upon existence of a record. The insertion fails if the primary key already exists in the table. In case the primary key already exists, then the record is updated. The insertion fails if the primary key already exists in the table. In case the primary key already exists, then the record is updated. The return type is Serializable which is the newly generated identifier id value as a Serializable object. The return type of the saveOrUpdate() method is void. The return type is Serializable which is the newly generated identifier id value as a Serializable object. The return type of the saveOrUpdate() method is void. This method is used to bring only a transient object to a persistent state. This method can bring both transient (new) and detached (existing) objects into a persistent state. It is often used to re-attach a detached object into a Session This method is used to bring only a transient object to a persistent state. This method can bring both transient (new) and detached (existing) objects into a persistent state. It is often used to re-attach a detached object into a Session Clearly, saveOrUpdate() is more flexible in terms of use but it involves extra processing to find out whether a record already exists in the table or not.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "6. Differentiate between get() and load() in Hibernate session",
        "answer": "These are the methods to get data from the database. The primary differences between get and load in Hibernate are given below: get() load()\nThis method gets the data from the database as soon as it is called. This method returns a proxy object and loads the data only when it is required.\nThe database is hit every time the method is called. The database is hit only when it is really needed and this is called Lazy Loading which makes the method better.\nThe method returns null if the object is not found. The method throws ObjectNotFoundException if the object is not found.\nThis method should be used if we are unsure about the existence of data in the database. This method is to be used when we know for sure that the data is present in the database. get() load()\nThis method gets the data from the database as soon as it is called. This method returns a proxy object and loads the data only when it is required.\nThe database is hit every time the method is called. The database is hit only when it is really needed and this is called Lazy Loading which makes the method better.\nThe method returns null if the object is not found. The method throws ObjectNotFoundException if the object is not found.\nThis method should be used if we are unsure about the existence of data in the database. This method is to be used when we know for sure that the data is present in the database. get() load() get() load() get() load() This method gets the data from the database as soon as it is called. This method returns a proxy object and loads the data only when it is required.\nThe database is hit every time the method is called. The database is hit only when it is really needed and this is called Lazy Loading which makes the method better.\nThe method returns null if the object is not found. The method throws ObjectNotFoundException if the object is not found.\nThis method should be used if we are unsure about the existence of data in the database. This method is to be used when we know for sure that the data is present in the database. This method gets the data from the database as soon as it is called. This method returns a proxy object and loads the data only when it is required. This method gets the data from the database as soon as it is called. This method returns a proxy object and loads the data only when it is required. The database is hit every time the method is called. The database is hit only when it is really needed and this is called Lazy Loading which makes the method better. The database is hit every time the method is called. The database is hit only when it is really needed and this is called Lazy Loading which makes the method better. The method returns null if the object is not found. The method throws ObjectNotFoundException if the object is not found. The method returns null if the object is not found. The method throws ObjectNotFoundException if the object is not found. This method should be used if we are unsure about the existence of data in the database. This method is to be used when we know for sure that the data is present in the database. This method should be used if we are unsure about the existence of data in the database. This method is to be used when we know for sure that the data is present in the database.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "7. What is criteria API in hibernate?",
        "answer": "Criteria API in Hibernate helps developers to build dynamic criteria queries on the persistence database. Criteria API is a more powerful and flexible alternative to HQL (Hibernate Query Language) queries for creating dynamic queries. dynamic criteria queries This API allows to programmatically development criteria query objects. The org.hibernate.Criteria interface is used for these purposes. The Session interface of hibernate framework has createCriteria() method that takes the persistent object’s class or its entity name as the parameters and returns persistence object instance the criteria query is executed. It also makes it very easy to incorporate restrictions to selectively retrieve data from the database. It can be achieved by using the add() method which accepts the org.hibernate.criterion.Criterion object representing individual restriction. Usage examples: Usage examples: To return all the data of InterviewBitEmployee entity class. To return all the data of InterviewBitEmployee entity class. Criteria criteria = session.createCriteria(InterviewBitEmployee.class);\nList<InterviewBitEmployee> results = criteria.list(); Criteria criteria = session.createCriteria(InterviewBitEmployee.class);\nList<InterviewBitEmployee> results = criteria.list(); To retrive objects whose property has value equal to the restriction, we use Restrictions.eq() method. For example, to fetch all records with name ‘Hibernate’: To retrive objects whose property has value equal to the restriction, we use Restrictions.eq() method. For example, to fetch all records with name ‘Hibernate’: Criteria criteria= session.createCriteria(InterviewBitEmployee.class);\ncriteria.add(Restrictions.eq(\"fullName\",\"Hibernate\"));\nList<InterviewBitEmployee> results = criteria.list(); Criteria criteria= session.createCriteria(InterviewBitEmployee.class);\ncriteria.add(Restrictions.eq(\"fullName\",\"Hibernate\"));\nList<InterviewBitEmployee> results = criteria.list(); To get objects whose property has the value “not equal to” the restriction, we use Restrictions.ne() method. For example, to fetch all the records whose employee’s name is not Hibernate: To get objects whose property has the value “not equal to” the restriction, we use Restrictions.ne() method. For example, to fetch all the records whose employee’s name is not Hibernate: Criteria criteria= session.createCriteria(InterviewBitEmployee.class);\ncriteria.add(Restrictions.ne(\"fullName\",\"Hibernate\"));\nList<Employee> results = criteria.list() Criteria criteria= session.createCriteria(InterviewBitEmployee.class);\ncriteria.add(Restrictions.ne(\"fullName\",\"Hibernate\"));\nList<Employee> results = criteria.list() To retrieve all objects whose property matches a given pattern, we use Restrictions.like() (for case sensitivenes) and Restrictions.ilike()(for case insensitiveness) To retrieve all objects whose property matches a given pattern, we use Restrictions.like() (for case sensitivenes) and Restrictions.ilike()(for case insensitiveness) Criteria criteria= session.createCriteria(InterviewBitEmployee.class);\ncriteria.add(Restrictions.like(\"fullName\",\"Hib%\",MatchMode.ANYWHERE));\nList<InterviewBitEmployee> results = criteria.list(); Criteria criteria= session.createCriteria(InterviewBitEmployee.class);\ncriteria.add(Restrictions.like(\"fullName\",\"Hib%\",MatchMode.ANYWHERE));\nList<InterviewBitEmployee> results = criteria.list(); Similarly, it also has other methods like isNull(), isNotNull(), gt(), ge(), lt(), le() etc for adding more varieties of restrictions. It has to be noted that for Hibernate 5 onwards, the functions returning an object of typeCriteria are deprecated. Hibernate 5 version has provided interfaces like CriteriaBuilder and CriteriaQuery to serve the purpose: javax.persistence.criteria.CriteriaBuilder\njavax.persistence.criteria.CriteriaQuery\n\n// Create CriteriaBuilder\nCriteriaBuilder builder = session.getCriteriaBuilder();\n\n// Create CriteriaQuery\nCriteriaQuery<YourClass> criteria = builder.createQuery(YourClass.class); javax.persistence.criteria.CriteriaBuilder\njavax.persistence.criteria.CriteriaQuery\n\n// Create CriteriaBuilder\nCriteriaBuilder builder = session.getCriteriaBuilder();\n\n// Create CriteriaQuery\nCriteriaQuery<YourClass> criteria = builder.createQuery(YourClass.class); For introducing restrictions in CriteriaQuery, we can use the CriteriaQuery.where method which is analogous to using the WHERE clause in a JPQL query.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "8. What is HQL?",
        "answer": "Hibernate Query Language (HQL) is used as an extension of SQL. It is very simple, efficient, and very flexible for performing complex operations on relational databases without writing complicated queries. HQL is the object-oriented representation of query language, i.e instead of using table name, we make use of the class name which makes this language independent of any database. Hibernate Query Language (HQL) SQL This makes use of the Query interface provided by Hibernate. The Query object is obtained by calling the createQuery() method of the hibernate Session interface. Following are the most commonly used methods of query interface: public int executeUpdate() : This method is used to run the update/delete query.\npublic List list(): This method returns the result as a list.\npublic Query setFirstResult(int rowNumber): This method accepts the row number as the parameter using which the record of that row number would be retrieved.\npublic Query setMaxResult(int rowsCount): This method returns a maximum up to the specified rowCount while retrieving from the database.\npublic Query setParameter(int position, Object value): This method sets the value to the attribute/column at a particular position. This method follows the JDBC style of the query parameter.\npublic Query setParameter(String name, Object value): This method sets the value to a named query parameter. public int executeUpdate() : This method is used to run the update/delete query. public List list(): This method returns the result as a list. public Query setFirstResult(int rowNumber): This method accepts the row number as the parameter using which the record of that row number would be retrieved. public Query setMaxResult(int rowsCount): This method returns a maximum up to the specified rowCount while retrieving from the database. public Query setParameter(int position, Object value): This method sets the value to the attribute/column at a particular position. This method follows the JDBC style of the query parameter. public Query setParameter(String name, Object value): This method sets the value to a named query parameter. Example: To get a list of all records from InterviewBitEmployee Table: Example: To get a list of all records from InterviewBitEmployee Table: Query query=session.createQuery(\"from InterviewBitEmployee\");  \nList<InterviewBitEmployee> list=query.list();  \nSystem.out.println(list.get(0)); Query query=session.createQuery(\"from InterviewBitEmployee\");  \nList<InterviewBitEmployee> list=query.list();  \nSystem.out.println(list.get(0));",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "9. Can you tell something about one to many associations and how can we use them in Hibernate?",
        "answer": "The one-to-many association is the most commonly used which indicates that one object is linked/associated with multiple objects. one-to-many association For example, one person can own multiple cars. Hibernate One To Many Mapping  Hibernate One To Many Mapping In Hibernate, we can achieve this by using @OnetoMany of JPA annotations in the model classes. Consider the above example of a person having multiple cars as shown below: @Entity\n@Table(name=\"Person\")\npublic class Person {\n\n   //...\n\n   @OneToMany(mappedBy=\"owner\")\n   private Set<Car> cars;\n\n   // getters and setters\n} @Entity\n@Table(name=\"Person\")\npublic class Person {\n\n   //...\n\n   @OneToMany(mappedBy=\"owner\")\n   private Set<Car> cars;\n\n   // getters and setters\n} In the Person class, we have defined the car's property to have @OneToMany association. The Car class would have owned property that is used by the mappedBy variable in the Person class. The Car class is as shown below: @Entity\n@Table(name=\"Car\")\npublic class Car {\n\n   // Other Properties\n   \n   @ManyToOne\n   @JoinColumn(name=\"person_id\", nullable=false)\n   private Person owner;\n\n   public Car() {}\n\n   // getters and setters\n} @Entity\n@Table(name=\"Car\")\npublic class Car {\n\n   // Other Properties\n   \n   @ManyToOne\n   @JoinColumn(name=\"person_id\", nullable=false)\n   private Person owner;\n\n   public Car() {}\n\n   // getters and setters\n} @ManyToOne annotation indicates that many instances of an entity are mapped to one instance of another entity – many cars of one person.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "10. What are Many to Many associations?",
        "answer": "Many-to-many association indicates that there are multiple relations between the instances of two entities. We could take the example of multiple students taking part in multiple courses and vice versa. Many-to-many association Since both the student and course entities refer to each other by means of foreign keys, we represent this relationship technically by creating a separate table to hold these foreign keys. Many To Many Associations  Many To Many Associations Here, Student-Course Table is called the Join Table where the student_id and course_id would form the composite primary key.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "11. What does session.lock() method in hibernate do?",
        "answer": "session.lock() method is used to reattach a detached object to the session. session.lock() method does not check for any data synchronization between the database and the object in the persistence context and hence this reattachment might lead to loss of data synchronization. session.lock() session.lock()",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "12. What is hibernate caching?",
        "answer": "Hibernate caching is the strategy for improving the application performance by pooling objects in the cache so that the queries are executed faster. Hibernate caching is particularly useful when fetching the same data that is executed multiple times. Rather than hitting the database, we can just access the data from the cache. This results in reduced throughput time of the application. Hibernate caching Types of Hibernate Caching First Level Cache: First Level Cache: This level is enabled by default.\nThe first level cache resides in the hibernate session object.\nSince it belongs to the session object, the scope of the data stored here will not be available to the entire application as an application can make use of multiple session objects. This level is enabled by default. The first level cache resides in the hibernate session object. Since it belongs to the session object, the scope of the data stored here will not be available to the entire application as an application can make use of multiple session objects. First Level Caching  First Level Caching Second Level Cache: Second Level Cache: Second level cache resides in the SessionFactory object and due to this, the data is accessible by the entire application.\nThis is not available by default. It has to be enabled explicitly.\nEH (Easy Hibernate) Cache, Swarm Cache, OS Cache, JBoss Cache are some example cache providers. Second level cache resides in the SessionFactory object and due to this, the data is accessible by the entire application. This is not available by default. It has to be enabled explicitly. EH (Easy Hibernate) Cache, Swarm Cache, OS Cache, JBoss Cache are some example cache providers. Second Level Caching  Second Level Caching",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "13. When is merge() method of the hibernate session useful?",
        "answer": "Merge() method can be used for updating existing values. The specialty of this method is, once the existing values are updated, the method creates a copy from the entity object and returns it. This result object goes into the persistent context and is then tracked for any changes. The object that was initially used is not tracked.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "14. Collection mapping can be done using One-to-One and Many-to-One Associations. What do you think?",
        "answer": "False, collection mapping is possible only with One-to-Many and Many-to-Many associations. One-to-Many Many-to-Many associations.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "15. Can you tell the difference between setMaxResults() and setFetchSize() of Query?",
        "answer": "setMaxResults() the function works similar to LIMIT in SQL. Here, we set the maximum number of rows that we want to be returned. This method is implemented by all database drivers. setFetchSize() works for optimizing how Hibernate sends the result to the caller for example: are the results buffered, are they sent in different size chunks, etc. This method is not implemented by all the database drivers.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "16. Does Hibernate support Native SQL Queries?",
        "answer": "Yes, it does. Hibernate provides the createSQLQuery() method to let a developer call the native SQL statement directly and returns a Query object. Consider the example where you want to get employee data with the full name “Hibernate”. We don’t want to use HQL-based features, instead, we want to write our own SQL queries. In this case, the code would be: Query query = session.createSQLQuery( \"select * from interviewbit_employee ibe where ibe.fullName = :fullName\")\n                   .addEntity(InterviewBitEmployee.class)\n                   .setParameter(\"fullName\", \"Hibernate\"); //named parameters\nList result = query.list(); Query query = session.createSQLQuery( \"select * from interviewbit_employee ibe where ibe.fullName = :fullName\")\n                   .addEntity(InterviewBitEmployee.class)\n                   .setParameter(\"fullName\", \"Hibernate\"); //named parameters\nList result = query.list(); Alternatively, native queries can also be supported when using NamedQueries.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "1. What happens when the no-args constructor is absent in the Entity bean?",
        "answer": "Hibernate framework internally uses Reflection API for creating entity bean instances when get() or load() methods are called. The method Class.newInstance() is used which requires a no-args constructor to be present. When we don't have this constructor in the entity beans, then hibernate fails to instantiate the bean and hence it throws HibernateException.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "2. Can we declare the Entity class final?",
        "answer": "No, we should not define the entity class final because hibernate uses proxy classes and objects for lazy loading of data and hits the database only when it is absolutely needed. This is achieved by extending the entity bean. If the entity class (or bean) is made final, then it cant be extended and hence lazy loading can not be supported.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "3. What are the states of a persistent entity?",
        "answer": "A persistent entity can exist in any of the following states: Transient: Transient: This state is the initial state of any entity object.\nOnce the instance of the entity class is created, then the object is said to have entered a transient state. These objects exist in heap memory.\nIn this state, the object is not linked to any session. Hence, it is not related to any database due to which any changes in the data object don't affect the data in the database. This state is the initial state of any entity object. Once the instance of the entity class is created, then the object is said to have entered a transient state. These objects exist in heap memory. In this state, the object is not linked to any session. Hence, it is not related to any database due to which any changes in the data object don't affect the data in the database. InterviewBitEmployee employee=new InterviewBitEmployee(); //The object is in the transient state.  \n   employee.setId(101);  \n   employee.setFullName(\"Hibernate\"); \n   employee.setEmail(\"hibernate@interviewbit.com\"); InterviewBitEmployee employee=new InterviewBitEmployee(); //The object is in the transient state.  \n   employee.setId(101);  \n   employee.setFullName(\"Hibernate\"); \n   employee.setEmail(\"hibernate@interviewbit.com\"); Persistent: Persistent: This state is entered whenever the object is linked or associated with the session.\nAn object is said to be in a persistence state whenever we save or persist an object in the database. Each object corresponds to the row in the database table. Any modifications to the data in this state cause changes in the record in the database. This state is entered whenever the object is linked or associated with the session. An object is said to be in a persistence state whenever we save or persist an object in the database. Each object corresponds to the row in the database table. Any modifications to the data in this state cause changes in the record in the database. Following methods can be used upon the persistence object: Following methods can be used upon the persistence object: session.save(record);  \nsession.persist(record);  \nsession.update(record);  \nsession.saveOrUpdate(record);  \nsession.lock(record);  \nsession.merge(record); session.save(record);  \nsession.persist(record);  \nsession.update(record);  \nsession.saveOrUpdate(record);  \nsession.lock(record);  \nsession.merge(record); Detached: Detached: The object enters this state whenever the session is closed or the cache is cleared.\nDue to the object being no longer part of the session, any changes in the object will not reflect in the corresponding row of the database. However, it would still have its representation in the database.\nIn case the developer wants to persist changes of this object, it has to be reattached to the hibernate session.\nIn order to achieve the reattachment, we can use the methods load(), merge(), refresh(), update(), or save() methods on a new session by using the reference of the detached object. The object enters this state whenever the session is closed or the cache is cleared. Due to the object being no longer part of the session, any changes in the object will not reflect in the corresponding row of the database. However, it would still have its representation in the database. In case the developer wants to persist changes of this object, it has to be reattached to the hibernate session. In order to achieve the reattachment, we can use the methods load(), merge(), refresh(), update(), or save() methods on a new session by using the reference of the detached object. The object enters this state whenever any of the following methods are called: session.close();\nsession.clear();\nsession.detach(record);\nsession.evict(record); session.close();\nsession.clear();\nsession.detach(record);\nsession.evict(record); Persistent Entity  Persistent Entity",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "4. Explain Query Cache",
        "answer": "Hibernate framework provides an optional feature called cache region for the queries’ resultset. Additional configurations have to be done in code in order to enable this. The query cache is useful for those queries which are most frequently called with the same parameters. This increases the speed of the data retrieval and greatly improves performance for commonly repetitive queries. This does not cache the state of actual entities in the result set but it only stores the identifier values and results of the value type. Hence, query cache should be always used in association with second-level cache. Configuration: Configuration: In the hibernate configuration XML file, set the use_query_cache property to true as shown below: <property name=\"hibernate.cache.use_query_cache\">true</property>\n\nIn the code, we need to do the below changes for the query object:\nQuery query = session.createQuery(\"from InterviewBitEmployee\");\nquery.setCacheable(true);\nquery.setCacheRegion(\"IB_EMP\"); <property name=\"hibernate.cache.use_query_cache\">true</property>\n\nIn the code, we need to do the below changes for the query object:\nQuery query = session.createQuery(\"from InterviewBitEmployee\");\nquery.setCacheable(true);\nquery.setCacheRegion(\"IB_EMP\");",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "5. Can you tell something about the N+1 SELECT problem in Hibernate?",
        "answer": "N+1 SELECT problem is due to the result of using lazy loading and on-demand fetching strategy. Let's take an example. If you have an N items list and each item from the list has a dependency on a collection of another object, say bid. In order to find the highest bid for each item while using the lazy loading strategy, hibernate has to first fire 1 query to load all items and then subsequently fire N queries to load big of each item. Hence, hibernate actually ends up executing N+1 queries.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "6. How to solve N+1 SELECT problem in Hibernate?",
        "answer": "Some of the strategies followed for solving the N+1 SELECT problem are: Pre-fetch the records in batches which helps us to reduce the problem of N+1 to (N/K) + 1 where K refers to the size of the batch.\nSubselect the fetching strategy\nAs last resort, try to avoid or disable lazy loading altogether. Pre-fetch the records in batches which helps us to reduce the problem of N+1 to (N/K) + 1 where K refers to the size of the batch. Subselect the fetching strategy As last resort, try to avoid or disable lazy loading altogether.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "7. What are the concurrency strategies available in hibernate?",
        "answer": "Concurrency strategies are the mediators responsible for storing and retrieving items from the cache. While enabling second-level cache, it is the responsibility of the developer to provide what strategy is to be implemented to decide for each persistent class and collection. Following are the concurrency strategies that are used: Following are the concurrency strategies that are used: Transactional: This is used in cases of updating data that most likely causes stale data and this prevention is most critical to the application.\nRead-Only: This is used when we don't want the data to be modified and can be used for reference data only.\nRead-Write: Here, data is mostly read and is used when the prevention of stale data is of critical importance.\nNon-strict-Read-Write: Using this strategy will ensure that there wouldn't be any consistency between the database and cache. This strategy can be used when the data can be modified and stale data is not of critical concern. Transactional: This is used in cases of updating data that most likely causes stale data and this prevention is most critical to the application. Transactional: Read-Only: This is used when we don't want the data to be modified and can be used for reference data only. Read-Only: Read-Write: Here, data is mostly read and is used when the prevention of stale data is of critical importance. Read-Write: Non-strict-Read-Write: Using this strategy will ensure that there wouldn't be any consistency between the database and cache. This strategy can be used when the data can be modified and stale data is not of critical concern. Non-strict-Read-Write:",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "8. What is Single Table Strategy?",
        "answer": "Single Table Strategy is a hibernate’s strategy for performing inheritance mapping. This strategy is considered to be the best among all the other existing ones. Here, the inheritance data hierarchy is stored in the single table by making use of a discriminator column which determines to what class the record belongs. For the example defined in the Hibernate Inheritance Mapping question above, if we follow this single table strategy, then all the permanent and contract employees’ details are stored in only one table called InterviewBitEmployee in the database and the employees would be differentiated by making use of discriminator column named employee_type. Hibernate provides @Inheritance annotation which takes strategy as the parameter. This is used for defining what strategy we would be using. By giving them value, InheritanceType.SINGLE_TABLE signifies that we are using a single table strategy for mapping. @DiscriminatorColumn is used for specifying what is the discriminator column of the table in the database corresponding to the entity.\n@DiscriminatorValue is used for specifying what value differentiates the records of two types. @DiscriminatorColumn is used for specifying what is the discriminator column of the table in the database corresponding to the entity. @DiscriminatorValue is used for specifying what value differentiates the records of two types. The code snippet would be like this: InterviewBitEmployee class: InterviewBitEmployee class: @Entity\n@Table(name = \"InterviewBitEmployee\")\n@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n@DiscriminatorColumn(name = \"employee_type\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitEmployee {\n   @Id\n   @Column(name = \"employee_id\")\n   private String employeeId;\n   private String fullName;\n   private String email;\n} @Entity\n@Table(name = \"InterviewBitEmployee\")\n@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n@DiscriminatorColumn(name = \"employee_type\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitEmployee {\n   @Id\n   @Column(name = \"employee_id\")\n   private String employeeId;\n   private String fullName;\n   private String email;\n} InterviewBitContractEmployee class: InterviewBitContractEmployee class: @Entity\n@DiscriminatorValue(\"contract\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitContractEmployee extends InterviewBitEmployee {\n   private LocalDate contractStartDate;\n   private LocalDate contractEndDate;\n   private String agencyName;\n} @Entity\n@DiscriminatorValue(\"contract\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitContractEmployee extends InterviewBitEmployee {\n   private LocalDate contractStartDate;\n   private LocalDate contractEndDate;\n   private String agencyName;\n} InterviewBitPermanentEmployee class: InterviewBitPermanentEmployee class: @Entity\n@DiscriminatorValue(\"permanent\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitPermanentEmployee extends InterviewBitEmployee {\n   private LocalDate workStartDate;\n   private int numberOfLeaves;\n} @Entity\n@DiscriminatorValue(\"permanent\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitPermanentEmployee extends InterviewBitEmployee {\n   private LocalDate workStartDate;\n   private int numberOfLeaves;\n}",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "9. Can you tell something about Table Per Class Strategy.",
        "answer": "Table Per Class Strategy is another type of inheritance mapping strategy where each class in the hierarchy has a corresponding mapping database table. For example, the InterviewBitContractEmployee class details are stored in the interviewbit_contract_employee table and InterviewBitPermanentEmployee class details are stored in interviewbit_permanent_employee tables respectively. As the data is stored in different tables, there will be no need for a discriminator column as done in a single table strategy. Hibernate provides @Inheritance annotation which takes strategy as the parameter. This is used for defining what strategy we would be using. By giving them value, InheritanceType.TABLE_PER_CLASS, it signifies that we are using a table per class strategy for mapping. The code snippet will be as shown below: InterviewBitEmployee class: InterviewBitEmployee class: @Entity(name = \"interviewbit_employee\")\n@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitEmployee {\n   @Id\n   @Column(name = \"employee_id\")\n   private String employeeId;\n   private String fullName;\n   private String email;\n} @Entity(name = \"interviewbit_employee\")\n@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitEmployee {\n   @Id\n   @Column(name = \"employee_id\")\n   private String employeeId;\n   private String fullName;\n   private String email;\n} InterviewBitContractEmployee class: InterviewBitContractEmployee class: @Entity(name = \"interviewbit_contract_employee\")\n@Table(name = \"interviewbit_contract_employee\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitContractEmployee extends InterviewBitEmployee {\n   private LocalDate contractStartDate;\n   private LocalDate contractEndDate;\n   private String agencyName;\n} @Entity(name = \"interviewbit_contract_employee\")\n@Table(name = \"interviewbit_contract_employee\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitContractEmployee extends InterviewBitEmployee {\n   private LocalDate contractStartDate;\n   private LocalDate contractEndDate;\n   private String agencyName;\n} InterviewBitPermanentEmployee class: InterviewBitPermanentEmployee class: @Entity(name = \"interviewbit_permanent_employee\")\n@Table(name = \"interviewbit_permanent_employee\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitPermanentEmployee extends InterviewBitEmployee {\n   private LocalDate workStartDate;\n   private int numberOfLeaves;\n} @Entity(name = \"interviewbit_permanent_employee\")\n@Table(name = \"interviewbit_permanent_employee\")\n@NoArgsConstructor\n@AllArgsConstructor\npublic class InterviewBitPermanentEmployee extends InterviewBitEmployee {\n   private LocalDate workStartDate;\n   private int numberOfLeaves;\n} Disadvantages: Disadvantages: This type of strategy offers less performance due to the need for additional joins to get the data.\nThis strategy is not supported by all JPA providers.\nOrdering is tricky in some cases since it is done based on a class and later by the ordering criteria. This type of strategy offers less performance due to the need for additional joins to get the data. This strategy is not supported by all JPA providers. Ordering is tricky in some cases since it is done based on a class and later by the ordering criteria.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "10. Can you tell something about Named SQL Query",
        "answer": "A named SQL query is an expression represented in the form of a table. Here, SQL expressions to select/retrieve rows and columns from one or more tables in one or more databases can be specified. This is like using aliases to the queries. In hibernate, we can make use of @NameQueries and @NameQuery annotations. @NameQueries annotation is used for defining multiple named queries.\n@NameQuery annotation is used for defining a single named query. @NameQueries annotation is used for defining multiple named queries. @NameQuery annotation is used for defining a single named query. Code Snippet: We can define Named Query as shown below Code Snippet: We can define Named Query as shown below @NamedQueries(  \n   {  \n       @NamedQuery(  \n       name = \"findIBEmployeeByFullName\",  \n       query = \"from InterviewBitEmployee e where e.fullName = :fullName\"  \n       )  \n   }  \n) @NamedQueries(  \n   {  \n       @NamedQuery(  \n       name = \"findIBEmployeeByFullName\",  \n       query = \"from InterviewBitEmployee e where e.fullName = :fullName\"  \n       )  \n   }  \n) :fullName refers to the parameter that is programmer defined and can be set using the query.setParameter method while using the named query. Usage: Usage: TypedQuery query = session.getNamedQuery(\"findIBEmployeeByFullName\");    \nquery.setParameter(\"fullName\",\"Hibernate\");   \nList<InterviewBitEmployee> ibEmployees = query.getResultList(); TypedQuery query = session.getNamedQuery(\"findIBEmployeeByFullName\");    \nquery.setParameter(\"fullName\",\"Hibernate\");   \nList<InterviewBitEmployee> ibEmployees = query.getResultList(); The getNamedQuery method takes the name of the named query and returns the query instance.",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "11. What are the benefits of NamedQuery?",
        "answer": "In order to understand the benefits of NamedQuery, let's first understand the disadvantage of HQL and SQL. The main disadvantage of having HQL and SQL scattered across data access objects is that it makes the code unreadable. Hence, as good practice, it is recommended to group all HQL and SQL codes in one place and use only their reference in the actual data access code. In order to achieve this, Hibernate gives us named queries. A named query is a statically defined query with a predefined unchangeable query string. They are validated when the session factory is created, thus making the application fail fast in case of an error. Conclusion Hibernate is the most powerful open source ORM tool that is used for mapping java objects with the database structures at run time. It has become more popular among software developers due to its nature of abstraction allowing developers to continue application development by being database independent and focus just on the application business logic. software developers Additional Resources Additional Resources Practice Coding Practice Coding Java Tutorials Java Tutorials Java Interview Questions Java Interview Questions Hibernate Vs JPA Hibernate Vs JPA",
        "reference": "interviewbit.com",
        "role": "hibernate"
    },
    {
        "question": "1) What is hibernate?",
        "answer": "Hibernate is an open-source and lightweight ORM tool that is used to store, manipulate, and retrieve data from the database.\nmore details...",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "2) What is ORM?",
        "answer": "ORM is an acronym for Object/Relational mapping. It is a programming strategy to map object with the data stored in the database. It simplifies data creation, data manipulation, and data access.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "3) Explain hibernate architecture?",
        "answer": "Hibernate architecture comprises of many interfaces such as Configuration, SessionFactory, Session, Transaction, etc.\nmore details...",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "4) What are the core interfaces of Hibernate?",
        "answer": "The core interfaces of Hibernate framework are:\nADVERTISEMENT\nConfiguration\nSessionFactory\nSession\nQuery\nCriteria\nTransaction\n5) Mention some of the advantages of using ORM over JDBC.\nORM has the following advantages over JDBC:\nApplication development is fast.\nManagement of transaction.\nGenerates key automatically.\nDetails of SQL queries are hidden.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "",
        "answer": "ORM has the following advantages over JDBC:\nApplication development is fast.\nManagement of transaction.\nGenerates key automatically.\nDetails of SQL queries are hidden.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "",
        "answer": "The objects of criteria are used for the creation and execution of the object-oriented criteria queries.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "",
        "answer": "Some of the databases supported by Hibernate are:\nDB2\nMySQL\nOracle\nSybase SQL Server\nInformix Dynamic Server\nHSQL\nPostgreSQL\nFrontBase",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "",
        "answer": "Key components of Hibernate are:\nConfiguration\nSession\nSessionFactory\nCriteria\nQuery\nTransaction",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "",
        "answer": "Database Connection\nClass Mapping Setup",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "10) How is SQL query created in Hibernate?",
        "answer": "The SQL query is created with the help of the following syntax:\n\nSession.createSQLQuery",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "11) What does HQL stand for?",
        "answer": "Hibernate Query Language",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "12) How is HQL query created?",
        "answer": "The HQL query is created with the help of the following syntax:\nSession.createQuery",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "13) How can we add criteria to a SQL query?",
        "answer": "A criterion is added to a SQL query by using the Session.createCriteria.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "",
        "answer": "Classes whose objects are stored in a database table are called as persistent classes.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "15) What is SessionFactory?",
        "answer": "SessionFactory provides the instance of Session. It is a factory of Session. It holds the data of second level cache that is not enabled by default.\nmore details...",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "16) Is SessionFactory a thread-safe object?",
        "answer": "Yes, SessionFactory is a thread-safe object, many threads cannot access it simultaneously.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "17) What is Session?",
        "answer": "It maintains a connection between the hibernate application and database.\nIt provides methods to store, update, delete or fetch data from the database such as persist(), update(), delete(), load(), get() etc.\n\nIt is a factory of Query, Criteria and Transaction i.e. it provides factory methods to return these instances.\nmore details...",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "18) Is Session a thread-safe object?",
        "answer": "No, Session is not a thread-safe object, many threads can access it simultaneously. In other words, you can share it between threads.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "persist() method?",
        "answer": "No. save() persist()\n1) returns the identifier (Serializable) of the instance. Return nothing because its return type is void.\n2) Syn: public Serializable save(Object o) Syn: public void persist(Object o)",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "20) What is the difference between get and load method?",
        "answer": "The differences between get() and load() methods are given below.\nNo. get() load()\n1) Returns null if an object is not found. Throws ObjectNotFoundException if an object is not found.\n2) get() method always hit the database.\nload() method doesn't hit the database.\n3) It returns the real object, not the proxy. It returns proxy object.\n4) It should be used if you are not sure about the existence of instance. It should be used if you are sure that instance exists.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "21) What is the difference between update and merge method?",
        "answer": "The differences between update() and merge() methods are given below.\nNo. The update() method merge() method\n1) Update means to edit something. Merge means to combine something.\n2) update() should be used if the session doesn't contain an already persistent state with the same id. It means an update should be used inside the session only. After closing the session, it will throw the error. merge() should be used if you don't know the state of the session, means you want to make the modification at any time.\nLet's try to understand the difference by the example given below:\n...  \nSessionFactory factory = cfg.buildSessionFactory();  \nSession session1 = factory.openSession();  \n   Employee e1 = (Employee) session1.get(Employee.class, Integer.valueOf(101));//passing id of employee  \nsession1.close();  \n   e1.setSalary(70000);  \n   Session session2 = factory.openSession();  \nEmployee e2 = (Employee) session1.get(Employee.class, Integer.valueOf(101));//passing same id  \n  Transaction tx=session2.beginTransaction();  \nsession2.merge(e1);  \n  tx.commit();  \nsession2.close();  \nAfter closing session1, e1 is in detached state. It will not be in the session1 cache. So if you call update() method, it will throw an error.\n\nThen, we opened another session and loaded the same Employee instance. If we call merge in session2, changes of e1 will be merged in e2.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "22) What are the states of the object in hibernate?",
        "answer": "There are 3 states of the object (instance) in hibernate.\nTransient: The object is in a transient state if it is just created but has no primary key (identifier) and not associated with a session.\nPersistent: The object is in a persistent state if a session is open, and you just saved the instance in the database or retrieved the instance from the database.\nDetached: The object is in a detached state if a session is closed. After detached state, the object comes to persistent state if you call lock() or update() method.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "23) What are the inheritance mapping strategies?",
        "answer": "There are 3 ways of inheritance mapping in hibernate.\nTable per hierarchy\nTable per concrete class\nTable per subclass\nmore details...",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "24) How to make an immutable class in hibernate?",
        "answer": "If you mark a class as mutable=\"false\", the class will be treated as an immutable class. By default, it is mutable=\"true\".",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "25) What is automatic dirty checking in hibernate?",
        "answer": "The automatic dirty checking feature of Hibernate, calls update statement automatically on the objects that are modified in a transaction.\nLet's understand it by the example given below:\n...  \nSessionFactory factory = cfg.buildSessionFactory();  \nSession session1 = factory.openSession();  \nTransaction tx=session2.beginTransaction();  \n   Employee e1 = (Employee) session1.get(Employee.class, Integer.valueOf(101));  \n   e1.setSalary(70000);  \n   tx.commit();  \nsession1.close();  \nHere, after getting employee instance e1 and we are changing the state of e1.\nAfter changing the state, we are committing the transaction. In such a case, the state will be updated automatically. This is known as dirty checking in hibernate.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "26) How many types of association mapping are possible in hibernate?",
        "answer": "There can be 4 types of association mapping in hibernate.\nOne to One\nOne to Many\nMany to One\nMany to Many",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "27) Is it possible to perform collection mapping with One-to-One and Many-to-One?",
        "answer": "No, collection mapping can only be performed with One-to-Many and Many-to-Many.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "28) What is lazy loading in hibernate?",
        "answer": "Lazy loading in hibernate improves the performance. It loads the child objects on demand.\nSince Hibernate 3, lazy loading is enabled by default, and you don't need to do lazy=\"true\". It means not to load the child objects when the parent is loaded.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "29) What is HQL (Hibernate Query Language)?",
        "answer": "Hibernate Query Language is known as an object-oriented query language. It is like a structured query language (SQL).\nThe main advantage of HQL over SQL is:\nYou don't need to learn SQL\nDatabase independent\nSimple to write a query",
        "reference": "javatpoint.com",
        "role": "hibernate"
    },
    {
        "question": "30) What is the difference between first level cache and second level cache?",
        "answer": "No. First Level Cache Second Level Cache\n1) First Level Cache is associated with Session. Second Level Cache is associated with SessionFactory.\n2) It is enabled by default. It is not enabled by default.",
        "reference": "javatpoint.com",
        "role": "hibernate"
    }
]