[
    {
        "question": "1. What is TypeScript?",
        "answer": "TypeScript is an enhanced version of JavaScript, characterized by static typing, which includes optional type annotations and other features aimed at aiding developers in writing code that is more maintainable and scalable.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "2. What are the key features of TypeScript?",
        "answer": "TypeScript offers features like static typing, type inference, classes, interfaces, modules, decorators, and support for modern ECMAScript features.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "3. How do you define variables and their types in TypeScript?",
        "answer": "In TypeScript, you can declare variables using the let or const keywords, followed by the variable name and its type annotation. For example, let count: number = 5;.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "4. What are interfaces in TypeScript?",
        "answer": "In TypeScript, interfaces establish a set of rules for objects, defining the structure of their properties and methods. By doing so, they ensure consistency and enable type-checking for objects that adhere to these rules.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "5. What is type inference in TypeScript?",
        "answer": "Type inference is the ability of the TypeScript compiler to automatically determine the type of a variable based on its initialization value. You don’t need to explicitly specify the type in such cases.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "6. How does TypeScript help catch errors during development?",
        "answer": "TypeScript performs static type checking, which means it analyzes the code and reports type-related errors before the code is executed. This helps catch potential errors early in the development process.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "7. Explain the difference between 'undefined' and 'null' in TypeScript.",
        "answer": "In TypeScript, “undefined” and “null” are two distinct types. “Undefined” represents the absence of a value, while “null” represents the intentional absence of an object value.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "8. How do you define an array type in TypeScript?",
        "answer": "In TypeScript, you can define an array type by using square brackets after the type annotation. For example, let numbers: number[] = [1, 2, 3]; declares an array of numbers.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "9. What is the 'any' type in TypeScript?",
        "answer": "The “any” type in TypeScript allows variables to have any type. It essentially disables type checking for that particular variable. It is often used when working with existing JavaScript code or when the type is unknown.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "10. What is the 'tuple' type in TypeScript?",
        "answer": "A tuple type in TypeScript represents an array with a fixed number of elements, where each element can have its type. For example, let person: [string, number] = [‘John Doe’, 30]; declares a tuple type for a person’s name and age.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "11. How does TypeScript handle type assertions?",
        "answer": "Type assertions in TypeScript allow you to explicitly inform the compiler about the type of a variable when you know more about the value than TypeScript can infer. They are denoted using the angle bracket syntax (<type>) or the “as” keyword.\n\nIntermediate TypeScript Interview Questions\nFind the most relevant TypeScript Interview Questions and Answers for Freshers",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "12. What benefits does TypeScript offer in terms of code quality, productivity, tooling support, and collaboration in software development?",
        "answer": "Advantages of Using TypeScript:\nEnhanced Code Quality: With static typing, TypeScript helps identify errors early in the development process, leading to more robust and bug-free code.\nImproved Productivity: TypeScript’s IntelliSense and code completion features enable developers to work faster and with greater accuracy.\nStronger Tooling Support: The TypeScript ecosystem offers a wide range of powerful tools and libraries for code analysis, refactoring, and documentation generation.\nBetter Collaboration: The use of types in TypeScript aids in clearer communication between team members, resulting in smoother collaboration on projects.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "13. Explain Arrays in TypeScript.",
        "answer": "Arrays are used to store multiple values in TypeScript. We use square brackets [] to create an array. The values in an array do not need to be the same type. We can access values in an array by their number called an index, which starts from zero. Arrays have a length property to know how many items are in them.\nSyntax for declaring an array in TypeScript:\ntype[] = [value1, value2, value3];",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "14. How to convert a string to a number in TypeScript?",
        "answer": "To change a string to a number in TypeScript, we use the Number function. We pass the string we want to change as a parameter to the Number function. This will return the string as a number type that we can then use in calculations.\nExample:\nlet stringVariable = \"100\";\nlet numberVariable = Number(stringVariable);",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "15. What are 'type aliases' in TypeScript?",
        "answer": "Type aliases in TypeScript allow you to create custom names for types, making the code more readable and expressive. They are defined using the type keyword. For example, type Point = { x: number, y: number }; creates a type alias for a point object.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "16. How does TypeScript support optional function parameters?",
        "answer": "TypeScript allows you to define optional parameters in function declarations by appending a question mark (?) after the parameter name. This enables you to call functions with or without supplying values for those parameters.\nGet 100% Hike!\nMaster Most in Demand Skills Now!\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "17. What is an 'enum' in TypeScript?",
        "answer": "Enums in TypeScript provide a way to define a set of named constants. They allow you to assign symbolic names to a series of related values, making the code more readable and maintainable.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "18. How can you define function types in TypeScript?",
        "answer": "In TypeScript, you can define function types using the arrow function syntax or the “Function” keyword. For example, type AddFunction = (a: number, b: number) => number; declares a type for a function that takes two numbers and returns a number.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "19. What is the 'keyof' operator in TypeScript?",
        "answer": "The “keyof” operator in TypeScript is a type operator that produces a union type of all property names of a given type. It is commonly used to iterate over the keys of an object or to create generic utility functions.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "20. Explain the concept of 'type guards' in TypeScript.",
        "answer": "Type guards in TypeScript are conditional statements or functions that narrow down the type of a variable within a certain block of code. They allow you to perform type-specific operations based on runtime checks.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "21. How does TypeScript handle type compatibility?",
        "answer": "TypeScript follows a structural type system, which means that type compatibility is based on the shape or structure of the types rather than their names. If two types have compatible properties, they are considered compatible.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "22. What is the 'never' type in TypeScript?",
        "answer": "The “never” type in TypeScript represents values that never occur. It is often used to indicate functions that never return or cases that are impossible to reach, helping catch potential logical errors.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "23. How can you define a type that allows multiple possible types for a property or variable?",
        "answer": "TypeScript provides the “union type” feature to define a property or variable that can hold values of multiple types. It is denoted by the “|” operator; for example, let value: string | number;.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "24. What are generics in TypeScript?",
        "answer": "Generics in TypeScript enable writing reusable and type-safe code by creating functions, classes, or interfaces that can work with different types. They allow us to define placeholders for types that are resolved at runtime.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "25. How does TypeScript support decorators?",
        "answer": "TypeScript supports decorators, which are a way to add metadata and modify the behavior of classes, methods, properties, or parameters. They are declared using the @ symbol and applied using the Reflect.decorate function.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "26. What is a namespace in TypeScript?",
        "answer": "Namespaces in TypeScript are used to organize code into logical groups and prevent naming conflicts. They provide a way to group related classes, interfaces, functions, and variables under a single name.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "27. How can you integrate TypeScript into an existing JavaScript project?",
        "answer": "TypeScript can be integrated into an existing JavaScript project by renaming the JavaScript files to have a .ts extension and gradually adding type annotations. TypeScript can compile both TypeScript and JavaScript files together.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "28. How does TypeScript handle module systems?",
        "answer": "TypeScript supports various module systems, such as CommonJS, AMD, and ES modules. You can specify the module system using the –module compiler flag or the module field in the tsconfig.json file.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "29. What are abstract classes in TypeScript?",
        "answer": "Abstract classes in TypeScript are base classes that cannot be instantiated directly. They are designed to be inherited and serve as blueprints for subclasses. Abstract classes may contain abstract methods that must be implemented by the derived classes.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "30. How can you extend existing types in TypeScript?",
        "answer": "TypeScript allows you to extend existing types using intersection types. By using the & operator, you can combine multiple types into a single type. For example, type ExtendedPerson = Person & { address: string; } adds an “address” property to the “Person” type.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "31. What is the 'readonly'modifier in TypeScript?",
        "answer": "The “readonly” modifier in TypeScript is used to make properties or array elements read-only, preventing them from being modified after initialization. It ensures that the value remains constant throughout the program.\n\nAdvanced TypeScript Interview Questions\nList of most asked Typescript Interview Questions and Answers for Experienced",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "32. What is JSX?",
        "answer": "JSX is a syntax for writing HTML tags in JavaScript. It allows embedding HTML tags directly in JavaScript code. React uses JSX which makes it easier to write React components and render HTML. JSX code gets compiled into regular JavaScript that can run anywhere.\nExample:\nconst element = <h1>Hello, world!</h1>;\nThis JSX code gets compiled into regular JavaScript that outputs a HTML heading element.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "33. What are getters/setters?",
        "answer": "Getters and setters are special methods that act as accessors for a property. Getters are used to return the value of a property, setters are used to set the property value. They define custom property access logic rather than directly accessing the data property.\nExample:\nclass Person {\nprivate _name: string;\nget name() {\nreturn this._name;\n}\nset name(value: string) {\nthis._name = value;\n}\n}\nThis defines a getter and setter for the “name” property.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "34. What is the difference between the internal module and external module?",
        "answer": "Internal modules are defined within a single file using namespaces. External modules are defined across multiple files using import/export. Internal modules group code together but everything is loaded together, external modules load code asynchronously only when imported. External modules are recommended for large apps as they avoid loading unused code.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "35. What is the Default Parameters Function in TypeScript?",
        "answer": "Default parameters allow defining default values for function parameters in TypeScript. If a value is not provided during function call, it will use the default defined. This avoids passing undefined values and makes functions more flexible.\nExample:\nfunction greet(name = ‘Stranger’) {\nconsole.log(‘Hello ‘ + name);\n}\ngreet(); // Hello Stranger\ngreet(‘John’); // Hello John\nThis function greet() has a default parameter name with value ‘Stranger’.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "36. How can you create and use decorators in TypeScript?",
        "answer": "Decorators in TypeScript can be created by defining a function that takes a target, property, or parameter as parameters and applies custom logic. They can be used to enhance classes, methods, or properties with additional functionality or metadata.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "37. What are 'conditional types' in TypeScript?",
        "answer": "Conditional types in TypeScript allow you to express type relationships based on conditional logic. They enable you to define types that depend on other types or type conditions, allowing for more advanced type manipulations.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "38. How does TypeScript handle async/await operations?",
        "answer": "TypeScript provides support for async/await operations, allowing you to write asynchronous code in a more synchronous and readable manner. The async keyword is used to mark a function as asynchronous, and await is used to pause the function until a promise is resolved.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "39. How can you extend built-in types in TypeScript?",
        "answer": "TypeScript allows you to extend built-in types, such as Array or String, by using declaration merging and interfaces. You can augment the existing types with additional properties or methods to suit your specific needs.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "40. How can you create and use intersection types in TypeScript?",
        "answer": "Intersection types in TypeScript allow you to combine multiple types into a single type, creating a new type that has all the properties and methods of the intersected types. They are denoted using the “&” operator.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "41. Explain the concept of 'declaration merging' in TypeScript.",
        "answer": "Declaration merging in TypeScript allows multiple declarations for the same name to be combined into a single definition. It is useful when extending interfaces, adding properties to classes, or merging namespaces.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "42. How does TypeScript handle module resolution and module loaders?",
        "answer": "TypeScript supports different module resolution strategies such as “Classic” (CommonJS/AMD), “Node” (Node.js style), and “ES2015” (ES modules). It also allows you to configure module loaders like SystemJS or Webpack.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "43. How does TypeScript handle 'namespace' conflicts?",
        "answer": "TypeScript provides namespaces as a way to organize code into logical groups. To avoid naming conflicts between namespaces, you can use the “export” and “import” keywords to expose and use their members selectively.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "44. Explain the concept of 'mapped types' in TypeScript.",
        "answer": "In TypeScript, mapped types permit the creation of new types by modifying the properties of an existing type. They enable you to iterate over and modify the properties of an object type, creating a modified version of the type.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "45. How does TypeScript handle 'module augmentation'?",
        "answer": "Module augmentation in TypeScript allows you to extend the functionality of existing modules by adding new declarations or modifying existing ones. It enables you to enhance external modules without modifying their original source code.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "46. What is the purpose of the 'NonNullable' type in TypeScript?",
        "answer": "The “NonNullable” type in TypeScript is used to create a new type that excludes null and undefined from the original type. It ensures that a variable of the NonNullable type will always have a defined value.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "47. Explain the concept of inheritance in TypeScript.",
        "answer": "In TypeScript, inheritance refers to the ability of a class (subclass) to inherit properties and methods from another class (superclass). The subclass in typescript can extend the functionality of the superclass and add its own unique features. It promotes code reusability and enables hierarchical relationships between classes.\nclass Rectangle {\nlength: number;\nbreadth: number\n\nconstructor(length: number, breadth: number) {\n  this.length = length;\n  this.breadth = breadth\n}\n\narea(): number {\n  return this.length * this.breadth;\n}\n}\n\nclass Square extends Rectangle {\nconstructor(side: number) {\n  super(side, side);\n}\n\nvolume() {\n  return \"Square doesn't have a volume!\"\n}\n}\n\nconst sq = new Square(10);\nconsole.log(sq.area());\nconsole.log(sq.volume());",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "48. What are Mixins?",
        "answer": "Mixins are reusable blocks of code that can be included in multiple classes to provide common functionality without extending base classes. They allow adding multiple functionalities to a class without relying on inheritance.\nExample:\n// Define a reusable mixin\nfunction Loggable {\nlog() {\nconsole.log(“Logging…”);\n}\n}\n// Class we want to make loggable\nclass Component {\nconstructor() {\n//…\n}\n}\n// Mix Loggable into Component\nObject.assign(Component.prototype, Loggable);\n// Usage\nconst myComponent = new Component();\nmyComponent.log(); // Logs “Logging…”\nThis defines a Loggable mixin with a log() method, and mixes it into the Component class prototype, allowing any Component instance to now call log().",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "49. Explain the symbol type in TypeScript.",
        "answer": "The symbol type in TypeScript represents unique identifiers. It is used to reference something that is unique like a class, method or property. Symbols are created using Symbol() and each symbol is unique. Symbols provide a way to associate metadata with a value in a way that won’t collide with other keys.\nExample:\nconst sym = Symbol();\nclass C {\n[sym]: string = “hello”;\n}\nlet c = new C();\nc[sym]; // “hello”\nThis creates and uses a symbol to associate metadata with a class in a unique way.",
        "reference": "intellipaat.com",
        "role": "typescript"
    },
    {
        "question": "1. What are the primitive types in TypeScript?",
        "answer": "TypeScript has three primitive types that are frequently used: string, number, and boolean. These correspond to the similarly named types in JavaScript. string: represents text values such as “javascript”, “typescript”, etc.\nnumber: represents numeric values like 1, 2, 32, 43, etc.\nboolean: represents a variable that can have either a ‘true’ or ‘false’ value. string: represents text values such as “javascript”, “typescript”, etc. string number: represents numeric values like 1, 2, 32, 43, etc. number boolean: represents a variable that can have either a ‘true’ or ‘false’ value. boolean:  ",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "2. Explain how the arrays work in TypeScript.",
        "answer": "We use arrays to store values of the same type. Arrays are ordered and indexed collections of values. The indexing starts at 0, i.e., the first element has index 0, the second has index 1, and so on. Here is the syntax to declare and initialize an array in TypeScript. let values: number[] = [];\nvalues[0] = 10;\nvalues[1] = 20;\nvalues[2] = 30; let values: number[] = [];\nvalues[0] = 10;\nvalues[1] = 20;\nvalues[2] = 30; You can also create an array using the short-hand syntax as follows: let values: number[] = [15, 20, 25, 30]; let values: number[] = [15, 20, 25, 30]; TypeScript provides an alternate syntax to specify the Array type. let values: Array<number> = [15, 20, 25, 30]; let values: Array<number> = [15, 20, 25, 30];",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "3. What is any type, and when to use it?",
        "answer": "There are times when you want to store a value in a variable but don’t know the type of that variable in advance. For example, the value is coming from an API call or the user input. The ‘any’ type allows you to assign a value of any type to the variable of type any. let person: any = \"Foo\"; let person: any = \"Foo\"; Here is an example that demonstrates the usage of any type. // json may come from a third-party API\nconst employeeData: string = `{\"name\": \"John Doe\", \"salary\": 60000}`;\n\n// parse JSON to build employee object\nconst employee: any = JSON.parse(employeeData);\n\nconsole.log(employee.name);\nconsole.log(employee.salary); // json may come from a third-party API\nconst employeeData: string = `{\"name\": \"John Doe\", \"salary\": 60000}`;\n\n// parse JSON to build employee object\nconst employee: any = JSON.parse(employeeData);\n\nconsole.log(employee.name);\nconsole.log(employee.salary); TypeScript assumes a variable is of type any when you don’t explicitly provide the type, and the compiler cannot infer the type from the surrounding context. any",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "4. What is void, and when to use the void type?",
        "answer": "The void indicates the absence of type on a variable. It acts as the opposite type to any. It is especially useful in functions that don’t return a value. function notify(): void {\n  alert(\"The user has been notified.\");\n} function notify(): void {\n  alert(\"The user has been notified.\");\n} If a variable is of type void, you can only assign the null or undefined values to that variable.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "5. What is an unknown type, and when to use it in TypeScript?",
        "answer": "The unknown type is the type-safe counterpart of any type. You can assign anything to the unknown, but the unknown isn’t assignable to anything but itself and any, without performing a type assertion of a control-flow-based narrowing. You cannot perform any operations on a variable of an unknown type without first asserting or narrowing it to a more specific type. Consider the following example. We create the foo variable of unknown type and assign a string value to it. If we try to assign that unknown variable to a string variable bar, the compiler gives an error. let foo: unknown = \"Akshay\";\nlet bar: string = foo; // Type 'unknown' is not assignable to type 'string'.(2322) let foo: unknown = \"Akshay\";\nlet bar: string = foo; // Type 'unknown' is not assignable to type 'string'.(2322) You can narrow down a variable of an unknown type to something specific by doing typeof checks or comparison checks or using type guards. For example, we can get rid of the above error by let foo: unknown = \"Akshay\";\nlet bar: string = foo as string; let foo: unknown = \"Akshay\";\nlet bar: string = foo as string;",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "6. What are the different keywords to declare variables in TypeScript?",
        "answer": "var: Declares a function-scoped or global variable. You can optionally set its value during the declaration. Its behavior and scoping rules are similar to the var keyword in JavaScript. For example, var: var foo = \"bar\"; var foo = \"bar\"; let: Declares a block-scoped local variable. Similar to var, you can optionally set the value of a variable during the declaration. For example, let: let a = 5;\n\nif (true) {\n  let a = 10;\n  console.log(a);  // 10\n}\nconsole.log(a);  // 5 let a = 5;\n\nif (true) {\n  let a = 10;\n  console.log(a);  // 10\n}\nconsole.log(a);  // 5 const: Declares a block-scoped constant value that cannot be changed after it’s initialized.  For example, const: const a = 5;\n\nif (true) {\n  a = 10; // Error: Cannot assign to 'a' because it is a constant.(2588)\n} const a = 5;\n\nif (true) {\n  a = 10; // Error: Cannot assign to 'a' because it is a constant.(2588)\n}",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "7. Explain the arrow function syntax in TypeScript.",
        "answer": "Arrow functions provide a short and convenient syntax to declare functions. They are also called lambdas in other programming languages. Consider a regular function that adds two numbers and returns a number. function add(x: number, y: number): number {\nlet sum = x + y;\nreturn sum;\n} function add(x: number, y: number): number {\nlet sum = x + y;\nreturn sum;\n} Using arrow functions syntax, the same function can be defined as: let add = (x: number, y: number): number => {\nlet sum = x + y;\nreturn sum;\n} let add = (x: number, y: number): number => {\nlet sum = x + y;\nreturn sum;\n} You can further simplify the syntax by getting rid of the brackets and the return statement. This is allowed when the function body consists of only one statement. For example, if we remove the temporary sum variable, we can rewrite the above function as: let add = (x: number, y: number): number => x + y; let add = (x: number, y: number): number => x + y; Arrow functions are often used to create anonymous callback functions in TypeScript. Consider the example below that loops over and filters an array of numbers and returns an array containing multiples of five. The filter function takes an arrow function. let numbers = [3, 5, 9, 15, 34, 35];\n\nlet fiveMultiples = numbers.filter(num => (num % 5) == 0);\n\nconsole.log(fiveMultiples);  // [5, 15, 35] let numbers = [3, 5, 9, 15, 34, 35];\n\nlet fiveMultiples = numbers.filter(num => (num % 5) == 0);\n\nconsole.log(fiveMultiples);  // [5, 15, 35]",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "8. Provide the syntax of a function with the type annotations.",
        "answer": "Functions are blocks of code to perform a specific code. Functions can optionally take one or more arguments, process them, and optionally return a value. Here’s the TypeScript syntax to create and call a function. function greet(name: string): string {\n  return `Hello, ${name}`;\n}\n\nlet greeting = greet(\"Anders\");\nconsole.log(greeting);  // \"Hello, Anders\" function greet(name: string): string {\n  return `Hello, ${name}`;\n}\n\nlet greeting = greet(\"Anders\");\nconsole.log(greeting);  // \"Hello, Anders\"",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "9. How to create objects in TypeScript?",
        "answer": "Objects are dictionary-like collections of keys and values. The keys have to be unique. They are similar to arrays and are also sometimes called associative arrays. However, an array uses numbers to index the values, whereas an object allows you to use any other type as the key. In TypeScript, an Object type refers to any value with properties. It can be defined by simply listing the properties and their types. For example, let pt: { x: number; y: number } = {\n  x: 10,\n  y: 20\n}; let pt: { x: number; y: number } = {\n  x: 10,\n  y: 20\n};",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "10. How to specify optional properties in TypeScript?",
        "answer": "An object type can have zero or more optional properties by adding a ‘?’ after the property name. let pt: { x: number; y: number; z?: number } = {\n  x: 10,\n  y: 20\n};\nconsole.log(pt); let pt: { x: number; y: number; z?: number } = {\n  x: 10,\n  y: 20\n};\nconsole.log(pt); In the example above, because the property ‘z’ is marked as optional, the compiler won’t complain if we don’t provide it during the initialization.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "11. Explain the concept of null and its use in TypeScript.",
        "answer": "In programming, a null value indicates an absence of value. A null variable doesn’t point to any object. Hence you cannot access any properties on the variable or call a method on it. In TypeScript, the null value is indicated by the ‘null’ keyword. You can check if a value is null as follows: function greet(name: string | null) {\nif (name === null) {\n  console.log(\"Name is not provided\");\n} else {\n  console.log(\"Good morning, \" + name.toUpperCase());\n}\n}\n\nvar foo = null;\ngreet(foo); // \"Name is not provided\"\n\nfoo = \"Anders\";\ngreet(foo);  // \"Good morning, ANDERS\" function greet(name: string | null) {\nif (name === null) {\n  console.log(\"Name is not provided\");\n} else {\n  console.log(\"Good morning, \" + name.toUpperCase());\n}\n}\n\nvar foo = null;\ngreet(foo); // \"Name is not provided\"\n\nfoo = \"Anders\";\ngreet(foo);  // \"Good morning, ANDERS\"",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "12. What is undefined in TypeScript?",
        "answer": "When a variable is declared without initialization, it’s assigned the undefined value. It’s not very useful on its own. A variable is undefined if it’s declared, but no value has been assigned to it. In contrast, null is assigned to a variable, and it represents no value. console.log(null == null); // true\nconsole.log(undefined == undefined); // true\nconsole.log(null == undefined); // true, with type-conversion\nconsole.log(null === undefined); // false, without type-conversion\nconsole.log(0 == undefined); // false\nconsole.log('' == undefined); // false\nconsole.log(false == undefined); // false console.log(null == null); // true\nconsole.log(undefined == undefined); // true\nconsole.log(null == undefined); // true, with type-conversion\nconsole.log(null === undefined); // false, without type-conversion\nconsole.log(0 == undefined); // false\nconsole.log('' == undefined); // false\nconsole.log(false == undefined); // false",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "13. Explain the purpose of the never type in TypeScript.",
        "answer": "As the name suggests, the never type represents the type of values that never occur. For example, a function that never returns a value or that always throws an exception can mark its return type as never. function error(message: string): never {\nthrow new Error(message);\n} function error(message: string): never {\nthrow new Error(message);\n} You might wonder why we need a ‘never’ type when we already have ‘void’. Though both types look similar, they represent two very different concepts. A function that doesn't return a value implicitly returns the value undefined in JavaScript. Hence, even though we are saying it’s not returning anything, it’s returning ‘undefined’. We usually ignore the return value in these cases. Such a function is inferred to have a void return type in TypeScript. // This function returns undefined\nfunction greet(name: string) {\nconsole.log(`Hello, ${name}`);\n}\n\nlet greeting = greet(\"David\");\nconsole.log(greeting);  // undefined // This function returns undefined\nfunction greet(name: string) {\nconsole.log(`Hello, ${name}`);\n}\n\nlet greeting = greet(\"David\");\nconsole.log(greeting);  // undefined In contrast, a function that has a never return type never returns. It doesn't return undefined, either. There are 2 cases where functions should return never type: In an unending loop e.g a while(true){} type loop.\nA function that throws an error e.g function foo(){throw new Exception('Error message')} In an unending loop e.g a while(true){} type loop. A function that throws an error e.g function foo(){throw new Exception('Error message')}",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "14. Explain how enums work in TypeScript?",
        "answer": "Enums allow us to create named constants. It is a simple way to give more friendly names to numeric constant values. An enum is defined by the keyword enum, followed by its name and the members. Consider the following example that defines an enum Team with four values in it. enum Team {\nAlpha,\nBeta,\nGamma,\nDelta\n}\nlet t: Team = Team.Delta; enum Team {\nAlpha,\nBeta,\nGamma,\nDelta\n}\nlet t: Team = Team.Delta; By default, the enums start the numbering at 0. You can override the default numbering by explicitly assigning the values to its members. TypeScript also lets you create enums with string values as follows: enum Author {\n  Anders = \"Anders\",\n  Hejlsberg = \"Hejlsberg\"\n}; enum Author {\n  Anders = \"Anders\",\n  Hejlsberg = \"Hejlsberg\"\n};",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "15. What is the typeof operator? How is it used in TypeScript?",
        "answer": "Similar to JavaScript, the typeof operator in TypeScript returns the type of the operand as a string. console.log(typeof 10);  // \"number\"\n\nconsole.log(typeof 'foo');  // \"string\"\n\nconsole.log(typeof false);  // \"boolean\"\n\nconsole.log(typeof bar);  // \"undefined\" console.log(typeof 10);  // \"number\"\n\nconsole.log(typeof 'foo');  // \"string\"\n\nconsole.log(typeof false);  // \"boolean\"\n\nconsole.log(typeof bar);  // \"undefined\" In TypeScript, you can use the typeof operator in a type context to refer to the type of a property or a variable. let greeting = \"hello\";\nlet typeOfGreeting: typeof greeting;  // similar to let typeOfGreeting: string let greeting = \"hello\";\nlet typeOfGreeting: typeof greeting;  // similar to let typeOfGreeting: string",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "16. What are the rest parameters and arguments in TypeScript?",
        "answer": "A rest parameter allows a function to accept an indefinite number of arguments as an array. It is denoted by the ‘…’ syntax and indicates that the function can accept one or more arguments. function add(...values: number[]) {\nlet sum = 0;\nvalues.forEach(val => sum += val);\nreturn sum;\n}\nconst sum = add(5, 10, 15, 20);\nconsole.log(sum);  // 50 function add(...values: number[]) {\nlet sum = 0;\nvalues.forEach(val => sum += val);\nreturn sum;\n}\nconst sum = add(5, 10, 15, 20);\nconsole.log(sum);  // 50 In contrast, the rest arguments allow a function caller to provide a variable number of arguments from an array. Consider the following example. const first = [1, 2, 3];\nconst second = [4, 5, 6];\n\nfirst.push(...second);\nconsole.log(first);  // [1, 2, 3, 4, 5, 6] const first = [1, 2, 3];\nconst second = [4, 5, 6];\n\nfirst.push(...second);\nconsole.log(first);  // [1, 2, 3, 4, 5, 6]",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "17. What is parameter destructuring?",
        "answer": "Parameter destructing allows a function to unpack the object provided as an argument into one or more local variables. function multiply({ a, b, c }: { a: number; b: number; c: number }) {\nconsole.log(a * b * c);\n}\n\nmultiply({ a: 1, b: 2, c: 3 });\n\nYou can simplify the above code by using an interface or a named type, as follows:\ntype ABC = { a: number; b: number; c: number };\n\nfunction multiply({ a, b, c }: ABC) {\nconsole.log(a * b * c);\n}\n\nmultiply({ a: 1, b: 2, c: 3 }); function multiply({ a, b, c }: { a: number; b: number; c: number }) {\nconsole.log(a * b * c);\n}\n\nmultiply({ a: 1, b: 2, c: 3 });\n\nYou can simplify the above code by using an interface or a named type, as follows:\ntype ABC = { a: number; b: number; c: number };\n\nfunction multiply({ a, b, c }: ABC) {\nconsole.log(a * b * c);\n}\n\nmultiply({ a: 1, b: 2, c: 3 });",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "18. Explain the TypeScript class syntax.",
        "answer": "TypeScript fully supports classes. The TypeScript syntax for class declaration is similar to that of JavaScript, with the added type support for the member declarations. Here is a simple class that defines an Employee type. class Employee {\n  name: string;\n  salary: number;\n\n  constructor(name: string, salary: number) {\n          this.name = name;\n          this.salary = salary;\n  }\n  promote() : void {\n    this.salary += 10000;\n  }\n} class Employee {\n  name: string;\n  salary: number;\n\n  constructor(name: string, salary: number) {\n          this.name = name;\n          this.salary = salary;\n  }\n  promote() : void {\n    this.salary += 10000;\n  }\n} You can create an instance (or object) of a class by using the new keyword. // Create a new employee\nlet john = new Employee(\"John\", 60000);\n\nconsole.log(john.salary);  // 60000\njohn.promote();\nconsole.log(john.salary);  // 70000 // Create a new employee\nlet john = new Employee(\"John\", 60000);\n\nconsole.log(john.salary);  // 60000\njohn.promote();\nconsole.log(john.salary);  // 70000",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "19. Provide the syntax for optional parameters in TypeScript.",
        "answer": "A function can mark one or more of its parameters as optional by suffixing its name with ‘?’. In the example below, the parameter greeting is marked optional. function greet(name: string, greeting?: string) {\nif (!greeting)\n  greeting = \"Hello\";\n\nconsole.log(`${greeting}, ${name}`);\n}\n\ngreet(\"John\", \"Hi\");  // Hi, John\ngreet(\"Mary\", \"Hola\");  // Hola, Mary\ngreet(\"Jane\");  // Hello, Jane function greet(name: string, greeting?: string) {\nif (!greeting)\n  greeting = \"Hello\";\n\nconsole.log(`${greeting}, ${name}`);\n}\n\ngreet(\"John\", \"Hi\");  // Hi, John\ngreet(\"Mary\", \"Hola\");  // Hola, Mary\ngreet(\"Jane\");  // Hello, Jane",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "20. What is the purpose of the tsconfig.json file?",
        "answer": "A tsconfig.json file in a directory marks that directory as the root of a TypeScript project. It provides the compiler options to compile the project. Here is a sample tsconfig.json file: {\n \"compilerOptions\": {\n   \"module\": \"system\",\n   \"noImplicitAny\": true,\n   \"removeComments\": true,\n   \"outFile\": \"../../built/local/tsc.js\",\n   \"sourceMap\": true\n },\n \"include\": [\"src/**/*\"],\n \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]\n} {\n \"compilerOptions\": {\n   \"module\": \"system\",\n   \"noImplicitAny\": true,\n   \"removeComments\": true,\n   \"outFile\": \"../../built/local/tsc.js\",\n   \"sourceMap\": true\n },\n \"include\": [\"src/**/*\"],\n \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]\n}",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "1. How to enforce strict null checks in TypeScript?",
        "answer": "Null pointers are one of the most common sources of unexpected runtime errors in programming. TypeScript helps you avoid them to a large degree by enforcing strict null checks. You can enforce strict null checks in two ways: providing the --strictNullChecks flag to the TypeScript (tsc) compiler\nsetting the strictNullChecks property to true in the tsconfig.json configuration file. providing the --strictNullChecks flag to the TypeScript (tsc) compiler setting the strictNullChecks property to true in the tsconfig.json configuration file. When the flag is false, TypeScript ignores null and undefined values in the code. When it is true, null and undefined have their distinct types. The compiler throws a type error if you try to use them where a concrete value is expected.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "2. Does TypeScript support static classes? If not, why?",
        "answer": "TypeScript doesn’t support static classes, unlike the popular object-oriented programming languages like C# and Java. These languages need static classes because all code, i.e., data and functions, need to be inside a class and cannot exist independently. Static classes provide a way to allow these functions without associating them with any objects. In TypeScript, you can create any data and functions as simple objects without creating a containing class. Hence TypeScript doesn’t need static classes. A singleton class is just a simple object in TypeScript.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "3. What are type assertions in TypeScript?",
        "answer": "Sometimes, you as a programmer might know more about the type of a variable than TypeScript can infer. Usually, this happens when you know the type of an object is more specific than its current type. In such cases, you can tell the TypeScript compiler not to infer the type of the variable by using type assertions. TypeScript provides two forms to assert the types. as syntax: as syntax: let value: unknown = \"Foo\";\nlet len: number = (value as string).length; let value: unknown = \"Foo\";\nlet len: number = (value as string).length; <> syntax: <> syntax: let value: unknown = \"Foo\";\nlet len: number = (<string>value).length; let value: unknown = \"Foo\";\nlet len: number = (<string>value).length; Type assertions are similar to typecasting in other programming languages such as C# or Java. However, unlike those languages, there’s no runtime penalty of boxing and unboxing variables to fit the types. Type assertions simply let the TypeScript compiler know the type of the variable.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "4. Explain how tuple destructuring works in TypeScript.",
        "answer": "You can destructure tuple elements by using the assignment operator (=). The destructuring variables get the types of the corresponding tuple elements. let employeeRecord: [string, number] = [\"John Doe\", 50000];\nlet [emp_name, emp_salary] = employeeRecord;\nconsole.log(`Name: ${emp_name}`);  // \"Name: John Doe\"\nconsole.log(`Salary: ${emp_salary}`);  // \"Salary: 50000\" let employeeRecord: [string, number] = [\"John Doe\", 50000];\nlet [emp_name, emp_salary] = employeeRecord;\nconsole.log(`Name: ${emp_name}`);  // \"Name: John Doe\"\nconsole.log(`Salary: ${emp_salary}`);  // \"Salary: 50000\" After destructuring, you can’t assign a value of a different type to the destructured variable. For example, emp_name = true;  // Type 'boolean' is not assignable to type 'string'.(2322) emp_name = true;  // Type 'boolean' is not assignable to type 'string'.(2322)",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "5. Explain the tuple types in TypeScript.",
        "answer": "Tuples are a special type in TypeScript. They are similar to arrays with a fixed number of elements with a known type. However, the types need not be the same. // Declare a tuple type and initialize it\nlet values: [string, number] = [\"Foo\", 15];\n\n// Type 'boolean' is not assignable to type 'string'.(2322)\n// Type 'string' is not assignable to type 'number'.(2322)\nlet wrongValues: [string, number] = [true, \"hello\"]; // Error // Declare a tuple type and initialize it\nlet values: [string, number] = [\"Foo\", 15];\n\n// Type 'boolean' is not assignable to type 'string'.(2322)\n// Type 'string' is not assignable to type 'number'.(2322)\nlet wrongValues: [string, number] = [true, \"hello\"]; // Error Since TypeScript 3.0, a tuple can specify one or more optional types using the ? as shown below. let values: [string, number, boolean?] = [\"Foo\", 15]; let values: [string, number, boolean?] = [\"Foo\", 15];",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "6. What are type aliases? How do you create one?",
        "answer": "Type aliases give a new, meaningful name for a type. They don’t create new types but create new names that refer to that type. For example, you can alias a union type to avoid typing all the types everywhere that value is being used. type alphanumeric = string | number;\nlet value: alphanumeric = \"\";\nvalue = 10; type alphanumeric = string | number;\nlet value: alphanumeric = \"\";\nvalue = 10;",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "7. What are intersection types?",
        "answer": "Intersection types let you combine the members of two or more types by using the ‘&’ operator. This allows you to combine existing types to get a single type with all the features you need. The following example creates a new type Supervisor that has the members of types Employee and Manager. interface Employee {\nwork: () => string;\n}\n\ninterface Manager {\nmanage: () => string;\n}\n\ntype Supervisor = Employee & Manager;\n\n// john can both work and manage\nlet john: Supervisor; interface Employee {\nwork: () => string;\n}\n\ninterface Manager {\nmanage: () => string;\n}\n\ntype Supervisor = Employee & Manager;\n\n// john can both work and manage\nlet john: Supervisor;",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "8. What are union types in TypeScript?",
        "answer": "A union type is a special construct in TypeScript that indicates that a value can be one of several types. A vertical bar (|) separates these types. Consider the following example where the variable value belongs to a union type consisting of strings and numbers. The value is initialized to string “Foo”. Because it can only be a string or a number, we can change it to a number later, and the TypeScript compiler doesn’t complain. let value: string | number = \"Foo\";\nvalue = 10;  // Okay let value: string | number = \"Foo\";\nvalue = 10;  // Okay However, if we try to set the value to a type not included in the union types, we get the following error. value = true;  // Type 'boolean' is not assignable to type 'string | number'.(2322) value = true;  // Type 'boolean' is not assignable to type 'string | number'.(2322) Union types allow you to create new types out of existing types. This removes a lot of boilerplate code as you don’t have to create new classes and type hierarchies.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "9. What are anonymous functions? Provide their syntax in TypeScript.",
        "answer": "An anonymous function is a function without a name. Anonymous functions are typically used as callback functions, i.e., they are passed around to other functions, only to be invoked by the other function at a later point in time. For example, setTimeout(function () {\n  console.log('Run after 2 seconds')\n}, 2000);\n\nYou can invoke an anonymous function as soon as it’s created. It’s called ‘immediately invoked function execution (IIFE)’, For example:\n(function() {\n  console.log('Invoked immediately after creation');\n})(); setTimeout(function () {\n  console.log('Run after 2 seconds')\n}, 2000);\n\nYou can invoke an anonymous function as soon as it’s created. It’s called ‘immediately invoked function execution (IIFE)’, For example:\n(function() {\n  console.log('Invoked immediately after creation');\n})();",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "10. What are abstract classes? When should you use one?",
        "answer": "Abstract classes are similar to interfaces in that they specify a contract for the objects, and you cannot instantiate them directly. However, unlike interfaces, an abstract class may provide implementation details for one or more of its members. An abstract class marks one or more of its members as abstract. Any classes that extend an abstract class have to provide an implementation for the abstract members of the superclass. Here is an example of an abstract class Writer with two member functions. The write() method is marked as abstract, whereas the greet() method has an implementation. Both the FictionWriter and RomanceWriter classes that extend from Writer have to provide their specific implementation for the write method. abstract class Writer {\nabstract write(): void;\n\ngreet(): void {\n  console.log(\"Hello, there. I am a writer.\");\n}\n}\n\nclass FictionWriter extends Writer {\nwrite(): void {\n  console.log(\"Writing a fiction.\");\n}\n}\n\nclass RomanceWriter extends Writer {\nwrite(): void {\n  console.log(\"Writing a romance novel.\");\n}\n}\n\nconst john = new FictionWriter();\njohn.greet();  // \"Hello, there. I am a writer.\"\njohn.write();  // \"Writing a fiction.\"\n\nconst mary = new RomanceWriter();\nmary.greet();  // \"Hello, there. I am a writer.\"\nmary.write();  // \"Writing a romance novel.\" abstract class Writer {\nabstract write(): void;\n\ngreet(): void {\n  console.log(\"Hello, there. I am a writer.\");\n}\n}\n\nclass FictionWriter extends Writer {\nwrite(): void {\n  console.log(\"Writing a fiction.\");\n}\n}\n\nclass RomanceWriter extends Writer {\nwrite(): void {\n  console.log(\"Writing a romance novel.\");\n}\n}\n\nconst john = new FictionWriter();\njohn.greet();  // \"Hello, there. I am a writer.\"\njohn.write();  // \"Writing a fiction.\"\n\nconst mary = new RomanceWriter();\nmary.greet();  // \"Hello, there. I am a writer.\"\nmary.write();  // \"Writing a romance novel.\"",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "11. How to make object properties immutable in TypeScript? (hint: readonly)",
        "answer": "You can mark object properties as immutable by using the readonly keyword before the property name. For example: interface Coordinate {\nreadonly x: number;\nreadonly y: number;\n} interface Coordinate {\nreadonly x: number;\nreadonly y: number;\n} When you mark a property as readonly, it can only be set when you initialize the object. Once the object is created, you cannot change it. let c: Coordinate = { x: 5, y: 15 };\nc.x = 20; // Cannot assign to 'x' because it is a read-only property.(2540) let c: Coordinate = { x: 5, y: 15 };\nc.x = 20; // Cannot assign to 'x' because it is a read-only property.(2540)",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "12. What is a type declaration file?",
        "answer": "A typical TypeScript project references other third-party TypeScript libraries such as JQuery to perform routine tasks. Having type information for the library code helps you in coding by providing detailed information about the types, method signatures, etc., and provides IntelliSense. A type declaration file is a text file ending with a .d.ts extension providing a way to declare the existence of some types or values without actually providing implementations for those values. It contains the type declarations but doesn’t have any source code. It doesn’t produce a .js file after compilation.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "13. What are triple-slash directives?",
        "answer": "Triple-slash directives are single-line comments that contain a single XML tag. TypeScript uses this XML tag as a compiler directive. You can only place a triple-slash directive at the top of the containing file. Only single or multi-line comments can come before a triple-slash directive. TypeScript treats them as regular comments if it occurs in the middle of a code block, after a statement. The primary use of triple-slash directives is to include other files in the compilation process. For example, the following directive instructs the compiler to include a file specified by the path in the containing TypeScript file. /// <reference path=\"...\" /> /// <reference path=\"...\" /> Triple-slash directives also order the output when using --out or --outFile. The output files are produced to the output file location in the same order as the input files.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "14. Explain the purpose of the ‘in’ operator.",
        "answer": "The in operator is used to find if a property is in the specified object. It returns true if the property belongs to the object. Otherwise, it returns false. const car = { make: 'Hyundai', model: 'Elantra', year: 2017 };\nconsole.log('model' in car);  // true\nconsole.log('test' in car);  // false const car = { make: 'Hyundai', model: 'Elantra', year: 2017 };\nconsole.log('model' in car);  // true\nconsole.log('test' in car);  // false",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "15. What are the ‘implements’ clauses in TypeScript?",
        "answer": "An implements clause is used to check that a class satisfies the contract specified by an interface. If a class implements an interface and doesn’t implement that interface, the TypeScript compiler issues an error. interface Runnable {\nrun(): void;\n}\n\nclass Job implements Runnable {\nrun() {\n  console.log(\"running the scheduled job!\");\n}\n}\n\n// Class 'Task' incorrectly implements interface 'Runnable'.\n// Property 'run' is missing in type 'Task' but required in type 'Runnable'.(2420)\nclass Task implements Runnable {\nperform() {\n  console.log(\"pong!\");\n}\n} interface Runnable {\nrun(): void;\n}\n\nclass Job implements Runnable {\nrun() {\n  console.log(\"running the scheduled job!\");\n}\n}\n\n// Class 'Task' incorrectly implements interface 'Runnable'.\n// Property 'run' is missing in type 'Task' but required in type 'Runnable'.(2420)\nclass Task implements Runnable {\nperform() {\n  console.log(\"pong!\");\n}\n} A class can implement more than one interface. In this case, the class has to specify all the contracts of those interfaces.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "16. What are string literal types?",
        "answer": "In TypeScript, you can refer to specific strings and numbers as types. let foo: \"bar\" = \"bar\";\n\n// OK\nfoo = \"bar\";\n\n// Error: Type '\"baz\"' is not assignable to type '\"bar\"'.(2322)\nfoo = \"baz\"; let foo: \"bar\" = \"bar\";\n\n// OK\nfoo = \"bar\";\n\n// Error: Type '\"baz\"' is not assignable to type '\"bar\"'.(2322)\nfoo = \"baz\"; String literal types on their own are not that useful. However, you can combine them into unions. This allows you to specify all the string values that a variable can take, in turn acting like enums. This can be useful for function parameters. function greet(name: string, greeting: \"hi\" | \"hello\" | \"hola\") {\n// ...\n}\n\ngreet(\"John\", \"hello\");\n\n// Error: Argument of type '\"Howdy?\"' is not assignable to parameter of type '\"hi\" | \"hello\" | \"hola\"'.(2345)\ngreet(\"Mary\", \"Howdy?\"); function greet(name: string, greeting: \"hi\" | \"hello\" | \"hola\") {\n// ...\n}\n\ngreet(\"John\", \"hello\");\n\n// Error: Argument of type '\"Howdy?\"' is not assignable to parameter of type '\"hi\" | \"hello\" | \"hola\"'.(2345)\ngreet(\"Mary\", \"Howdy?\"); String literal types can help us spell-check the string values.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "17. What are template literal types?",
        "answer": "Template literal types are similar to the string literal types. You can combine them with concrete, literal types to produce a new string literal type. Template literal types allow us to use the string literal types as building blocks to create new string literal types. type Point = \"GraphPoint\";\n\n// type Shape = \"Grid GraphPoint\"\ntype Shape = `Grid ${Point}`; type Point = \"GraphPoint\";\n\n// type Shape = \"Grid GraphPoint\"\ntype Shape = `Grid ${Point}`; Template literal types can also expand into multiple strings via unions. It helps us create the set of every possible string literal that each union member can represent. type Color = \"green\" | \"yellow\";\ntype Quantity = \"five\" | \"six\";\n\n// type ItemTwo = \"five item\" | \"six item\" | \"green item\" | \"yellow item\"\ntype ItemOne = `${Quantity | Color} item`; type Color = \"green\" | \"yellow\";\ntype Quantity = \"five\" | \"six\";\n\n// type ItemTwo = \"five item\" | \"six item\" | \"green item\" | \"yellow item\"\ntype ItemOne = `${Quantity | Color} item`;",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "18. Explain the concept of inheritance in TypeScript.",
        "answer": "Inheritance allows a class to extend another class and reuse and modify the behavior defined in the other class. The class which inherits another class is called the derived class, and the class getting inherited is called the base class. In TypeScript, a class can only extend one class. TypeScript uses the keyword ‘extends’ to specify the relationship between the base class and the derived classes. class Rectangle {\nlength: number;\nbreadth: number\n\nconstructor(length: number, breadth: number) {\n  this.length = length;\n  this.breadth = breadth\n}\n\narea(): number {\n  return this.length * this.breadth;\n}\n}\n\nclass Square extends Rectangle {\nconstructor(side: number) {\n  super(side, side);\n}\n\nvolume() {\n  return \"Square doesn't have a volume!\"\n}\n}\n\nconst sq = new Square(10);\n\nconsole.log(sq.area());  // 100\nconsole.log(sq.volume());  // \"Square doesn't have a volume!\" class Rectangle {\nlength: number;\nbreadth: number\n\nconstructor(length: number, breadth: number) {\n  this.length = length;\n  this.breadth = breadth\n}\n\narea(): number {\n  return this.length * this.breadth;\n}\n}\n\nclass Square extends Rectangle {\nconstructor(side: number) {\n  super(side, side);\n}\n\nvolume() {\n  return \"Square doesn't have a volume!\"\n}\n}\n\nconst sq = new Square(10);\n\nconsole.log(sq.area());  // 100\nconsole.log(sq.volume());  // \"Square doesn't have a volume!\" In the above example, because the class Square extends functionality from Rectangle, we can create an instance of square and call both the area() and volume() methods.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "19. What are conditional types? How do you create them?",
        "answer": "A conditional type allows you to dynamically select one of two possible types based on a condition. The condition is expressed as a type relationship test. C extends B ? TypeX : TypeY C extends B ? TypeX : TypeY Here, if type C extends B, the value of the above type is TypeX. Otherwise, it is TypeY.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "20. What is the Function type in TypeScript?",
        "answer": "Function is a global type in TypeScript. It has properties like bind, call, and apply, along with the other properties present on all function values. function perform(fn: Function) {\nfn(10);\n} function perform(fn: Function) {\nfn(10);\n} You can always call a value of the Function type, and it returns a value of ‘any’ type.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "21. List some of the utility types provided by TypeScript and explain their usage.",
        "answer": "TypeScript provides various utility types that make common type transformations easy. These utility types are available globally. Here are some of the essential utility types included in TypeScript. Utility Type Description\nPartial<Type> Constructs a type with all properties of Type set to optional.\nRequired<Type> Constructs a type consisting of all properties of Type set to required.\nReadonly<Type>  Constructs a type with all properties of Type set to readonly.\nRecord<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type. Utility Type Description\nPartial<Type> Constructs a type with all properties of Type set to optional.\nRequired<Type> Constructs a type consisting of all properties of Type set to required.\nReadonly<Type>  Constructs a type with all properties of Type set to readonly.\nRecord<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type. Utility Type Description Utility Type Description Utility Type Description Partial<Type> Constructs a type with all properties of Type set to optional.\nRequired<Type> Constructs a type consisting of all properties of Type set to required.\nReadonly<Type>  Constructs a type with all properties of Type set to readonly.\nRecord<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type. Partial<Type> Constructs a type with all properties of Type set to optional. Partial<Type> Constructs a type with all properties of Type set to optional. Required<Type> Constructs a type consisting of all properties of Type set to required. Required<Type> Constructs a type consisting of all properties of Type set to required. Readonly<Type>  Constructs a type with all properties of Type set to readonly. Readonly<Type> Constructs a type with all properties of Type set to readonly. Record<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type. Record<Keys, Type> Constructs an object type with property keys are of type Keys, and values are Type.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "22. Explain the various ways to control member visibility in TypeScript.",
        "answer": "TypeScript provides three keywords to control the visibility of class members, such as properties or methods. public: You can access a public member anywhere outside the class. All class members are public by default. \nprotected: A protected member is visible only to the subclasses of the class containing that member. Outside code that doesn’t extend the container class can’t access a protected member. \nprivate: A private member is only visible inside the class. No outside code can access the private members of a class. public: You can access a public member anywhere outside the class. All class members are public by default. public: protected: A protected member is visible only to the subclasses of the class containing that member. Outside code that doesn’t extend the container class can’t access a protected member. protected: private: A private member is only visible inside the class. No outside code can access the private members of a class. private:",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "23. Explain the different variants of the for loop in TypeScript.",
        "answer": "TypeScript provides the following three ways to loop over collections. ‘for’ loop ‘for’ loop let values = [10, \"foo\", true];\n\nfor(let i=0; i<values.length; i++) {\n  console.log(values[i]);  // 10, \"foo\", true\n} let values = [10, \"foo\", true];\n\nfor(let i=0; i<values.length; i++) {\n  console.log(values[i]);  // 10, \"foo\", true\n} ‘forEach’ function ‘forEach’ function let values = [10, \"foo\", true];\nvalues.forEach(val => {\n    console.log(val);  // 10, \"foo\", true\n}) let values = [10, \"foo\", true];\nvalues.forEach(val => {\n    console.log(val);  // 10, \"foo\", true\n}) ‘for..of’ statement ‘for..of’ statement let values = [10, \"foo\", true];\nfor (let val of values) {\nconsole.log(val); // 10, \"foo\", true\n} let values = [10, \"foo\", true];\nfor (let val of values) {\nconsole.log(val); // 10, \"foo\", true\n}",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "24. Explain the symbol type in TypeScript.",
        "answer": "Symbols were introduced in ES6 and are supported by TypeScript. Similar to numbers and strings, symbols are primitive types. You can use Symbols to create unique properties for objects. You can create symbol values by calling the Symbol() constructor, optionally providing a string key. let foo = Symbol();\nlet bar = Symbol(\"bar\"); // optional string key let foo = Symbol();\nlet bar = Symbol(\"bar\"); // optional string key A key characteristic of symbols is that they are unique and immutable. let foo = Symbol(\"foo\");\nlet newFoo = Symbol(\"foo\");\n\nlet areEqual = foo === newFoo;\nconsole.log(areEqual);  // false, symbols are unique let foo = Symbol(\"foo\");\nlet newFoo = Symbol(\"foo\");\n\nlet areEqual = foo === newFoo;\nconsole.log(areEqual);  // false, symbols are unique",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "25. Explain how optional chaining works in TypeScript.",
        "answer": "Optional chaining allows you to access properties and call methods on them in a chain-like fashion. You can do this using the ‘?.’ operator. TypeScript immediately stops running some expression if it runs into a ‘null’ or ‘undefined’ value and returns ‘undefined’ for the entire expression chain. Using optional chaining, the following expression let x = foo === null || foo === undefined ? undefined : foo.bar.baz(); let x = foo === null || foo === undefined ? undefined : foo.bar.baz(); can be expressed as: let x = foo?.bar.baz(); let x = foo?.bar.baz();",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "26. Provide the TypeScript syntax to create function overloads.",
        "answer": "Function overloading allows us to define multiple functions with the same name, as long as their number of parameters or the types of parameters are different. The following example defines two overloads for the function buildDate. The first overload takes a number as a parameter, whereas the second takes three numbers as parameters. These are called overload signatures. The body of the function also called an implementation signature, follows the overload signatures. You can’t call this signature directly, as it’s not visible from the outside. It should be compatible with the overload signatures. function buildDate(timestamp: number): Date;\nfunction buildDate(m: number, d: number, y: number): Date;\nfunction buildDate(mOrTimestamp: number, d?: number, y?: number): Date {\nif (d !== undefined && y !== undefined) {\n  return new Date(y, mOrTimestamp, d);\n} else {\n  return new Date(mOrTimestamp);\n}\n}\n\nconst d1 = buildDate(87654321);\nconst d2 = buildDate(2, 2, 2); function buildDate(timestamp: number): Date;\nfunction buildDate(m: number, d: number, y: number): Date;\nfunction buildDate(mOrTimestamp: number, d?: number, y?: number): Date {\nif (d !== undefined && y !== undefined) {\n  return new Date(y, mOrTimestamp, d);\n} else {\n  return new Date(mOrTimestamp);\n}\n}\n\nconst d1 = buildDate(87654321);\nconst d2 = buildDate(2, 2, 2);",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "27. What is meant by type inference?",
        "answer": "TypeScript can infer the type of a variable when you don’t provide an explicit type. This is known as type inference. This is usually done when the variables or parameters are initialized during the declaration. For example, TypeScript knows that the variable foo is a string, even though we don’t mention string as a type. let foo = \"this is a string\";\nconsole.log(typeof foo);  // \"string\" let foo = \"this is a string\";\nconsole.log(typeof foo);  // \"string\"",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "28. What is meant by contextual typing?",
        "answer": "When the TypeScript compiler uses the location (or context) of a variable to infer its type, it’s called contextual typing. In the following example, TypeScript uses the Window.onmousedown function type information to infer the type of the function expression on the right-hand side of the assignment. This allows it to infer the type of the e parameter, which does have a button property but not a property named foo. window.onmousedown = function (e) {\nconsole.log(e.button); //<- OK\nconsole.log(e.foo); //<- Error!\n}; window.onmousedown = function (e) {\nconsole.log(e.button); //<- OK\nconsole.log(e.foo); //<- Error!\n};",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "29. What is the purpose of noImplicitAny?",
        "answer": "Usually, when we don’t provide any type on a variable, TypeScript assumes ‘any’ type. For example, TypeScript compiles the following code, assuming the parameter ‘s’ is of any type. It works as long as the caller passes a string. s’ function parse(s) {\nconsole.log(s.split(' '));\n}\nparse(\"Hello world\");  // [\"Hello\", \"world\"] function parse(s) {\nconsole.log(s.split(' '));\n}\nparse(\"Hello world\");  // [\"Hello\", \"world\"] However, the code breaks down as soon as we pass a number or other type than a string that doesn’t have a split() method on it. For example, function parse(s) {\nconsole.log(s.split(' '));  // [ERR]: s.split is not a function\n}\nparse(10); function parse(s) {\nconsole.log(s.split(' '));  // [ERR]: s.split is not a function\n}\nparse(10); noImplicitAny is a compiler option that you set in the tsconfig.json file. It forces the TypeScript compiler to raise an error whenever it infers a variable is of any type. This prevents us from accidentally causing similar errors. noImplicitAny Parameter 's' implicitly has an 'any' type.(7006)\nfunction parse(s) {\nconsole.log(s.split(' '));  // [ERR]: s.split is not a function\n} Parameter 's' implicitly has an 'any' type.(7006)\nfunction parse(s) {\nconsole.log(s.split(' '));  // [ERR]: s.split is not a function\n}",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "30. What is an interface?",
        "answer": "An interface defines a contract by specifying the type of data an object can have and its operations. In TypeScript, you can specify an object’s shape by creating an interface and using it as its type. It’s also called “duck typing”. In TypeScript, you can create and use an interface as follows: interface Employee {\nname: string;\nsalary: number;\n}\n\nfunction process(employee: Employee) {\nconsole.log(`${employee.name}'s salary = ${employee.salary}`);\n}\n\nlet john: Employee = {\nname: \"John Doe\",\nsalary: 150000\n}\n\nprocess(john);  // \"John Doe's salary = 150000\" interface Employee {\nname: string;\nsalary: number;\n}\n\nfunction process(employee: Employee) {\nconsole.log(`${employee.name}'s salary = ${employee.salary}`);\n}\n\nlet john: Employee = {\nname: \"John Doe\",\nsalary: 150000\n}\n\nprocess(john);  // \"John Doe's salary = 150000\" Interfaces are an effective way to specify contracts within your code as well as outside your code.",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "1. Conclusion",
        "answer": "TypeScript has been increasing in popularity for the last few years, and many large organizations and popular frameworks have adopted TypeScript to manage their large JavaScript codebases. It’s a valuable skill to have as a developer. In this article, we explored the questions that a developer might get asked in an interview. We have provided simple code examples to cement the concepts further. Finally, you can use the multiple-choice questions at the end of the article to test your understanding of the various topics in TypeScript. Reference: TypeScript Documentation\nAngular Interview Questions and Answers\nJavaScript Interview Questions\nDifference between Typescript and Javascript TypeScript Documentation TypeScript Documentation Angular Interview Questions and Answers Angular Interview Questions and Answers JavaScript Interview Questions JavaScript Interview Questions Difference between Typescript and Javascript Difference between Typescript and Javascript",
        "reference": "interviewbit.com",
        "role": "typescript"
    },
    {
        "question": "1) What is Typescript?",
        "answer": "TypeScript is a free and open-source programming language developed and maintained by Microsoft. It is a strongly typed superset of JavaScript that compiles to plain JavaScript. It is a language for application-scale JavaScript development. TypeScript is quite easy to learn and use for developers familiar with C#, Java and all strong typed languages.\nTypeScript can be executed on Any browser, Any Host, and Any Operating System. TypeScript is not directly run on the browser. It needs a compiler to compile and generate in JavaScript file. TypeScript is the ES6 version of JavaScript with some additional features.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "2) How is TypeScript different from JavaScript?",
        "answer": "TypeScript is different from JavaScript in the following manner:\nSN JavaScript TypeScript\n1 It was developed by Netscape in 1995. It was developed by Anders Hejlsberg in 2012.\n2 JavaScript source file is in \".js\" extension. TypeScript source file is in \".ts\" extension.\n3 JavaScript doesn't support ES6. TypeScript supports ES6.\n4 It doesn't support strongly typed or static typing. It supports strongly typed or static typing feature.\n5 It is just a scripting language. It supports object-oriented programming concept like classes, interfaces, inheritance, generics, etc.\n6 JavaScript has no optional parameter feature. TypeScript has optional parameter feature.\n7 It is interpreted language that's why it highlighted the errors at runtime. It compiles the code and highlighted errors during the development time.\n8 JavaScript doesn't support modules. TypeScript gives support for modules.\n9 In this, number, string are the objects. In this, number, string are the interface.\n10 JavaScript doesn't support generics. TypeScript supports generics.\nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "3) Why do we need TypeScript?",
        "answer": "We need TypeScript:\nADVERTISEMENT\nTypeScript is fast, simple, and most importantly, easy to learn.\nTypeScript supports object-oriented programming features such as classes, interfaces, inheritance, generics, etc.\nTypeScript provides the error-checking feature at compilation time. It will compile the code, and if any error found, then it highlighted the errors before the script is run.\nTypeScript supports all JavaScript libraries because it is the superset of JavaScript.\nTypeScript support reusability by using the inheritance.\nTypeScript make app development quick and easy as possible, and the tooling support of TypeScript gives us autocompletion, type checking, and source documentation.\nTypeScript supports the latest JavaScript features including ECMAScript 2015.\nTypeScript gives all the benefits of ES6 plus more productivity.\nTypeScript supports Static typing, Strongly type, Modules, Optional Parameters, etc.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "4) List some features of Typescript?",
        "answer": "To know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "5) List some benefits of using Typescript?",
        "answer": "TypeScript has the following benefits.\nIt provides the benefits of optional static typing. Here, Typescript provides types that can be added to variables, functions, properties, etc.\nTypescript has the ability to compile down to a version of JavaScript that runs on all browsers.\nTypeScript always highlights errors at compilation time during the time of development whereas JavaScript points out errors at the runtime.\nTypeScript supports strongly typed or static typing whereas this is not in JavaScript.\nIt helps in code structuring.\nIt uses class-based object-oriented programming.\nIt provides excellent tooling supports with IntelliSense which provides active hints as the code is added.\nIt has a namespace concept by defining a module.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "6) What are the disadvantages of TypeScript?",
        "answer": "TypeScript has the following disadvantages:\nTypeScript takes a long time to compile the code.\nTypeScript does not support abstract classes.\nIf we run the TypeScript application in the browser, a compilation step is required to transform TypeScript into JavaScript.\nWeb developers are using JavaScript from decades and TypeScript doesn?t bring anything new.\nTo use any third party library, the definition file is must. And not all the third party library have definition file available.\nQuality of type definition files is a concern as for how can you be sure the definitions are correct?",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "7) What are the different components of TypeScript?",
        "answer": "The TypeScript has mainly three components. These are-\n\nLanguage\nThe language comprises elements like new syntax, keywords, type annotations, and allows us to write TypeScript.\nCompiler\nThe TypeScript compiler is open source, cross-platform, and is written in TypeScript. It transforms the code written in TypeScript equivalent to its JavaScript code. It performs the parsing, type checking of our TypeScript code to JavaScript code. It can also help in concatenating different files to the single output file and in generating source maps.\nLanguage Service\nThe language service provides information which helps editors and other tools to give better assistance features such as automated refactoring and IntelliSense.\nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "8) Who developed Typescript and what is the current stable version of Typescript?",
        "answer": "The typescript was developed by Anders Hejlsberg, who is also one of the core members of the development team of C# language. The typescript was first released in the month of October 1st, 2012 and was labeled version 0.8. It is developed and maintained by Microsoft under the Apache 2 license. It was designed for the development of a large application.\nThe current stable version of TypeScript is 3.2 which was released on September 30, 2018. Typescript compiles to simple JavaScript code which runs on any browser that supports ECMAScript 2015 framework. It offers support for the latest and evolving JavaScript features.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "OR how can we get TypeScript and install it?",
        "answer": "TypeScript can be installed and managed with the help of node via npm (the Node.js package manager). To install TypeScript, first ensure that the npm is installed correctly, then run the following command which installs TypeScript globally on the system.\n$ npm install -g typescript  \nIt installs a command line code \"tsc\" which will further be used to compile our Typescript code. Make sure that we check the version of Typescript installed on the system.\nFollowing steps are involved for installing TypeScript:\nDownload and run the .msi installer for the node.\nEnter the command \"node -v\" to check if the installation was successful.\nType the following command in the terminal window to install Typescript: $ npm install -g typescript\n\nTo know installation process click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "",
        "answer": "The built-in data types are also known as primitive data types in Typescript. These are given below.\n\nNumber type: It is used to represent number type values. All the numbers in TypeScript are stored as floating point values.\nSyntax: let identifier: number = value;\nString type: It represents a sequence of characters stored as Unicode UTF-16 code. We include string literals in our scripts by enclosing them in single or double quotation marks.\nSyntax: let identifier: string = \" \";\n\nBoolean type: It is used to represent a logical value. When we use the Boolean type, we get output only in true or false. A Boolean value is a truth value that specifies whether the condition is true or not.\nSyntax: let identifier: bool = Boolean value;\nNull type: Null represents a variable whose value is undefined. It is not possible to directly reference the null type value itself. Null type is not useful because we can only assign a null value to it.\nSyntax: let num: number = null;\nUndefined type: It is the type of undefined literal. The Undefined type denotes all uninitialized variables. It is not useful because we can only assign an undefined value to it. This type of built-in type is the sub-type of all the types.\nSyntax: let num: number = undefined;\nVoid type: A void is the return type of the functions that do not return any type of value. It is used where no datatype is available.\nSyntax: let unusable: void = undefined;\nTo know TypeScript datatypes in detail click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "11) What are the variables in Typescript? How to create a variable in Typescript?",
        "answer": "A variable is the storage location, which is used to store value/information to be referenced and used by programs. It acts as a container for value in a program. It can be declared using the var keyword. It should be declared before the use. While declaring a variable in Typescript, certain rules should be followed-\nThe variable name must be an alphabet or numeric digits.\nThe variable name cannot start with digits.\nThe variable name cannot contain spaces and special character, except the underscore(_) and the dollar($) sign.\nWe can declare a variable in one of the four ways:\nDeclare type and value in a single statement. Syntax: var [identifier] : [type-annotation] = value;\nDeclare type without value. Syntax: var [identifier] : [type-annotation];\nDeclare its value without type. Syntax: var [identifier] = value;\nDeclare without value and type. Syntax: var [identifier];\nTo know more in detail click here.https://www.javatpoint.com/typescript-variables",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "12) How to compile a Typescript file?",
        "answer": "Here is the command which is followed while compiling a Typescript file into JavaScript.\n$ tsc <TypeScript File Name>  \nFor example, to compile \"Helloworld.ts.\"\n$ tsc helloworld.ts  \nThe result would be helloworld.js.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "js file? If yes, then how?",
        "answer": "Yes, it is possible. For this, we need to add --outFILE [OutputJSFileName] compiling option.\n$ tsc --outFile comman.js file1.ts file2.ts file3.ts  \nThe above command will compile all three \".ts\"file and result will be stored into single \"comman.js\" file. In the case, when we don't provide an output file name as like in below command.\n$ tsc --outFile file1.ts file2.ts file3.ts  \nThen, the file2.ts and file3.ts will be compiled, and the output will be placed in file1.ts. So now our file1.ts contains JavaScript code.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "ts file?",
        "answer": "Yes, it is possible to compile \".ts\" automatically with real-time changes in the .ts file. This can be achieved by using --watch compiler option\ntsc --watch file1.ts  \nThe above command first compiles file1.ts in file1.js and watch for the file changes. If there is any change detected, it will compile the file again. Here, we need to ensure that command prompt must not be closed on running with --watch option.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "",
        "answer": "An Interface is a structure which acts as a contract in our application. It defines the syntax for classes to follow, it means a class that implements an interface is bound to implement all its members. It cannot be instantiated but can be referenced by the class object that implements it. The TypeScript compiler uses interface for type-checking (also known as \"duck typing\" or \"structural subtyping\") whether the object has a specific structure or not.\nSyntax:\ninterface interface_name {    \n          // variables' declaration    \n          // methods' declaration    \n}    \nThe interface just declares the methods and fields. It cannot be used to build anything. Interfaces need not be converted to JavaScript for execution. They have zero runtime JavaScript impact. Thus, their only purpose is to help in the development stage.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "",
        "answer": "We know, TypeScript is a type of Object-Oriented JavaScript language and supports OOPs programming features like classes, interfaces, etc. Like Java, classes are the fundamental entities which are used to create reusable components. It is a group of objects which have common properties. A class is a template or blueprint for creating objects. It is a logical entity. The \"class\" keyword is used to declare a class in Typescript.\nExample:\nclass Student {    \n    studCode: number;    \n    studName: string;    \n    constructor(code: number, name: string) {    \n            this.studName = name;    \n            this.studCode = code;    \n    }    \n    getGrade() : string {    \n        return \"A+\" ;    \n    }    \n}    \nFeatures of a class are-\nInheritance\nEncapsulation\nPolymorphism\nAbstraction",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "17) Is Native Javascript supports modules?",
        "answer": "No. Currently, modules are not supported by Native JavaScript. To create and work with modules in Javascript we require an external like CommonJS.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "18) Which object oriented terms are supported by TypeScript?",
        "answer": "TypeScript supports following object oriented terms.\nModules\nClasses\nInterfaces\nInheritance\nData Types\nMember functions",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "19) How to Call Base Class Constructor from Child Class in TypeScript?",
        "answer": "super() function is used to called parent or base class constructor from Child Class.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "20) How do you implement inheritance in TypeScript?",
        "answer": "Inheritance is a mechanism that acquires the properties and behaviors of a class from another class. It is an important aspect of OOPs languages and has the ability which creates new classes from an existing class. The class whose members are inherited is called the base class, and the class that inherits those members is called the derived class.\nAn Inheritance can be implemented by using the extend keyword. We can understand it by the following example.\nclass Shape {     \n   Area:number     \n   constructor(area:number) {     \n      this.Area = area    \n   }     \n}     \nclass Circle extends Shape {     \n   display():void {     \n      console.log(\"Area of the circle: \"+this.Area)     \n   }     \n}    \nvar obj = new Circle(320);     \nobj.display()  //Output: Area of the circle: 320  \nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "21) What are the Modules in Typescript?",
        "answer": "A module is a powerful way to create a group of related variables, functions, classes, and interfaces, etc. It can be executed within their own scope, not in the global scope. In other words, the variables, functions, classes, and interfaces declared in a module cannot be accessible outside the module directly.\nCreating a Module\nA module can be created by using the export keyword and can be used in other modules by using the import keyword.\nmodule module_name{  \n    class xyz{  \n        export sum(x, y){  \n            return x+y;  \n         }  \n    }  \n}  \nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "22) What is the difference between the internal module and the external module?",
        "answer": "The difference between internal and external module is given below:\nSN Internal Module External Module\n1 Internal modules were used to logically group the classes, interfaces, functions, variables into a single unit and can be exported in another module. External modules are useful in hiding the internal statements of the module definitions and show only the methods and parameters associated with the declared variable.\n2 Internal modules were in the earlier version of Typescript. But they are still supported by using namespace in the latest version of TypeScript. External modules are simply known as a module in the latest version of TypeScript.\n3 Internal modules are local or exported members of other modules (including the global module and external modules). External modules are separately loaded bodies of code referenced using external module names.\n4 Internal modules are declared using ModuleDeclarations that specify their name and body. An external module is written as a separate source file that contains at least one import or export declaration.\n5 Example:\nmodule Sum {   \n   export function add(a, b) {    \n      console.log(\"Sum: \" +(a+b));   \n   }   \n} \nExample:\nexport class Addition{  \n    constructor(private x?: number, private y?: number){  \n    }  \n    Sum(){  \n        console.log(\"SUM: \" +(this.x + this.y));  \n    }  \n}\nTo know more in detail click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "23) What is namespace in Typescript? How to declare a namespace in Typescript?",
        "answer": "A namespace is a way that is used for logical grouping of functionalities. Namespaces are used to maintain the legacy code of typescript internally. It encapsulates the features and objects that share certain relationships. A namespace is also known as internal modules. A namespace can also include interfaces, classes, functions, and variables to support a group of related functionalities.\nNote: A namespace can be defined in multiple files and allow to keep each file as they were all defined in one place. It makes code easier to maintain.\nSynatax for creating namespace\nnamespace <namespace_name> {    \n           export interface I1 { }    \n           export class c1{ }    \n}    \nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "24) Explain Decorators in Typescript?",
        "answer": "A Decorator is a special kind of declaration that can be applied to classes, methods, accessor, property, or parameter. Decorators are simply functions that are prefixed @expression symbol, where expression must evaluate to a function that will be called at runtime with information about the decorated declaration.\nTypeScript Decorators serves the purpose of adding both annotations and metadata to the existing code in a declarative way. Decorators are an experimental feature proposed for ES7. It is already in use by some of the JavaScript frameworks including Angular 2. The Decorators may change in future releases.\nTo enable experimental support for decorators, we must enable the experimentalDecorators compiler option either on the command line or in our tsconfig.json:\n\nCommand Line\n$tsc --target ES5 --experimentalDecorators    \ntsconfig.json\n{    \n    \"compilerOptions\": {    \n        \"target\": \"ES5\",    \n        \"experimentalDecorators\": true    \n    }    \n}    \nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "25) What are Mixins?",
        "answer": "In Javascript, Mixins are a way of building up classes from reusable components is to build them by combining simpler partial classes called mixins.\nThe idea is simple, instead of a class A extending class B to get its functionality, function B takes class A and returns a new class with this added functionality. Function B is a mixin.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "26) What is default visibility for properties/methods in TypeScript classes?",
        "answer": "Public is the default visibility for properties/methods in TypeScript classes.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "27) How does TypeScript support optional parameters in function as in JavaScript every parameter is optional for a function?",
        "answer": "Unlike JavaScript, the TypeScript compiler will throw an error if we try to invoke a function without providing the exact number and types of parameters as declared in its function signature. To overcome this problem, we can use optional parameters by using question mark sign ('?'). It means that the parameters which may or may not receive a value can be appended with a '?' to mark them optional.\nfunction Demo(arg1: number, arg2? :number) {              \n}So, arg1 is always required, and arg2 is an optional parameter.   \nSo, arg1 is always required, and arg2 is an optional parameter.\nNote: Optional parameters must follow the required parameters. If we want to make arg1 optional, instead of arg2, then we need to change the order and arg1 must be put after arg2.\nfunction Demo(arg2: number, arg1? :number) {  \n}  \nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "28) Does TypeScript supports function overloading as JavaScript doesn't support function overloading?",
        "answer": "Yes, TypeScript support function overloading. But the implementation is odd. When we perform function overloading in TypeScript, then we can implement only one functions with multiple signatures.\n//Function with string type parameter    \nfunction add(a:string, b:string): string;    \n  //Function with number type parameter    \nfunction add(a:number, b:number): number;    \n  //Function Definition    \nfunction add(a: any, b:any): any {    \n    return a + b;    \n}    \nIn the above example, the first two lines are the function overload declaration. It has two overloads. The first signature has a parameter of type string whereas the second signature has a parameter of type number. The third function contains the actual implementation and has a parameter of type any. Any data type can take any type of data. The implementation then checks for the type of the supplied parameter and execute a different piece of code based on supplier parameter type.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "29) Is it possible to debug any TypeScript file?",
        "answer": "Yes, it is possible. To debug any TypeScript file, we need .js source map file. So compile the .ts file with the --sourcemap flag to generate a source map file.\n$ tsc -sourcemap file1.ts  \nThis will create file1.js and file1.js.map. And last line of file1.js would be reference of source map file.\n//# sourceMappingURL=file1.js.map",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "30) What is TypeScript Definition Manager and why do we need it?",
        "answer": "TypeScript Definition Manager (TSD) is a package manager used to search and install TypeScript definition files directly from the community-driven DefinitelyTyped repository.\nSuppose, we want to use some jQuery code in our .ts file.\n$(document).ready(function() { //Your jQuery code });",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "31) What is TypeScript Declare Keyword?",
        "answer": "We know that all JavaScript libraries/frameworks don't have TypeScript declaration files, but we want to use them in our TypeScript file without any compilation errors. To do this, we use the declare keyword. The declare keyword is used for ambient declarations and methods where we want to define a variable that may exist elsewhere.\nFor example, suppose we have a library called myLibrary that doesn't have a TypeScript declaration file and have a namespace called myLibrary in the global namespace. If we want to use that library in our TypeScript code, we can use the following code:\ndeclare var myLibrary;  \nTypeScript runtime will assign the myLibrary variable as any type. Here is a problem that we won't get Intellisense in design time but we will be able to use the library in our code.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "ts file?",
        "answer": "We can generate TypeScript definition file from any .ts file by using tsc compiler. It will be generating a TypeScript definition which makes our TypeScript file reusable.\ntsc --declaration file1.ts",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "json file?",
        "answer": "The tsconfig.json file is a file which is in JSON format. In the tsconfig.json file, we can specify various options to tell the compiler how to compile the current project. The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. Below is a sample tsconfig.json file.\n{  \n   \"compilerOptions\": {  \n      \"declaration\": true,      \n      \"emitDecoratorMetadata\": false,      \n      \"experimentalDecorators\": false,      \n      \"module\": \"none\",      \n      \"moduleResolution\": \"node\"  \n      \"removeComments\": true,  \n      \"sourceMap\": true  \n   },  \n   \"files\": [  \n      \"main.ts\",  \n      \"othermodule.ts\"  \n    ]  \n}  \nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "34) Explain generics in TypeScript?",
        "answer": "TypeScript Generics is a tool which provides a way to create reusable components. It is able to create components that can work with a variety of data types rather than a single data type. Generics provides type safety without compromising the performance, or productivity. Generics allow us to create generic classes, generic functions, generic methods, and generic interfaces.\nIn generics, a type parameter is written between the open (<) and close (>) brackets which makes it strongly typed collections. Generics use a special kind of type variable <T> that denotes types. The generics collections contain only similar types of objects.\nfunction identity<T>(arg: T): T {      \n    return arg;      \n}      \nlet output1 = identity<string>(\"myString\");      \nlet output2 = identity<number>( 100 );    \nconsole.log(output1);    \nconsole.log(output2);     \nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "35) Does TypeScript support all object-oriented principles?",
        "answer": "Yes, TypeScript support all object-oriented principles. There are four main principles to object-oriented programming:\nEncapsulation,\nInheritance,\nAbstraction, and\nPolymorphism.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "36) How to check null and undefined in TypeScript?",
        "answer": "By using a juggling-check, we can check both null and undefined:\nif (x == null) {  \n}  \nIf we use a strict-check, it will always true for values set to null and won't evaluate as true for undefined variables.\nExample\nvar a: number;  \nvar b: number = null;  \nfunction check(x, name) {  \n    if (x == null) {  \n        console.log(name + ' == null');  \n    }  \n    if (x === null) {  \n        console.log(name + ' === null');  \n    }  \n    if (typeof x === 'undefined') {  \n        console.log(name + ' is undefined');  \n    }  \n}  \ncheck(a, 'a');  \ncheck(b, 'b');  \nOutput\n\"a == null\"  \n\"a is undefined\"  \n\"b == null\"  \n\"b === null\"",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "37) Could we use TypeScript on the backend? If yes, how?",
        "answer": "Yes, we can use TypeScript on the backend. We can understand it with the following example. Here, we choose Node.js and have some additional type safety and the other abstraction that the language brings.\nInstall Typescript compiler\nnpm i -g typescript  \nThe TypeScript compiler takes options in the tsconfig.json file. This file determines where to put built files.\n{  \n  \"compilerOptions\": {  \n    \"target\": \"es5\",  \n    \"module\": \"commonjs\",  \n    \"declaration\": true,  \n    \"outDir\": \"build\"  \n  }  \n}  \nCompile ts files\ntsc  \nRun\nnode build/index.js",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "38) What is the difference between \"interface vs type\" statements?",
        "answer": "interface X {  \n    a: number  \n    b: string  \n}  \ntype X = {  \n    a: number  \n    b: string  \n};  \nSN interface type\n1 An interface declaration always introduces a named object type. A type alias declaration can introduce a name for any kind of type, including primitive, union, and intersection types.\n2 An interface can be named in an extends or implements clause. Type alias for an object type literal cannot be named in an extends or implements clause.\n3 Interfaces create a new name that is used everywhere. Type aliases don't create a new name.\n4 An interface can have multiple merged declarations. Type alias for an object type literal cannot have multiple merged declarations.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "39) What are Ambients in TypeScripts and when to use them?",
        "answer": "Ambient declarations tell the compiler about the actual source code exist elsewhere. If these source codes do not exist at runtime and we try to use them, then it will break without warning.\nAmbient declarations files are like docs file. If the source changes, the docs need to be kept updated also. If the ambient declaration file is not updated, then we will get compiler errors.\nThe Ambient declarations allow us to safely and easily use existing popular JavaScript libraries like jquery, angularjs, nodejs, etc.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "40) What is a TypeScript Map file?",
        "answer": "TypeScript Map file is a source map file which holds information about our original files.\n.map files are source map files that let tools map between the emitted JavaScript code and the TypeScript source files that created it.\nMany debuggers can consume these files so we can debug the TypeScript file instead of the JavaScript file.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "41) What is Type assertions in TypeScript?",
        "answer": "Type assertion works like a typecasting in other languages, but it doesn't perform type checking or restructuring of data just like other languages can do like C# and Java. The typecasting comes with runtime support whereas type assertion has no impact on runtime. However, type assertions are used purely by the compiler and provide hints to the compiler on how we want our code to be analyzed.\nExample\nlet empCode: any = 111;     \nlet employeeCode = <number> code;     \nconsole.log(typeof(employeeCode)); //Output: number  \nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "42) What is \"as\" syntax in TypeScript?",
        "answer": "The as is the additional syntax for Type assertion in TypeScript. The reason for introducing the as-syntax is that the original syntax (<type>) conflicted with JSX.\nExample\nlet empCode: any = 111;     \nlet employeeCode = code as number;   \nWhen using TypeScript with JSX, only as-style assertions are allowed.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "43) What is JSX? Can we use JSX in TypeScript?",
        "answer": "JSX is NOTHING BUT Javascript with a different extension. Facebook came up with this new extension so that they can distinguish from the XML-like implementation of HTML in JavaScript.\nJSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript. JSX came to popularity with the React framework. TypeScript supports embedding, type checking, and compiling JSX directly into JavaScript.\nTo use JSX, we must do two things.\nName the files with a .tsx extension\nEnable the jsx option",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "44) What is Rest parameters?",
        "answer": "The rest parameter is used to pass zero or more values to a function. It is declared by prefixing the three dot characters ('...')before the parameter. It allows the functions to have a variable number of arguments without using the arguments object. It is very useful where we have an undetermined number of parameters.\nRules to follow in rest parameter:\nOnly one rest parameter is allowed in a function.\nIt must be an array type.\nIt must be a last parameter in the parameter list.\nfunction sum(a: number, ...b: number[]): number {    \n let result = a;    \n for (var i = 0; i < b.length; i++) {    \n result += b[i];    \n }    \n console.log(result);    \n}    \nlet result1 = sum(3, 5);    \nlet result2 = sum(3, 5, 7, 9);   \nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "45) Explain Enum in TypeScript?",
        "answer": "Enums or enumerations are a TypeScipt data type that allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. It is a collection of related values that can be numeric or string values.\nExample\nenum Gender {  \n  Male,  \n  Female  \n  Other  \n}  \nconsole.log(Gender.Female); // Output: 1  \n//We can also access an enum value by it's number value.  \nconsole.log(Gender[1]); // Output: Female",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "",
        "answer": "Non-Relative Relative\nA non-relative import can be resolved relative to baseUrl, or through path mapping. In other words, we use non-relative paths when importing any of our external dependencies.\nExample:\nimport * as $ from \"jquery\";\nimport { Component } from \"@angular/core\";\nRelative imports can be used for our own modules that are guaranteed to maintain their relative location at runtime. A relative import is starts with /, ./ or ../.\nExample:\nimport Entry from \"./components/Entry\";\nimport {DefaultHeaders} from \"../constants/http\";",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "47) What is an anonymous function?",
        "answer": "An anonymous function is a function that was declared without any named identifier. These functions are dynamically declared at runtime. Anonymous functions can accept inputs and return outputs, just as standard functions do. An anonymous function is usually not accessible after its initial creation.\nExample\nlet myAdd = function(x: number, y: number): number {   \nreturn x + y;   \n};  \nconsole.log(myAdd())",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "48) What is Declaration Merging?",
        "answer": "Declaration merging is the process followed by the compiler to merge two or more separate declarations. The declaration declared with the same name into a single definition. This merged definition has the features of both of the original declarations.\nThe simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.\nExample\ninterface Cloner {  \n    clone(animal: Animal): Animal;  \n}  \ninterface Cloner {  \n    clone(animal: Sheep): Sheep;  \n}  \ninterface Cloner {  \n    clone(animal: Dog): Dog;  \n    clone(animal: Cat): Cat;  \n}  \nThe three interfaces will merge to create a single declaration as so:\ninterface Cloner {  \n    clone(animal: Dog): Dog;  \n    clone(animal: Cat): Cat;  \n    clone(animal: Sheep): Sheep;  \n    clone(animal: Animal): Animal;  \n}  \nNote: Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or variables.",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "49) What are method overriding in TypeScript?",
        "answer": "If subclass (child class) has the same method as declared in the parent class, it is known as method overriding. In other words, redefined the base class methods in the derived class or child class.\nRules for Method Overriding\nThe method must have the same name as in the parent class\nThe method must have the same parameter as in the parent class.\nThere must be an IS-A relationship (inheritance).\nExample\nclass NewPrinter extends Printer {  \n    doPrint(): any {  \n        super.doPrint();  \n        console.log(\"Called Child class.\");  \n    }  \n    doInkJetPrint(): any {  \n        console.log(\"Called doInkJetPrint().\");  \n    }  \n}  \nlet printer: new () => NewPrinter;  \nprinter.doPrint();  \nprinter.doInkJetPrint();",
        "reference": "javatpoint.com",
        "role": "typescript"
    },
    {
        "question": "50) What is Lambda/Arrow function?",
        "answer": "ES6 version of TypeScript provides shorthand syntax for defining the anonymous function, i.e., for function expressions. These arrow functions are also called Lambda functions. A lambda function is a function without a name. Arrow function omits the function keyword.\nExample\nlet sum = (a: number, b: number): number => {    \n            return a + b;    \n}    \nconsole.log(sum(20, 30)); //returns 50    \nIn the above, the ?=>? is a lambda operator and (a + b) is the body of the function and (a: number, b: number) are inline parameters.\nTo know more click here.",
        "reference": "javatpoint.com",
        "role": "typescript"
    }
]