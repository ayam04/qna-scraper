[
    {
        "question": "1. What is JavaScript, and what are its key features?",
        "answer": "JavaScript is a very powerful high-level programming language commonly used to make web pages more interactive and dynamic. It allows developers to create responsive and engaging websites by adding features like animations, form validations, and interactive elements. JavaScript is lightweight and easy to use, making it a popular choice for web development. It supports different programming styles, including object-oriented and functional approaches, giving developers the flexibility to write code in a way that suits their needs best. With JavaScript, developers can breathe life into static web pages, making the user experience more enjoyable and interactive.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "2. Explain the difference between let, var, and const for declaring variables in JavaScript.",
        "answer": "‘let’ and ‘const’ are block-scoped variables introduced in ES6 (short for ECMAScript 6), while ‘var’ is function-scoped. ‘let’ allows reassigning values, ‘const’ is for constants that cannot be reassigned and ‘var’ can be reassigned but has a broader scope than let.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "3. How do you create and use functions in JavaScript?",
        "answer": "Functions in JavaScript are like building blocks that allow developers to create reusable blocks of code. \nThere are two ways to create functions: \nUsing the function keyword or \nUsing the arrow functions (() => {}). \nFunctions can take input values, which we call parameters, and perform specific actions or calculations based on these inputs. After performing the desired actions, functions can also return a value using the return keyword. This returned value can then be used or stored for further use in the program. With functions, developers can organize their code into logical modules, making it easier to understand and maintain. They are a fundamental concept in JavaScript programming and play a crucial role in creating dynamic and interactive web applications",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "4. What is the purpose of NaN in JavaScript, and how do you check for it?",
        "answer": "‘NaN’, short for ‘Not a Number’, is a unique value in JavaScript that indicates an invalid result from a mathematical operation. For example, if you try to perform a mathematical calculation that doesn’t yield a valid number, JavaScript will return ‘NaN’. \nTo check if a value is ‘NaN’, you can use the ‘isNaN()’, which will return true if the value is indeed ‘NaN’ and false if it is a valid number. This helps developers handle scenarios where the result of a calculation might not be a number, ensuring that the code behaves as expected and avoids unexpected errors. Understanding ‘NaN’ and how to check for it is an essential aspect of working with numerical data in JavaScript and contributes to creating reliable and accurate code.\nInterested in learning Java? Enroll in our Java Training now!",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "5. Describe the difference between '==' and '===' in JavaScript.",
        "answer": "The ‘==’ is an equality operator that checks for equality after converting the operands to the same type if needed. On the other hand, the ‘===’ is a strict equality operator that checks for equality without any type of conversion.\nIn simple terms, ‘==’ allows for loose comparison, while ‘===’ enforces strict comparison, ensuring that both the value and the data type must match for it to return true.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "6. How do you handle asynchronous operations in JavaScript? Provide an example.",
        "answer": "Asynchronous operations are tasks in JavaScript that may take some time to complete, such as fetching data from a server or reading files. Unlike synchronous operations that block the execution of the code until the task is finished, asynchronous operations allow the program to continue executing other tasks while waiting for the asynchronous task to complete.\nThere are three main ways to handle asynchronous operations in JavaScript:\nCallbacks: Callbacks are functions passed as arguments to other functions, which will be executed once the asynchronous task is completed. The callback function allows the program to respond to the result of the asynchronous task or handle any errors that might occur. \nPromises: Promises are a more structured way to handle asynchronous operations and provide a better alternative to callbacks. A Promise represents a value that may not be available yet but will be resolved in the future.\nIt has then() and catch() methods to handle successful and error outcomes, respectively. Promises allow the chaining of asynchronous tasks in a more readable and sequential manner, making the code more organized and easier to understand.\nAsync/Await: Async/Await is a modern and elegant syntax built on top of Promises, introduced in ES2017 (ES8). It allows developers to write asynchronous code that looks and behaves more like synchronous code. By using the async keyword before a function declaration, the function automatically returns a Promise. The await keyword is then used inside the async function to pause execution until the Promise is resolved, making it appear as if the asynchronous operation is synchronous.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "7. What are Arrays in JavaScript, and how do you access their elements?",
        "answer": "Arrays in JavaScript are a fundamental data structure used to store and organize collections of data. They are ordered, meaning the elements are stored in a specific sequence. Each element in an array is identified by its index, which starts at 0 for the first element, 1 for the second element, and so on.\nTo access the elements of an array, you can use square brackets ([]) along with the index of the element you want to retrieve.\nFor example, if you have an array named myArray, you can access its first element using myArray[0], the second element using myArray[1], and so on.\n//Creating an array of numbers\nconst numbers = [10, 20, 30, 40, 50];\n\n//Accessing elements of the array\nconsole.log(numbers[0]);\n\nconsole.log(numbers[2]);\n\nconsole.log(numbers[4]);\n \n<strong>Output:</strong>\n10\n30\n50\nGet 100% Hike!\nMaster Most in Demand Skills Now!\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "8. Explain the role of ‘this’ keyword in JavaScript and how it behaves in different contexts.",
        "answer": "The ‘this’ keyword in JavaScript plays a pivotal role in referencing the current execution context. Its behavior varies based on the context in which it is used, such as within a function, method, or event handler. ‘this’ typically refers to the object that is called the function/method, but in certain situations, it may point to the global object or remain undefined. Understanding ‘this keyword in JS’ is crucial for precise and effective programming in JavaScript.\nRead on:- Java Tutorial to enhance your knowledge!",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "9. How do you loop through an object's properties in JavaScript?",
        "answer": "When you need to iterate through an object’s properties in JavaScript, you have several options available. One way is to use a ‘for’ in loop, which allows you to loop through each property of the object one by one. Another approach is to use the methods ‘Object.keys()’, ‘Object.values()’, or, ‘Object.entries()’ introduced in ES6. These methods provide arrays of the object’s keys, values, or key-value pairs, respectively, which you can then iterate through using traditional array looping techniques like for or forEach. These techniques offer different ways to access and work with an object’s properties, providing flexibility and convenience when handling complex data structures in JavaScript.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "10. What is the purpose of the 'typeof' operator in JavaScript? Give an example.",
        "answer": "Developers can determine the data type of a variable or expression with the aid of the ‘typeof’ operator in JavaScript. You can use it to figure out whether a value is a number, text, boolean, object, function, undefined, or any other data type that the language supports. Making judgments in your code and managing data appropriately based on its kind require the use of this knowledge.\nlet name = 'John';\nlet age = 30; \nlet isMarried = false; \n//Accessing elements of the array\nconsole.log(typeof name);\nconsole.log(typeof age); \nconsole.log(typeof isMarried); \nOutput:\nstring\nnumber\nboolean\nIntermediate JavaScript Interview Questions\nHere are some more JavaScript Questions for Learners",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "11. Explain hoisting in JavaScript.",
        "answer": "Hoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their scope before code execution. This means functions can be called before they are declared and variables can be accessed before they are declared without throwing errors.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "12. What is the 'use strict' mode in JavaScript?",
        "answer": "The “use strict” mode is a way to opt into a restricted variant of JavaScript. It catches common coding mistakes and “unsafe” actions. When used, it disables actions like using undeclared variables, deleting variables, and others to prevent bugs. It makes JavaScript code more secure and helps developers write cleaner code.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "13. What is the difference between map and foreach in JavaScript?",
        "answer": "The map method returns a new array with the results of calling a function on every element in an array, while each simply executes the function on each element without returning a value. Map allows you to transform an array, while each is used only to iterate over elements without modifying the original array.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "14. What are ES6 modules in JavaScript?",
        "answer": "ES6 modules allow JavaScript code and functions to be split across multiple separate files called modules. Each module handles a specific task and can export functions or objects for other modules to use. This avoids polluting the global namespace and makes code more maintainable by separating concerns into individual modules.\nAlso, check our blog on Python vs JavaScript: Top Key Differences!",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "15. Explain the concept of object-oriented programming in JavaScript.",
        "answer": "Object-oriented programming (OOP) in JavaScript uses objects and classes to structure code. Objects contain data (properties) and related behaviors (methods). Classes act as templates to create objects with common properties and methods. OOP principles like inheritance, encapsulation, and polymorphism help organize code and make it reusable.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "16. What are the different types of errors in JavaScript?",
        "answer": "The main types of errors in JavaScript are syntax errors, runtime errors, and logical errors. Syntax errors occur due to incorrect syntax like missing brackets. Runtime errors happen during execution like reference errors. Logical errors produce unintended results even if the code runs without crashing, due to flawed thinking in programming logic.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "17. What is the difference between synchronous and asynchronous programming?",
        "answer": "In synchronous programming, tasks are executed sequentially where each subsequent task waits for the previous task to complete before starting. Asynchronous programming doesn’t wait and allows multiple tasks to run concurrently without blocking. JavaScript uses asynchronous programming to make UI responsive and handle long tasks without freezing the browser.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "18. What are Closures in JavaScript, and how are they useful? Provide an example.",
        "answer": "Closures in JavaScript are functions that have access to variables from their containing (enclosing) function, even after the enclosing function has finished executing. This occurs because the inner function maintains a reference to the environment in which it was created, allowing it to ‘“close over’” and retain access to its outer function’s variables. Closures are powerful and useful for creating private variables, implementing data encapsulation, and achieving functional programming paradigms in JavaScript.\nCode:\nfunction outerFunction() {\n  let outerVariable = ‘I am from the outerFunction’;\n  \n  function innerFunction() {\n    console.log(outerVariable);\n  }\n  return innerFunction;\n}\nconst closureFunction = outerFunction();\nclosureFunction();\nOutput:\nI am from the outer function",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "19. Explain the concept of Prototypal inheritance in JavaScript.",
        "answer": "Prototypal inheritance is the mechanism by which objects in JavaScript inherit properties and methods from other objects, forming a prototype chain. Each object has an internal link to its prototype (also known as __proto__). When a property or method is accessed on an object, JavaScript searches for the property/method in the object itself and then in its prototype chain until it finds the property or reaches the end of the chain (i.e., the root Object.prototype). This concept allows objects to inherit and share functionality, leading to code reusability and a more memory-efficient way of handling similar objects.\nReady to level up your JavaScript skills? Dive into our guide on What is a Callback Function in JavaScript by mastering their power and application in your code effortlessly.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "20. How do you handle errors and exceptions in JavaScript using try...catch blocks?",
        "answer": "The try…catch block is used in JavaScript to handle errors and exceptions gracefully. When code that may cause an error is placed within the try block, if an error occurs,  control is immediately transferred to the corresponding catch block. This prevents the error from causing the entire program to crash. The catch block receives an error object that contains information about the error, allowing developers to log or handle the error appropriately.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "21. Describe the concept of Event delegation in JavaScript and its benefits.",
        "answer": "Event delegation is a technique in JavaScript where a single event handler is attached to a common ancestor element instead of attaching individual event handlers to multiple child elements. This way, events can be efficiently managed and handled for dynamically added elements or elements that are not yet present in the DOM. Event delegation reduces memory consumption and improves performance by leveraging event propagation (bubbling or capturing) to handle events at a higher level in the DOM tree.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "22. What are higher-order functions in JavaScript? Provide a practical example.",
        "answer": "In JavaScript, higher-order functions are functions that can take one or more functions as arguments and/or return a function as their result. This concept is derived from functional programming, which treats functions as first-class citizens, meaning they can be assigned to variables, passed as arguments, and returned as values.\nHigher-order functions enable developers to write more flexible and reusable code by abstracting common patterns and behaviors into functions that can be manipulated and combined with other functions. They are an essential feature of functional programming and are widely used in modern JavaScript development.\nExample of higher-order functions in JavaScript:\nCode:\n// Original array of numbers\nconst numbers = [1, 2, 3, 4, 5];\n\n// Higher-order function using map()\nconst doubledNumbers = numbers.map(function (number) {\n  return number * 2;\n});\nconsole.log(doubledNumbers);\nOutput:\n[2, 4, 6, 8, 10]",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "23. How does the async/await syntax simplify asynchronous programming in JavaScript?",
        "answer": "Simplifying Asynchronous Programming with async/await:\nThe async/await syntax is a feature introduced in ES2017 (ES8) that simplifies working with asynchronous code in JavaScript. By marking a function with the async keyword, it automatically returns a Promise. Within an async function, the await keyword can be used to pause execution until a Promise is resolved or rejected. This makes asynchronous code look more like synchronous code, improving code readability and maintainability.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "24. Discuss the concept of Callback functions and their role in Asynchronous operations.",
        "answer": "Callback functions are functions passed as arguments to other functions and are executed once the asynchronous operation is completed. They are commonly used in older asynchronous patterns (such as callbacks in setTimeout() or XMLHttpRequest) but are gradually being replaced by promises and async/await due to the callback hell problem, where multiple nested callbacks lead to difficult-to-read code.\nAlso, check our blog on What is React.js?",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "25. What are Immediately-Invoked Function Expressions (IIFE) in JavaScript, and why would you use them?",
        "answer": "Immediately-Invoked Function Expressions (IIFE) is a design pattern in JavaScript where a function is defined and immediately invoked. This pattern is often used to create a private scope, encapsulating variables and preventing them from polluting the global namespace. IIFE is commonly used in older JavaScript code to avoid variable collisions and maintain cleaner code.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "26. How do you use Modules in modern JavaScript development? Give an example of importing and exporting modules.",
        "answer": "In modern JavaScript development, modules are used to organize code into separate files, each containing a specific piece of functionality. The ES6 module system allows developers to import and export functionality between modules, promoting code reusability and maintainability. Modules help manage dependencies, avoid global scope pollution, and make code easier to manage in large-scale applications.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "27. Explain the concept of hoisting in JavaScript and its implications.",
        "answer": "Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their containing scope during the compilation phase. This allows variables and functions to be accessed before they are formally declared in the code. However, only the declarations are hoisted, not the initializations. Understanding hoisting is crucial to avoiding unexpected behavior and writing more predictable code.\n\nAdvanced JavaScript Interview Questions\nHere are some more JavaScript Questions for Experienced",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "28. What are the advantages of using JavaScript frameworks/libraries like React or Angular?",
        "answer": "Frameworks provide reusable code and components, save development time, and make it easier to build large, complex apps. They handle tasks like DOM manipulation which is difficult in plain JS. Frameworks enforce style guides and best practices. Apps built with frameworks are more organized, scalable, and maintainable compared to vanilla JS code. Frameworks also provide built-in functionality like routing and state management.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "29. What is the difference between local storage and session storage in JavaScript?",
        "answer": "Local storage stores data with no expiration date, and remains even after browser tab closes. Session storage stores data for one session only, data is lost when tab closes. Local storage does not have a size limit but session storage is limited to 5MB. Local storage is better for permanent storage and session storage for temporary data that needs to be deleted.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "30. Explain the concept of the DOM (Document Object Model) in JavaScript.",
        "answer": "The DOM represents an HTML document as nodes and objects. It provides programming interfaces to dynamically access and update the content, structure, and style of a document. With DOM, JavaScript can connect to HTML and manipulate how it displays. This allows dynamic changes to webpages without reloading. The DOM tree has the HTML document as the root and all other elements, texts, and images as nodes",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "31. What is the purpose of the 'bind' method in JavaScript?",
        "answer": "The ‘bind’ method creates a new function that, when called, has its ‘this’ keyword set to a specific value, enabling explicit control over the context in which a function is executed.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "32. What is the difference between 'null' and 'undefined' in JavaScript?",
        "answer": "Null is an assignment value that means empty or no value assigned. Undefined means a variable has been declared but no value assigned to it yet. While null is an object, undefined is a primitive value. A variable with a null value is by design, undefined means a missing reference usually due to programming errors or lack of initialization.\nTo know the difference between Node.js and Javascript, check out our blog on Node.js VS JavaScript – The Comprehensive Guide!",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "33. What are the differences between arrow functions and regular functions in JavaScript?",
        "answer": "Arrow functions in JavaScript are like quick ways to write functions with =>, and are good for short tasks, while regular functions use functions and suit bigger jobs.\nFor example:\nArrow function:\nconst arrowFunction = (a, b) = > a + b;\nRegular function:\nfunction regularFunction(a, b) {\nreturn a + b;\n}",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "34. Explain the concept of the spread operator in JavaScript.",
        "answer": "The spread operator (…) allows iterables like arrays and objects to be expanded in places where zero or more arguments are expected. It copies the elements of an array or properties of an object and places them in a new array/object. This is useful for concatenating arrays, merging objects, function calls and more",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "35. Describe the concept of the event loop in JavaScript and how it enables asynchronous behavior.",
        "answer": "The event loop is a crucial mechanism in JavaScript that enables asynchronous behavior, ensuring that programs can handle time-consuming operations efficiently without becoming unresponsive. JavaScript is single-threaded, which means it executes one task at a time. Asynchronous tasks, such as fetching data from servers or reading files, may take some time to complete, potentially blocking the program’s execution if it were to wait for them. However, the event loop solves this problem by constantly checking a message queue for pending tasks or events. When the call stack is empty, the event loop picks the next task from the queue and executes it, allowing the program to continue processing other tasks while awaiting the completion of asynchronous operations. This way, the application remains responsive and avoids being blocked, providing a smooth user experience.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "36. What are Promises in JavaScript, and how do they handle asynchronous operations?",
        "answer": "Promises in JavaScript are a feature introduced in ES6 to handle asynchronous operations in a more structured and elegant way than using traditional callbacks. A Promise represents a future value that may or may not be available at a particular moment. It can be in one of three states: pending (initial state), fulfilled (resolved with a value), or rejected (failed with an error). Promises provide two main methods: then() to handle successful outcomes and catch() to handle errors. When an asynchronous operation is complete, the Promise resolves or rejects with the corresponding result or error, respectively. Promises help avoid callback hell and provide a more readable and maintainable way to deal with asynchronous flows.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "37. Explain the role of bind, call, and apply methods in managing the context of this.",
        "answer": "In JavaScript, we have three methods – bind(), call(), and apply() – that allow us to manage the ‘this’ context when calling a function. These methods are helpful when we want to ensure that a function is executed with a specific object as its ‘this’ value.\nbind() Method: The bind() method creates a new function that is a copy of the original function, but with a fixed value. This means that whenever the new function is called, the ‘this’ keyword inside it will always refer to the object passed as an argument to bind(). The original function is not affected by bind(); instead, it remains unchanged.\ncall() Method: The call() method allows us to call a function immediately, specifying the object that should be used as the ‘this’ value inside the function. It also allows us to pass individual arguments to the function, which will be received as separate parameters inside the function.\napply() Method: Similar to call(), the apply() method also calls a function immediately and sets the ‘this’ value to the specified object. However, it accepts an array of arguments as the second argument, making it useful when the number of arguments is not known in advance.\nThese methods come in handy when we want to control the context in which a function is executed. For example, when using object methods as event handlers, we can use bind() to ensure that this inside the method refers to the object itself, regardless of how the method is called. Similarly, call() and apply() are useful when we want to borrow methods from one object to use with another object and set the correct ‘this’ context for the borrowed method.\nOverall, these methods provide flexibility and control over the ‘this’ context in JavaScript functions, allowing developers to write more organized and maintainable code when working with objects and methods.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "38. Discuss the differences between ES5 and ES6 (ECMAScript 2015) in JavaScript.",
        "answer": "ES5 and ES6 (also known as ECMAScript 2015) are two different versions of the ECMAScript standard, which is the specification that defines the JavaScript language. ES6 introduced several new features and improvements over ES5, aiming to make JavaScript more powerful, expressive, and developer-friendly. Here are the key differences between ES5 and ES6:\nLet and const Declarations:\nES6 introduced the let and const keywords for declaring variables with block scope, whereas in ES5, variables are declared using var, which has function scope.\nlet allows reassignment of values, similar to var, but it restricts the scope to the block where it’s defined.\nconst is used for defining constants that cannot be reassigned once they are initialized.\nArrow Functions:\nES6 introduced arrow functions, which provide a concise syntax for writing anonymous functions.\nArrow functions have a shorter syntax and automatically capture the surrounding values, making it easier to handle context-related issues.\nTemplate Literals:\nES6 introduced template literals using backticks ( ), allowing multi-line strings and easy string interpolation.\nTemplate literals provide a more readable and expressive way to create strings with variables embedded directly inside them.\nClass Syntax:\nES6 introduced a class syntax for defining classes and constructor functions, making it easier to implement object-oriented programming in JavaScript.\nPrior to ES6, class-like structures were implemented using constructor functions and prototypes.\nDestructuring Assignment:\nES6 added destructuring assignment, enabling you to extract values from arrays and objects and assign them to variables in a concise and readable way.\nDefault Parameters:\nES6 allows you to define default parameter values in function declarations, making it simpler to handle optional arguments in function calls.\nSpread and Rest Operators\nES6 introduced the spread (…) and rest (…) operators for working with arrays and function arguments.\nThe spread operator can expand an array or object into individual elements, while the rest operator collects multiple function arguments into a single array.\nModules:\nES6 introduced native support for modules, allowing you to export and import functionality between different JavaScript files.\nModules provide a cleaner and more organized way to structure and manage code in large applications.\nPromises:\nAlthough promises were initially introduced as a separate library, ES6 standardized them, providing native support for handling asynchronous operations and avoiding callback hell.\nOther Enhancements:\nES6 introduced many other smaller enhancements, such as for…of loops for iterating over iterable objects, Symbols for creating unique identifiers, and Map and Set data structures for managing collections of data.\nOverall, ES6 brought significant improvements to JavaScript, making it a more modern and expressive language, and it has become the foundation for subsequent ECMAScript versions. However, it’s essential to be mindful of browser support when using ES6 features, as older browsers may not fully support all ES6 features without transpilation or polyfills.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "39. What are Generators in JavaScript, and how can they be useful in certain scenarios?",
        "answer": "Generators in JavaScript are a powerful feature  introduced in ES6. They are functions that can be paused and resumed during their execution, allowing for more complex control flows and lazy evaluation of data. Generators are denoted by an asterisk (*) after the function keyword. When a generator function is called, it returns an iterator object that can be used to control the function’s execution. Generators are useful for scenarios where you need to handle sequences of data or control flow in a more sophisticated manner.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "40. Describe the concept of Memoization and its application to optimizing function performance.",
        "answer": "Memoization in JavaScript  is a technique used to optimize function performance by caching the results of expensive function calls and returning the cached result when the same inputs occur again. It helps reduce redundant computations and improve the efficiency of functions that are frequently called with the same arguments. Memoization is particularly useful for recursive or computationally intensive functions, as it avoids repetitive calculations and significantly speeds up the overall execution time.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "41. How do you implement a debounce function in JavaScript, and when is it beneficial?",
        "answer": "To create a debounce function in JavaScript, you can design a higher-order function that receives another function as input and produces a new function as output. This new function is responsible for postponing the execution of the original function until a specific time interval has elapsed since its last invocation. If the function is called again during this waiting period, the timer restarts, and the waiting time is reset accordingly. This debounce technique effectively limits the frequency of function calls and helps optimize performance in scenarios where frequent and rapid invocations are expected, such as handling user input events. By using debounce, you can enhance the efficiency of your JavaScript code and prevent unnecessary and excessive function calls, leading to a more responsive and smoother user experience.\nA simple debounce function can be created like this:\nfunction debounce(func, delay) {\n  let timer;\n  return function (…args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => func.apply(this, args), delay);\n  };\n}\nThe debounce function is beneficial in scenarios where you want to optimize performance by reducing the number of function invocations. It is commonly used in scenarios like auto-complete search boxes, resizing events, or handling user input where you want to delay the execution of the function until the user has stopped typing or interacting with the UI. By using debounce, you can prevent excessive and unnecessary function calls, leading to a more responsive and efficient user experience.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "42. Explain the concept of Web Workers in JavaScript and how they improve multi-threading in the browser.",
        "answer": "Web Workers in JavaScript are a feature that enables multi-threading in the browser. They allow developers to run scripts in the background without affecting the main UI thread. By doing so, Web Workers improve the responsiveness of web applications, as time-consuming tasks can be offloaded to separate threads, preventing the main thread from being blocked. This separation of tasks into different threads enhances the overall performance and user experience, making web applications more efficient and capable of handling computationally intensive operations without causing freezing or delays in the user interface.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "43. Discuss the advantages and disadvantages of using arrow functions in JavaScript.",
        "answer": "Advantages:\nShorter Syntax: Arrow functions provide a concise syntax, making code more readable and reducing boilerplate code, especially for simple one-liner functions.\nNo this Binding: Arrow functions inherit the ‘this’ value from the surrounding lexical context, eliminating the need to use bind() or store the reference to this in a separate variable.\nImplicit Return: Arrow functions with a single expression automatically return the result of that expression, saving developers from writing explicit return statements.\nNo Binding of arguments: Arrow functions do not bind their own arguments object, which can be beneficial as it avoids potential confusion with other variables named arguments.\nDisadvantages:\nNo arguments Object: As mentioned earlier, arrow functions do not have their own arguments object, which means you cannot access the function arguments using arguments within an arrow function.\nNo ‘this’ Manipulation: The automatic lexical ‘this’ binding in arrow functions can be disadvantageous in some cases where dynamic ‘this’ manipulation is required.\nNot Suitable for Object Methods: Arrow functions are not ideal for defining object methods because they lack their own ‘this’ binding, and using this in such cases would refer to the surrounding context, not the object itself.\nLimited Use in Constructors: Arrow functions cannot be used as constructors, which means they cannot be instantiated using the new keyword. This can be a limitation in certain scenarios that require constructor functions.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "44. What is the role of the Map and Set data structures in modern JavaScript, and how are they different from regular objects and arrays?",
        "answer": "In modern JavaScript, the Map and Set data structures serve specific purposes and offer advantages over regular objects and arrays in certain scenarios:\nMap: \nKey-Value Pairs: Maps are primarily used to store key-value pairs, where both keys and values can be of any data type. This makes them more versatile compared to regular objects, which only allow strings or symbols as keys.\nOrder Preservation: Unlike regular objects, which do not guarantee the order of properties, Map maintains the insertion order of elements, making it suitable for use cases where the order of insertion matters.\nKey Existence Check: Maps offer a convenient way to check if a specific key exists using the has method, without the need for additional checks or iterating over the object.\nIterating and Size Retrieval: Maps have built-in methods like forEach for easy iteration over the key-value pairs, and the size property to quickly retrieve the number of entries.\nSet:\nUnique Values: Sets are designed to store unique values of any data type. If you add a value that already exists, it won’t be duplicated in the Set.\nMembership Check: Sets provide an efficient way to check whether a particular value is present in the Set using the has method, without the need for custom checks or iterations.\nIterating and Size Retrieval: Sets have built-in methods like forEach for easy iteration over the unique values, and the size property to quickly retrieve the number of elements.\nDifferences from Regular Objects and Arrays:\nKeys and Indexing:\nRegular objects use strings or symbols as keys, and values can be accessed using dot notation or bracket notation (e.g., obj.key or obj[‘key’]).\nMaps allow any value as a key, and values can be accessed using the get method (e.g., map.get(key)).\nArrays use numeric indices and allow elements to be accessed using index notation (e.g., arr[0]).\nOrder Preservation:\nRegular objects do not guarantee the order of properties, and the order of insertion is not preserved.\nMaps maintain the order of elements based on their insertion order.\nArrays preserve the order of elements based on their index.\nKey Existence Check:\nFor regular objects, you need to manually check for their existence using methods like hasOwnProperty or in.\nMaps provide a built-in method to check for key existence.\nArrays do not have built-in methods for key existence checks, as they are primarily indexed by numeric values.\nValues and Duplicates:\nRegular objects and Maps can store any data type as values.\nSets only store unique values; duplicates are automatically removed.\nIn summary, Maps and Sets in modern JavaScript provide specialized data structures for specific use cases, offering advantages like key-value pair storage, order preservation, efficient membership checks, and handling unique values. Regular objects and arrays are more general-purpose data structures and do not offer the same specialized features as Maps and Sets. Choosing the right data structure for computer programming depends on the specific requirements of your problem statement or application.\nThese top Javascript interview questions and answers cover a wide range of topics and levels varied in difficulty to assess a fresher’s understanding of JavaScript. Preparing for these questions will provide freshers with a solid foundation for JavaScript interviews questions and boost their confidence in handling various JavaScript-related concepts and challenges.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "45. Explain WeakMap in javascript.",
        "answer": "WeakMap is a collection of key-value pairs where the keys are weakly referenced. This allows key objects to be garbage collected if there are no other references to them. Since keys are weakly held, WeakMaps don’t interfere with the garbage collection of objects. This makes WeakMaps useful for caching and temporary data that don’t need to be strongly referenced.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "46. What is a Temporal Dead Zone?",
        "answer": "The Temporal Dead Zone refers to the period between entering a block and declaring a variable with let or const where a ReferenceError will be thrown if trying to access the variable. This is because let and const variables are not hoisted like var, and exist only after their declaration in block scope, not for the whole block.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "47. Explain the difference between 'map()' and 'filter()' methods in JavaScript.",
        "answer": "Map() returns a new array by performing a function on each array element. Filter() returns a new array by keeping elements that pass a test. Map() always returns an array of the same length, while filter() returns an array with a length potentially less than or equal to the original. Map() transforms elements, filter() extracts matching elements based on condition.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "48. What is the difference between 'slice()' and 'splice()' methods in JavaScript?",
        "answer": "slice() extracts a portion of an array and returns a new array with the extracted elements without modifying the original array.\nsplice() removes elements from an original array and can insert new elements in their place, modifying the original array.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "49. Explain the concept of debouncing and throttling in JavaScript.",
        "answer": "Debouncing in JavaScript: Delays the execution of a function until a certain amount of time has elapsed since the last call. Useful for performance to avoid unnecessary executions.\nThrottling in JavaScript: Limits the rate at which a function can be called over time. Executes at most once per period. Useful for limiting frequent calls to improve performance.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "50. Explain the difference between 'async' and 'defer' attributes in script tags.",
        "answer": "async:- The async attribute downloads the external script file asynchronously in the background without blocking page rendering. As soon as the script is downloaded, it is executed immediately, even if the HTML document is still parsing. Execution order is not guaranteed with async scripts.\ndefer:- The defer attribute also downloads the external script file asynchronously in the background like async. However, it delays the execution of the script until the HTML document has finished parsing. This ensures proper execution order and allows multiple deferred scripts to execute in the order they appear. defer does not block page rendering either.",
        "reference": "intellipaat.com",
        "role": "javascript"
    },
    {
        "question": "1. What are the different data types present in javascript?",
        "answer": "To know the type of a JavaScript variable, we can use the typeof operator. typeof 1. Primitive types 1. Primitive types String - It represents a series of characters and is written with quotes. A string can be represented using a single or a double quote. String Example : var str = \"Vivek Singh Bisht\"; //using double quotes\nvar str2 = 'John Doe'; //using single quotes var str = \"Vivek Singh Bisht\"; //using double quotes\nvar str2 = 'John Doe'; //using single quotes var \"Vivek Singh Bisht\" //using double quotes var 'John Doe' //using single quotes Number - It represents a number and can be written with or without decimals. Number - It represents a number and can be written with or without decimals. Number Example : var x = 3; //without decimal\nvar y = 3.6; //with decimal var x = 3; //without decimal\nvar y = 3.6; //with decimal var 3 //without decimal var 3.6 //with decimal BigInt - This data type is used to store numbers which are above the limitation of the Number data type. It can store large integers and is represented by adding “n” to an integer literal. BigInt - This data type is used to store numbers which are above the limitation of the Number data type. It can store large integers and is represented by adding “n” to an integer literal. BigInt Example : var bigInteger =  234567890123456789012345678901234567890; var bigInteger =  234567890123456789012345678901234567890; var 234567890123456789012345678901234567890 Boolean - It represents a logical entity and can have only two values : true or false. Booleans are generally used for conditional testing. Boolean - It represents a logical entity and can have only two values : true or false. Booleans are generally used for conditional testing. Boolean Example : var a = 2;\nvar b =  3;\nvar c =  2;\n(a == b) // returns false\n(a == c) //returns true var a = 2;\nvar b =  3;\nvar c =  2;\n(a == b) // returns false\n(a == c) //returns true var 2 var 3 var 2 // returns false //returns true Undefined - When a variable is declared but not assigned, it has the value of undefined and it’s type is also undefined. Undefined - When a variable is declared but not assigned, it has the value of undefined and it’s type is also undefined. Undefined Example : var x; // value of x is undefined\nvar y = undefined; // we can also set the value of a variable as undefined var x; // value of x is undefined\nvar y = undefined; // we can also set the value of a variable as undefined var // value of x is undefined var undefined // we can also set the value of a variable as undefined Null - It represents a non-existent or a invalid value. Null - It represents a non-existent or a invalid value. Null Example : var z = null; var z = null; var null Symbol - It is a new data type introduced in the ES6 version of javascript. It is used to store an anonymous and unique value. Symbol - It is a new data type introduced in the ES6 version of javascript. It is used to store an anonymous and unique value. Symbol Example : var symbol1 = Symbol('symbol'); var symbol1 = Symbol('symbol'); var Symbol 'symbol' typeof of primitive types : typeof of primitive types : of primitive types typeof \"John Doe\" // Returns \"string\"\ntypeof 3.14 // Returns \"number\"\ntypeof true // Returns \"boolean\"\ntypeof 234567890123456789012345678901234567890n // Returns bigint\ntypeof undefined // Returns \"undefined\"\ntypeof null // Returns \"object\" (kind of a bug in JavaScript)\ntypeof Symbol('symbol') // Returns Symbol typeof \"John Doe\" // Returns \"string\"\ntypeof 3.14 // Returns \"number\"\ntypeof true // Returns \"boolean\"\ntypeof 234567890123456789012345678901234567890n // Returns bigint\ntypeof undefined // Returns \"undefined\"\ntypeof null // Returns \"object\" (kind of a bug in JavaScript)\ntypeof Symbol('symbol') // Returns Symbol typeof \"John Doe\" // Returns \"string\" typeof 3.14 // Returns \"number\" typeof true // Returns \"boolean\" typeof 234567890123456789012345678901234567890n // Returns bigint typeof undefined // Returns \"undefined\" typeof null // Returns \"object\" (kind of a bug in JavaScript) typeof Symbol 'symbol' // Returns Symbol 2. Non-primitive types 2. Non-primitive types Primitive data types can store only a single value. To store multiple and complex values, non-primitive data types are used.\nObject - Used to store collection of data.\nExample: Primitive data types can store only a single value. To store multiple and complex values, non-primitive data types are used. Object - Used to store collection of data. Example: // Collection of data in key-value pairs\n\nvar obj1 = {\n   x:  43,\n   y:  \"Hello world!\",\n   z: function(){\n      return this.x;\n   }\n}\n      \n// Collection of data as an ordered list\n     \nvar array1 = [5, \"Hello\", true, 4.1]; // Collection of data in key-value pairs\n\nvar obj1 = {\n   x:  43,\n   y:  \"Hello world!\",\n   z: function(){\n      return this.x;\n   }\n}\n      \n// Collection of data as an ordered list\n     \nvar array1 = [5, \"Hello\", true, 4.1]; // Collection of data in key-value pairs var x 43 y \"Hello world!\" z function() function  return this // Collection of data as an ordered list var 5 \"Hello\" true 4.1 Note- It is important to remember that any data type that is not a primitive data type, is of Object type in javascript. Note- It is important to remember that any data type that is not a primitive data type, is of Object type in javascript. Note- It is important to remember that any data type that is not a primitive data type, is of Object type in javascript.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "2. Explain Hoisting in javascript.",
        "answer": "Hoisting is the default behaviour of javascript where all the variable and function declarations are moved on top.   This means that irrespective of where the variables and functions are declared, they are moved on top of the scope. The scope can be both local and global.\n\nExample 1:   Example 1: hoistedVariable = 3;\nconsole.log(hoistedVariable); // outputs 3 even when the variable is declared after it is initialized \nvar hoistedVariable; hoistedVariable = 3;\nconsole.log(hoistedVariable); // outputs 3 even when the variable is declared after it is initialized \nvar hoistedVariable; 3 console // outputs 3 even when the variable is declared after it is initialized var Example 2: Example 2: hoistedFunction();  // Outputs \" Hello world! \" even when the function is declared after calling\n\nfunction hoistedFunction(){ \n  console.log(\" Hello world! \");\n} hoistedFunction();  // Outputs \" Hello world! \" even when the function is declared after calling\n\nfunction hoistedFunction(){ \n  console.log(\" Hello world! \");\n} // Outputs \" Hello world! \" even when the function is declared after calling function hoistedFunction() function hoistedFunction  console \" Hello world! \" Example 3: Example 3: // Hoisting takes place in the local scope as well\nfunction doSomething(){\n  x = 33;\n  console.log(x);\n  var x;\n} // Hoisting takes place in the local scope as well\nfunction doSomething(){\n  x = 33;\n  console.log(x);\n  var x;\n} // Hoisting takes place in the local scope as well function doSomething() function doSomething  33 console var doSomething(); // Outputs 33 since the local variable “x” is hoisted inside the local scope Note - Variable initializations are not hoisted, only variable declarations are hoisted: Note - Variable initializations are not hoisted, only variable declarations are hoisted: Note - Variable initializations are not hoisted, only variable declarations are hoisted: var x;\nconsole.log(x); // Outputs \"undefined\" since the initialization of \"x\" is not hoisted\nx = 23; var x;\nconsole.log(x); // Outputs \"undefined\" since the initialization of \"x\" is not hoisted\nx = 23; var console // Outputs \"undefined\" since the initialization of \"x\" is not hoisted 23 Note - To avoid hoisting, you can run javascript in strict mode by using “use strict” on top of the code: Note - To avoid hoisting, you can run javascript in strict mode by using “use strict” on top of the code: Note - To avoid hoisting, you can run javascript in strict mode by using “use strict” on top of the code: \"use strict\";\nx = 23; // Gives an error since 'x' is not declared\nvar x; \"use strict\";\nx = 23; // Gives an error since 'x' is not declared\nvar x; \"use strict\" 23 // Gives an error since 'x' is not declared var",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "3. Why do we use the word “debugger” in javascript?",
        "answer": "The debugger for the browser must be activated in order to debug the code. Built-in debuggers may be switched on and off, requiring the user to report faults. The remaining section of the code should stop execution before moving on to the next line while debugging.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "4. Difference between “ == “ and “ === “ operators.",
        "answer": "Both are comparison operators. The difference between both the operators is that “==” is used to compare values whereas, “ === “ is used to compare both values and types. Example: Example: var x = 2;\nvar y = \"2\";\n(x == y)  // Returns true since the value of both x and y is the same\n(x === y) // Returns false since the typeof x is \"number\" and typeof y is \"string\" var x = 2;\nvar y = \"2\";\n(x == y)  // Returns true since the value of both x and y is the same\n(x === y) // Returns false since the typeof x is \"number\" and typeof y is \"string\" var 2 var \"2\" // Returns true since the value of both x and y is the same // Returns false since the typeof x is \"number\" and typeof y is \"string\"",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "5. Difference between var and let keyword in javascript.",
        "answer": "Some differences are  From the very beginning, the 'var' keyword was used in JavaScript programming whereas the keyword 'let' was just added in 2015.\nThe keyword 'Var' has a function scope. Anywhere in the function, the variable specified using var is accessible but in ‘let’ the scope of a variable declared with the 'let' keyword is limited to the block in which it is declared. Let's start with a Block Scope.\nIn ECMAScript 2015, let and const are hoisted but not initialized. Referencing the variable in the block before the variable declaration results in a ReferenceError because the variable is in a \"temporal dead zone\" from the start of the block until the declaration is processed. From the very beginning, the 'var' keyword was used in JavaScript programming whereas the keyword 'let' was just added in 2015. whereas the keyword The keyword 'Var' has a function scope. Anywhere in the function, the variable specified using var is accessible but in ‘let’ the scope of a variable declared with the 'let' keyword is limited to the block in which it is declared. Let's start with a Block Scope. In ECMAScript 2015, let and const are hoisted but not initialized. Referencing the variable in the block before the variable declaration results in a ReferenceError because the variable is in a \"temporal dead zone\" from the start of the block until the declaration is processed.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "6. Explain Implicit Type Coercion in javascript.",
        "answer": "Implicit type coercion in javascript is the automatic conversion of value from one data type to another. It takes place when the operands of an expression are of different data types. String coercion String coercion String coercion String coercion takes place while using the ‘ + ‘ operator. When a number is added to a string, the number type is always converted to the string type. Example 1: var x = 3;\nvar y = \"3\";\nx + y // Returns \"33\" var x = 3;\nvar y = \"3\";\nx + y // Returns \"33\" var 3 var \"3\" // Returns \"33\" Example 2: var x = 24;\nvar y = \"Hello\";\nx + y   // Returns \"24Hello\"; var x = 24;\nvar y = \"Hello\";\nx + y   // Returns \"24Hello\"; var 24 var \"Hello\" // Returns \"24Hello\"; Note - ‘ + ‘ operator when used to add two numbers, outputs a number. The same ‘ + ‘ operator when used to add two strings, outputs the concatenated string: Note - ‘ + ‘ operator when used to add two numbers, outputs a number. The same ‘ + ‘ operator when used to add two strings, outputs the concatenated string: var name = \"Vivek\";\nvar surname = \" Bisht\";\nname + surname     // Returns \"Vivek Bisht\" var name = \"Vivek\";\nvar surname = \" Bisht\";\nname + surname     // Returns \"Vivek Bisht\" var \"Vivek\" var \" Bisht\" // Returns \"Vivek Bisht\" Let’s understand both the examples where we have added a number to a string, When JavaScript sees that the operands of the expression x + y are of different types ( one being a number type and the other being a string type ), it converts the number type to the string type and then performs the operation. Since after conversion, both the variables are of string type, the ‘ + ‘ operator outputs the concatenated string “33” in the first example and “24Hello” in the second example. Note - Type coercion also takes place when using the ‘ - ‘ operator, but the difference while using ‘ - ‘ operator is that, a string is converted to a number and then subtraction takes place. Note - Type coercion also takes place when using the ‘ - ‘ operator, but the difference while using ‘ - ‘ operator is that, a string is converted to a number and then subtraction takes place. var x = 3;\nVar y = \"3\";\nx - y    //Returns 0 since the variable y (string type) is converted to a number type var x = 3;\nVar y = \"3\";\nx - y    //Returns 0 since the variable y (string type) is converted to a number type var 3 \"3\" //Returns 0 since the variable y (string type) is converted to a number type Boolean Coercion Boolean Coercion Boolean Coercion Boolean coercion takes place when using logical operators, ternary operators, if statements, and loop checks. To understand boolean coercion in if statements and operators, we need to understand truthy and falsy values.\n\nTruthy values are those which will be converted (coerced) to true. Falsy values are those which will be converted to false.\n\nAll values except false, 0, 0n, -0, “”, null, undefined, and NaN are truthy values.   true false   false, 0, 0n, -0, “”, null, undefined, and NaN If statements: If statements: Example: var x = 0;\nvar y = 23;\n        \nif(x) { console.log(x) }   // The code inside this block will not run since the value of x is 0(Falsy)  \n        \nif(y) { console.log(y) }    // The code inside this block will run since the value of y is 23 (Truthy) var x = 0;\nvar y = 23;\n        \nif(x) { console.log(x) }   // The code inside this block will not run since the value of x is 0(Falsy)  \n        \nif(y) { console.log(y) }    // The code inside this block will run since the value of y is 23 (Truthy) var 0 var 23 if console // The code inside this block will not run since the value of x is 0(Falsy) if console // The code inside this block will run since the value of y is 23 (Truthy) Logical operators: Logical operators: Logical operators: Logical operators in javascript, unlike operators in other programming languages, do not return true or false. They always return one of the operands.\n\nOR ( | | ) operator - If the first value is truthy, then the first value is returned. Otherwise, always the second value gets returned.\n\nAND ( && ) operator - If both the values are truthy, always the second value is returned. If the first value is falsy then the first value is returned or if the second value is falsy then the second value is returned.\n\nExample: do not return true or false. They always return one of the operands.   OR ( | | ) operator   AND ( && ) operator   var x = 220;\nvar y = \"Hello\";\nvar z = undefined;\n        \nx | | y    // Returns 220 since the first value is truthy\n        \nx | | z   // Returns 220 since the first value is truthy\n        \nx && y    // Returns \"Hello\" since both the values are truthy\n        \ny && z   // Returns undefined since the second value is falsy\n        \nif( x && y ){ \n  console.log(\"Code runs\" ); // This block runs because x && y returns \"Hello\" (Truthy)\n}   \n        \nif( x || z ){\n  console.log(\"Code runs\");  // This block runs because x || y returns 220(Truthy)\n} var x = 220;\nvar y = \"Hello\";\nvar z = undefined;\n        \nx | | y    // Returns 220 since the first value is truthy\n        \nx | | z   // Returns 220 since the first value is truthy\n        \nx && y    // Returns \"Hello\" since both the values are truthy\n        \ny && z   // Returns undefined since the second value is falsy\n        \nif( x && y ){ \n  console.log(\"Code runs\" ); // This block runs because x && y returns \"Hello\" (Truthy)\n}   \n        \nif( x || z ){\n  console.log(\"Code runs\");  // This block runs because x || y returns 220(Truthy)\n} var 220 var \"Hello\" var undefined // Returns 220 since the first value is truthy // Returns 220 since the first value is truthy // Returns \"Hello\" since both the values are truthy // Returns undefined since the second value is falsy if console \"Code runs\" // This block runs because x && y returns \"Hello\" (Truthy) if console \"Code runs\" // This block runs because x || y returns 220(Truthy) Equality Coercion Equality Coercion Equality Coercion Equality coercion takes place when using ‘ == ‘ operator. As we have stated before\n\nThe ‘ == ‘ operator compares values and not types.\n\nWhile the above statement is a simple way to explain == operator, it’s not completely true\n\nThe reality is that while using the ‘==’ operator, coercion takes place.\n\nThe ‘==’ operator, converts both the operands to the same type and then compares them.\n\nExample:   The ‘ == ‘ operator compares values and not types.         var a = 12;\nvar b = \"12\";\na == b // Returns true because both 'a' and 'b' are converted to the same type and then compared. Hence the operands are equal. var a = 12;\nvar b = \"12\";\na == b // Returns true because both 'a' and 'b' are converted to the same type and then compared. Hence the operands are equal. var 12 var \"12\" // Returns true because both 'a' and 'b' are converted to the same type and then compared. Hence the operands are equal. Coercion does not take place when using the ‘===’ operator. Both operands are not converted to the same type in the case of ‘===’ operator. Example: var a = 226;\nvar b = \"226\";\n\na === b // Returns false because coercion does not take place and the  operands are of different types. Hence they are not equal. var a = 226;\nvar b = \"226\";\n\na === b // Returns false because coercion does not take place and the  operands are of different types. Hence they are not equal. var 226 var \"226\" // Returns false because coercion does not take place and the  operands are of different types. Hence they are not equal.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "7. Is javascript a statically typed or a dynamically typed language?",
        "answer": "JavaScript is a dynamically typed language. In a dynamically typed language, the type of a variable is checked during run-time in contrast to a statically typed language, where the type of a variable is checked during compile-time. run-time compile-time.   Since javascript is a loosely(dynamically) typed language, variables in JS are not associated with any type. A variable can hold the value of any data type. For example, a variable that is assigned a number type can be converted to a string type: var a = 23;\nvar a = \"Hello World!\"; var a = 23;\nvar a = \"Hello World!\"; var 23 var \"Hello World!\"",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "8. What is NaN property in JavaScript?",
        "answer": "NaN property represents the “Not-a-Number” value. It indicates a value that is not a legal number. “Not-a-Number” typeof of NaN will return a Number. typeof Number To check if a value is NaN, we use the isNaN() function, isNaN() Note- isNaN() function converts the given value to a Number type, and then equates to NaN. Note- isNaN() function converts the given value to a Number type, and then equates to NaN. isNaN(\"Hello\")  // Returns true\nisNaN(345)   // Returns false\nisNaN('1')  // Returns false, since '1' is converted to Number type which results in 0 ( a number) \nisNaN(true) // Returns false, since true converted to Number type results in 1 ( a number)\nisNaN(false) // Returns false\nisNaN(undefined) // Returns true isNaN(\"Hello\")  // Returns true\nisNaN(345)   // Returns false\nisNaN('1')  // Returns false, since '1' is converted to Number type which results in 0 ( a number) \nisNaN(true) // Returns false, since true converted to Number type results in 1 ( a number)\nisNaN(false) // Returns false\nisNaN(undefined) // Returns true isNaN \"Hello\" // Returns true isNaN 345 // Returns false isNaN '1' // Returns false, since '1' is converted to Number type which results in 0 ( a number) isNaN true // Returns false, since true converted to Number type results in 1 ( a number) isNaN false // Returns false isNaN undefined // Returns true",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "9. Explain passed by value and passed by reference.",
        "answer": "In JavaScript, primitive data types are passed by value and non-primitive data types are passed by reference.\n\nFor understanding passed by value and passed by reference, we need to understand what happens when we create a variable and assign a value to it, In JavaScript, primitive data types are passed by value and non-primitive data types are passed by reference.   var x = 2; var x = 2; var 2 In the above example, we created a variable x and assigned it a value of “2”. In the background, the “=” (assign operator) allocates some space in the memory, stores the value “2” and returns the location of the allocated memory space. Therefore, the variable x in the above code points to the location of the memory space instead of pointing to the value 2 directly. Assign operator behaves differently when dealing with primitive and non-primitive data types,\n\nAssign operator dealing with primitive types:   Assign operator dealing with primitive types:   var y = 234;\nvar z = y; var y = 234;\nvar z = y; var 234 var In the above example, the assign operator knows that the value assigned to y is a primitive type (number type in this case), so when the second line code executes, where the value of y is assigned to z, the assign operator takes the value of y (234) and allocates a new space in the memory and returns the address. Therefore, variable z is not pointing to the location of variable y, instead, it is pointing to a new location in the memory. var y = #8454; // y pointing to address of the value 234\n\nvar z = y; \n     \nvar z = #5411; // z pointing to a completely new address of the value 234\n     \n// Changing the value of y\ny = 23;\nconsole.log(z);  // Returns 234, since z points to a new address in the memory so changes in y will not effect z var y = #8454; // y pointing to address of the value 234\n\nvar z = y; \n     \nvar z = #5411; // z pointing to a completely new address of the value 234\n     \n// Changing the value of y\ny = 23;\nconsole.log(z);  // Returns 234, since z points to a new address in the memory so changes in y will not effect z var 8454 // y pointing to address of the value 234 var var 5411 // z pointing to a completely new address of the value 234 // Changing the value of y 23 console // Returns 234, since z points to a new address in the memory so changes in y will not effect z From the above example, we can see that primitive data types when passed to another variable, are passed by value. Instead of just assigning the same address to another variable, the value is passed and new space of memory is created.\n\nAssign operator dealing with non-primitive types:   Assign operator dealing with non-primitive types:   var obj = { name: \"Vivek\", surname: \"Bisht\" };\nvar obj2 = obj; var obj = { name: \"Vivek\", surname: \"Bisht\" };\nvar obj2 = obj; var name \"Vivek\" surname \"Bisht\" var In the above example, the assign operator directly passes the location of the variable obj to the variable obj2. In other words, the reference of the variable obj is passed to the variable obj2. var obj = #8711;  // obj pointing to address of { name: \"Vivek\", surname: \"Bisht\" }\nvar obj2 = obj;\n    \nvar obj2 = #8711; // obj2 pointing to the same address \n\n// changing the value of obj1\n        \nobj.name = \"Akki\";\nconsole.log(obj2);\n        \n// Returns {name:\"Akki\", surname:\"Bisht\"} since both the variables are pointing to the same address. var obj = #8711;  // obj pointing to address of { name: \"Vivek\", surname: \"Bisht\" }\nvar obj2 = obj;\n    \nvar obj2 = #8711; // obj2 pointing to the same address \n\n// changing the value of obj1\n        \nobj.name = \"Akki\";\nconsole.log(obj2);\n        \n// Returns {name:\"Akki\", surname:\"Bisht\"} since both the variables are pointing to the same address. var 8711 // obj pointing to address of { name: \"Vivek\", surname: \"Bisht\" } var var 8711 // obj2 pointing to the same address // changing the value of obj1 \"Akki\" console // Returns {name:\"Akki\", surname:\"Bisht\"} since both the variables are pointing to the same address. From the above example, we can see that while passing non-primitive data types, the assigned operator directly passes the address (reference).\n\nTherefore, non-primitive data types are always passed by reference.   passed by reference.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "10. What is an Immediately Invoked Function in JavaScript?",
        "answer": "An Immediately Invoked Function ( known as IIFE and pronounced as IIFY) is a function that runs as soon as it is defined. An Immediately Invoked Function ( known as IIFE and pronounced as IIFY) is a function that runs as soon as it is defined. Syntax of IIFE : (function(){ \n  // Do something;\n})(); (function(){ \n  // Do something;\n})(); function() function  // Do something; To understand IIFE, we need to understand the two sets of parentheses that are added while creating an IIFE :\n\nThe first set of parenthesis:   (function (){\n   //Do something;\n}) (function (){\n   //Do something;\n}) function () function  //Do something; While executing javascript code, whenever the compiler sees the word “function”, it assumes that we are declaring a function in the code. Therefore, if we do not use the first set of parentheses, the compiler throws an error because it thinks we are declaring a function, and by the syntax of declaring a function, a function should always have a name. function() {\n  //Do something;\n}\n// Compiler gives an error since the syntax of declaring a function is wrong in the code above. function() {\n  //Do something;\n}\n// Compiler gives an error since the syntax of declaring a function is wrong in the code above. function() function  //Do something; // Compiler gives an error since the syntax of declaring a function is wrong in the code above. To remove this error, we add the first set of parenthesis that tells the compiler that the function is not a function declaration, instead, it’s a function expression.\n\nThe second set of parenthesis:   (function (){\n  //Do something;\n})(); (function (){\n  //Do something;\n})(); function () function  //Do something; From the definition of an IIFE, we know that our code should run as soon as it is defined. A function runs only when it is invoked. If we do not invoke the function, the function declaration is returned: (function (){\n  // Do something;\n})\n\n// Returns the function declaration (function (){\n  // Do something;\n})\n\n// Returns the function declaration function () function  // Do something; // Returns the function declaration Therefore to invoke the function, we use the second set of parenthesis. Therefore to invoke the function, we use the second set of parenthesis.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "11. What do you mean by strict mode in javascript and characteristics of javascript strict-mode?",
        "answer": "In ECMAScript 5, a new feature called JavaScript Strict Mode allows you to write a code or a function in a \"strict\" operational environment. In most cases, this language is 'not particularly severe' when it comes to throwing errors. In 'Strict mode,' however, all forms of errors, including silent errors, will be thrown. As a result, debugging becomes a lot simpler.  Thus programmer's chances of making an error are lowered. Characteristics of strict mode in javascript Duplicate arguments are not allowed by developers.\nIn strict mode, you won't be able to use the JavaScript keyword as a parameter or function name.\nThe 'use strict' keyword is used to define strict mode at the start of the script. Strict mode is supported by all browsers.\nEngineers will not be allowed to create global variables in 'Strict Mode. Duplicate arguments are not allowed by developers. In strict mode, you won't be able to use the JavaScript keyword as a parameter or function name. The 'use strict' keyword is used to define strict mode at the start of the script. Strict mode is supported by all browsers. Engineers will not be allowed to create global variables in 'Strict Mode.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "12. Explain Higher Order Functions in javascript.",
        "answer": "Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.\n\nHigher-order functions are a result of functions being first-class citizens in javascript. Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.   first-class citizens Examples of higher-order functions: function higherOrder(fn) {\n  fn();\n}\n   \nhigherOrder(function() { console.log(\"Hello world\") }); function higherOrder(fn) {\n  fn();\n}\n   \nhigherOrder(function() { console.log(\"Hello world\") }); function higherOrder(fn) function higherOrder fn function() function  console \"Hello world\" function higherOrder2() {\n  return function() {\n    return \"Do something\";\n  }\n}      \nvar x = higherOrder2();\nx()   // Returns \"Do something\" function higherOrder2() {\n  return function() {\n    return \"Do something\";\n  }\n}      \nvar x = higherOrder2();\nx()   // Returns \"Do something\" function higherOrder2() function higherOrder2  return function() function  return \"Do something\" var // Returns \"Do something\"",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "13. Explain “this” keyword.",
        "answer": "The “this” keyword refers to the object that the function is a property of.\n\nThe value of the “this” keyword will always depend on the object that is invoking the function.\\ The “this” keyword refers to the object that the function is a property of.   The value of the “this” keyword will always depend on the object that is invoking the function.\\ Confused? Let’s understand the above statements by examples: function doSomething() {\n  console.log(this);\n}\n   \ndoSomething(); function doSomething() {\n  console.log(this);\n}\n   \ndoSomething(); function doSomething() function doSomething  console this What do you think the output of the above code will be? Note - Observe the line where we are invoking the function. Note - Observe the line where we are invoking the function. Check the definition again: The “this” keyword refers to the object that the function is a property of. The “this” keyword refers to the object that the function is a property of. The “this” keyword refers to the object that the function is a property of. In the above code, the function is a property of which object? Since the function is invoked in the global context, the function is a property of the global object. the function is a property of the global object. Therefore, the output of the above code will be the global object. Since we ran the above code inside the browser, the global object is the window object. the global object. the window object. Example 2: var obj = {\n    name:  \"vivek\",\n    getName: function(){\n    console.log(this.name);\n  }\n}\n   \nobj.getName(); var obj = {\n    name:  \"vivek\",\n    getName: function(){\n    console.log(this.name);\n  }\n}\n   \nobj.getName(); var name \"vivek\" getName function() function  console this In the above code, at the time of invocation, the getName function is a property of the object obj , therefore, this keyword will refer to the object obj, and hence the output will be “vivek”. obj this obj Example 3: var obj = {\n    name:  \"vivek\",\n    getName: function(){\n    console.log(this.name);\n  }\n     \n}\n       \nvar getName = obj.getName;\n       \nvar obj2 = {name:\"akshay\", getName };\nobj2.getName(); var obj = {\n    name:  \"vivek\",\n    getName: function(){\n    console.log(this.name);\n  }\n     \n}\n       \nvar getName = obj.getName;\n       \nvar obj2 = {name:\"akshay\", getName };\nobj2.getName(); var name \"vivek\" getName function() function  console this var var name \"akshay\" Can you guess the output here? The output will be “akshay”. Although the getName function is declared inside the object obj, at the time of invocation, getName() is a property of obj2, therefore the “this” keyword will refer to obj2. obj obj2 obj2 The silly way to understand the “this” keyword is, whenever the function is invoked, check the object before the dot. The value of this . keyword will always be the object before the dot. this” dot this dot If there is no object before the dot-like in example1, the value of this keyword will be the global object. Example 4: var obj1 = {\n    address : \"Mumbai,India\",\n    getAddress: function(){\n    console.log(this.address); \n  }\n}\n   \nvar getAddress = obj1.getAddress;\nvar obj2 = {name:\"akshay\"};\nobj2.getAddress(); var obj1 = {\n    address : \"Mumbai,India\",\n    getAddress: function(){\n    console.log(this.address); \n  }\n}\n   \nvar getAddress = obj1.getAddress;\nvar obj2 = {name:\"akshay\"};\nobj2.getAddress(); var address \"Mumbai,India\" getAddress function() function  console this var var name \"akshay\" Can you guess the output? The output will be an error. The output will be an error. Although in the code above, this keyword refers to the object obj2, obj2 does not have the property “address”‘, hence the getAddress function throws an error. obj2",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "14. What do you mean by Self Invoking Functions?",
        "answer": "Without being requested, a self-invoking expression is automatically invoked (initiated). If a function expression is followed by (), it will execute automatically. A function declaration cannot be invoked by itself. Normally, we declare a function and call it, however, anonymous functions may be used to run a function automatically when it is described and will not be called again. And there is no name for these kinds of functions.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "15. Explain call(), apply() and, bind() methods.",
        "answer": "1. call(): 1. call(): It’s a predefined method in javascript.\nThis method invokes a method (function) by specifying the owner object.\nExample 1: It’s a predefined method in javascript. This method invokes a method (function) by specifying the owner object. Example 1: function sayHello(){\n  return \"Hello \" + this.name;\n}\n        \nvar obj = {name: \"Sandy\"};\n        \nsayHello.call(obj);\n        \n// Returns \"Hello Sandy\" function sayHello(){\n  return \"Hello \" + this.name;\n}\n        \nvar obj = {name: \"Sandy\"};\n        \nsayHello.call(obj);\n        \n// Returns \"Hello Sandy\" function sayHello() function sayHello  return \"Hello \" this var name \"Sandy\" // Returns \"Hello Sandy\" call() method allows an object to use the method (function) of another object.\nExample 2: call() method allows an object to use the method (function) of another object. Example 2: var person = {\n  age: 23,\n  getAge: function(){\n    return this.age;\n  }\n}        \nvar person2 = {age:  54};\nperson.getAge.call(person2);      \n// Returns 54 var person = {\n  age: 23,\n  getAge: function(){\n    return this.age;\n  }\n}        \nvar person2 = {age:  54};\nperson.getAge.call(person2);      \n// Returns 54 var age 23 getAge function() function  return this var age 54 // Returns 54 call() accepts arguments: call() accepts arguments: function saySomething(message){\n  return this.name + \" is \" + message;\n}     \nvar person4 = {name:  \"John\"};     \nsaySomething.call(person4, \"awesome\");\n// Returns \"John is awesome\" function saySomething(message){\n  return this.name + \" is \" + message;\n}     \nvar person4 = {name:  \"John\"};     \nsaySomething.call(person4, \"awesome\");\n// Returns \"John is awesome\" function saySomething(message) function saySomething message return this \" is \" var name \"John\" \"awesome\" // Returns \"John is awesome\" apply()\n\nThe apply method is similar to the call() method. The only difference is that,\n\ncall() method takes arguments separately whereas, apply() method takes arguments as an array. apply()     call() method takes arguments separately whereas, apply() method takes arguments as an array. function saySomething(message){\n  return this.name + \" is \" + message;\n}        \nvar person4 = {name:  \"John\"};\nsaySomething.apply(person4, [\"awesome\"]); function saySomething(message){\n  return this.name + \" is \" + message;\n}        \nvar person4 = {name:  \"John\"};\nsaySomething.apply(person4, [\"awesome\"]); function saySomething(message) function saySomething message return this \" is \" var name \"John\" \"awesome\" 2. bind(): 2. bind(): This method returns a new function, where the value of “this” keyword will be bound to the owner object, which is provided as a parameter.\nExample with arguments: This method returns a new function, where the value of “this” keyword will be bound to the owner object, which is provided as a parameter. “this” Example with arguments: var bikeDetails = {\n    displayDetails: function(registrationNumber,brandName){\n    return this.name+ \" , \"+ \"bike details: \"+ registrationNumber + \" , \" + brandName;\n  }\n}\n   \nvar person1 = {name:  \"Vivek\"};\n     \nvar detailsOfPerson1 = bikeDetails.displayDetails.bind(person1, \"TS0122\", \"Bullet\");\n      \n// Binds the displayDetails function to the person1 object\n        \n      \ndetailsOfPerson1();\n//Returns Vivek, bike details: TS0122, Bullet var bikeDetails = {\n    displayDetails: function(registrationNumber,brandName){\n    return this.name+ \" , \"+ \"bike details: \"+ registrationNumber + \" , \" + brandName;\n  }\n}\n   \nvar person1 = {name:  \"Vivek\"};\n     \nvar detailsOfPerson1 = bikeDetails.displayDetails.bind(person1, \"TS0122\", \"Bullet\");\n      \n// Binds the displayDetails function to the person1 object\n        \n      \ndetailsOfPerson1();\n//Returns Vivek, bike details: TS0122, Bullet var displayDetails function(registrationNumber,brandName) function registrationNumber,brandName return this \" , \" \"bike details: \" \" , \" var name \"Vivek\" var \"TS0122\" \"Bullet\" // Binds the displayDetails function to the person1 object //Returns Vivek, bike details: TS0122, Bullet",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "16. What is the difference between exec () and test () methods in javascript?",
        "answer": "test () and exec () are RegExp expression methods used in javascript. \nWe'll use exec () to search a string for a specific pattern, and if it finds it, it'll return the pattern directly; else, it'll return an 'empty' result.\nWe will use a test () to find a string for a specific pattern. It will return the Boolean value 'true' on finding the given text otherwise, it will return 'false'. test () and exec () are RegExp expression methods used in javascript. test () exec () We'll use exec () to search a string for a specific pattern, and if it finds it, it'll return the pattern directly; else, it'll return an 'empty' result. exec () We will use a test () to find a string for a specific pattern. It will return the Boolean value 'true' on finding the given text otherwise, it will return 'false'. test ()",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "17. What is currying in JavaScript?",
        "answer": "Currying is an advanced technique to transform a function of arguments n, to n functions of one or fewer arguments. Currying is an advanced technique to transform a function of arguments n, to n functions of one or fewer arguments. Example of a curried function: function add (a) {\n  return function(b){\n    return a + b;\n  }\n}\n\nadd(3)(4) function add (a) {\n  return function(b){\n    return a + b;\n  }\n}\n\nadd(3)(4) function add (a) function add a return function(b) function b return 3 4 For Example, if we have a function f(a,b), then the function after currying, will be transformed to f(a)(b).\n\nBy using the currying technique, we do not change the functionality of a function, we just change the way it is invoked.\n\nLet’s see currying in action: f(a,b) f(a)(b).     function multiply(a,b){\n  return a*b;\n}\n\nfunction currying(fn){\n  return function(a){\n    return function(b){\n      return fn(a,b);\n    }\n  }\n}\n\nvar curriedMultiply = currying(multiply);\n\nmultiply(4, 3); // Returns 12\n\ncurriedMultiply(4)(3); // Also returns 12 function multiply(a,b){\n  return a*b;\n}\n\nfunction currying(fn){\n  return function(a){\n    return function(b){\n      return fn(a,b);\n    }\n  }\n}\n\nvar curriedMultiply = currying(multiply);\n\nmultiply(4, 3); // Returns 12\n\ncurriedMultiply(4)(3); // Also returns 12 function multiply(a,b) function multiply a,b return function currying(fn) function currying fn return function(a) function a return function(b) function b return var 4 3 // Returns 12 4 3 // Also returns 12 As one can see in the code above, we have transformed the function multiply(a,b) to a function curriedMultiply , which takes in one parameter at a time. multiply(a,b) curriedMultiply",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "18. What are some advantages of using External JavaScript?",
        "answer": "External JavaScript is the JavaScript Code (script) written in a separate file with the extension.js, and then we link that file inside the <head> or <body> element of the HTML file where the code is to be placed.  Some advantages of external javascript are It allows web designers and developers to collaborate on HTML and javascript files.\nWe can reuse the code.\nCode readability is simple in external javascript. It allows web designers and developers to collaborate on HTML and javascript files. We can reuse the code. Code readability is simple in external javascript.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "19. Explain Scope and Scope Chain in javascript.",
        "answer": "Scope in JS determines the accessibility of variables and functions at various parts of one’s code.\n\nIn general terms, the scope will let us know at a given part of code, what are variables and functions we can or cannot access.\n\nThere are three types of scopes in JS:     Global Scope\nLocal or Function Scope\nBlock Scope Global Scope Local or Function Scope Block Scope Global Scope: Variables or functions declared in the global namespace have global scope, which means all the variables and functions having global scope can be accessed from anywhere inside the code. Global Scope: var globalVariable = \"Hello world\";\n\nfunction sendMessage(){\n  return globalVariable; // can access globalVariable since it's written in global space\n}\nfunction sendMessage2(){\n  return sendMessage(); // Can access sendMessage function since it's written in global space\n}\nsendMessage2();  // Returns “Hello world” var globalVariable = \"Hello world\";\n\nfunction sendMessage(){\n  return globalVariable; // can access globalVariable since it's written in global space\n}\nfunction sendMessage2(){\n  return sendMessage(); // Can access sendMessage function since it's written in global space\n}\nsendMessage2();  // Returns “Hello world” var \"Hello world\" function sendMessage() function sendMessage  return // can access globalVariable since it's written in global space function sendMessage2() function sendMessage2  return // Can access sendMessage function since it's written in global space // Returns “Hello world” Function Scope: Any variables or functions declared inside a function have local/function scope, which means that all the variables and functions declared inside a function, can be accessed from within the function and not outside of it. Function Scope: function awesomeFunction(){\n  var a = 2;\n\n  var multiplyBy2 = function(){\n    console.log(a*2); // Can access variable \"a\" since a and multiplyBy2 both are written inside the same function\n  }\n}\nconsole.log(a); // Throws reference error since a is written in local scope and cannot be accessed outside\n\nmultiplyBy2(); // Throws reference error since multiplyBy2 is written in local scope function awesomeFunction(){\n  var a = 2;\n\n  var multiplyBy2 = function(){\n    console.log(a*2); // Can access variable \"a\" since a and multiplyBy2 both are written inside the same function\n  }\n}\nconsole.log(a); // Throws reference error since a is written in local scope and cannot be accessed outside\n\nmultiplyBy2(); // Throws reference error since multiplyBy2 is written in local scope function awesomeFunction() function awesomeFunction  var 2 var function() function  console 2 // Can access variable \"a\" since a and multiplyBy2 both are written inside the same function console // Throws reference error since a is written in local scope and cannot be accessed outside // Throws reference error since multiplyBy2 is written in local scope Block Scope: Block scope is related to the variables declared using let and const. Variables declared with var do not have block scope. Block scope tells us that any variable declared inside a block { }, can be accessed only inside that block and cannot be accessed outside of it. Block Scope: {\n  let x = 45;\n}\n\nconsole.log(x); // Gives reference error since x cannot be accessed outside of the block\n\nfor(let i=0; i<2; i++){\n  // do something\n}\n\nconsole.log(i); // Gives reference error since i cannot be accessed outside of the for loop block {\n  let x = 45;\n}\n\nconsole.log(x); // Gives reference error since x cannot be accessed outside of the block\n\nfor(let i=0; i<2; i++){\n  // do something\n}\n\nconsole.log(i); // Gives reference error since i cannot be accessed outside of the for loop block let 45 console // Gives reference error since x cannot be accessed outside of the block for let 0 2 // do something console // Gives reference error since i cannot be accessed outside of the for loop block Scope Chain: JavaScript engine also uses Scope to find variables. Let’s understand that using an example: Scope Chain: var y = 24;\n\nfunction favFunction(){\n  var x = 667;\n  var anotherFavFunction = function(){\n    console.log(x); // Does not find x inside anotherFavFunction, so looks for variable inside favFunction, outputs 667\n  }\n\n  var yetAnotherFavFunction = function(){\n    console.log(y); // Does not find y inside yetAnotherFavFunction, so looks for variable inside favFunction and does not find it, so looks for variable in global scope, finds it and outputs 24\n  }\n\n  anotherFavFunction();\n  yetAnotherFavFunction();\n}\nfavFunction(); var y = 24;\n\nfunction favFunction(){\n  var x = 667;\n  var anotherFavFunction = function(){\n    console.log(x); // Does not find x inside anotherFavFunction, so looks for variable inside favFunction, outputs 667\n  }\n\n  var yetAnotherFavFunction = function(){\n    console.log(y); // Does not find y inside yetAnotherFavFunction, so looks for variable inside favFunction and does not find it, so looks for variable in global scope, finds it and outputs 24\n  }\n\n  anotherFavFunction();\n  yetAnotherFavFunction();\n}\nfavFunction(); var 24 function favFunction() function favFunction  var 667 var function() function  console // Does not find x inside anotherFavFunction, so looks for variable inside favFunction, outputs 667 var function() function  console // Does not find y inside yetAnotherFavFunction, so looks for variable inside favFunction and does not find it, so looks for variable in global scope, finds it and outputs 24 As you can see in the code above, if the javascript engine does not find the variable in local scope, it tries to check for the variable in the outer scope. If the variable does not exist in the outer scope, it tries to find the variable in the global scope. As you can see in the code above, if the javascript engine does not find the variable in local scope, it tries to check for the variable in the outer scope. If the variable does not exist in the outer scope, it tries to find the variable in the global scope. If the variable is not found in the global space as well, a reference error is thrown.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "20. Explain Closures in JavaScript.",
        "answer": "Closures are an ability of a function to remember the variables and functions that are declared in its outer scope. var Person = function(pName){\n  var name = pName;\n\n  this.getName = function(){\n    return name;\n  }\n}\n\nvar person = new Person(\"Neelesh\");\nconsole.log(person.getName()); var Person = function(pName){\n  var name = pName;\n\n  this.getName = function(){\n    return name;\n  }\n}\n\nvar person = new Person(\"Neelesh\");\nconsole.log(person.getName()); var function(pName) function pName var this function() function  return var new \"Neelesh\" console Let’s understand closures by example: function randomFunc(){\n  var obj1 = {name:\"Vivian\", age:45};\n\n  return function(){\n    console.log(obj1.name + \" is \"+ \"awesome\"); // Has access to obj1 even when the randomFunc function is executed\n\n  }\n}\n\nvar initialiseClosure = randomFunc(); // Returns a function\n\ninitialiseClosure(); function randomFunc(){\n  var obj1 = {name:\"Vivian\", age:45};\n\n  return function(){\n    console.log(obj1.name + \" is \"+ \"awesome\"); // Has access to obj1 even when the randomFunc function is executed\n\n  }\n}\n\nvar initialiseClosure = randomFunc(); // Returns a function\n\ninitialiseClosure(); function randomFunc() function randomFunc  var name \"Vivian\" age 45 return function() function  console \" is \" \"awesome\" // Has access to obj1 even when the randomFunc function is executed var // Returns a function Let’s understand the code above,\n\nThe function randomFunc() gets executed and returns a function when we assign it to a variable:   var initialiseClosure = randomFunc(); var initialiseClosure = randomFunc(); var The returned function is then executed when we invoke initialiseClosure: initialiseClosure(); initialiseClosure(); The line of code above outputs “Vivian is awesome” and this is possible because of closure. console.log(obj1.name + \" is \"+ \"awesome\"); console.log(obj1.name + \" is \"+ \"awesome\"); console \" is \" \"awesome\" When the function randomFunc() runs, it seems that the returning function is using the variable obj1 inside it: Therefore randomFunc(), instead of destroying the value of obj1 after execution, saves the value in the memory for further reference. This is the reason why the returning function is able to use the variable declared in the outer scope even after the function is already executed.\n\nThis ability of a function to store a variable for further reference even after it is executed is called Closure. saves the value in the memory for further reference.   This ability of a function to store a variable for further reference even after it is executed is called Closure.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "21. Mention some advantages of javascript.",
        "answer": "There are many advantages of javascript. Some of them are Javascript is executed on the client-side as well as server-side also. There are a variety of Frontend Frameworks that you may study and utilize. However, if you want to use JavaScript on the backend, you'll need to learn NodeJS. It is currently the only JavaScript framework that may be used on the backend.\nJavascript is a simple language to learn.\nWeb pages now have more functionality because of Javascript.\nTo the end-user, Javascript is quite quick. Javascript is executed on the client-side as well as server-side also. There are a variety of Frontend Frameworks that you may study and utilize. However, if you want to use JavaScript on the backend, you'll need to learn NodeJS. It is currently the only JavaScript framework that may be used on the backend. Javascript is a simple language to learn. Web pages now have more functionality because of Javascript. To the end-user, Javascript is quite quick.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "22. What are object prototypes?",
        "answer": "All javascript objects inherit properties from a prototype. For example, Date objects inherit properties from the Date prototype\nMath objects inherit properties from the Math prototype\nArray objects inherit properties from the Array prototype.\nOn top of the chain is Object.prototype. Every prototype inherits properties and methods from the Object.prototype.\nA prototype is a blueprint of an object. The prototype allows us to use properties and methods on an object even if the properties and methods do not exist on the current object. Date objects inherit properties from the Date prototype Math objects inherit properties from the Math prototype Array objects inherit properties from the Array prototype. On top of the chain is Object.prototype. Every prototype inherits properties and methods from the Object.prototype. Object.prototype. A prototype is a blueprint of an object. The prototype allows us to use properties and methods on an object even if the properties and methods do not exist on the current object. A prototype is a blueprint of an object. The prototype Let’s see prototypes help us use methods and properties:   var arr = [];\narr.push(2);\n\nconsole.log(arr); // Outputs [2] var arr = [];\narr.push(2);\n\nconsole.log(arr); // Outputs [2] var 2 console // Outputs [2] In the code above, as one can see, we have not defined any property or method called push on the array “arr” but the javascript engine does not throw an error. The reason is the use of prototypes. As we discussed before, Array objects inherit properties from the Array prototype. The javascript engine sees that the method push does not exist on the current array object and therefore, looks for the method push inside the Array prototype and it finds the method. Whenever the property or method is not found on the current object, the javascript engine will always try to look in its prototype and if it still does not exist, it looks inside the prototype's prototype and so on.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "23. What are callbacks?",
        "answer": "A callback is a function that will be executed after another function gets executed. In javascript, functions are treated as first-class citizens, they can be used as an argument of another function, can be returned by another function, and can be used as a property of an object. Functions that are used as an argument to another function are called callback functions. Example: Functions that are used as an argument to another function are called callback functions. function divideByHalf(sum){\n  console.log(Math.floor(sum / 2));\n}\n\nfunction multiplyBy2(sum){\n  console.log(sum * 2);\n}\n\nfunction operationOnSum(num1,num2,operation){\n  var sum = num1 + num2;\n  operation(sum);\n}\n\noperationOnSum(3, 3, divideByHalf); // Outputs 3\n\noperationOnSum(5, 5, multiplyBy2); // Outputs 20 function divideByHalf(sum){\n  console.log(Math.floor(sum / 2));\n}\n\nfunction multiplyBy2(sum){\n  console.log(sum * 2);\n}\n\nfunction operationOnSum(num1,num2,operation){\n  var sum = num1 + num2;\n  operation(sum);\n}\n\noperationOnSum(3, 3, divideByHalf); // Outputs 3\n\noperationOnSum(5, 5, multiplyBy2); // Outputs 20 function divideByHalf(sum) function divideByHalf sum console Math 2 function multiplyBy2(sum) function multiplyBy2 sum console 2 function operationOnSum(num1,num2,operation) function operationOnSum num1,num2,operation var 3 3 // Outputs 3 5 5 // Outputs 20 In the code above, we are performing mathematical operations on the sum of two numbers. The operationOnSum function takes 3 arguments, the first number, the second number, and the operation that is to be performed on their sum (callback).\nBoth divideByHalf and multiplyBy2 functions are used as callback functions in the code above.\nThese callback functions will be executed only after the function operationOnSum is executed.\nTherefore, a callback is a function that will be executed after another function gets executed. In the code above, we are performing mathematical operations on the sum of two numbers. The operationOnSum function takes 3 arguments, the first number, the second number, and the operation that is to be performed on their sum (callback). Both divideByHalf and multiplyBy2 functions are used as callback functions in the code above. These callback functions will be executed only after the function operationOnSum is executed. Therefore, a callback is a function that will be executed after another function gets executed.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "24. What are the types of errors in javascript?",
        "answer": "There are two types of errors in javascript. Syntax error: Syntax errors are mistakes or spelling problems in the code that cause the program to not execute at all or to stop running halfway through. Error messages are usually supplied as well.\nLogical error: Reasoning mistakes occur when the syntax is proper but the logic or program is incorrect. The application executes without problems in this case. However, the output findings are inaccurate. These are sometimes more difficult to correct than syntax issues since these applications do not display error signals for logic faults. Syntax error: Syntax errors are mistakes or spelling problems in the code that cause the program to not execute at all or to stop running halfway through. Error messages are usually supplied as well. Syntax error Logical error: Reasoning mistakes occur when the syntax is proper but the logic or program is incorrect. The application executes without problems in this case. However, the output findings are inaccurate. These are sometimes more difficult to correct than syntax issues since these applications do not display error signals for logic faults. Logical error",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "25. What is memoization?",
        "answer": "Memoization is a form of caching where the return value of a function is cached based on its parameters. If the parameter of that function is not changed, the cached version of the function is returned.\nLet’s understand memoization, by converting a simple function to a memoized function:  Note- Memoization is used for expensive function calls but in the following example, we are considering a simple function for understanding the concept of memoization better. Note- Memoization is used for expensive function calls but in the following example, we are considering a simple function for understanding the concept of memoization better. Consider the following function: function addTo256(num){\n  return num + 256;\n}\naddTo256(20); // Returns 276\naddTo256(40); // Returns 296\naddTo256(20); // Returns 276 function addTo256(num){\n  return num + 256;\n}\naddTo256(20); // Returns 276\naddTo256(40); // Returns 296\naddTo256(20); // Returns 276 function addTo256(num) function addTo256 num return 256 20 // Returns 276 40 // Returns 296 20 // Returns 276 In the code above, we have written a function that adds the parameter to 256 and returns it.\n\nWhen we are calling the function addTo256 again with the same parameter (“20” in the case above), we are computing the result again for the same parameter.\n\nComputing the result with the same parameter, again and again, is not a big deal in the above case, but imagine if the function does some heavy-duty work, then, computing the result again and again with the same parameter will lead to wastage of time.     This is where memoization comes in, by using memoization we can store(cache) the computed results based on the parameters. If the same parameter is used again while invoking the function, instead of computing the result, we directly return the stored (cached) value. Let’s convert the above function addTo256, to a memoized function: function memoizedAddTo256(){\n  var cache = {};\n\n  return function(num){\n    if(num in cache){\n      console.log(\"cached value\");\n      return cache[num]\n    }\n    else{\n      cache[num] = num + 256;\n      return cache[num];\n    }\n  }\n}\nvar memoizedFunc = memoizedAddTo256();\n\nmemoizedFunc(20); // Normal return\nmemoizedFunc(20); // Cached return function memoizedAddTo256(){\n  var cache = {};\n\n  return function(num){\n    if(num in cache){\n      console.log(\"cached value\");\n      return cache[num]\n    }\n    else{\n      cache[num] = num + 256;\n      return cache[num];\n    }\n  }\n}\nvar memoizedFunc = memoizedAddTo256();\n\nmemoizedFunc(20); // Normal return\nmemoizedFunc(20); // Cached return function memoizedAddTo256() function memoizedAddTo256  var return function(num) function num if in console \"cached value\" return else 256 return var 20 // Normal return 20 // Cached return In the code above, if we run the memoizedFunc function with the same parameter, instead of computing the result again, it returns the cached result. Note- Although using memoization saves time, it results in larger consumption of memory since we are storing all the computed results. Note- Although using memoization saves time, it results in larger consumption of memory since we are storing all the computed results.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "26. What is recursion in a programming language?",
        "answer": "Recursion is a technique to iterate over an operation by having a function call itself repeatedly until it arrives at a result. function add(number) {\n  if (number <= 0) {\n    return 0;\n  } else {\n    return number + add(number - 1);\n  }\n}\nadd(3) => 3 + add(2)\n          3 + 2 + add(1)\n          3 + 2 + 1 + add(0)\n          3 + 2 + 1 + 0 = 6 function add(number) {\n  if (number <= 0) {\n    return 0;\n  } else {\n    return number + add(number - 1);\n  }\n}\nadd(3) => 3 + add(2)\n          3 + 2 + add(1)\n          3 + 2 + 1 + add(0)\n          3 + 2 + 1 + 0 = 6 Example of a recursive function:\n\nThe following function calculates the sum of all the elements in an array by using recursion:   function computeSum(arr){\n  if(arr.length === 1){\n    return arr[0];\n  }\n  else{\n    return arr.pop() + computeSum(arr);\n  }\n}\ncomputeSum([7, 8, 9, 99]); // Returns 123 function computeSum(arr){\n  if(arr.length === 1){\n    return arr[0];\n  }\n  else{\n    return arr.pop() + computeSum(arr);\n  }\n}\ncomputeSum([7, 8, 9, 99]); // Returns 123",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "27. What is the use of a constructor function in javascript?",
        "answer": "Constructor functions are used to create objects in javascript. When do we use constructor functions? If we want to create multiple objects having similar properties and methods, constructor functions are used. Note- The name of a constructor function should always be written in Pascal Notation: every word should start with a capital letter. Note- The name of a constructor function should always be written in Pascal Notation: every word should start with a capital letter. Note- The name of a constructor function should always be written in Pascal Notation: every word should start with a capital letter. Example: function Person(name,age,gender){\n  this.name = name;\n  this.age = age;\n  this.gender = gender;\n}\n\n\nvar person1 = new Person(\"Vivek\", 76, \"male\");\nconsole.log(person1);\n\nvar person2 = new Person(\"Courtney\", 34, \"female\");\nconsole.log(person2); function Person(name,age,gender){\n  this.name = name;\n  this.age = age;\n  this.gender = gender;\n}\n\n\nvar person1 = new Person(\"Vivek\", 76, \"male\");\nconsole.log(person1);\n\nvar person2 = new Person(\"Courtney\", 34, \"female\");\nconsole.log(person2); function Person(name,age,gender) function Person name,age,gender this this this var new \"Vivek\" 76 \"male\" console var new \"Courtney\" 34 \"female\" console In the code above, we have created a constructor function named Person. Whenever we want to create a new object of the type Person, We need to create it using the new keyword: var person3 = new Person(\"Lilly\", 17, \"female\"); var person3 = new Person(\"Lilly\", 17, \"female\"); var new \"Lilly\" 17 \"female\" The above line of code will create a new object of the type Person. Constructor functions allow us to group similar objects.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "28. What is DOM?",
        "answer": "DOM stands for Document Object Model.  DOM is a programming interface for HTML and XML documents.\nWhen the browser tries to render an HTML document, it creates an object based on the HTML document called DOM. Using this DOM, we can manipulate or change various elements inside the HTML document.\nExample of how HTML code gets converted to DOM: DOM stands for Document Object Model.  DOM is a programming interface for HTML and XML documents. When the browser tries to render an HTML document, it creates an object based on the HTML document called DOM. Using this DOM, we can manipulate or change various elements inside the HTML document. Example of how HTML code gets converted to DOM:  ",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "29. Which method is used to retrieve a character from a certain index?",
        "answer": "The charAt() function of the JavaScript string finds a char element at the supplied index. The index number begins at 0 and continues up to n-1, Here n is the string length. The index value must be positive, higher than, or the same as the string length.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "30. What do you mean by BOM?",
        "answer": "Browser Object Model is known as BOM. It allows users to interact with the browser. A browser's initial object is a window. As a result, you may call all of the window's functions directly or by referencing the window. The document, history, screen, navigator, location, and other attributes are available in the window object.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "31. What is the distinction between client-side and server-side JavaScript?",
        "answer": "Client-side JavaScript is made up of two parts, a fundamental language and predefined objects for performing JavaScript in a browser. JavaScript for the client is automatically included in the HTML pages. At runtime, the browser understands this script.   Server-side JavaScript, involves the execution of JavaScript code on a server in response to client requests. It handles these requests and delivers the relevant response to the client, which may include client-side JavaScript for subsequent execution within the browser.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "1. What are arrow functions?",
        "answer": "Arrow functions were introduced in the ES6 version of javascript. They provide us with a new and shorter syntax for declaring functions. Arrow functions can only be used as a function expression.\n\nLet’s compare the normal function declaration and the arrow function declaration in detail:   // Traditional Function Expression\nvar add = function(a,b){\n  return a + b;\n}\n\n// Arrow Function Expression\nvar arrowAdd = (a,b) => a + b; // Traditional Function Expression\nvar add = function(a,b){\n  return a + b;\n}\n\n// Arrow Function Expression\nvar arrowAdd = (a,b) => a + b; // Traditional Function Expression var function(a,b) function a,b return // Arrow Function Expression var (a,b) => a,b Arrow functions are declared without the function keyword. If there is only one returning expression then we don’t need to use the return keyword as well in an arrow function as shown in the example above. Also, for functions having just one line of code, curly braces { } can be omitted. // Traditional function expression\nvar multiplyBy2 = function(num){\n  return num * 2;\n}\n// Arrow function expression\nvar arrowMultiplyBy2 = num => num * 2; // Traditional function expression\nvar multiplyBy2 = function(num){\n  return num * 2;\n}\n// Arrow function expression\nvar arrowMultiplyBy2 = num => num * 2; // Traditional function expression var function(num) function num return 2 // Arrow function expression var num => num 2 If the function takes in only one argument, then the parenthesis () around the parameter can be omitted as shown in the code above. var obj1 = {\n  valueOfThis: function(){\n    return this;\n  }\n}\nvar obj2 = {\n  valueOfThis: ()=>{\n    return this;\n  }\n}\n\nobj1.valueOfThis(); // Will return the object obj1\nobj2.valueOfThis(); // Will return window/global object var obj1 = {\n  valueOfThis: function(){\n    return this;\n  }\n}\nvar obj2 = {\n  valueOfThis: ()=>{\n    return this;\n  }\n}\n\nobj1.valueOfThis(); // Will return the object obj1\nobj2.valueOfThis(); // Will return window/global object var valueOfThis function() function  return this var valueOfThis ()=> return this // Will return the object obj1 // Will return window/global object The biggest difference between the traditional function expression and the arrow function is the handling of this keyword. By general definition, this keyword always refers to the object that is calling the function. As you can see in the code above, obj1.valueOfThis() returns obj1 since this keyword refers to the object calling the function. this this obj1.valueOfThis() this In the arrow functions, there is no binding of this keyword. This keyword inside an arrow function does not refer to the object calling it. It rather inherits its value from the parent scope which is the window object in this case. Therefore, in the code above, obj2.valueOfThis() returns the window object. this  obj2.valueOfThis()",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "2. What do mean by prototype design pattern?",
        "answer": "The Prototype Pattern produces different objects, but instead of returning uninitialized objects, it produces objects that have values replicated from a template – or sample – object. Also known as the Properties pattern, the Prototype pattern is used to create prototypes. The introduction of business objects with parameters that match the database's default settings is a good example of where the Prototype pattern comes in handy. The default settings for a newly generated business object are stored in the prototype object. The Prototype pattern is hardly used in traditional languages, however, it is used in the development of new objects and templates in JavaScript, which is a prototypal language.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "3. Differences between declaring variables using var, let and const.",
        "answer": "Before the ES6 version of javascript, only the keyword var was used to declare variables. With the ES6 Version, keywords let and const were introduced to declare variables. keyword const let var\nglobal scope no no yes\nfunction scope yes yes yes\nblock scope yes yes no\ncan be reassigned no yes yes keyword const let var\nglobal scope no no yes\nfunction scope yes yes yes\nblock scope yes yes no\ncan be reassigned no yes yes keyword const let var\nglobal scope no no yes\nfunction scope yes yes yes\nblock scope yes yes no\ncan be reassigned no yes yes keyword const let var keyword const let var global scope no no yes global scope no no yes function scope yes yes yes function scope yes yes yes block scope yes yes no block scope yes yes no can be reassigned no yes yes can be reassigned no yes yes Let’s understand the differences with examples: Let’s understand the differences with examples: var variable1 = 23;\n\nlet variable2 = 89;\n\nfunction catchValues(){\n  console.log(variable1);\n  console.log(variable2);\n\n// Both the variables can be accessed anywhere since they are declared in the global scope\n}\n\nwindow.variable1; // Returns the value 23\n\nwindow.variable2; // Returns undefined var variable1 = 23;\n\nlet variable2 = 89;\n\nfunction catchValues(){\n  console.log(variable1);\n  console.log(variable2);\n\n// Both the variables can be accessed anywhere since they are declared in the global scope\n}\n\nwindow.variable1; // Returns the value 23\n\nwindow.variable2; // Returns undefined var 23 let 89 function catchValues() function catchValues  console console // Both the variables can be accessed anywhere since they are declared in the global scope window // Returns the value 23 window // Returns undefined The variables declared with the let keyword in the global scope behave just like the variable declared with the var keyword in the global scope.\nVariables declared in the global scope with var and let keywords can be accessed from anywhere in the code.\nBut, there is one difference! Variables that are declared with the var keyword in the global scope are added to the window/global object. Therefore, they can be accessed using window.variableName.\nWhereas, the variables declared with the let keyword are not added to the global object, therefore, trying to access such variables using window.variableName results in an error. The variables declared with the let keyword in the global scope behave just like the variable declared with the var keyword in the global scope. Variables declared in the global scope with var and let keywords can be accessed from anywhere in the code. But, there is one difference! Variables that are declared with the var keyword in the global scope are added to the window/global object. Therefore, they can be accessed using window.variableName.\nWhereas, the variables declared with the let keyword are not added to the global object, therefore, trying to access such variables using window.variableName results in an error.  var vs let in functional scope var vs let in functional scope function varVsLetFunction(){\n  let awesomeCar1 = \"Audi\";\n  var awesomeCar2 = \"Mercedes\";\n}\n\nconsole.log(awesomeCar1); // Throws an error\nconsole.log(awesomeCar2); // Throws an error function varVsLetFunction(){\n  let awesomeCar1 = \"Audi\";\n  var awesomeCar2 = \"Mercedes\";\n}\n\nconsole.log(awesomeCar1); // Throws an error\nconsole.log(awesomeCar2); // Throws an error function varVsLetFunction() function varVsLetFunction  let \"Audi\" var \"Mercedes\" console // Throws an error console // Throws an error Variables are declared in a functional/local scope using var and let keywords behave exactly the same, meaning, they cannot be accessed from outside of the scope. var let {\n  var variable3 = [1, 2, 3, 4];\n}\n\nconsole.log(variable3); // Outputs [1,2,3,4]\n\n{\n  let variable4 = [6, 55, -1, 2];\n}\n\nconsole.log(variable4); // Throws error\n\nfor(let i = 0; i < 2; i++){\n  //Do something\n}\n\nconsole.log(i); // Throws error\n\nfor(var j = 0; j < 2; i++){\n  // Do something\n}\n\nconsole.log(j) // Outputs 2 {\n  var variable3 = [1, 2, 3, 4];\n}\n\nconsole.log(variable3); // Outputs [1,2,3,4]\n\n{\n  let variable4 = [6, 55, -1, 2];\n}\n\nconsole.log(variable4); // Throws error\n\nfor(let i = 0; i < 2; i++){\n  //Do something\n}\n\nconsole.log(i); // Throws error\n\nfor(var j = 0; j < 2; i++){\n  // Do something\n}\n\nconsole.log(j) // Outputs 2 var 1 2 3 4 console // Outputs [1,2,3,4] let 6 55 1 2 console // Throws error for let 0 2 //Do something console // Throws error for var 0 2 // Do something console // Outputs 2 In javascript, a block means the code written inside the curly braces {}.\nVariables declared with var keyword do not have block scope. It means a variable declared in block scope {} with the var keyword is the same as declaring the variable in the global scope.\nVariables declared with let keyword inside the block scope cannot be accessed from outside of the block. In javascript, a block means the code written inside the curly braces {}. {} Variables declared with var keyword do not have block scope. It means a variable declared in block scope {} with the var keyword is the same as declaring the variable in the global scope. var {} var Variables declared with let keyword inside the block scope cannot be accessed from outside of the block. let Const keyword Const keyword Variables with the const keyword behave exactly like a variable declared with the let keyword with only one difference, any variable declared with the const keyword cannot be reassigned.\nExample: Variables with the const keyword behave exactly like a variable declared with the let keyword with only one difference, any variable declared with the const keyword cannot be reassigned. const any variable declared with the const keyword cannot be reassigned. Example: const x = {name:\"Vivek\"};\n\nx = {address: \"India\"}; // Throws an error\n\nx.name = \"Nikhil\"; // No error is thrown\n\nconst y = 23;\n\ny = 44; // Throws an error const x = {name:\"Vivek\"};\n\nx = {address: \"India\"}; // Throws an error\n\nx.name = \"Nikhil\"; // No error is thrown\n\nconst y = 23;\n\ny = 44; // Throws an error const name \"Vivek\" address \"India\" // Throws an error \"Nikhil\" // No error is thrown const 23 44 // Throws an error In the code above, although we can change the value of a property inside the variable declared with const keyword, we cannot completely reassign the variable itself. const",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "4. What is the rest parameter and spread operator?",
        "answer": "Both rest parameter and spread operator were introduced in the ES6 version of javascript.\n\nRest parameter ( … ):   Rest parameter ( … ): It provides an improved way of handling the parameters of a function.\nUsing the rest parameter syntax, we can create functions that can take a variable number of arguments.\nAny number of arguments will be converted into an array using the rest parameter.\nIt also helps in extracting all or some parts of the arguments.\nRest parameters can be used by applying three dots (...) before the parameters. It provides an improved way of handling the parameters of a function. Using the rest parameter syntax, we can create functions that can take a variable number of arguments. Any number of arguments will be converted into an array using the rest parameter. It also helps in extracting all or some parts of the arguments. Rest parameters can be used by applying three dots (...) before the parameters. function extractingArgs(...args){\n  return args[1];\n}\n\n// extractingArgs(8,9,1); // Returns 9\n\nfunction addAllArgs(...args){\n  let sumOfArgs = 0;\n  let i = 0;\n  while(i < args.length){\n    sumOfArgs += args[i];\n    i++;\n  }\n  return sumOfArgs;\n}\n\naddAllArgs(6, 5, 7, 99); // Returns 117\naddAllArgs(1, 3, 4); // Returns 8 function extractingArgs(...args){\n  return args[1];\n}\n\n// extractingArgs(8,9,1); // Returns 9\n\nfunction addAllArgs(...args){\n  let sumOfArgs = 0;\n  let i = 0;\n  while(i < args.length){\n    sumOfArgs += args[i];\n    i++;\n  }\n  return sumOfArgs;\n}\n\naddAllArgs(6, 5, 7, 99); // Returns 117\naddAllArgs(1, 3, 4); // Returns 8 function extractingArgs(...args) function extractingArgs ...args return 1 // extractingArgs(8,9,1); // Returns 9 function addAllArgs(...args) function addAllArgs ...args let 0 let 0 while return 6 5 7 99 // Returns 117 1 3 4 // Returns 8 **Note- Rest parameter should always be used at the last parameter of a function: **Note- Rest parameter should always be used at the last parameter of a function: // Incorrect way to use rest parameter\nfunction randomFunc(a,...args,c){\n//Do something\n}\n\n// Correct way to use rest parameter\nfunction randomFunc2(a,b,...args){\n//Do something\n} // Incorrect way to use rest parameter\nfunction randomFunc(a,...args,c){\n//Do something\n}\n\n// Correct way to use rest parameter\nfunction randomFunc2(a,b,...args){\n//Do something\n} // Incorrect way to use rest parameter function randomFunc(a,...args,c) function randomFunc a,...args,c //Do something // Correct way to use rest parameter function randomFunc2(a,b,...args) function randomFunc2 a,b,...args //Do something Spread operator (…): Although the syntax of the spread operator is exactly the same as the rest parameter, the spread operator is used to spreading an array, and object literals. We also use spread operators where one or more arguments are expected in a function call. Spread operator (…): Although the syntax of the spread operator is exactly the same as the rest parameter, the spread operator is used to spreading an array, and object literals. We also use spread operators where one or more arguments are expected in a function call. Spread operator (…): function addFourNumbers(num1,num2,num3,num4){\n  return num1 + num2 + num3 + num4;\n}\n\nlet fourNumbers = [5, 6, 7, 8];\n\n\naddFourNumbers(...fourNumbers);\n// Spreads [5,6,7,8] as 5,6,7,8\n\nlet array1 = [3, 4, 5, 6];\nlet clonedArray1 = [...array1];\n// Spreads the array into 3,4,5,6\nconsole.log(clonedArray1); // Outputs [3,4,5,6]\n\n\nlet obj1 = {x:'Hello', y:'Bye'};\nlet clonedObj1 = {...obj1}; // Spreads and clones obj1\nconsole.log(obj1);\n\nlet obj2 = {z:'Yes', a:'No'};\nlet mergedObj = {...obj1, ...obj2}; // Spreads both the objects and merges it\nconsole.log(mergedObj);\n// Outputs {x:'Hello', y:'Bye',z:'Yes',a:'No'}; function addFourNumbers(num1,num2,num3,num4){\n  return num1 + num2 + num3 + num4;\n}\n\nlet fourNumbers = [5, 6, 7, 8];\n\n\naddFourNumbers(...fourNumbers);\n// Spreads [5,6,7,8] as 5,6,7,8\n\nlet array1 = [3, 4, 5, 6];\nlet clonedArray1 = [...array1];\n// Spreads the array into 3,4,5,6\nconsole.log(clonedArray1); // Outputs [3,4,5,6]\n\n\nlet obj1 = {x:'Hello', y:'Bye'};\nlet clonedObj1 = {...obj1}; // Spreads and clones obj1\nconsole.log(obj1);\n\nlet obj2 = {z:'Yes', a:'No'};\nlet mergedObj = {...obj1, ...obj2}; // Spreads both the objects and merges it\nconsole.log(mergedObj);\n// Outputs {x:'Hello', y:'Bye',z:'Yes',a:'No'}; function addFourNumbers(num1,num2,num3,num4) function addFourNumbers num1,num2,num3,num4 return let 5 6 7 8 // Spreads [5,6,7,8] as 5,6,7,8 let 3 4 5 6 let // Spreads the array into 3,4,5,6 console // Outputs [3,4,5,6] let x 'Hello' y 'Bye' let // Spreads and clones obj1 console let z 'Yes' a 'No' let // Spreads both the objects and merges it console // Outputs {x:'Hello', y:'Bye',z:'Yes',a:'No'}; ***Note- Key differences between rest parameter and spread operator:\nRest parameter is used to take a variable number of arguments and turns them into an array while the spread operator takes an array or an object and spreads it\nRest parameter is used in function declaration whereas the spread operator is used in function calls. ***Note- Key differences between rest parameter and spread operator: Rest parameter is used to take a variable number of arguments and turns them into an array while the spread operator takes an array or an object and spreads it\nRest parameter is used in function declaration whereas the spread operator is used in function calls. Rest parameter is used to take a variable number of arguments and turns them into an array while the spread operator takes an array or an object and spreads it Rest parameter is used in function declaration whereas the spread operator is used in function calls.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "5. In JavaScript, how many different methods can you make an object?",
        "answer": "In JavaScript, there are several ways to declare or construct an object. Object.\nusing Class.\ncreate Method.\nObject Literals.\nusing Function.\nObject Constructor. Object. using Class. create Method. Object Literals. using Function. Object Constructor.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "6. What is the use of promises in javascript?",
        "answer": "Promises are used to handle asynchronous operations in javascript.\n\nBefore promises, callbacks were used to handle asynchronous operations. But due to the limited functionality of callbacks, using multiple callbacks to handle asynchronous code can lead to unmanageable code.\n\nPromise object has four states - Promises are used to handle asynchronous operations in javascript.     Pending - Initial state of promise. This state represents that the promise has neither been fulfilled nor been rejected, it is in the pending state.\nFulfilled - This state represents that the promise has been fulfilled, meaning the async operation is completed.\nRejected - This state represents that the promise has been rejected for some reason, meaning the async operation has failed.\nSettled - This state represents that the promise has been either rejected or fulfilled. Pending - Initial state of promise. This state represents that the promise has neither been fulfilled nor been rejected, it is in the pending state. Fulfilled - This state represents that the promise has been fulfilled, meaning the async operation is completed. Rejected - This state represents that the promise has been rejected for some reason, meaning the async operation has failed. Settled - This state represents that the promise has been either rejected or fulfilled. A promise is created using the Promise constructor which takes in a callback function with two parameters, resolve and reject respectively. Promise resolve reject   resolve is a function that will be called when the async operation has been successfully completed.\n\nreject is a function that will be called, when the async operation fails or if some error occurs.\n\nExample of a promise:\n\nPromises are used to handle asynchronous operations like server requests, for ease of understanding, we are using an operation to calculate the sum of three elements.\n\nIn the function below, we are returning a promise inside a function: resolve   reject     Promises are used to handle asynchronous operations like server requests, for ease of understanding, we are using an operation to calculate the sum of three elements.   function sumOfThreeElements(...elements){\n  return new Promise((resolve,reject)=>{\n    if(elements.length > 3 ){\n      reject(\"Only three elements or less are allowed\");\n    }\n    else{\n      let sum = 0;\n      let i = 0;\n      while(i < elements.length){\n        sum += elements[i];\n        i++;\n      }\n      resolve(\"Sum has been calculated: \"+sum);\n    }\n  })\n} function sumOfThreeElements(...elements){\n  return new Promise((resolve,reject)=>{\n    if(elements.length > 3 ){\n      reject(\"Only three elements or less are allowed\");\n    }\n    else{\n      let sum = 0;\n      let i = 0;\n      while(i < elements.length){\n        sum += elements[i];\n        i++;\n      }\n      resolve(\"Sum has been calculated: \"+sum);\n    }\n  })\n} function sumOfThreeElements(...elements) function sumOfThreeElements ...elements return new Promise (resolve,reject)=> resolve,reject if 3 \"Only three elements or less are allowed\" else let 0 let 0 while \"Sum has been calculated: \" In the code above, we are calculating the sum of three elements, if the length of the elements array is more than 3, a promise is rejected, or else the promise is resolved and the sum is returned. We can consume any promise by attaching then() and catch() methods to the consumer.   then() method is used to access the result when the promise is fulfilled. then() catch() method is used to access the result/error when the promise is rejected. In the code below, we are consuming the promise: catch() sumOfThreeElements(4, 5, 6)\n.then(result=> console.log(result))\n.catch(error=> console.log(error));\n// In the code above, the promise is fulfilled so the then() method gets executed\n\nsumOfThreeElements(7, 0, 33, 41)\n.then(result => console.log(result))\n.catch(error=> console.log(error));\n// In the code above, the promise is rejected hence the catch() method gets executed sumOfThreeElements(4, 5, 6)\n.then(result=> console.log(result))\n.catch(error=> console.log(error));\n// In the code above, the promise is fulfilled so the then() method gets executed\n\nsumOfThreeElements(7, 0, 33, 41)\n.then(result => console.log(result))\n.catch(error=> console.log(error));\n// In the code above, the promise is rejected hence the catch() method gets executed 4 5 6 result=> result console error=> error console // In the code above, the promise is fulfilled so the then() method gets executed 7 0 33 41 result => result console error=> error console // In the code above, the promise is rejected hence the catch() method gets executed",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "7. What are classes in javascript?",
        "answer": "Introduced in the ES6 version, classes are nothing but syntactic sugars for constructor functions. They provide a new way of declaring constructor functions in javascript.  Below are the examples of how classes are declared and used: // Before ES6 version, using constructor functions\nfunction Student(name,rollNumber,grade,section){\n  this.name = name;\n  this.rollNumber = rollNumber;\n  this.grade = grade;\n  this.section = section;\n}\n\n// Way to add methods to a constructor function\nStudent.prototype.getDetails = function(){\n  return 'Name: ${this.name}, Roll no: ${this.rollNumber}, Grade: ${this.grade}, Section:${this.section}';\n}\n\n\nlet student1 = new Student(\"Vivek\", 354, \"6th\", \"A\");\nstudent1.getDetails();\n// Returns Name: Vivek, Roll no:354, Grade: 6th, Section:A\n\n// ES6 version classes\nclass Student{\n  constructor(name,rollNumber,grade,section){\n    this.name = name;\n    this.rollNumber = rollNumber;\n    this.grade = grade;\n    this.section = section;\n  }\n\n  // Methods can be directly added inside the class\n  getDetails(){\n    return 'Name: ${this.name}, Roll no: ${this.rollNumber}, Grade:${this.grade}, Section:${this.section}';\n  }\n}\n\nlet student2 = new Student(\"Garry\", 673, \"7th\", \"C\");\nstudent2.getDetails();\n// Returns Name: Garry, Roll no:673, Grade: 7th, Section:C // Before ES6 version, using constructor functions\nfunction Student(name,rollNumber,grade,section){\n  this.name = name;\n  this.rollNumber = rollNumber;\n  this.grade = grade;\n  this.section = section;\n}\n\n// Way to add methods to a constructor function\nStudent.prototype.getDetails = function(){\n  return 'Name: ${this.name}, Roll no: ${this.rollNumber}, Grade: ${this.grade}, Section:${this.section}';\n}\n\n\nlet student1 = new Student(\"Vivek\", 354, \"6th\", \"A\");\nstudent1.getDetails();\n// Returns Name: Vivek, Roll no:354, Grade: 6th, Section:A\n\n// ES6 version classes\nclass Student{\n  constructor(name,rollNumber,grade,section){\n    this.name = name;\n    this.rollNumber = rollNumber;\n    this.grade = grade;\n    this.section = section;\n  }\n\n  // Methods can be directly added inside the class\n  getDetails(){\n    return 'Name: ${this.name}, Roll no: ${this.rollNumber}, Grade:${this.grade}, Section:${this.section}';\n  }\n}\n\nlet student2 = new Student(\"Garry\", 673, \"7th\", \"C\");\nstudent2.getDetails();\n// Returns Name: Garry, Roll no:673, Grade: 7th, Section:C // Before ES6 version, using constructor functions function Student(name,rollNumber,grade,section) function Student name,rollNumber,grade,section this this this this // Way to add methods to a constructor function function() function  return 'Name: ${this.name}, Roll no: ${this.rollNumber}, Grade: ${this.grade}, Section:${this.section}' let new \"Vivek\" 354 \"6th\" \"A\" // Returns Name: Vivek, Roll no:354, Grade: 6th, Section:A // ES6 version classes class Student class Student constructor(name,rollNumber,grade,section) constructor name,rollNumber,grade,section this this this this // Methods can be directly added inside the class getDetails() getDetails  return 'Name: ${this.name}, Roll no: ${this.rollNumber}, Grade:${this.grade}, Section:${this.section}' let new \"Garry\" 673 \"7th\" \"C\" // Returns Name: Garry, Roll no:673, Grade: 7th, Section:C Key points to remember about classes: Unlike functions, classes are not hoisted. A class cannot be used before it is declared.\nA class can inherit properties and methods from other classes by using the extend keyword.\nAll the syntaxes inside the class must follow the strict mode(‘use strict’) of javascript. An error will be thrown if the strict mode rules are not followed. Unlike functions, classes are not hoisted. A class cannot be used before it is declared. A class can inherit properties and methods from other classes by using the extend keyword. All the syntaxes inside the class must follow the strict mode(‘use strict’) of javascript. An error will be thrown if the strict mode rules are not followed.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "8. What are generator functions?",
        "answer": "Introduced in the ES6 version, generator functions are a special class of functions.\n\nThey can be stopped midway and then continue from where they had stopped.\n\nGenerator functions are declared with the function* keyword instead of the normal function keyword:   They can be stopped midway and then continue from where they had stopped.   function* function function* genFunc(){\n  // Perform operation\n} function* genFunc(){\n  // Perform operation\n} function* genFunc() function genFunc  // Perform operation In normal functions, we use the return keyword to return a value and as soon as the return statement gets executed, the function execution stops: return function normalFunc(){\n  return 22;\n  console.log(2); // This line of code does not get executed\n} function normalFunc(){\n  return 22;\n  console.log(2); // This line of code does not get executed\n} function normalFunc() function normalFunc  return 22 console 2 // This line of code does not get executed In the case of generator functions, when called, they do not execute the code, instead, they return a generator object. This generator object handles the execution. generator object function* genFunc(){\n  yield 3;\n  yield 4;\n}\ngenFunc(); // Returns Object [Generator] {} function* genFunc(){\n  yield 3;\n  yield 4;\n}\ngenFunc(); // Returns Object [Generator] {} function* genFunc() function genFunc  yield 3 yield 4 // Returns Object [Generator] {} The generator object consists of a method called next(), this method when called, executes the code until the nearest yield statement, and returns the yield value.\n\nFor example, if we run the next() method on the above code: next() yield   genFunc().next(); // Returns {value: 3, done:false} genFunc().next(); // Returns {value: 3, done:false} // Returns {value: 3, done:false} As one can see the next method returns an object consisting of a value and done properties.  Value property represents the yielded value. Done property tells us whether the function code is finished or not. (Returns true if finished). value done Generator functions are used to return iterators. Let’s see an example where an iterator is returned: function* iteratorFunc() {\n  let count = 0;\n  for (let i = 0; i < 2; i++) {\n      count++;\n      yield i;\n  }\n  return count;\n}\n\nlet iterator = iteratorFunc();\nconsole.log(iterator.next()); // {value:0,done:false}\nconsole.log(iterator.next()); // {value:1,done:false}\nconsole.log(iterator.next()); // {value:2,done:true} function* iteratorFunc() {\n  let count = 0;\n  for (let i = 0; i < 2; i++) {\n      count++;\n      yield i;\n  }\n  return count;\n}\n\nlet iterator = iteratorFunc();\nconsole.log(iterator.next()); // {value:0,done:false}\nconsole.log(iterator.next()); // {value:1,done:false}\nconsole.log(iterator.next()); // {value:2,done:true} function* iteratorFunc() function iteratorFunc  let 0 for let 0 2 yield return let console // {value:0,done:false} console // {value:1,done:false} console // {value:2,done:true} As you can see in the code above, the last line returns done:true, since the code reaches the return statement. done:true",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "9. Explain WeakSet in javascript.",
        "answer": "In javascript, a Set is a collection of unique and ordered elements. Just like Set, WeakSet is also a collection of unique and ordered elements with some key differences: Weakset contains only objects and no other type.\nAn object inside the weakset is referenced weakly. This means, that if the object inside the weakset does not have a reference, it will be garbage collected.\nUnlike Set, WeakSet only has three methods, add() , delete() and has() . Weakset contains only objects and no other type. An object inside the weakset is referenced weakly. This means, that if the object inside the weakset does not have a reference, it will be garbage collected. Unlike Set, WeakSet only has three methods, add() , delete() and has() . add() delete() has() const newSet = new Set([4, 5, 6, 7]);\nconsole.log(newSet);// Outputs Set {4,5,6,7}\n\nconst newSet2 = new WeakSet([3, 4, 5]); //Throws an error\n\n\nlet obj1 = {message:\"Hello world\"};\nconst newSet3 = new WeakSet([obj1]);\nconsole.log(newSet3.has(obj1)); // true const newSet = new Set([4, 5, 6, 7]);\nconsole.log(newSet);// Outputs Set {4,5,6,7}\n\nconst newSet2 = new WeakSet([3, 4, 5]); //Throws an error\n\n\nlet obj1 = {message:\"Hello world\"};\nconst newSet3 = new WeakSet([obj1]);\nconsole.log(newSet3.has(obj1)); // true const new Set 4 5 6 7 console // Outputs Set {4,5,6,7} const new WeakSet 3 4 5 //Throws an error let message \"Hello world\" const new WeakSet console // true",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "10. Why do we use callbacks?",
        "answer": "A callback function is a method that is sent as an input to another function (now let us name this other function \"thisFunction\"), and it is performed inside the thisFunction after the function has completed execution. JavaScript is a scripting language that is based on events. Instead of waiting for a reply before continuing, JavaScript will continue to run while monitoring for additional events. Callbacks are a technique of ensuring that a particular code does not run until another code has completed its execution.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "11. Explain WeakMap in javascript.",
        "answer": "In javascript, Map is used to store key-value pairs. The key-value pairs can be of both primitive and non-primitive types. WeakMap is similar to Map with key differences: The keys and values in weakmap should always be an object.\nIf there are no references to the object, the object will be garbage collected. The keys and values in weakmap should always be an object. If there are no references to the object, the object will be garbage collected. const map1 = new Map();\nmap1.set('Value', 1);\n\nconst map2 = new WeakMap();\nmap2.set('Value', 2.3); // Throws an error\n\nlet obj = {name:\"Vivek\"};\nconst map3 = new WeakMap();\nmap3.set(obj, {age:23}); const map1 = new Map();\nmap1.set('Value', 1);\n\nconst map2 = new WeakMap();\nmap2.set('Value', 2.3); // Throws an error\n\nlet obj = {name:\"Vivek\"};\nconst map3 = new WeakMap();\nmap3.set(obj, {age:23}); const new Map 'Value' 1 const new WeakMap 'Value' 2.3 // Throws an error let name \"Vivek\" const new WeakMap age 23",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "12. What is Object Destructuring?",
        "answer": "Object destructuring is a new way to extract elements from an object or an array. Object destructuring: Before ES6 version: Object destructuring: Before ES6 version: Object destructuring: const classDetails = {\n  strength: 78,\n  benches: 39,\n  blackBoard:1\n}\n\nconst classStrength = classDetails.strength;\nconst classBenches = classDetails.benches;\nconst classBlackBoard = classDetails.blackBoard; const classDetails = {\n  strength: 78,\n  benches: 39,\n  blackBoard:1\n}\n\nconst classStrength = classDetails.strength;\nconst classBenches = classDetails.benches;\nconst classBlackBoard = classDetails.blackBoard; const strength 78 benches 39 blackBoard 1 const const const The same example using object destructuring: const classDetails = {\n  strength: 78,\n  benches: 39,\n  blackBoard:1\n}\n\nconst {strength:classStrength, benches:classBenches,blackBoard:classBlackBoard} = classDetails;\n\nconsole.log(classStrength); // Outputs 78\nconsole.log(classBenches); // Outputs 39\nconsole.log(classBlackBoard); // Outputs 1 const classDetails = {\n  strength: 78,\n  benches: 39,\n  blackBoard:1\n}\n\nconst {strength:classStrength, benches:classBenches,blackBoard:classBlackBoard} = classDetails;\n\nconsole.log(classStrength); // Outputs 78\nconsole.log(classBenches); // Outputs 39\nconsole.log(classBlackBoard); // Outputs 1 const strength 78 benches 39 blackBoard 1 const strength benches blackBoard console // Outputs 78 console // Outputs 39 console // Outputs 1 As one can see, using object destructuring we have extracted all the elements inside an object in one line of code. If we want our new variable to have the same name as the property of an object we can remove the colon: const {strength:strength} = classDetails;\n// The above line of code can be written as:\nconst {strength} = classDetails; const {strength:strength} = classDetails;\n// The above line of code can be written as:\nconst {strength} = classDetails; const strength // The above line of code can be written as: const Array destructuring: Before ES6 version: Array destructuring: Before ES6 version: Array destructuring: const arr = [1, 2, 3, 4];\nconst first = arr[0];\nconst second = arr[1];\nconst third = arr[2];\nconst fourth = arr[3]; const arr = [1, 2, 3, 4];\nconst first = arr[0];\nconst second = arr[1];\nconst third = arr[2];\nconst fourth = arr[3]; const 1 2 3 4 const 0 const 1 const 2 const 3 The same example using object destructuring: const arr = [1, 2, 3, 4];\nconst [first,second,third,fourth] = arr;\nconsole.log(first); // Outputs 1\nconsole.log(second); // Outputs 2\nconsole.log(third); // Outputs 3\nconsole.log(fourth); // Outputs 4 const arr = [1, 2, 3, 4];\nconst [first,second,third,fourth] = arr;\nconsole.log(first); // Outputs 1\nconsole.log(second); // Outputs 2\nconsole.log(third); // Outputs 3\nconsole.log(fourth); // Outputs 4 const 1 2 3 4 const console // Outputs 1 console // Outputs 2 console // Outputs 3 console // Outputs 4",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "13. Difference between prototypal and classical inheritance",
        "answer": "Programers build objects, which are representations of real-time entities, in traditional OO programming. Classes and objects are the two sorts of abstractions. A class is a generalization of an object, whereas an object is an abstraction of an actual thing. A Vehicle, for example, is a specialization of a Car. As a result, automobiles (class) are descended from vehicles (object). Classical inheritance differs from prototypal inheritance in that classical inheritance is confined to classes that inherit from those remaining classes, but prototypal inheritance allows any object to be cloned via an object linking method. Despite going into too many specifics, a prototype essentially serves as a template for those other objects, whether they extend the parent object or not.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "14. What is a Temporal Dead Zone?",
        "answer": "Temporal Dead Zone is a behaviour that occurs with variables declared using let and const keywords. It is a behaviour where we try to access a variable before it is initialized. Examples of temporal dead zone: let const x = 23; // Gives reference error\n\nlet x;\n\nfunction anotherRandomFunc(){\n  message = \"Hello\"; // Throws a reference error\n\n  let message;\n}\nanotherRandomFunc(); x = 23; // Gives reference error\n\nlet x;\n\nfunction anotherRandomFunc(){\n  message = \"Hello\"; // Throws a reference error\n\n  let message;\n}\nanotherRandomFunc(); 23 // Gives reference error let function anotherRandomFunc() function anotherRandomFunc  \"Hello\" // Throws a reference error let In the code above, both in the global scope and functional scope, we are trying to access variables that have not been declared yet. This is called the Temporal Dead Zone. Temporal Dead Zone",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "15. What do you mean by JavaScript Design Patterns?",
        "answer": "JavaScript design patterns are repeatable approaches for errors that arise sometimes when building JavaScript browser applications. They truly assist us in making our code more stable. They are divided mainly into 3 categories Creational Design Pattern\nStructural Design Pattern\nBehavioral Design Pattern. Creational Design Pattern Structural Design Pattern Behavioral Design Pattern. Creational Design Pattern: The object generation mechanism is addressed by the JavaScript Creational Design Pattern. They aim to make items that are appropriate for a certain scenario.\nStructural Design Pattern: The JavaScript Structural Design Pattern explains how the classes and objects we've generated so far can be combined to construct bigger frameworks. This pattern makes it easier to create relationships between items by defining a straightforward way to do so.\nBehavioral Design Pattern: This design pattern highlights typical patterns of communication between objects in JavaScript. As a result, the communication may be carried out with greater freedom. Creational Design Pattern: The object generation mechanism is addressed by the JavaScript Creational Design Pattern. They aim to make items that are appropriate for a certain scenario. Creational Design Pattern: Structural Design Pattern: The JavaScript Structural Design Pattern explains how the classes and objects we've generated so far can be combined to construct bigger frameworks. This pattern makes it easier to create relationships between items by defining a straightforward way to do so. Structural Design Pattern: Behavioral Design Pattern: This design pattern highlights typical patterns of communication between objects in JavaScript. As a result, the communication may be carried out with greater freedom. Behavioral Design Pattern:",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "16. Is JavaScript a pass-by-reference or pass-by-value language?",
        "answer": "The variable's data is always a reference for objects, hence it's always pass by value. As a result, if you supply an object and alter its members inside the method, the changes continue outside of it. It appears to be pass by reference in this case. However, if you modify the values of the object variable, the change will not last, demonstrating that it is indeed passed by value.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "17. Difference between Async/Await and Generators usage to achieve the same functionality.",
        "answer": "Generator functions are run by their generator yield by yield which means one output at a time, whereas Async-await functions are executed sequentially one after another.\nAsync/await provides a certain use case for Generators easier to execute.\nThe output result of the Generator function is always value: X, done: Boolean, but the return value of the Async function is always an assurance or throws an error. Generator functions are run by their generator yield by yield which means one output at a time, whereas Async-await functions are executed sequentially one after another. Async/await provides a certain use case for Generators easier to execute. The output result of the Generator function is always value: X, done: Boolean, but the return value of the Async function is always an assurance or throws an error.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "18. What are the primitive data types in JavaScript?",
        "answer": "A primitive is a data type that isn't composed of other data types. It's only capable of displaying one value at a time. By definition, every primitive is a built-in data type (the compiler must be knowledgeable of them) nevertheless, not all built-in datasets are primitives. In JavaScript, there are 5 different forms of basic data. The following values are available: Boolean\nUndefined\nNull\nNumber\nString Boolean Undefined Null Number String",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "19. What is the role of deferred scripts in JavaScript?",
        "answer": "The processing of HTML code while the page loads are disabled by nature till the script hasn't halted. Your page will be affected if your network is a bit slow, or if the script is very hefty. When you use Deferred, the script waits for the HTML parser to finish before executing it. This reduces the time it takes for web pages to load, allowing them to appear more quickly.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "20. What has to be done in order to put Lexical Scoping into practice?",
        "answer": "To support lexical scoping, a JavaScript function object's internal state must include not just the function's code but also a reference to the current scope chain.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "21. What is the purpose of the following JavaScript code?",
        "answer": "var scope = \"global scope\";\nfunction check() \n{\n    var scope = \"local scope\"; \n    function f() \n    { \n         return scope; \n    }\n    return f;\n} var scope = \"global scope\";\nfunction check() \n{\n    var scope = \"local scope\"; \n    function f() \n    { \n         return scope; \n    }\n    return f;\n} var \"global scope\" function check() function check  var \"local scope\" function f() function f  return return Every executing function, code block, and script as a whole in JavaScript has a related object known as the Lexical Environment. The preceding code line returns the value in scope.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "1. What is the output of the following code?",
        "answer": "const b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nfor (let i = 0; i < 10; i++) {\n  setTimeout(() => console.log(b[i]), 1000);\n}\n\nfor (var i = 0; i < 10; i++) {\n  setTimeout(() => console.log(b[i]), 1000);\n} const b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nfor (let i = 0; i < 10; i++) {\n  setTimeout(() => console.log(b[i]), 1000);\n}\n\nfor (var i = 0; i < 10; i++) {\n  setTimeout(() => console.log(b[i]), 1000);\n} const 1 2 3 4 5 6 7 8 9 10 for let 0 10 setTimeout () => console 1000 for var 0 10 setTimeout () => console 1000 Ans. Ans. 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined\nundefined 1 2 3 4 5 6 7 8 9 10 undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined Conclusion It is preferable to keep the JavaScript, CSS, and HTML in distinct Separate 'javascript' files. Dividing the code and HTML sections will make them easier to understand and deal with. This strategy is also simpler for several programmers to use at the same time. JavaScript code is simple to update. Numerous pages can utilize the same group of JavaScript Codes. If we utilize External JavaScript scripts and need to alter the code, we must do it just once. So that we may utilize a number and maintain it much more easily. Remember that professional experience and expertise are only one aspect of recruitment. Previous experience and personal skills are both vital in landing (or finding the ideal applicant for the job. Remember that many JavaScript structured interviews are free and have no one proper answer. Interviewers would like to know why you answered the way you did, not if you remembered the answer. Explain your answer process and be prepared to address it. If you're looking to further enhance your JavaScript skills, consider enrolling in this free JavaScript course by Scaler Topics to gain hands-on experience and improve your problem-solving abilities. Scaler Topics Scaler Topics Recommended Resources JavaScript Cheat Sheet: Basics to Advanced(2023)\nOnline Javascript Compiler\nTop JavaScript Features You Must Know\n50 JavaScript MCQ With Answers\nTop 15+ JavaScript Projects for Beginners to Advanced [With Source Code]\n9 Best JavaScript IDE & Source Code Editors [2023]\nTop ES6 Interview Questions (2023)\n10 Best JavaScript Books for Beginners to Advanced [2023]\n30+ Top Node.js Interview Questions (2023)\nTypescript vs Javascript: What’s The Difference?\nTop 5 JavaScript Libraries You Must Know in 2023\nDifference Between HTML and JavaScript\nJavascript Vs jQuery: What’s the Difference? [2023]\nJavascript Vs Python: What’s The Difference? [2023]\nDifference Between Java and Javascript\nDifference between Typescript and Javascript JavaScript Cheat Sheet: Basics to Advanced(2023) JavaScript Cheat Sheet: Basics to Advanced(2023) Online Javascript Compiler Online Javascript Compiler Top JavaScript Features You Must Know Top JavaScript Features You Must Know 50 JavaScript MCQ With Answers 50 JavaScript MCQ With Answers Top 15+ JavaScript Projects for Beginners to Advanced [With Source Code] Top 15+ JavaScript Projects for Beginners to Advanced [With Source Code] 9 Best JavaScript IDE & Source Code Editors [2023] 9 Best JavaScript IDE & Source Code Editors [2023] Top ES6 Interview Questions (2023) Top ES6 Interview Questions (2023) 10 Best JavaScript Books for Beginners to Advanced [2023] 10 Best JavaScript Books for Beginners to Advanced [2023] 30+ Top Node.js Interview Questions (2023) 30+ Top Node.js Interview Questions (2023) Typescript vs Javascript: What’s The Difference? Typescript vs Javascript: What’s The Difference? Top 5 JavaScript Libraries You Must Know in 2023 Top 5 JavaScript Libraries You Must Know in 2023 Difference Between HTML and JavaScript Difference Between HTML and JavaScript Javascript Vs jQuery: What’s the Difference? [2023] Javascript Vs jQuery: What’s the Difference? [2023] Javascript Vs Python: What’s The Difference? [2023] Javascript Vs Python: What’s The Difference? [2023] Difference Between Java and Javascript Difference Between Java and Javascript Difference between Typescript and Javascript Difference between Typescript and Javascript Interview Guides The Ultimate Guide to Acing Your Technical Interview\n300+ Must Do Coding Questions from Interviews\nMock Interview\nInterviewBit - No.1 Resource for Tech Interview Preparation The Ultimate Guide to Acing Your Technical Interview The Ultimate Guide to Acing Your Technical Interview 300+ Must Do Coding Questions from Interviews 300+ Must Do Coding Questions from Interviews Mock Interview Mock Interview InterviewBit - No.1 Resource for Tech Interview Preparation InterviewBit - No.1 Resource for Tech Interview Preparation",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "2. In JavaScript, how do you turn an Object into an Array []?",
        "answer": "let obj = { id: \"1\", name: \"user22\", age: \"26\", work: \"programmer\" };\n\n//Method 1: Convert the keys to Array using - Object.keys()\nconsole.log(Object.keys(obj));\n// [\"id\", \"name\", \"age\", \"work\"]\n\n// Method 2 Converts the Values to Array using - Object.values()\nconsole.log(Object.values(obj));\n// [\"1\", \"user22r\", \"26\", \"programmer\"]\n\n// Method 3 Converts both keys and values using - Object.entries()\nconsole.log(Object.entries(obj));\n//[[\"id\", \"1\"],[\"name\", \"user22\"],[\"age\", \"26\"],[\"work\", “programmer\"]] let obj = { id: \"1\", name: \"user22\", age: \"26\", work: \"programmer\" };\n\n//Method 1: Convert the keys to Array using - Object.keys()\nconsole.log(Object.keys(obj));\n// [\"id\", \"name\", \"age\", \"work\"]\n\n// Method 2 Converts the Values to Array using - Object.values()\nconsole.log(Object.values(obj));\n// [\"1\", \"user22r\", \"26\", \"programmer\"]\n\n// Method 3 Converts both keys and values using - Object.entries()\nconsole.log(Object.entries(obj));\n//[[\"id\", \"1\"],[\"name\", \"user22\"],[\"age\", \"26\"],[\"work\", “programmer\"]] let id \"1\" name \"user22\" age \"26\" work \"programmer\" //Method 1: Convert the keys to Array using - Object.keys() console Object // [\"id\", \"name\", \"age\", \"work\"] // Method 2 Converts the Values to Array using - Object.values() console Object // [\"1\", \"user22r\", \"26\", \"programmer\"] // Method 3 Converts both keys and values using - Object.entries() console Object //[[\"id\", \"1\"],[\"name\", \"user22\"],[\"age\", \"26\"],[\"work\", “programmer\"]]",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "3. Write the code to find the vowels",
        "answer": "const findVowels = str => {\n  let count = 0\n  const vowels = ['a', 'e', 'i', 'o', 'u']\n  for(let char of str.toLowerCase()) {\n    if(vowels.includes(char)) {\n      count++\n    }\n  }\n  return count\n} const findVowels = str => {\n  let count = 0\n  const vowels = ['a', 'e', 'i', 'o', 'u']\n  for(let char of str.toLowerCase()) {\n    if(vowels.includes(char)) {\n      count++\n    }\n  }\n  return count\n} const str => str let 0 const 'a' 'e' 'i' 'o' 'u' for let of if return",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "4. Write the code given If two strings are anagrams of one another, then return true.",
        "answer": "var firstWord = \"Deepak\";\nvar secondWord = \"Aman\";\n\nisAnagram(wordOne, wordTwo); // true\n\nfunction isAnagram(one, two) {\n  //Change both words to lowercase for case insensitivity..\n  var a = one.toLowerCase();\n  var b = two.toLowerCase();\n\n  // Sort the strings, then combine the array to a string. Examine the outcomes.\n  a = a.split(\"\").sort().join(\"\");\n  b = b.split(\"\").sort().join(\"\");\n\n  return a === b;\n} var firstWord = \"Deepak\";\nvar secondWord = \"Aman\";\n\nisAnagram(wordOne, wordTwo); // true\n\nfunction isAnagram(one, two) {\n  //Change both words to lowercase for case insensitivity..\n  var a = one.toLowerCase();\n  var b = two.toLowerCase();\n\n  // Sort the strings, then combine the array to a string. Examine the outcomes.\n  a = a.split(\"\").sort().join(\"\");\n  b = b.split(\"\").sort().join(\"\");\n\n  return a === b;\n} var \"Deepak\" var \"Aman\" // true function isAnagram(one, two) function isAnagram one, two //Change both words to lowercase for case insensitivity.. var var // Sort the strings, then combine the array to a string. Examine the outcomes. \"\" \"\" \"\" \"\" return",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "5. Write the code for dynamically inserting new components.",
        "answer": "<html> \n<head> \n<title>inserting new components dynamically</title> \n<script type=\"text/javascript\"> \n    function addNode () { var newP = document. createElement(\"p\"); \n    var textNode = document.createTextNode(\" This is other node\"); \n    newP.appendChild(textNode); document.getElementById(\"parent1\").appendChild(newP); } \n</script> \n</head> \n<body> <p id=\"parent1\">firstP<p> </body> \n</html> <html> \n<head> \n<title>inserting new components dynamically</title> \n<script type=\"text/javascript\"> \n    function addNode () { var newP = document. createElement(\"p\"); \n    var textNode = document.createTextNode(\" This is other node\"); \n    newP.appendChild(textNode); document.getElementById(\"parent1\").appendChild(newP); } \n</script> \n</head> \n<body> <p id=\"parent1\">firstP<p> </body> \n</html>",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "6. Implement a function that returns an updated array with r right rotations on an array of integers a .",
        "answer": "Example: Example: Given the following array: [2,3,4,5,7]\nPerform 3 right rotations:\nFirst rotation : [7,2,3,4,5] , Second rotation : [5,7,2,3,4] and, Third rotation: [4,5,7,2,3] [2,3,4,5,7]  3  return [4,5,7,2,3] [4,5,7,2,3] Answer: Answer: function rotateRight(arr,rotations){\n  if(rotations == 0) return arr;\n  for(let i = 0; i < rotations;i++){\n    let element = arr.pop();\n    arr.unshift(element);\n  }\n  return arr;\n}\nrotateRight([2, 3, 4, 5, 7], 3); // Return [4,5,7,2,3]\nrotateRight([44, 1, 22, 111], 5); // Returns [111,44,1,22] function rotateRight(arr,rotations){\n  if(rotations == 0) return arr;\n  for(let i = 0; i < rotations;i++){\n    let element = arr.pop();\n    arr.unshift(element);\n  }\n  return arr;\n}\nrotateRight([2, 3, 4, 5, 7], 3); // Return [4,5,7,2,3]\nrotateRight([44, 1, 22, 111], 5); // Returns [111,44,1,22]",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "7. Write a function that performs binary search on a sorted array.",
        "answer": "function binarySearch(arr,value,startPos,endPos){\n  if(startPos > endPos) return -1;\n\n  let middleIndex = Math.floor(startPos+endPos)/2;\n\n  if(arr[middleIndex] === value) return middleIndex;\n\n  elsif(arr[middleIndex] > value){\n    return binarySearch(arr,value,startPos,middleIndex-1);\n  }\n  else{\n    return binarySearch(arr,value,middleIndex+1,endPos);\n  }\n} function binarySearch(arr,value,startPos,endPos){\n  if(startPos > endPos) return -1;\n\n  let middleIndex = Math.floor(startPos+endPos)/2;\n\n  if(arr[middleIndex] === value) return middleIndex;\n\n  elsif(arr[middleIndex] > value){\n    return binarySearch(arr,value,startPos,middleIndex-1);\n  }\n  else{\n    return binarySearch(arr,value,middleIndex+1,endPos);\n  }\n} function binarySearch(arr,value,startPos,endPos) function binarySearch arr,value,startPos,endPos if return 1 let Math 2 if return elsif(arr[middleIndex] > value) elsif arr[middleIndex] > value return 1 else return 1",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "8. Guess the outputs of the following code:",
        "answer": "**Note - Code 2 and Code 3 require you to modify the code, instead of guessing the output. **Note - Code 2 and Code 3 require you to modify the code, instead of guessing the output. // Code 1\n\n(function(a){\n  return (function(){\n    console.log(a);\n    a = 23;\n  })()\n})(45);\n\n// Code 2\n\n// Each time bigFunc is called, an array of size 700 is being created,\n// Modify the code so that we don't create the same array again and again\n\nfunction bigFunc(element){\n  let newArray = new Array(700).fill('♥');\n  return newArray[element];\n}\n\nconsole.log(bigFunc(599)); // Array is created\nconsole.log(bigFunc(670)); // Array is created again\n\n// Code 3\n\n// The following code outputs 2 and 2 after waiting for one second\n// Modify the code to output 0 and 1 after one second.\n\nfunction randomFunc(){\n  for(var i = 0; i < 2; i++){\n    setTimeout(()=> console.log(i),1000);\n  }\n}\nrandomFunc(); // Code 1\n\n(function(a){\n  return (function(){\n    console.log(a);\n    a = 23;\n  })()\n})(45);\n\n// Code 2\n\n// Each time bigFunc is called, an array of size 700 is being created,\n// Modify the code so that we don't create the same array again and again\n\nfunction bigFunc(element){\n  let newArray = new Array(700).fill('♥');\n  return newArray[element];\n}\n\nconsole.log(bigFunc(599)); // Array is created\nconsole.log(bigFunc(670)); // Array is created again\n\n// Code 3\n\n// The following code outputs 2 and 2 after waiting for one second\n// Modify the code to output 0 and 1 after one second.\n\nfunction randomFunc(){\n  for(var i = 0; i < 2; i++){\n    setTimeout(()=> console.log(i),1000);\n  }\n}\nrandomFunc(); // Code 1 function(a) function a return function() function  console 23 45 // Code 2 // Each time bigFunc is called, an array of size 700 is being created, // Modify the code so that we don't create the same array again and again function bigFunc(element) function bigFunc element let new Array 700 '♥' return console 599 // Array is created console 670 // Array is created again // Code 3 // The following code outputs 2 and 2 after waiting for one second // Modify the code to output 0 and 1 after one second. function randomFunc() function randomFunc  for var 0 2 setTimeout ()=> console 1000 Answers -\n\nCode 1 - Outputs 45.\n\nEven though a is defined in the outer function, due to closure the inner functions have access to it.\n\nCode 2 - This code can be modified by using closures, Answers -   Code 1 45     Code 2 function bigFunc(){\n  let newArray = new Array(700).fill('♥');\n  return (element) => newArray[element];\n}\n\nlet getElement = bigFunc(); // Array is created only once\ngetElement(599);\ngetElement(670); function bigFunc(){\n  let newArray = new Array(700).fill('♥');\n  return (element) => newArray[element];\n}\n\nlet getElement = bigFunc(); // Array is created only once\ngetElement(599);\ngetElement(670); function bigFunc() function bigFunc  let new Array 700 '♥' return (element) => element let // Array is created only once 599 670 Code 3 - Can be modified in two ways:\n\nUsing let keyword: Code 3   let function randomFunc(){\n  for(let i = 0; i < 2; i++){\n    setTimeout(()=> console.log(i),1000);\n  }\n}\nrandomFunc(); function randomFunc(){\n  for(let i = 0; i < 2; i++){\n    setTimeout(()=> console.log(i),1000);\n  }\n}\nrandomFunc(); function randomFunc() function randomFunc  for let 0 2 setTimeout ()=> console 1000 Using closure: Using closure: function randomFunc(){\n  for(var i = 0; i < 2; i++){\n  (function(i){\n      setTimeout(()=>console.log(i),1000);\n    })(i);\n  }\n}\nrandomFunc(); function randomFunc(){\n  for(var i = 0; i < 2; i++){\n  (function(i){\n      setTimeout(()=>console.log(i),1000);\n    })(i);\n  }\n}\nrandomFunc(); function randomFunc() function randomFunc  for var 0 2 function(i) function i setTimeout ()=> console 1000",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "9. Guess the outputs of the following code:",
        "answer": "// Code 1\n\n  let hero = {\n    powerLevel: 99,\n    getPower(){\n      return this.powerLevel;\n    }\n  }\n  \n  let getPower = hero.getPower;\n  \n  let hero2 = {powerLevel:42};\n  console.log(getPower());\n  console.log(getPower.apply(hero2));\n  \n\n\n  // Code 2\n  \n  const a = function(){\n    console.log(this);\n  \n    const b = {\n      func1: function(){\n        console.log(this);\n      }  \n    }\n  \n    const c = {\n      func2: ()=>{\n        console.log(this);\n      }\n    }\n  \n    b.func1();\n    c.func2();\n  }\n  \n  a();\n  \n\n\n  // Code 3\n  \n  const b = {\n    name:\"Vivek\",\n    f: function(){\n      var self = this;\n      console.log(this.name);\n      (function(){\n        console.log(this.name);\n        console.log(self.name);\n      })();\n    }\n  }\n  b.f(); // Code 1\n\n  let hero = {\n    powerLevel: 99,\n    getPower(){\n      return this.powerLevel;\n    }\n  }\n  \n  let getPower = hero.getPower;\n  \n  let hero2 = {powerLevel:42};\n  console.log(getPower());\n  console.log(getPower.apply(hero2));\n  \n\n\n  // Code 2\n  \n  const a = function(){\n    console.log(this);\n  \n    const b = {\n      func1: function(){\n        console.log(this);\n      }  \n    }\n  \n    const c = {\n      func2: ()=>{\n        console.log(this);\n      }\n    }\n  \n    b.func1();\n    c.func2();\n  }\n  \n  a();\n  \n\n\n  // Code 3\n  \n  const b = {\n    name:\"Vivek\",\n    f: function(){\n      var self = this;\n      console.log(this.name);\n      (function(){\n        console.log(this.name);\n        console.log(self.name);\n      })();\n    }\n  }\n  b.f(); Answers:\n\nCode 1 - Output in the following order:   Code 1 undefined\n42 undefined\n42 Reason - The first output is undefined since when the function is invoked, it is invoked referencing the global object: undefined window.getPower() = getPower(); window.getPower() = getPower(); Code 2 - Outputs in the following order:  Code 2 global/window object\nobject \"b\"\nglobal/window object global/window object\nobject \"b\"\nglobal/window object Since we are using the arrow function inside func2, this keyword refers to the global object.\n\nCode 3 - Outputs in the following order:  func2, this   Code 3 \"Vivek\"\nundefined\n\"Vivek\" \"Vivek\"\nundefined\n\"Vivek\" Only in the IIFE inside the function f, this keyword refers to the global/window object. f this ",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "10. Guess the output of the following code:",
        "answer": "var x = 23;\n\n(function(){\n  var x = 43;\n  (function random(){\n    x++;\n    console.log(x);\n    var x = 21;\n  })();\n})(); var x = 23;\n\n(function(){\n  var x = 43;\n  (function random(){\n    x++;\n    console.log(x);\n    var x = 21;\n  })();\n})(); var 23 function() function  var 43 function random() function random  console var 21 Answer: Output is NaN.\n\nrandom() function has functional scope since x is declared and hoisted in the functional scope.\n\nRewriting the random function will give a better idea about the output: NaN     function random(){\n  var x; // x is hoisted\n  x++; // x is not a number since it is not initialized yet\n  console.log(x); // Outputs NaN\n  x = 21; // Initialization of x\n} function random(){\n  var x; // x is hoisted\n  x++; // x is not a number since it is not initialized yet\n  console.log(x); // Outputs NaN\n  x = 21; // Initialization of x\n} function random() function random  var // x is hoisted // x is not a number since it is not initialized yet console // Outputs NaN 21 // Initialization of x",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "11. Guess the outputs of the following code:",
        "answer": "// Code 1:\n\nlet x= {}, y = {name:\"Ronny\"},z = {name:\"John\"};\nx[y] = {name:\"Vivek\"};\nx[z] = {name:\"Akki\"};\nconsole.log(x[y]);\n\n// Code 2:\n\nfunction runFunc(){\n  console.log(\"1\" + 1);\n  console.log(\"A\" - 1);\n  console.log(2 + \"-2\" + \"2\");\n  console.log(\"Hello\" - \"World\" + 78);\n  console.log(\"Hello\"+ \"78\");\n}\nrunFunc();\n\n// Code 3:\n\nlet a = 0;\nlet b = false;\nconsole.log((a == b));\nconsole.log((a === b)); // Code 1:\n\nlet x= {}, y = {name:\"Ronny\"},z = {name:\"John\"};\nx[y] = {name:\"Vivek\"};\nx[z] = {name:\"Akki\"};\nconsole.log(x[y]);\n\n// Code 2:\n\nfunction runFunc(){\n  console.log(\"1\" + 1);\n  console.log(\"A\" - 1);\n  console.log(2 + \"-2\" + \"2\");\n  console.log(\"Hello\" - \"World\" + 78);\n  console.log(\"Hello\"+ \"78\");\n}\nrunFunc();\n\n// Code 3:\n\nlet a = 0;\nlet b = false;\nconsole.log((a == b));\nconsole.log((a === b)); // Code 1: let name \"Ronny\" name \"John\" name \"Vivek\" name \"Akki\" console // Code 2: function runFunc() function runFunc  console \"1\" 1 console \"A\" 1 console 2 \"-2\" \"2\" console \"Hello\" \"World\" 78 console \"Hello\" \"78\" // Code 3: let 0 let false console console Answers:\n\nCode 1 - Output will be {name: “Akki”}.\n\nAdding objects as properties of another object should be done carefully.\n\nWriting x[y] = {name:”Vivek”} , is same as writing x[‘object Object’] = {name:”Vivek”} ,\n\nWhile setting a property of an object, javascript coerces the parameter into a string.\n\nTherefore, since y is an object, it will be converted to ‘object Object’.\n\nBoth x[y] and x[z] are referencing the same property.\n\nCode 2 - Outputs in the following order: Answers:   Code 1 {name: “Akki”}.     x[y] = {name:”Vivek”} x[‘object Object’] = {name:”Vivek”}   javascript coerces the parameter into a string.   y ‘object Object’.     Code 2 11\nNan\n2-22\nNaN\nHello78 11\nNan\n2-22\nNaN\nHello78 11 2 22 NaN Code 3 - Output in the following order due to equality coercion: Code 3 true\nfalse true\nfalse true false",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "12. Guess the outputs of the following codes:",
        "answer": "// Code 1:\n\nfunction func1(){\n  setTimeout(()=>{\n    console.log(x);\n    console.log(y);\n  },3000);\n\n  var x = 2;\n  let y = 12;\n}\nfunc1();\n\n// Code 2:\n\nfunction func2(){\n  for(var i = 0; i < 3; i++){\n    setTimeout(()=> console.log(i),2000);\n}\n}\nfunc2();\n\n// Code 3:\n\n(function(){\n  setTimeout(()=> console.log(1),2000);\n  console.log(2);\n  setTimeout(()=> console.log(3),0);\n  console.log(4);\n})(); // Code 1:\n\nfunction func1(){\n  setTimeout(()=>{\n    console.log(x);\n    console.log(y);\n  },3000);\n\n  var x = 2;\n  let y = 12;\n}\nfunc1();\n\n// Code 2:\n\nfunction func2(){\n  for(var i = 0; i < 3; i++){\n    setTimeout(()=> console.log(i),2000);\n}\n}\nfunc2();\n\n// Code 3:\n\n(function(){\n  setTimeout(()=> console.log(1),2000);\n  console.log(2);\n  setTimeout(()=> console.log(3),0);\n  console.log(4);\n})(); // Code 1: function func1() function func1  setTimeout ()=> console console 3000 var 2 let 12 // Code 2: function func2() function func2  for var 0 3 setTimeout ()=> console 2000 // Code 3: function() function  setTimeout ()=> console 1 2000 console 2 setTimeout ()=> console 3 0 console 4 Answers: Answers: Code 1 - Outputs 2 and 12. Since, even though let variables are not hoisted, due to the async nature of javascript, the complete function code runs before the setTimeout function. Therefore, it has access to both x and y.\nCode 2 - Outputs 3, three times since variable declared with var keyword does not have block scope. Also, inside the for loop, the variable i is incremented first and then checked.\nCode 3 - Output in the following order: Code 1 - Outputs 2 and 12. Since, even though let variables are not hoisted, due to the async nature of javascript, the complete function code runs before the setTimeout function. Therefore, it has access to both x and y. Code 1 2 12 let Code 2 - Outputs 3, three times since variable declared with var keyword does not have block scope. Also, inside the for loop, the variable i is incremented first and then checked. Code 2 3 var Code 3 - Output in the following order: Code 3 2\n4\n3\n1 // After two seconds 2\n4\n3\n1 // After two seconds 2 4 3 1 // After two seconds Even though the second timeout function has a waiting time of zero seconds, the javascript engine always evaluates the setTimeout function using the Web API, and therefore, the complete function executes before the setTimeout function can execute.",
        "reference": "interviewbit.com",
        "role": "javascript"
    },
    {
        "question": "1) What is JavaScript?",
        "answer": "JavaScript is a scripting language. It is different from Java language. It is object-based, lightweight, cross-platform translated language. It is widely used for client-side validation. The JavaScript Translator (embedded in the browser) is responsible for translating the JavaScript code for the web browser. More details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "",
        "answer": "Some of the features of JavaScript are:\nADVERTISEMENT\nLightweight\nInterpreted programming language\nGood for the applications which are network-centric\nComplementary to Java\nComplementary to HTML\nOpen source\nCross-platform",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "3) Who developed JavaScript, and what was the first name of JavaScript?",
        "answer": "JavaScript was developed by Brendan Eich, who was a Netscape programmer. Brendan Eich developed this new scripting language in just ten days in the year September 1995. At the time of its launch, JavaScript was initially called Mocha. After that, it was called Live Script and later known as JavaScript.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "",
        "answer": "Some of the advantages of JavaScript are:\nServer interaction is less\nFeedback to the visitors is immediate\nInteractivity is high\nInterfaces are richer",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "",
        "answer": "Some of the disadvantages of JavaScript are:\nNo support for multithreading\nNo support for multiprocessing\nReading and writing of files is not allowed\nNo support for networking applications.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "",
        "answer": "The function which has named at the time of definition is called a named function. For example\nfunction msg()  \n{  \n  document.writeln(\"Named Function\");  \n}  \nmsg();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "7) Name the types of functions",
        "answer": "The types of function are:\nNamed - These type of functions contains name at the time of definition. For Example:\nfunction display()  \n{  \n  document.writeln(\"Named Function\");  \n}  \ndisplay();  \nAnonymous - These type of functions doesn't contain any name. They are declared dynamically at runtime.\nvar display=function()  \n{  \n  document.writeln(\"Anonymous Function\");  \n}  \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "8) Define anonymous function",
        "answer": "It is a function that has no name. These functions are declared dynamically at runtime using the function operator instead of the function declaration. The function operator is more flexible than a function declaration. It can be easily used in the place of an expression. For example:\nvar display=function()  \n{  \n  alert(\"Anonymous Function is invoked\");  \n}  \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "9) Can an anonymous function be assigned to a variable?",
        "answer": "Yes, you can assign an anonymous function to a variable.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "10) In JavaScript what is an argument object?",
        "answer": "The variables of JavaScript represent the arguments that are passed to a function.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "",
        "answer": "In JavaScript, we need closures when a variable which is defined outside the scope in reference is accessed from some inner scope.\nvar num = 10;  \nfunction sum()   \n{  \ndocument.writeln(num+num);  \n}   \nsum();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "12) If we want to return the character from a specific index which method is used?",
        "answer": "The JavaScript string charAt() method is used to find out a char value present at the specified index. The index number starts from 0 and goes to n-1, where n is the length of the string. The index value can't be a negative, greater than or equal to the length of the string. For example:\nvar str=\"Javatpoint\";    \ndocument.writeln(str.charAt(4));",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "13) What is the difference between JavaScript and JScript?",
        "answer": "Netscape provided the JavaScript language. Microsoft changed the name and called it JScript to avoid the trademark issue. In other words, you can say JScript is the same as JavaScript, but Microsoft provides it.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "14) How to write a hello world example of JavaScript?",
        "answer": "A simple example of JavaScript hello world is given below. You need to place it inside the body tag of HTML.\n<script type=\"text/javascript\">  \ndocument.write(\"JavaScript Hello World!\");  \n</script>  \nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "15) What are the key differences between Java and JavaScript? / How is JavaScript different from Java?",
        "answer": "JavaScript is a lightweight programming language (most commonly known as scripting language) developed by Netscape, Inc. It is used to make web pages interactive. It is not a part of the Java platform. Following is a list of some key differences between Java and JavaScript\nA list of key differences between Java and JavaScript\nJava JavaScript\nJava is a complete and strongly typed programming language used for backend coding. In Java, variables must be declared first to use in the program, and the type of a variable is checked at compile-time. JavaScript is a weakly typed, lightweight programming language (most commonly known as scripting language) and has more relaxed syntax and rules.\nJava is an object-oriented programming (OOPS) language or structured programming languages such as C, C++, or .Net. JavaScript is a client-side scripting language, and it doesn't fully support the OOPS concept. It resides inside the HTML documents and is used to make web pages interactive (not achievable with simple HTML).\nJava creates applications that can run in any virtual machine (JVM) or browser. JavaScript code can run only in the browser, but it can now run on the server via Node.js.\nThe Java code needs to be compiled. The JavaScript code doesn't require to be complied.\nJava Objects are class-based. You can't make any program in Java without creating a class. JavaScript Objects are prototype-based.\nJava is a Complete and Standalone language that can be used in backend coding. JavaScript is assigned within a web page and integrates with its HTML content.\nJava programs consume more memory. JavaScript code is used in HTML web pages and requires less memory.\nThe file extension of the Java program is written as \".Java\" and it translates source code into bytecodes which are then executed by JVM (Java Virtual Machine). The JavaScript file extension is written as \".js\" and it is interpreted but not compiled. Every browser has a JavaScript interpreter to execute the JS code.\nJava supports multithreading. JavaScript doesn't support multithreading.\nJava uses a thread-based approach to concurrency. JavaScript uses an event-based approach to concurrency.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "16) How to use external JavaScript file?",
        "answer": "I am assuming that js file name is message.js, place the following script tag inside the head tag.\n<script type=\"text/javascript\" src=\"message.js\"></script>  \nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "17) Is JavaScript case sensitive language?",
        "answer": "Yes, JavaScript is a case sensitive language. For example:\nVar msg = \"JavaScript is a case-sensitive language\"; //Here, var should be used to declare a variable  \nfunction display()   \n{  \ndocument.writeln(msg); // It will not display the result.  \n}   \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "18) What is BOM?",
        "answer": "BOM stands for Browser Object Model. It provides interaction with the browser. The default object of a browser is a window. So, you can call all the functions of the window by specifying the window or directly. The window object provides various properties like document, history, screen, navigator, location, innerHeight, innerWidth,\n\nMore Details: Browser Object Model",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "19) What is DOM? What is the use of document object?",
        "answer": "DOM stands for Document Object Model. A document object represents the HTML document. It can be used to access and change the content of HTML.\nMore Details: Document Object Model",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "20) What is the use of window object?",
        "answer": "The window object is created automatically by the browser that represents a window of a browser. It is not an object of JavaScript. It is a browser object.\n\nThe window object is used to display the popup dialog box. Let's see with description.\nMethod Description\nalert() displays the alert box containing the message with ok button.\nconfirm() displays the confirm dialog box containing the message with ok and cancel button.\nprompt() displays a dialog box to get input from the user.\nopen() opens the new window.\nclose() closes the current window.\nsetTimeout() performs the action after specified time like calling function, evaluating expressions.\nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "21) What is the use of history object?",
        "answer": "The history object of a browser can be used to switch to history pages such as back and forward from the current page or another page. There are three methods of history object.\nhistory.back() - It loads the previous page.\nhistory.forward() - It loads the next page.\nhistory.go(number) - The number may be positive for forward, negative for backward. It loads the given page number.\nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "22) How to write a comment in JavaScript?",
        "answer": "There are two types of comments in JavaScript.\nSingle Line Comment: It is represented by // (double forward slash)\nMulti-Line Comment: Slash represents it with asterisk symbol as /* write comment here */\nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "23) How to create a function in JavaScript?",
        "answer": "To create a function in JavaScript, follow the following syntax.\nfunction function_name(){  \n//function body  \n}  \nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "24) What are the different data types present in JavaScript?",
        "answer": "There are two types of data types in JavaScript:\nPrimitive data types\nNon- Primitive data types\nPrimitive data types\n\nThe primitive data types are as follows:\nString: The string data type represents a sequence of characters. It is written within quotes and can be represented using a single or a double quote.\nExample:\nvar str1 = \"Hello JavaTpoint\"; //using double quotes  \nvar str2 = 'Hello Javatpoint'; //using single quotes  \nNumber: The number data type is used to represent numeric values and can be written with or without decimals.\nExample:\nvar x = 5; //without decimal  \nvar y = 5.0; //with decimal  \nBoolean: The Boolean data type is used to represent a Boolean value, either false or true. This data type is generally used for conditional testing.\nExample:\nvar x = 5;  \nvar y =  6;  \nvar z =  5;  \n(x == y) // returns false  \n(x == z) //returns true  \nBigInt: The BigInt data type is used to store numbers beyond the Number data type limitation. This data type can store large integers and is represented by adding \"n\" to an integer literal.\nExample:\nvar bigInteger =  123456789012345678901234567890;  \n// This is an example of bigInteger.  \nUndefined: The Undefined data type is used when a variable is declared but not assigned. The value of this data type is undefined, and its type is also undefined.\nExample:\nvar x; // value of x is undefined  \nvar y = undefined; // You can also set the value of a variable as undefined.  \nNull: The Null data type is used to represent a non-existent, null, or a invalid value i.e. no value at all.\nExample:\nvar  x = null;  \nSymbol: Symbol is a new data type introduced in the ES6 version of JavaScript. It is used to store an anonymous and unique value.\nExample:\nvar symbol1 = Symbol('symbol');  \ntypeof: The typeof operator is used to determine what type of data a variable or operand contains. It can be used with or without parentheses (typeof(x) or typeof x). This is mainly used in situations when you need to process the values of different types.\nExample:\ntypeof 10;  // Returns: \"number\"  \ntypeof 10.0;  // Returns: \"number\"  \ntypeof 2.5e-4;  // Returns: \"number\"  \ntypeof Infinity;  // Returns: \"number\"  \ntypeof NaN;  // Returns: \"number\". Despite being \"Not-A-Number\"  \n// Strings  \ntypeof '';  // Returns: \"string\"  \ntypeof 'Welcome to JavaTpoint';  // Returns: \"string\"  \ntypeof '12';  // Returns: \"string\". Number within quotes is typeof string  \n// Booleans  \ntypeof true;  // Returns: \"boolean\"  \ntypeof false;  // Returns: \"boolean\"  \n// Undefined  \ntypeof undefined;  // Returns: \"undefined\"  \ntypeof undeclaredVariable; // Returns: \"undefined\"  \n// Null  \ntypeof Null;  // Returns: \"object\"  \n// Objects  \ntypeof {name: \"John\", age: 18};  // Returns: \"object\"  \n// Arrays  \ntypeof [1, 2, 3];  // Returns: \"object\"  \n// Functions  \ntypeof function(){};  // Returns: \"function\"  \nNon-Primitive data types\nIn the above examples, we can see that the primitive data types can store only a single value. To store multiple and complex values, we have to use non-primitive data types.\nThe non-primitive data types are as follows:\nObject: The Object is a non-primitive data type. It is used to store collections of data. An object contains properties, defined as a key-value pair. A property key (name) is always a string, but the value can be any data type, such as strings, numbers, Booleans, or complex data types like arrays, functions, and other objects.\nExample:\n// Collection of data in key-value pairs  \nvar obj1 = {  \n   x:  123,  \n   y:  \"Welcome to JavaTpoint\",  \n   z: function(){  \n      return this.x;  \n   }  \n}  \nArray: The Array data type is used to represent a group of similar values. Every value in an array has a numeric position, called its index, and it may contain data of any data type-numbers, strings, Booleans, functions, objects, and even other arrays. The array index starts from 0 so that the first array element is arr[0], not arr[1].\nExample:\nvar colors = [\"Red\", \"Yellow\", \"Green\", \"Orange\"];  \nvar cities = [\"Noida\", \"Delhi\", \"Ghaziabad\"];  \nalert(colors[2]);   // Output: Green  \nalert(cities[1]);   // Output: Delhi  \nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "25) What is the difference between == and ===?",
        "answer": "The == operator checks equality only whereas === checks equality, and data type, i.e., a value must be of the same type.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "26) How to write HTML code dynamically using JavaScript?",
        "answer": "The innerHTML property is used to write the HTML code using JavaScript dynamically. Let's see a simple example:\ndocument.getElementById('mylocation').innerHTML=\"<h2>This is heading using JavaScript</h2>\";   \nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "27) How to write normal text code using JavaScript dynamically?",
        "answer": "The innerText property is used to write the simple text using JavaScript dynamically. Let's see a simple example:\ndocument.getElementById('mylocation').innerText=\"This is text using JavaScript\";   \nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "28) How to create objects in JavaScript?",
        "answer": "There are 3 ways to create an object in JavaScript.\nBy object literal\nBy creating an instance of Object\nBy Object Constructor\nLet's see a simple code to create an object using object literal.\nemp={id:102,name:\"Rahul Kumar\",salary:50000}   \nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "29) How to create an array in JavaScript?",
        "answer": "There are 3 ways to create an array in JavaScript.\nBy array literal\nBy creating an instance of Array\nBy using an Array constructor\nLet's see a simple code to create an array using object literal.\nvar emp=[\"Shyam\",\"Vimal\",\"Ratan\"];    \nMore details.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "30) What does the isNaN() function?",
        "answer": "The isNan() function returns true if the variable value is not a number. For example:\nfunction number(num) {  \n  if (isNaN(num)) {  \n    return \"Not a Number\";  \n  }  \n  return \"Number\";  \n}  \nconsole.log(number('1000F'));  \n// expected output: \"Not a Number\"  \n  console.log(number('1000'));  \n// expected output: \"Number\"",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "31) What is the output of 10+20+\"30\" in JavaScript?",
        "answer": "3030 because 10+20 will be 30. If there is numeric value before and after +, it treats as binary + (arithmetic operator).\nfunction display()  \n{  \n  document.writeln(10+20+\"30\");  \n}  \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "32) What is the output of \"10\"+20+30 in JavaScript?",
        "answer": "102030 because after a string all the + will be treated as string concatenation operator (not binary +).\nfunction display()  \n{  \n  document.writeln(\"10\"+20+30);  \n}  \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "33) Difference between Client side JavaScript and Server side JavaScript?",
        "answer": "Client-side JavaScript comprises the basic language and predefined objects which are relevant to running JavaScript in a browser. The client-side JavaScript is embedded directly by in the HTML pages. The browser interprets this script at runtime.\nServer-side JavaScript also resembles client-side JavaScript. It has a relevant JavaScript which is to run in a server. The server-side JavaScript are deployed only after compilation.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "34) In which location cookies are stored on the hard disk?",
        "answer": "The storage of cookies on the hard disk depends on the OS and the browser.\nThe Netscape Navigator on Windows uses a cookies.txt file that contains all the cookies. The path is c:\\Program Files\\Netscape\\Users\\username\\cookies.txt\nThe Internet Explorer stores the cookies on a file [email protected] The path is: c:\\Windows\\Cookies\\[email protected]",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "stopPropagation() methods in JavaScript?",
        "answer": "In JavaScript, the event.preventDefault() method is used to prevent the default behavior of an element.\nFor example: If you use it in a form element, it prevents it from submitting. If used in an anchor element, it prevents it from navigating. If used in a contextmenu, it prevents it from showing or displaying.\nOn the other hand, the event.stopPropagation() method is used to stop the propagation of an event or stop the event from occurring in the bubbling or capturing phase.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "36) What is the real name of JavaScript?",
        "answer": "The original name was Mocha, a name chosen by Marc Andreessen, founder of Netscape. In September of 1995, the name was changed to LiveScript. In December 1995, after receiving a trademark license from Sun, the name JavaScript was adopted.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "preventDefault() method was used in an element?",
        "answer": "When we use the event.defaultPrevent() method in the event object returns a Boolean indicating that the event.preventDefault() was called in a particular element.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "38) What is the difference between undefined value and null value?",
        "answer": "Undefined value: A value that is not defined and has no keyword is known as undefined value. For example:\nint number;//Here, a number has an undefined value.  \nNull value: A value that is explicitly specified by the keyword \"null\" is known as a null value. For example:\nString str=null;//Here, str has a null value.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "39) How to set the cursor to wait in JavaScript?",
        "answer": "The cursor can be set to wait in JavaScript by using the property \"cursor\". The following example illustrates the usage:\n<script>  \nwindow.document.body.style.cursor = \"wait\";   \n</script>",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "40) What is this [[[]]]?",
        "answer": "This is a three-dimensional array.\nvar myArray = [[[]]];",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "41) Are Java and JavaScript same?",
        "answer": "No, Java and JavaScript are the two different languages. Java is a robust, secured and object-oriented programming language whereas JavaScript is a client-side scripting language with some limitations.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "42) What is negative infinity?",
        "answer": "Negative Infinity is a number in JavaScript which can be derived by dividing the negative number by zero. For example:\nvar num=-5;  \nfunction display()  \n{  \n  document.writeln(num/0);  \n}  \ndisplay();  \n//expected output: -Infinity",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "43) What is the difference between View state and Session state?",
        "answer": "\"View state\" is specific to a page in a session whereas \"Session state\" is specific to a user or browser that can be accessed across all pages in the web application.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "44) What are the pop-up boxes available in JavaScript?",
        "answer": "Alert Box\nConfirm Box\nPrompt Box\nExample of alert() in JavaScript\n<script type=\"text/javascript\">  \nfunction msg(){  \n alert(\"Hello Alert Box\");  \n}  \n</script>  \n<input type=\"button\" value=\"click\" onclick=\"msg()\"/>  \nExample of confirm() in JavaScript\n<script type=\"text/javascript\">  \nfunction msg(){  \nvar v= confirm(\"Are u sure?\");  \nif(v==true){  \nalert(\"ok\");  \n}  \nelse{  \nalert(\"cancel\");  \n}  \n  }  \n</script>  \n  <input type=\"button\" value=\"delete record\" onclick=\"msg()\"/>  \nExample of prompt() in JavaScript\n<script type=\"text/javascript\">  \nfunction msg(){  \nvar v= prompt(\"Who are you?\");  \nalert(\"I am \"+v);  \n  }  \n</script>  \n  <input type=\"button\" value=\"click\" onclick=\"msg()\"/>",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "45) How can we detect OS of the client machine using JavaScript?",
        "answer": "The navigator.appVersion string can be used to detect the operating system on the client machine.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "46) How to submit a form using JavaScript by clicking a link?",
        "answer": "Let's see the JavaScript code to submit the form by clicking the link.\n<form name=\"myform\" action=\"index.php\">  \nSearch: <input type='text' name='query' />  \n<a href=\"javascript: submitform()\">Search</a>  \n</form>  \n<script type=\"text/javascript\">  \nfunction submitform()  \n{  \n  document.myform.submit();  \n}  \n</script>",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "47) Is JavaScript faster than ASP script?",
        "answer": "Yes, because it doesn't require web server's support for execution.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "48) How to change the background color of HTML document using JavaScript?",
        "answer": "<script type=\"text/javascript\">  \ndocument.body.bgColor=\"pink\";  \n</script>",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "49) How to handle exceptions in JavaScript?",
        "answer": "By the help of try/catch block, we can handle exceptions in JavaScript. JavaScript supports try, catch, finally and throw keywords for exception handling.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "50) How to validate a form in JavaScript?",
        "answer": "<script>  \nfunction validateform(){  \nvar name=document.myform.name.value;  \nvar password=document.myform.password.value;  \n  if (name==null || name==\"\"){  \n  alert(\"Name can't be blank\");  \n  return false;  \n}else if(password.length<6){  \n  alert(\"Password must be at least 6 characters long.\");  \n  return false;  \n  }  \n}  \n</script>  \n<body>  \n<form name=\"myform\" method=\"post\" action=\"abc.jsp\" onsubmit=\"return validateform()\" >  \nName: <input type=\"text\" name=\"name\"><br/>  \nPassword: <input type=\"password\" name=\"password\"><br/>  \n<input type=\"submit\" value=\"register\">  \n</form>  \nTest it Now\nVisit here: JavaScript form validation.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "51) How to validate email in JavaScript?",
        "answer": "<script>  \nfunction validateemail()  \n{  \nvar x=document.myform.email.value;  \nvar atposition=x.indexOf(\"@\");  \nvar dotposition=x.lastIndexOf(\".\");  \nif (atposition<1 || dotposition<atposition+2 || dotposition+2>=x.length){  \n  alert(\"Please enter a valid e-mail address \\n atpostion:\"+atposition+\"\\n dotposition:\"+dotposition);  \n  return false;  \n  }  \n}  \n</script>  \n<body>  \n<form name=\"myform\"  method=\"post\" action=\"#\" onsubmit=\"return validateemail();\">  \nEmail: <input type=\"text\" name=\"email\"><br/>  \n  <input type=\"submit\" value=\"register\">  \n</form>  \nTest it Now\nVisit here: JavaScript Email validation.",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "52) What is this keyword in JavaScript?",
        "answer": "The this keyword is a reference variable that refers to the current object. For example:\nvar address=    \n{    \ncompany:\"Javatpoint\",    \ncity:\"Noida\",    \nstate:\"UP\",    \nfullAddress:function()    \n{    \nreturn this.company+\" \"+this.city+\" \"+this.state;    \n}    \n};    \nvar fetch=address.fullAddress();    \ndocument.writeln(fetch);",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "53) What is the requirement of debugging in JavaScript?",
        "answer": "JavaScript didn't show any error message in a browser. However, these mistakes can affect the output. The best practice to find out the error is to debug the code. The code can be debugged easily by using web browsers like Google Chrome, Mozilla Firebox.\nTo perform debugging, we can use any of the following approaches:\nUsing console.log() method\nUsing debugger keyword",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "54) What is the use of debugger keyword in JavaScript?",
        "answer": "JavaScript debugger keyword sets the breakpoint through the code itself. The debugger stops the execution of the program at the position it is applied. Now, we can start the flow of execution manually. If an exception occurs, the execution will stop again on that particular line.. For example:\nfunction display()  \n{  \nx = 10;    \ny = 15;    \nz = x + y;    \ndebugger;    \ndocument.write(z);    \ndocument.write(a);     \n}     \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "55) What is the role of a strict mode in JavaScript?",
        "answer": "The JavaScript strict mode is used to generates silent errors. It provides \"use strict\"; expression to enable the strict mode. This expression can only be placed as the first statement in a script or a function. For example:\n\"use strict\";    \nx=10;    \nconsole.log(x);",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "57) What is the use of Math object in JavaScript?",
        "answer": "The JavaScript math object provides several constants and methods to perform a mathematical operation. Unlike date object, it doesn't have constructors. For example:\nfunction display()  \n{  \n  document.writeln(Math.random());  \n}  \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "58) What is the use of a Date object in JavaScript?",
        "answer": "The JavaScript date object can be used to get a year, month and day. You can display a timer on the webpage by the help of JavaScript date object.\nfunction display()  \n{  \n  var date=new Date();    \nvar day=date.getDate();    \nvar month=date.getMonth()+1;    \nvar year=date.getFullYear();    \ndocument.write(\"<br>Date is: \"+day+\"/\"+month+\"/\"+year);    \n}  \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "59) What is the use of a Number object in JavaScript?",
        "answer": "The JavaScript number object enables you to represent a numeric value. It may be integer or floating-point. JavaScript number object follows the IEEE standard to represent the floating-point numbers.\nfunction display()  \n{  \nvar x=102;//integer value    \nvar y=102.7;//floating point value    \nvar z=13e4;//exponent value, output: 130000    \nvar n=new Number(16);//integer value by number object    \ndocument.write(x+\" \"+y+\" \"+z+\" \"+n);    \n}     \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "60) What is the use of a Boolean object in JavaScript?",
        "answer": "The JavaScript Boolean is an object that represents value in two states: true or false. You can create the JavaScript Boolean object by Boolean() constructor.\nfunction display()  \n{  \ndocument.writeln(10<20);//true    \ndocument.writeln(10<5);//false     \n}     \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "61) What is the use of a TypedArray object in JavaScript?",
        "answer": "The JavaScript TypedArray object illustrates an array like a view of an underlying binary data buffer. There is any number of different global properties, whose values are TypedArray constructors for specific element types.\nfunction display()  \n{  \nvar arr1= [1,2,3,4,5,6,7,8,9,10];     \n       arr1.copyWithin(2) ;   \n       document.write(arr1);    \n}  \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "62) What is the use of a Set object in JavaScript?",
        "answer": "The JavaScript Set object is used to store the elements with unique values. The values can be of any type i.e. whether primitive values or object references. For example:\nfunction display()  \n{  \nvar set = new Set();    \nset.add(\"jQuery\");    \nset.add(\"AngularJS\");    \nset.add(\"Bootstrap\");    \nfor (let elements of set) {    \n document.writeln(elements+\"<br>\");    \n}     \n}  \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "63) What is the use of a WeakSet object in JavaScript?",
        "answer": "The JavaScript WeakSet object is the type of collection that allows us to store weakly held objects. Unlike Set, the WeakSet are the collections of objects only. It doesn't contain the arbitrary values. For example:\nfunction display()  \n{  \nvar ws = new WeakSet();    \nvar obj1={};    \nvar obj2={};    \nws.add(obj1);    \nws.add(obj2);    \n//Let's check whether the WeakSet object contains the added object    \ndocument.writeln(ws.has(obj1)+\"<br>\");    \ndocument.writeln(ws.has(obj2));     \n}     \ndisplay()",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "64) What is the use of a Map object in JavaScript?",
        "answer": "The JavaScript Map object is used to map keys to values. It stores each element as key-value pair. It operates the elements such as search, update and delete on the basis of specified key. For example:\nfunction display()  \n{  \nvar map=new Map();    \nmap.set(1,\"jQuery\");    \nmap.set(2,\"AngularJS\");    \nmap.set(3,\"Bootstrap\");    \ndocument.writeln(map.get(1)+\"<br>\");    \ndocument.writeln(map.get(2)+\"<br>\");    \ndocument.writeln(map.get(3));    \n}  \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "65) What is the use of a WeakMap object in JavaScript?",
        "answer": "The JavaScript WeakMap object is a type of collection which is almost similar to Map. It stores each element as a key-value pair where keys are weakly referenced. Here, the keys are objects and the values are arbitrary values. For example:\nfunction display()  \n{  \nvar wm = new WeakMap();    \nvar obj1 = {};    \nvar obj2 = {};    \nvar obj3= {};    \nwm.set(obj1, \"jQuery\");    \nwm.set(obj2, \"AngularJS\");    \nwm.set(obj3,\"Bootstrap\");    \ndocument.writeln(wm.has(obj2));     \n}     \ndisplay();",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "66) What are the falsy values in JavaScript, and how can we check if a value is falsy?",
        "answer": "Those values which become false while converting to Boolean are called falsy values.\nconst falsyValues = ['', 0, null, undefined, NaN, false];   \nWe can check if a value is falsy by using the Boolean function or the Double NOT operator (!!).",
        "reference": "javatpoint.com",
        "role": "javascript"
    },
    {
        "question": "67) What do you understand by hoisting in JavaScript?",
        "answer": "Hoisting is the default behavior of JavaScript where all the variable and function declarations are moved on top. In simple words, we can say that Hoisting is a process in which, irrespective of where the variables and functions are declared, they are moved on top of the scope. The scope can be both local and global.\nExample 1:\nhoistedVariable = 12;  \nconsole.log(hoistedVariable); // outputs 12 even when the variable is declared after it is initialized    \nvar hoistedVariable;  \nExample2:\nhoistedFunction();  // Outputs \" Welcome to JavaTpoint \" even when the function is declared after calling  \nfunction hoistedFunction(){   \n  console.log(\" Welcome to JavaTpoint \");  \n}  \nExample3:  \n// Hoisting in a local scope   \nfunction doSomething(){  \n  x = 11;  \n  console.log(x);  \n  var x;  \n}  \ndoSomething(); // Outputs 11 since the local variable \"x\" is hoisted inside the local scope  \nJavaScript MCQ\n1) Which of the following statement is true?\nIf onKeyDown returns false, the key-up event is canceled.\nIf onKeyDown returns false, the key-press event is canceled.\nIf onKeyPress returns false, the key-down event is canceled.\nIf onKeyPress returns false, the key-up event is canceled.\nShow Answer\nWorkspace\n\n\n2) Which of the following statement shows the primary difference between JavaScript and Java?\nThere is no difference between JavaScript and Java.\nFunctions are considered as fields.\nVariables are specific.\nFunctions are values, and there is no such distinction between methods and fields.\nShow Answer\nWorkspace\n\n\n3) Which of the following syntax is valid for creating a RegExp object?\n1. var txt=new RegExp(pattern,attributes);  \n2. var txt=/pattern/attributes;  \nOnly 1 syntax\nOnly 2 syntax\nBoth 1 and 2 syntax\nNone of the above\nShow Answer\nWorkspace\n\n\n4) Which of the following statement specifies the meaning of Augmenting classes?\nObjects inherit prototype properties even in a dynamic state.\nObjects inherit prototype properties only in a dynamic state.\nObjects inherit prototype properties in the static state.\nAn object doesn't inherit prototype properties in the static state.\nShow Answer\nWorkspace\n\n\n5) If para1 is the DOM object for a paragraph, which of the following would be the correct syntax to change the text within the paragraph?\npara1=\"New Text\"\nfirstChild.nodeValue= \"New Text\";\nvalue=\"New Text\";\nnodeValue=\"New Text\";\nShow Answer\nWorkspace\n\n\n6) Which of the following is used to define the behavior of the instances present of a class inside a method?\nMethod\nClasses\nInterfaces\nClasses and Interfaces\nShow Answer\nWorkspace\n\n\n7) Which of the following statement is true in the case of the property of the JSON() method?\nA JSON() method can be invoked manually as object.JSON()\nA JSON() method is invoked automatically by the JSON.stringify() method\nA JSON() method is automatically invoked by the compiler.\nA JSON() method cannot be invoked in any form.\nShow Answer\nWorkspace\n\n\n8) Which of the following statement is true if class B can extend another class A?\nA is the superclass, and B is the subclass.\nB is the superclass, and A is the subclass.\nBoth A and B are the superclass.\nBoth A and B are subclass.\nShow Answer\nWorkspace\n\n\n9) Which of the following is the correct syntax of the eval() function?\n[objectName.]eval(numeric)\n[EvalName.]eval(string)\n[EvalName.]eval(numeric)\n[objectName.]eval(string)\nShow Answer\nWorkspace\n\n\n10) What would be the output of the following JavaScript code?\nconst obj1 =   \n{    \n    a: 10,    \n    b: 15,    \n    c: 18    \n};    \nconst obj2 = Object.assign({c: 11, d: 12}, obj1);    \nconsole.log(obj2.c, obj2.d);   \n10, 12\n11, 12\nUndefined\nError\nShow Answer\nWorkspace",
        "reference": "javatpoint.com",
        "role": "javascript"
    }
]