[
    {
        "question": "1. What is COBOL? What are the main features of COBOL?",
        "answer": "COBOL stands for Common Business-Oriented Language. It was developed in the late 1950s as a programming language specifically designed for business applications.\nThe main features of COBOL are the following:\nEnglish-Like Syntax: COBOL’s syntax is designed to resemble English, making it easy for programmers to understand and write code.\nData Handling: COBOL is well-suited for handling large volumes of data, which is crucial for business applications dealing with extensive datasets.\nArithmetic Operations: It provides robust capabilities for performing complex arithmetic calculations, which are essential for financial and scientific computations.\nReport Generation: COBOL supports the generation of formatted reports, enabling a clear and organized presentation of data.\nCompatibility: COBOL is designed to be compatible with various hardware and software platforms, ensuring versatility and adaptability.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "2. How would you declare variables in COBOL?",
        "answer": "In COBOL, variables can be declared using either the level-number or picture clause methods. The level-number method assigns a specific hierarchy to each variable based on its usage within the program, while the picture clause method allows you to define specific rules about what type of data can be stored in each variable.\nGet 100% Hike!\nMaster Most in Demand Skills Now!\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "3. How can COBOL be used in business?",
        "answer": "COBOL, or Common Business Oriented Language, has been a staple programming language in the business industry for over 60 years. It was designed specifically to handle large-scale data processing and is therefore widely used in industries such as banking, finance, insurance, and government.\nOne of the main ways COBOL is used in business is for legacy systems. Many businesses still rely on older computer systems that were developed using COBOL. These systems are often too expensive or risky to replace entirely, so businesses continue to use them while updating certain parts with newer technologies.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "4. How can you implement multi-threading in COBOL programs?",
        "answer": "COBOL does not have built-in support for multi-threading. However, if your COBOL program runs under a supporting environment (such as IBM’s z/OS), you can utilize Language Environment (LE) features like Language Environment User-Managed Threads (UMTs) or Asynchronous Concurrency support to achieve multi-threading. These features allow multiple threads of execution within a single COBOL program, enabling concurrent processing and improved performance.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "5. What is the difference between CALL and LINK statements in COBOL?",
        "answer": "The CALL statement is used to invoke a subprogram or a program at runtime. It transfers control to the called program, and control returns to the calling program after the called program completes execution. On the other hand, the LINK statement establishes direct program-to-program communication and transfers control to the linked program. The control does not automatically return to the calling program after the linked program completes execution, so an explicit RETURN statement is needed to transfer control back.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "6. How can you perform dynamic memory allocation in COBOL?",
        "answer": "COBOL supports dynamic memory allocation through the CEEGTST and CEEBRK routines, which are part of the Language Environment (LE) services. These routines allow you to dynamically allocate and deallocate memory during program execution. You can call these routines using the CALL statement to allocate memory and retrieve a pointer to the allocated memory area.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "7. How can you handle exceptions and errors in COBOL?",
        "answer": "COBOL provides the ON EXCEPTION and NOT ON EXCEPTION phrases for handling exceptions and errors. The ON EXCEPTION phrase is used to specify a section of code to execute when an exception occurs, while the NOT ON EXCEPTION phrase defines a section to execute when no exception occurs. Additionally, COBOL provides the FILE STATUS clause to handle file-related errors and the USE AFTER EXCEPTION phrase to handle exceptional conditions for a specific record.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "8. What is a COBOL paragraph?",
        "answer": "A COBOL paragraph is a user-defined or predefined name followed by a period. It consists of zero or more sentences. It is the subdivision of a “Section” or “Division.”\nExample 1. Division -> paragraph -> sentences",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "9. Mention any three Divisions of COBOL.",
        "answer": "Identification Division: The IDENTIFICATION DIVISION identifies the program with a name and, optionally, gives other identifying information, such as the Author’s name, the program compiled date (last modified), etc.\nEnvironment Division: The Environment Division describes the aspects of your program that depend on the computing environment, such as the computer configuration and the computer inputs and outputs.\nData Division: The Data Division is where the characteristics of data are defined in one of the following sections:\nFile Section:\nIt defines data used in input-output operations.\nLinkage Section:\nIt describes data from another program when defining data developed for internal processing.\nWorking-Storage Section:\nIt is the storage allocated and remaining for the life of the program.\nLocal-Storage Section:\nStorage is allocated each time a program is called and de-allocated when the program ends.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "10. How do you load a table dynamically in COBOL?",
        "answer": "To load a table dynamically, we need to use the PERFORM statement with either subscripting or indexing.\nProper data management is of utmost importance to maintain data within the allocated table space, mitigating the risks associated with data overflow or exceeding capacity.\nDetermine Table Size: Calculate the size of the table you want to create dynamically based on the data it will hold and the number of records it needs to accommodate.\nAllocate Memory: Use appropriate language-specific or system-specific functions to dynamically allocate memory for the table. In COBOL, you can achieve this through techniques like “Working-Storage Section” or “Linkage Section” with POINTER data types.\nRead Data: Retrieve the data from an external source (e.g., a file, database, or user input) that you want to load into the table.\nPopulate the Table: As you read the data, dynamically store it in the memory space allocated for the table. Ensure that you handle the data correctly based on the table’s structure and format.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "11. How is COBOL code used for sequential handling?",
        "answer": "COBOL code used for sequential file handling involves the following steps:\nENVIRONMENT DIVISION.\n– SELECT clauses\n– ASSIGN clauses\nDATA DIVISION.\n– FD statements\nPROCEDURE DIVISION.\n– OPEN statements\n– CLOSE statements\n– READ INTO statement\n– WRITE FROM statement",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "12. What are datasets, records, and fields?",
        "answer": "Datasets: Datasets are logical or physical collections of data records. They serve as containers that hold related information, structured in a way that facilitates efficient data access and management. Datasets can represent files stored on disk or datasets maintained within a database system.\nRecords: Records are individual units of data within a dataset. Each record contains a set of related information, representing a single entity or data entry. In a database context, records are equivalent to rows in a table, with each record holding specific attributes or fields.\nFields: Fields are the smallest components within a record and represent individual data elements. They store the actual data values corresponding to specific attributes of the entity represented by the record. Fields can be data types like text, numbers, dates, or other formats, depending on the nature of the data they hold.\nUnderstanding datasets, records, and fields is crucial for effective data management and manipulation in various applications, including database systems, file processing, and programming in languages like COBOL.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "13. How do COBOL programming techniques read and write records sequentially?",
        "answer": "While reading records, the program must initially verify if there are any records left to read. If a record exists, its fields populate variable names as defined by the FD clause. COBOL utilizes a PERFORM statement for iteration. In computer programming, “iterative” refers to a scenario where a sequence of instructions or statements can be executed multiple times. Each pass through the sequence is known as an iteration, and this process is also commonly referred to as a loop. In other programming languages, “DO” or “FOR” statements are employed for iterative execution.\nREAD-NEXT-RECORD\nCLOSE-STOP\nREAD-RECORD\nWRITE-RECORD\nThe process of READ-NEXT-RECORD involves continuously executing READ-RECORD and WRITE-RECORD until the last record is reached. Once the last record is encountered, the program proceeds to execute CLOSE-STOP, effectively stopping the program.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "14. What are the Arithmetic expression precedence rules?",
        "answer": "Order of operation rules have been hammered into your head throughout the years of learning mathematics; remember the classic PEMDAS (parentheses, exponents, multiply, divide, add, subtract)? Arithmetic expressions in COBOL are not exempt from these rules and often use parentheses to specify the order in which elements are to be evaluated.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "15. What is an intrinsic function?",
        "answer": "Intrinsic functions are effectively re-usable code with simple syntax implementation. Intrinsic functions enable desired logic processing with a single line of code. They also have capabilities for manipulating strings and numbers. Because the value of an intrinsic function is derived automatically at the time of reference, you do not need to define these functions in the DATA DIVISION.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "16. What are the categories of intrinsic functions?",
        "answer": "The intrinsic functions possess a classification into six distinct categories, which are determined by the nature of the services they provide. They are mathematical, date/time, statistical, character-handling, financial, and general.\nIn COBOL, intrinsic functions cater to alphanumeric, national, numeric, and integer data items, each belonging to specific classes and categories. Here’s an overview of these functions:\nAlphanumeric Functions: Belonging to the alphanumeric class and category, these functions return values with an implicit usage of DISPLAY format. The number of character positions in the returned value is determined by the function definition.\nNational Functions: Falling under the national class and category, these functions return values with an implicit usage of NATIONAL format, represented in national characters (UTF-16). The number of character positions in the returned value is determined by the function definition.\nNumeric Functions: Classified under the numeric category, these functions always return values considered to have an operational sign, resulting in a numeric intermediate result.\nInteger Functions: Also part of the numeric category, integer functions return values with an operational sign and are treated as integer intermediate results. The number of digit positions in the returned value is determined by the function definition.\nBy utilizing these intrinsic functions correctly, COBOL programmers can manipulate data more effectively and efficiently, adhering to specific usage and representation requirements based on the function category.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "17. Why does ABEND happen?",
        "answer": "Unlike your normal workstation, the mainframe utilizes an instruction set architecture called the z/Architecture. This instruction set describes what instructions can be executed at the lower machine code level. In the case that the system encounters an instruction that is not permitted under the instruction set, an ABEND will happen. This can happen during the compilation, link-edit, or execution of your COBOL program.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "18. What are the best practices to avoid ABEND?",
        "answer": "To avoid ABEND, we can do something called defensive programming. It is a form of programming where we defensively design our code to ensure that it is still running under unforeseen circumstances. By doing defensive programming, we can reduce the number of bugs and make the program more predictable, regardless of the inputs.\nListed below are a few things we can do to avoid ABEND in COBOL:\nINITIALIZE Fields at the Beginning of a Routine: By using the INITIALIZE statement, you can set all fields to their default initial values, ensuring they start with the correct data at the beginning of the program. However, when using this statement, it’s essential to exercise caution and verify that any flags or accumulators dependent on specific initial values are appropriately initialized to avoid potential errors during program execution.\nI/O Statement Checking: Implementing I/O statement checking is crucial to handle potential issues related to file operations. This can be achieved by using FILE STATUS variables, which provide information about the success or failure of file-related operations. Before proceeding with any further I/O operation, you should check these FILE STATUS variables to ensure the previous I/O operation was successful.\nNumeric Field Checking: A general policy would be to not trust a numeric field we are doing math on. Assume that the input is invalid. It would be recommended to use the ON OVERFLOW and ON SIZE ERROR phrases to catch invalid or abnormal data. Special care should be taken when we need to do rounding, as truncation can occur in some cases.\nConsistent Use of Scope Terminators: It would be best practice to explicitly terminate a scope using scope terminators such as END-IF, END-COMPUTE, or END-PERFORM.\nTesting, Checking, and Peer-Review: Proper tests and peer review can be conducted to catch possible errors that may have slipped through your program. Additionally, we can also ensure that the business logic is correct.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "19. Explain the differences between static and dynamic calls in COBOL.",
        "answer": "In COBOL, static and dynamic calls are two different methods of invoking subprograms or procedures. The main differences between them are as follows:\nStatic Call\nA static call is resolved at compile time.\nThe target subprogram or procedure is known and specified in the program code during compilation.\nThe linkage editor or binder is used to create a load module that contains the addresses of all called subprograms.\nThe load module is then used at runtime, and the addresses of called subprograms are fixed.\nStatic calls are faster than dynamic calls but provide less flexibility.\nStatic calls are typically used when the program structure is fixed and known at compile time.\nDynamic Call\nA dynamic call is resolved at runtime.\nThe target subprogram or procedure is determined and specified during program execution.\nThe address of the target subprogram is not known until runtime, and it is looked up dynamically.\nDynamic calls provide more flexibility as the target can be determined based on conditions or input data.\nDynamic calls are slower than static calls due to the additional runtime address resolution.\nDynamic calls are typically used when the program structure is not known at compile time or when flexibility is required.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "20. What is the purpose of the INSPECT verb in COBOL, and what are some common scenarios where it is used?",
        "answer": "The “INSPECT” verb in COBOL is used to manipulate and transform data within a given data item or group of data items. It provides a powerful set of string and data manipulation functions. Here are some common scenarios where the “INSPECT” verb is often used:\nString Manipulation\nCOBOL developers frequently turn to the “INSPECT” verb for its efficient handling of strings, enabling operations such as string concatenation, character replacement, text insertion, and deletion. With its adaptable nature and high effectiveness, the “INSPECT” verb proves indispensable for data transformation tasks in COBOL programming.\nData Validation and Cleansing\nWithin COBOL programming, the “INSPECT” verb assumes a crucial role in data validation and cleansing, enabling developers to effectively manage tasks like removing leading or trailing spaces, validating numeric data, and conducting pattern checks within data items. Moreover, it offers essential features like counting characters or substrings, intelligently replacing characters or substrings based on specific rules, and verifying data item formats. As a result, it significantly enhances the reliability and accuracy of data processing in COBOL applications.\nData Transformation\nCOBOL programs often need to transform data from one format to another, such as converting uppercase letters to lowercase or vice versa, changing date formats, or reformatting numbers.\nParsing and Extracting\nThe “INSPECT” verb can be used to parse and extract specific portions of data from a larger data item based on predefined patterns or delimiters.\nIt allows COBOL programs to extract information like names, addresses, phone numbers, or any other structured data from a given input.\n\nCobol Interview Questions and Answers for Intermediate",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "21. What is the difference between a SEARCH and a SEARCH ALL statement in COBOL? When would you use each?",
        "answer": "In COBOL, the “SEARCH” statement is utilized for locating a specific value in a table or array, performing a sequential search to find the first occurrence. It transfers control to the appropriate “AT END” or “WHEN” phrase based on the search result, making it suitable for finding a single occurrence of a value and determining its existence.\nOn the other hand, the “SEARCH ALL” statement is employed when searching for multiple occurrences of a value in a sorted table. It utilizes a binary search algorithm, making it more efficient for large sorted tables, and sets an index to indicate the position of each occurrence within the table. This makes it ideal for scenarios where you need to find multiple instances of a value or determine their positions within the sorted table.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "22. What is the purpose of the SET verb in COBOL, and how does it differ from the MOVE verb?",
        "answer": "The “SET” and “MOVE” verbs in COBOL serve different purposes in data manipulation.\n“SET” Verb: The “SET” verb in COBOL is used to assign specific values to variables or data items. It allows you to set a value to a variable, an individual character within a data item, or even a group of related data items in a single statement. The “SET” verb is mainly used to initialize or modify the content of variables during program execution.\n“MOVE” Verb: The “MOVE” verb is used for the assignment of data from one data item to another. It transfers the entire content of one data item (e.g., variable, field, or record) to another data item of a compatible data type. The “MOVE” verb is commonly used for copying data between variables or for data transfer between different data structures like record-to-record or file-to-file.\nIn summary, the “SET” verb is used for directly assigning specific values to variables or parts of data items, while the “MOVE” verb is employed for copying entire data items from one location to another. The choice between “SET” and “MOVE” depends on the specific data manipulation requirement in your COBOL program.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "23. What is the purpose of the INITIALIZE verb in COBOL, and when would you use it?",
        "answer": "In COBOL, the “INITIALIZE” verb proves to be a valuable asset for developers, offering an efficient way to set the initial values of data items or groups. It serves as a convenient solution for tasks like initializing variables, clearing memory, and establishing the starting state of data structures within a program.\nPurpose\nThe “INITIALIZE” verb allows you to set one or more data items to their initial or default values.\nIt is particularly useful when you want to ensure that data items start with a known and consistent value before they are used in your program.\nSyntax\nWith the “INITIALIZE” verb in COBOL, developers can effortlessly apply it not only to individual data items and groups but also to entire tables or arrays, ensuring efficient initialization of data within various program structures.\nIt follows the general syntax: INITIALIZE data-item-1 [data-item-2 …].\nFunctionality\nWhen the “INITIALIZE” verb is executed, COBOL sets the specified data items to their initial values based on their data types.\nNumeric data items are typically initialized to zero, while alphanumeric data items are initialized with spaces.\nFor group data items or tables, the “INITIALIZE” verb recursively initializes each component or entry within the structure.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "24. What is the purpose of the OCCURS clause in COBOL, and how is it used?",
        "answer": "In COBOL, the “OCCURS” clause is used to define arrays or tables, allowing you to group multiple occurrences of the same data item. Here are some key points about the “OCCURS” clause:\nPurpose\nThe “OCCURS” clause holds significant significance in COBOL as it empowers developers to define arrays or tables, offering a streamlined approach to managing data collections with shared attributes. By promoting efficiency in data manipulation and contributing to improved readability and maintainability, the “OCCURS” clause remains an essential and valuable aspect of COBOL programming.\nSyntax\nThe “OCCURS” clause is typically used in the DATA DIVISION of a COBOL program within the description of a group data item.\nThe general syntax is 88 data-name OCCURS n TIMES [INDEXED BY index-name].\n“data-name” refers to the name of the group data item that represents the array or table.\n“n” specifies the number of occurrences or entries in the array or table.\nThe optional “INDEXED BY” phrase allows you to define an index that can be used to access individual elements within the array or table.\nUsage\nThe “OCCURS” clause is an essential feature in COBOL, allowing developers to handle multiple occurrences of the same data structure or item efficiently. It finds common usage in managing data collections, processing arrays or tables, and performing calculations on related data groups. This clause serves as a valuable asset, promoting effective and well-organized data management within COBOL programs.\nBy using the “INDEXED BY” phrase, you can define and use an index that allows you to access and manipulate individual elements within the array or table.\nExample:\nHere’s an example of using the “OCCURS” clause:\n01 CUSTOMER-TABLE.\n05 CUSTOMER-INFO OCCURS 100 TIMES.\n10 CUSTOMER-ID PIC X(10).\n10 CUSTOMER-NAME PIC X(50).\nIn this context, the “CUSTOMER-TABLE” represents an array or table with the capacity to hold up to 100 occurrences of “CUSTOMER-INFO.” Each “CUSTOMER-INFO” occurrence consists of two fields: “CUSTOMER-ID” and “CUSTOMER-NAME.” This setup offers an effective means of storing and organizing customer data, enabling developers to manage information related to multiple customers in a well-structured manner within a COBOL program.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "25. What is the purpose of ONE SIZE ERROR options in trapping errors?",
        "answer": "The “ONE SIZE ERROR” option in error trapping is used to handle arithmetic errors in COBOL programs. When this option is specified, it allows the program to continue execution even if an arithmetic error occurs during a calculation. Instead of immediately terminating the program, the error condition is noted, and the erroneous result is replaced with an implementation-defined value.\nUsing the “ONE SIZE ERROR” option can be beneficial in situations where minor arithmetic errors may occur. The program can still proceed with its intended functionality without halting. However, it is crucial to handle these errors appropriately to prevent unintended consequences or data inconsistencies in the program’s output.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "26. How can you handle file processing errors in COBOL, and what are some of the common FILE STATUS codes used for error identification?",
        "answer": "By utilizing the FILE STATUS clause in conjunction with “AT END” and “INVALID KEY” phrases, COBOL programmers can adeptly handle file processing errors, guaranteeing seamless and dependable file operations.\nThe FILE STATUS codes, including “00,” “10,” “23,” “30,” “35,” “39,” and “46,” play a pivotal role in pinpointing precise error conditions, empowering developers to implement effective error-handling strategies within their COBOL programs. This proactive approach ensures resilient and error-resistant file processing, elevating the overall reliability of the COBOL application.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "27. Explain the difference between PERFORM and CALL statements in COBOL. When would you use each, and what are the key considerations in choosing between them?",
        "answer": "The “PERFORM” and “CALL” statements in COBOL serve distinct purposes in executing procedures or paragraphs.\nPERFORM STATEMENT\nThe “PERFORM” statement is designed for iterative or repetitive tasks, enabling the execution of a specific section of code (a paragraph or a group of paragraphs) repeatedly until a particular condition is met.\nControlled using constructs like “PERFORM UNTIL,” “PERFORM VARYING,” or “PERFORM TIMES,” it is ideal for tasks that require executing a set of operations multiple times, such as processing records in a file or iterating over an array.\nCALL STATEMENT\nThe “CALL” statement is intended for procedural calls or invoking other COBOL programs or external routines.\nIt transfers control to the called program or routine and, once the control returns, allows the calling program to resume from where it left off.\n“CALL” is well-suited for invoking separate, reusable code segments, including subroutines or COBOL programs residing in different modules.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "28. Which mode do you use to operate a sequential file in COBOL?",
        "answer": "In COBOL, the “SEQUENTIAL” mode is employed for operating on a sequential file. This mode facilitates sequential access to the file, enabling the reading or writing of records in the order they are stored in the file. Sequential access starts at the beginning of the file and proceeds sequentially to the end, processing one record at a time. It is commonly utilized for files with a predefined record order that necessitates sequential processing, like reading or writing data sequentially to or from a text file.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "29. What are SSRANGE and NOSSRANGE?",
        "answer": "In COBOL, SSRANGE and NOSSRANGE are compiler directives that control array subscript range checking during program execution.\nSSRANGE (Subscript Range Checking)\nSSRANGE is a compiler option that enables array subscript range checking. When SSRANGE is specified, the compiler performs bounds checking on array indices or subscripts at runtime. If the program attempts to access an element outside the defined boundaries of the array, it triggers a runtime error, helping to prevent array index out-of-bounds errors. SSRANGE adds an extra layer of safety by ensuring that array access is within the permissible limits.\nNOSSRANGE (No Subscript Range Checking)\nNOSSRANGE is another compiler option that disables array subscript range checking. When NOSSRANGE is used, the compiler skips the bounds check during program execution. This means that the program can freely access elements in the array without being restricted by any index boundaries. However, disabling subscript range checking comes with a trade-off; it increases the risk of potential array index out-of-bounds errors if the program does not handle array access carefully.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "30. What is a COBOL copybook? What are the benefits of using these?",
        "answer": "In COBOL, a copybook is a separate and reusable file that contains data items and record declarations, along with other common elements used in multiple COBOL programs. The copybook serves as a template or blueprint for defining data structures that are shared across various COBOL programs.\nInstead of duplicating the same data declarations in multiple programs, the copybook allows programmers to centralize the data definitions in one place. Programs can include the content of the copybook using the “COPY” statement during the compilation process. The “COPY” statement inserts the copybook’s content directly into the source code of the program, as if the data declarations were part of the program itself.\nThe benefits of using copybooks are the following:\nReusability: By defining data structures once in the copybook, they can be shared among different programs, reducing redundancy and ensuring consistency.\nMaintenance: Any updates or modifications to the data structures can be made in the copybook, and those changes will be automatically reflected in all programs that include it.\nReadability: Separating data declarations into a copybook makes the main program’s source code more concise and easier to read.\nModularization: Copybooks promote modular programming by encapsulating data definitions, making it easier to manage and understand large programs.\nCopybooks typically have a “.cpy” file extension and contain data item declarations, record layouts, and sometimes other COBOL statements. However, they do not contain program logic or procedure divisions, focusing solely on providing reusable data structures for multiple programs.\nAdvanced COBOL Interview Questions\n Let’s discuss some of the Cobol Interview Questions for Experienced",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "31. Mention three components of COBOL as a business language.",
        "answer": "Here are three components of COBOL as a business language:\nData Division: The Data Division in COBOL is responsible for defining and describing the data used in the program. It includes data item declarations, record layouts, and file descriptions. This division allows developers to establish the structure and characteristics of the data required for business applications.\nProcedure Division: The Procedure Division contains the actual procedural logic of the COBOL program. It consists of executable statements that perform data processing, calculations, and business operations. This division is where the main processing logic of the program is implemented to achieve the desired business functionality.\nFile Handling: COBOL has built-in support for file handling, enabling programs to read from and write to files for data input and output. This feature is essential for business applications that frequently involve interacting with external files to manage and process data efficiently.\nThese three components work together to form the core of COBOL as a business language, providing developers with the tools to define data structures, implement business rules, and manage data effectively in file-based business applications.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "32. What are Call By Reference and Call By Content in COBOL?",
        "answer": "In COBOL, “Call By Reference” and “Call By Content” are two different mechanisms used for passing data between programs or procedures.\nCall By Reference\nIn “Call By Reference,” the memory address (reference) of the data item is passed to the called program or procedure. This means that the called program operates directly on the original data in the calling program’s memory. Any changes made to the data within the called program will reflect in the original data in the calling program. This direct access to the memory location allows for efficient data manipulation, especially when dealing with large data structures.\nAdvantages of Call By Reference:\nMemory-efficient as it avoids data duplication.\nAllows the called program to modify the original data, making it useful for scenarios where changes in data need to be propagated back to the calling program.\nCall By Content (Call By Value)\nIn “Call By Content,” a copy of the data is passed to the called program or procedure rather than its memory address. The called program works with the copied data, and any changes made to this copy do not affect the original data in the calling program. This approach preserves the integrity of the original data and prevents unintended modifications within the calling program.\nAdvantages of Call By Content:\nEnsures data safety by keeping the original data intact in the calling program.\nPrevents side effects, as any changes made within the called program are confined to the copied data.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "33. Which is the default, TEST BEFORE or TEST AFTER, for a PERFORM statement?",
        "answer": "In COBOL, the default testing method for a PERFORM statement is “TEST BEFORE.”\nWith “TEST BEFORE,” the condition specified in the PERFORM statement is evaluated before entering the loop. If the condition is true, the loop’s body is executed, and the loop continues to execute as long as the condition remains true. Once the condition evaluates to false, the loop terminates, and the program proceeds to the next statement after the PERFORM.\nIt’s essential to keep in mind that if you want to change the default testing method to “TEST AFTER,” you need to explicitly specify it in the PERFORM statement using the “WITH TEST AFTER” clause. Otherwise, the compiler will assume “TEST BEFORE” by default.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "34. What is the linkage section, and what do you use it for?",
        "answer": "In COBOL, the Linkage Section is a division within the program that defines data items used to pass information between the calling program and the called program or subprogram. It serves as a communication interface between different programs, allowing them to exchange data during program execution.\nThe Linkage Section is typically placed in the called program or subprogram and contains data items declared using the “LINKAGE SECTION” header. These data items are also known as “parameters” or “arguments.” When the calling program invokes the called program, it passes values to these data items, which are then used within the called program.\nKey uses of the Linkage Section are the following:\nPassing Data: It allows the calling program to pass data or information to the called program for processing or manipulation.\nParameter Passing: It enables the passing of parameters (values or references) from the calling program to the called program, providing flexibility in data handling.\nReturning Results: The called program can also use the Linkage Section to return results or computed values to the calling program.\nEncapsulation: By using the Linkage Section, programs can be encapsulated as separate, reusable modules, enhancing program structure and maintainability.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "35. How do you write a COBOL program that can be used in a distributed environment?",
        "answer": "To write a COBOL program that can be used in a distributed environment, consider the following steps:\nPlatform Independence: Write your COBOL code using standard language features to ensure it can be compiled and executed on different platforms without modification. Avoid using platform-specific extensions.\nRemote Procedure Call (RPC): If necessary, use Remote Procedure Call (RPC) mechanisms to enable communication between distributed components. RPC allows you to invoke procedures or functions in remote systems seamlessly.\nPerformance Optimization: In a distributed environment, network latency and communication overhead can impact performance. Optimize your COBOL program for efficiency and minimize unnecessary data transfers.\nDocumentation: Provide comprehensive documentation for your COBOL program, outlining its interface, data exchange format, and dependencies. This helps other developers understand and integrate your program into their distributed systems.\nTesting: Thoroughly test your COBOL program in a distributed environment to ensure it functions correctly and meets performance requirements.\nBy following these guidelines, you can develop a well-designed and adaptable COBOL program that effectively operates in a distributed environment, facilitating seamless communication and interaction with other systems in the network.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "36. What is the PIC clause in COBOL?",
        "answer": "In COBOL, the “PIC” (Picture) clause is a fundamental element that allows programmers to define the format, data type, and characteristics of data items, ensuring precise data handling and efficient storage within COBOL programs.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "37. Describe the role of the ENVIRONMENT DIVISION in a COBOL program and its importance in handling computing environment dependencies.",
        "answer": "The “ENVIRONMENT DIVISION” in a COBOL program is a crucial section that describes the aspects of the program that depend on the computing environment in which the program will be executed. It provides essential information to the compiler and runtime system about the specific hardware, software, and file system configurations needed to run the COBOL program successfully.\nThe “ENVIRONMENT DIVISION” contains two primary sections:\nCONFIGURATION SECTION: This section specifies the hardware and software environment requirements for the COBOL program. It includes details such as the character encoding scheme, word size, and other machine-specific attributes.\nINPUT-OUTPUT SECTION: This section defines the files used by the program for input and output operations. It specifies the organization, access mode, and file attributes for each file, ensuring proper interaction with the external data sources.\nThe following are the importance in handling computing Environment Dependencies:\nPortability: By defining the program’s environment requirements in the “ENVIRONMENT DIVISION,” developers can ensure that the COBOL program is portable across different computing platforms. It allows the program to adapt to the specific characteristics of the target environment, making it easier to run on various systems without modification.\nCompatibility: The “ENVIRONMENT DIVISION” enables the COBOL program to interact seamlessly with the underlying operating system and file system. By providing the necessary details about file organization and access methods, the program can read and write data without compatibility issues.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "38. How can you handle file status errors in COBOL I/O operations?",
        "answer": "Handling file status errors in COBOL I/O operations is crucial to ensure proper error handling and graceful handling of exceptional situations during file processing. To handle file status errors in COBOL, you can use the FILE CONTINUE and FILE EXCEPTION phrases in I/O statements. These phrases allow you to specify different actions based on the status of the file operation.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "39. What is COBOL layout?",
        "answer": "COBOL layout refers to the structure and organization of data fields within a record or data structure in a COBOL program. COBOL is a language commonly used in business applications, and it is essential to define the layout accurately to handle data properly during file processing.\nIn COBOL, data files are composed of records, and each record is made up of individual data fields. The layout defines the order, size, and data types of these fields, allowing the COBOL program to correctly read, write, and process the data in the file.\nHere’s a brief explanation of the COBOL layout:\nData Description Entry (FD Entry): The layout in COBOL is usually defined in the Data Division of the program, specifically in the FILE SECTION and WORKING-STORAGE SECTION.\nData Record Description (01 Level): Within the FD entry, each record in the file is described using a Data Record Description. This is defined using a level number of 01. It represents the highest level of data and acts as the container for all the data fields within the record.\nData fields are defined under the 01 level using individual level numbers.\nData Fields (Subordinate Levels): Under the 01 level, individual data fields are defined using subordinate level numbers (02, 03, etc.). These fields represent the actual data elements within the record. Each data field is defined with a name, data type (such as alphanumeric, numeric, or binary), and length.",
        "reference": "intellipaat.com",
        "role": "cobol"
    },
    {
        "question": "1. What is COBOL?",
        "answer": "COBOL stands for Common Business Oriented Language and is one of the oldest high-level programming languages used for solving complex business problems in different domains like business verticals, finance, security and administrative purposes. Following are the features of this programming language: Simplicity: It is an easy-to-learn language with a simple and wide vocabulary for syntax and has an uncluttered style of coding.\nBusiness-oriented capabilities: COBOL has advanced capabilities for file handling that let it operate on huge data and can be used for simple to complex processing operations thereby being it the most popular technology for handling business transactions.\nUniversality: COBOL is one of the oldest programming languages and has survived for more than 6 decades across growing business needs and has adapted across almost every platform, product and compiler.\nScalability: COBOL is highly scalable, reliable and is also portable across different platforms. They provide variables control structures that make it easy to read, debug and modify. Simplicity: It is an easy-to-learn language with a simple and wide vocabulary for syntax and has an uncluttered style of coding. Simplicity: Business-oriented capabilities: COBOL has advanced capabilities for file handling that let it operate on huge data and can be used for simple to complex processing operations thereby being it the most popular technology for handling business transactions. Business-oriented capabilities: Universality: COBOL is one of the oldest programming languages and has survived for more than 6 decades across growing business needs and has adapted across almost every platform, product and compiler. Universality: Scalability: COBOL is highly scalable, reliable and is also portable across different platforms. They provide variables control structures that make it easy to read, debug and modify. Scalability:",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "2. What are the available data types in the COBOL language?",
        "answer": "There are mainly three data types supported by COBOL, they are: Numeric data type – Used for representing numerical values between 0-9.\nAlphabetic data type – Used for representing alphabetic values ranging from A-Z.\nAlphanumeric data type – Used for representing both numeric and alphabetic types. Numeric data type – Used for representing numerical values between 0-9. Numeric data type Alphabetic data type – Used for representing alphabetic values ranging from A-Z. Alphabetic data type Alphanumeric data type – Used for representing both numeric and alphabetic types. Alphanumeric data type",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "3. How is the NEXT SENTENCE statement different from CONTINUE statement?",
        "answer": "The CONTINUE statement is like a null statement that indicates no operation and the control needs to be passed to the next executable instruction after explicit scope terminator. It can be used anywhere in conditional statements or imperative statements are used. Example syntax for CONTINUE in case of IF construct is: CONTINUE CONTINUE IF condition-1 THEN\n   {statement-1 ...    | CONTINUE}\n[ELSE {statement-2 ... | CONTINUE}]\n[END-IF] IF condition-1 THEN\n   {statement-1 ...    | CONTINUE}\n[ELSE {statement-2 ... | CONTINUE}]\n[END-IF] The NEXT SENTENCE statement does the task of simply transferring the control to an implicit CONTINUE statement that is present immediately after the next separator period. If the statement is specified along with the END-IF statement then the control passes to the statement after the closest following period. It is mainly used to transfer control to the next sentence. NEXT SENTENCE IF condition-1 THEN\n   {statement-1 ... | NEXT SENTENCE} IF condition-1 THEN\n   {statement-1 ... | NEXT SENTENCE}",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "4. What is IS NUMERIC clause?",
        "answer": "This clause is used for checking if an item is a numeric value or not. If it is numeric - positive or negative, TRUE will be returned. For example: CHECK-NUMBER SECTION.\n    DISPLAY 'Check if input is numeric ' INPUT-NUM\n    IF INPUT-NUM IS NUMERIC\n        DISPLAY 'input is numeric'\n    ELSE\n        DISPLAY 'input is non numeric' CHECK-NUMBER SECTION.\n    DISPLAY 'Check if input is numeric ' INPUT-NUM\n    IF INPUT-NUM IS NUMERIC\n        DISPLAY 'input is numeric'\n    ELSE\n        DISPLAY 'input is non numeric'",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "5. What is the importance of using REPLACING option in a COPY statement?",
        "answer": "REPLACING option is used for allowing the same copy to be used multiple times by changing the replace value in the same code.\nSyntax COPY <VariableName> REPLACING BY  COPY <VariableName> REPLACING BY",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "6. How is SSRANGE different from NOSSRANGE?",
        "answer": "Both are options used by the compiler for finding subscript outside of range.\nSSRANGE is used for handling the overflow of an array systematically. It needs to be specified explicitly which helps in finding exact subscript outside of range. Whereas the NOSSRANGE is used in cases of very sensitive applications that are driven by performance. It is the default option that gets applied and need not be specified explicitly and it does not support runtime errors whenever the index goes out of range. ",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "7. How is PERFORM … WITH TEST AFTER different from PERFORM … WITH TEST BEFORE?",
        "answer": "PERFORM ... WITH TEST BEFORE indicates that the condition must be tested at the beginning of every execution of the specified PERFORM range. Whereas TEST AFTER is used for testing the condition after every execution. PERFORM ... WITH TEST BEFORE",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "8. What happens during INPUT PROCEDURE and OUTPUT PROCEDURE?",
        "answer": "In INPUT PROCEDURE, the input file will be opened, the records from the file are read and can also be edited. The records will then be released to sorting operation and then the file will be closed. Whereas in OUTPUT PROCEDURE, the output file will be opened, the records post sorting will be written in the output file and then the file will be closed.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "9. Why is LINKAGE SECTION needed?",
        "answer": "It is used for passing data from one program to another. It can also be used for passing data from a procedure to another program. It maps data in the calling program’s working storage.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "10. Why should we not define OCCURS clause at 01 level?",
        "answer": "01 level is the level of record. We can repeat the fields within a record but we cannot repeat the record itself. The OCCURS clause indicates the repetition of the definition of data names. This is why we cannot use the OCCURS clause at the 01 level.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "11. How do we find current date from the system within a century?",
        "answer": "We can find it out by using the Intrinsic function called FUNCTION CURRENT-DATE. We can also make use of the DATE function for accepting the current date. It has to be noted that the current date cannot be accepted if we are using CICS COBOL programs. FUNCTION CURRENT-DATE",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "12. How is CALL command different from LINK?",
        "answer": "CALL command is an actual command that initiates an external program and returns. The LINK command is also similar to CALL but it does not belong to COBOL verb vocabulary. The LINK command runs like a separate run unit whereas CALL is executed as a single run unit.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "13. What is the importance of INITIALIZE verb?",
        "answer": "INITIALIZE verb is used for initializing values in data items to their default value. Numeric items will be set to 0, alphabetic and alphanumeric items will be set to spaces. Items like FILLERS, OCCURS DEPENDING ON are to be left untouched during the initialization.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "14. Differentiate between OS/VS COBOL and VS COBOL II.",
        "answer": "OS/VS COBOL VS COBOL II\nRuns in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes.\nSupports Report Writer. Does not support Report Writer.\nUSAGE IS POINTER is not supported. USAGE IS POINTER is supported.\nReference modification is not supported here. Reference modification is supported here.\nEVALUATE is not supported here. EVALUATE is supported here.\nScope terminators are not supported. Scope terminators are supported.\nFollows ANSI 74 standards. ANSI 85 standards are followed here.\nCalls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS. OS/VS COBOL VS COBOL II\nRuns in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes.\nSupports Report Writer. Does not support Report Writer.\nUSAGE IS POINTER is not supported. USAGE IS POINTER is supported.\nReference modification is not supported here. Reference modification is supported here.\nEVALUATE is not supported here. EVALUATE is supported here.\nScope terminators are not supported. Scope terminators are supported.\nFollows ANSI 74 standards. ANSI 85 standards are followed here.\nCalls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS. OS/VS COBOL VS COBOL II OS/VS COBOL VS COBOL II OS/VS COBOL VS COBOL II Runs in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes.\nSupports Report Writer. Does not support Report Writer.\nUSAGE IS POINTER is not supported. USAGE IS POINTER is supported.\nReference modification is not supported here. Reference modification is supported here.\nEVALUATE is not supported here. EVALUATE is supported here.\nScope terminators are not supported. Scope terminators are supported.\nFollows ANSI 74 standards. ANSI 85 standards are followed here.\nCalls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS. Runs in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes. Runs in 24-bit addressing mode. Runs either in 24-bit or 31-bit addressing modes. Supports Report Writer. Does not support Report Writer. Supports Report Writer. Does not support Report Writer. USAGE IS POINTER is not supported. USAGE IS POINTER is supported. USAGE IS POINTER is not supported. USAGE IS POINTER is supported. Reference modification is not supported here. Reference modification is supported here. Reference modification is not supported here. Reference modification is supported here. EVALUATE is not supported here. EVALUATE is supported here. EVALUATE is not supported here. EVALUATE is supported here. Scope terminators are not supported. Scope terminators are supported. Scope terminators are not supported. Scope terminators are supported. Follows ANSI 74 standards. ANSI 85 standards are followed here. Follows ANSI 74 standards. ANSI 85 standards are followed here. Calls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS. Calls between programs are not supported under CICS (Customer Information Control System). Calls between programs are supported under CICS.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "15. What do you understand by static and dynamic linking?",
        "answer": "Static and dynamic linking are two types of linking available in COBOL. Static linking refers to the linking of subroutine into calling program and not existing as a separate module. In dynamic linking, the subroutine exists as a separate program and does not link to the main program. The static linking can be done by using the NODYNAM link option and the dynamic linking can be done by using the DYNAM option.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "16. What are the object oriented features provided in COBOL?",
        "answer": "Object-Oriented COBOL provides the following features: Define classes and let programs define and create objects of those classes.\nData encapsulation is due to the ability to create objects. The data properties will be encapsulated in the objects.\nBehaviour of objects can be defined for the class by means of methods.\nInheritance is supported in COBOL.\nProvides maximum flexibility by means of polymorphism and defining interfaces.\nAlso compatible with procedural programming. Define classes and let programs define and create objects of those classes. Data encapsulation is due to the ability to create objects. The data properties will be encapsulated in the objects. Behaviour of objects can be defined for the class by means of methods. Inheritance is supported in COBOL. Provides maximum flexibility by means of polymorphism and defining interfaces. Also compatible with procedural programming.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "1. Consider a scenario where we have a program having an array of 20 items. When the program tries to access the 21st item, the program fails to abend. What is the reason for this?",
        "answer": "The default compiler option NOSSRANGE must have been used which does not allow the program to abend. If we want the program to abend whenever accessing an array element that is out of bounds, we need to use the compiler option of SSRANGE. Using this option, the program abends with SOC4 error which indicates that it tried to access an invalid address by using the wrong index.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "2. Why is S9(4) COMP needed despite knowing that Comp-3 would utilise less space?",
        "answer": "S9(4) COMP represents that the item is a small integer which means two words of 1 byte each can occupy a total of 2 bytes. In S9(4) COMP-3, one word is equal to half a byte which means 4 words can occupy 2 bytes and additionally, the sign occupies another half byte which results in a maximum of 3 bytes usage. More can be accommodated in S9(4) COMP when compares to COMP-3.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "3. What do you understand by the following terminologies?",
        "answer": "AMODE(31)\nAMODE(24)\nRMODE(24)\nRMODE(ANY) AMODE(31) AMODE(31) AMODE(24) AMODE(24) RMODE(24) RMODE(24) RMODE(ANY) RMODE(ANY) All 4 are the options that are available in compile or link editing. AMODE expands to Addressing Mode. AMODE(31) and AMODE(24) represents that the addressing mode used is 31-bit and 24-bit respectively. When we use AMODE(ANY), it indicates that either 31-bit mode or 24-bit addressing mode can be used and it is dependent on the value of RMODE. RMODE represents Resident Mode within the virtual storage. RMODE(24) represents that the mode can reside within virtual storage below the 16 Meg line. RMODE(ANY) represents that the mode can reside below or above 16 Meg line and the address bit can be either 24-bit or 31-bit depending on the RMODE.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "4. How is INCLUDE different from COPY?",
        "answer": "The main similarity between INCLUDE and COPY is that both help in expanding the program variables or codes. The important difference between them is that INCLUDE is used for expanding the code at the time of pre-compilation. Whereas the COPY expands the code at compilation time. DB2 pre-compilers won’t be able to process COPY statements which is why the statements involving the validation of table attributes and DCL statements are embedded using INCLUDE.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "5. What are the problems associated with using ordered sequential files?",
        "answer": "The main nature of ordered sequential files is that the records are arranged based on some key field(s). When a user wants to perform operations like insert or deletion, then the order based on the field(s) should be maintained at all times. This is attained only by creating a new file where we insert or update or delete the records within the new file and then maintain the ordered nature. All these take place on the disk directly and the time required to access data on disk is the main bottleneck while processing any functionality. This reduces the speed of computation and slows down the system unnecessarily if we try to use ordered sequential files whenever not needed.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "6. Under what circumstances are scope terminators mandatorily needed?",
        "answer": "When we are using in-line PERFORMS or EVALUATE statements, we need to use scope terminators. It is recommended because it helps to read the code better and is deemed as a good coding practice.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "7. What are the causes of S0C7, S0C5 and S0C1?",
        "answer": "S0C7 is caused mainly due to the following reasons: S0C7 is caused mainly due to the following reasons: Whenever numeric operations are performed on data of non-numeric type.\nWhen we are working on the uninitialized storage.\nWhen we try to code excessively that surpasses the maximum permitted dub script. Whenever numeric operations are performed on data of non-numeric type. When we are working on the uninitialized storage. When we try to code excessively that surpasses the maximum permitted dub script. S0C5 is caused mainly due to the following reasons: S0C5 is caused mainly due to the following reasons: Damaged index or subscript.\nExit occurred incorrectly from a perform.\nBefore the read operation, I/O is accessed.\nWhen we try to close an unopened dataset. Damaged index or subscript. Exit occurred incorrectly from a perform. Before the read operation, I/O is accessed. When we try to close an unopened dataset. S0C1 is caused mainly due to the following reasons: S0C1 is caused mainly due to the following reasons: Incorrectly spelt DD name.\nWhen we perform a read or write operation on an unopened dataset.\nWhen the subprograms that are called are not found. Incorrectly spelt DD name. When we perform a read or write operation on an unopened dataset. When the subprograms that are called are not found.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "8. What are the differences between Structured COBOL and Object-Oriented COBOL programming?",
        "answer": "Structured COBOL Programming Object-Oriented COBOL Programming\nAll functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner.\nLess secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding.\nMore natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure. Structured COBOL Programming Object-Oriented COBOL Programming\nAll functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner.\nLess secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding.\nMore natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure. Structured COBOL Programming Object-Oriented COBOL Programming Structured COBOL Programming Object-Oriented COBOL Programming Structured COBOL Programming Object-Oriented COBOL Programming All functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner.\nLess secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding.\nMore natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure. All functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner. All functionalities are divided into modules. This follows a logical style of programming that helps to write code logic in a clean manner. Less secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding. Less secure as there is no data hiding feature involved. Since it follows an object-oriented approach, there is encapsulation and abstraction involved which helps in data hiding. More natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure. More natural way of coding. Here, objects are first identified and functionalities of those are then written. Hence, it is more secure.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "9. How can we reference or make COBOL program realise that about the following file formats?",
        "answer": "1. Fixed Block File\n2. Fixed Unblock File\n3. Variable Block File\n4. Variable Unblock File\n5. Printer File 1. Fixed Block File  2. Fixed Unblock File  3. Variable Block File  4. Variable Unblock File  5. Printer File Following are the explanation to the points one by one: Fixed Block File: We can identify that a file is a fixed block file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAINS 0\nFixed Unblock File: We can identify that a file is a fixed unblock file if the following 2 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nVariable Block File: We can identify that a file is a variable block file if the following 4 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nBLOCK CONTAINS 0\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4.\nVariable Unblock File: We can identify that a file is a variable unblock file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4.\nPrinter File: We can reference that a file is a printer file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAIN 0 Fixed Block File: We can identify that a file is a fixed block file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAINS 0 Fixed Block File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAINS 0 ORGANIZATION IS SEQUENTIAL RECORDING MODE IS F BLOCK CONTAINS 0 Fixed Unblock File: We can identify that a file is a fixed unblock file if the following 2 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F Fixed Unblock File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F ORGANIZATION IS SEQUENTIAL RECORDING MODE IS F Variable Block File: We can identify that a file is a variable block file if the following 4 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nBLOCK CONTAINS 0\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. Variable Block File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nBLOCK CONTAINS 0\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. ORGANIZATION IS SEQUENTIAL RECORDING MODE IS V BLOCK CONTAINS 0 Record length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. Variable Unblock File: We can identify that a file is a variable unblock file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. Variable Unblock File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS V\nRecord length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. ORGANIZATION IS SEQUENTIAL RECORDING MODE IS V Record length is never coded as 4 bytes in FD as JCL will consider the record length as the max length of record plus 4. Printer File: We can reference that a file is a printer file if the following 3 conditions are met:\nORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAIN 0 Printer File: ORGANIZATION IS SEQUENTIAL\nRECORDING MODE IS F\nBLOCK CONTAIN 0 ORGANIZATION IS SEQUENTIAL RECORDING MODE IS F BLOCK CONTAIN 0",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "10. How can we process two files by comparing key fields?",
        "answer": "There are 2 possible approaches for this: Approach 1:\nWe can read records from both files, if the key fields match, then they can be ignored.\nIf upon key comparison, the results are unequal, then we identify which file has missing or new records and update the file with missing records accordingly.\nApproach 2:\nIf both files have the same records, then the work will be reduced.\nIf file 1 comes to the AT END state, then we have to move HIGH VALUES into the key field. The same goes to file 2.\nThis process needs to be repeated until both key fields are equal to HIGH VALUES.\nFor this process to work, the key fields should be in PIC(X) format and not numeric. Approach 1:\nWe can read records from both files, if the key fields match, then they can be ignored.\nIf upon key comparison, the results are unequal, then we identify which file has missing or new records and update the file with missing records accordingly. Approach 1: We can read records from both files, if the key fields match, then they can be ignored.\nIf upon key comparison, the results are unequal, then we identify which file has missing or new records and update the file with missing records accordingly. We can read records from both files, if the key fields match, then they can be ignored. If upon key comparison, the results are unequal, then we identify which file has missing or new records and update the file with missing records accordingly. Approach 2:\nIf both files have the same records, then the work will be reduced.\nIf file 1 comes to the AT END state, then we have to move HIGH VALUES into the key field. The same goes to file 2.\nThis process needs to be repeated until both key fields are equal to HIGH VALUES.\nFor this process to work, the key fields should be in PIC(X) format and not numeric. Approach 2: If both files have the same records, then the work will be reduced.\nIf file 1 comes to the AT END state, then we have to move HIGH VALUES into the key field. The same goes to file 2.\nThis process needs to be repeated until both key fields are equal to HIGH VALUES.\nFor this process to work, the key fields should be in PIC(X) format and not numeric. If both files have the same records, then the work will be reduced. If file 1 comes to the AT END state, then we have to move HIGH VALUES into the key field. The same goes to file 2. AT END HIGH VALUES This process needs to be repeated until both key fields are equal to HIGH VALUES. For this process to work, the key fields should be in PIC(X) format and not numeric. To make the process easier, we can avoid a lot of I-O operations by reading data to the local array table and then processing the records from there.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "11. How do we remove the spaces at end of every record in an output file that is of variable length?",
        "answer": "Spaces that are present at the end of the record are called trailing spaces. COBOL does not provide the functionality to remove such trailing spaces. But it can be achieved by using the RECORD-LENGTH field as follows:\nConsider a scenario where we have a file of variable length and the maximum possible record length is 4000. To remove trailing space from every record, then we can alter the record length value to RECORD-LENGTH. This ensures that the records are trimmed which are beyond actual record length. Assuming that a variable-length file has a maximum record length of 4000.  Move the original record length value to RECORD-LENGTH. This process enables the trimming of the entire record that is beyond the length.\nIn case the data is populated only up to 3000 bytes - meaning there are 1000 trailing spaces. Then move the record length value to RECORD-LENGTH.\nBy doing this, the records would be trimmed off and 1000 bytes would be freed. Move the original record length value to RECORD-LENGTH. This process enables the trimming of the entire record that is beyond the length. In case the data is populated only up to 3000 bytes - meaning there are 1000 trailing spaces. Then move the record length value to RECORD-LENGTH. By doing this, the records would be trimmed off and 1000 bytes would be freed.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "12. Why should the file be opened in I-O mode when it is being used for REWRITE purposes?",
        "answer": "When the file REWRITE of the record needs to be performed, the file should first be opened and then the record must be read from the file. This is why the file should always be opened in I-O mode.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "13. How is sorting achieved in the COBOL program?",
        "answer": "It is done by using the SORT command whose syntax goes as follows: SORT file_1 ON ASCENDING/DESCENDING KEY key…\nUSING file_2\nGIVING file_3. SORT file_1 ON ASCENDING/DESCENDING KEY key…\nUSING file_2\nGIVING file_3. where file_1 - sort workfile that needs to be described by using SD entry in FILE SECTION.\nfile_2 - input file for SORT that needs to be described using FD entry in FILE SECTION and using a SELECT clause in FILE CONTROL.\nfile_3 - output file from SORT and again needs to be described using FD entry in FILE SECTION and SELECT clause in FILE CONTROL section. file_1 - sort workfile that needs to be described by using SD entry in FILE SECTION. file_2 - input file for SORT that needs to be described using FD entry in FILE SECTION and using a SELECT clause in FILE CONTROL. file_3 - output file from SORT and again needs to be described using FD entry in FILE SECTION and SELECT clause in FILE CONTROL section. All three files are not supposed to be opened explicitly. Note: Note: USING clause can be replaced by INPUT PROCEDURE IS para_1 THRU para_2. While using INPUT PROCEDURE, we need to remember that the section will be executed before sort and the records need to be released to the work file from the result of the input procedure.\nGIVING clause can be replaced by OUTPUT PROCEDURE IS para_1 THRU para_2. While using OUTPUT PROCEDURE, we need to note that the procedure will be executed once all records were sorted and the records from the sort work file should be populated one record at a time to the output procedure. USING clause can be replaced by INPUT PROCEDURE IS para_1 THRU para_2. While using INPUT PROCEDURE, we need to remember that the section will be executed before sort and the records need to be released to the work file from the result of the input procedure. USING INPUT PROCEDURE IS para_1 THRU para_2 GIVING clause can be replaced by OUTPUT PROCEDURE IS para_1 THRU para_2. While using OUTPUT PROCEDURE, we need to note that the procedure will be executed once all records were sorted and the records from the sort work file should be populated one record at a time to the output procedure. GIVING OUTPUT PROCEDURE IS para_1 THRU para_2  ",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "14. What are the different divisions in COBOL programs?",
        "answer": "There are mainly 4 divisions in a COBOL program, they are: IDENTIFICATION DIVISION: This is the most important division that is used for identifying the program. This division is needed for any COBOL program to run. If this division is not included in your program, then the program cannot be compiled.\nENVIRONMENT DIVISION: This division is subdivided into 2 types - Configuration and Input-Output section. They define the written program’s environment.\nDATA DIVISION: This division is used for identifying the data items, allocating proper memory and defining the names within the program. It also has a file, linkage section and working storage.\nPROCEDURE DIVISION: This division supports the main logic of the program. It should consist of at least one statement for using user-defined variables. IDENTIFICATION DIVISION: This is the most important division that is used for identifying the program. This division is needed for any COBOL program to run. If this division is not included in your program, then the program cannot be compiled. IDENTIFICATION DIVISION ENVIRONMENT DIVISION: This division is subdivided into 2 types - Configuration and Input-Output section. They define the written program’s environment. ENVIRONMENT DIVISION DATA DIVISION: This division is used for identifying the data items, allocating proper memory and defining the names within the program. It also has a file, linkage section and working storage. DATA DIVISION PROCEDURE DIVISION: This division supports the main logic of the program. It should consist of at least one statement for using user-defined variables. PROCEDURE DIVISION  ",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "15. What are some of the guidelines that can be followed while developing a structured COBOL program?",
        "answer": "Certain guidelines need to be followed while writing a structured COBOL program. When developing the CASE construct, we can use EQUIVALENT statements. \nWe can use Scope Terminators while using nested constructs. \nWe can also try using IN-LINE PERFORM statements whenever possible when we want a program to perform something. \nTo perform a proper conditional check, we can also try using TEST BEFORE and TEST AFTER statements while using loop constructs to ensure desired results. When developing the CASE construct, we can use EQUIVALENT statements. We can use Scope Terminators while using nested constructs. We can also try using IN-LINE PERFORM statements whenever possible when we want a program to perform something. To perform a proper conditional check, we can also try using TEST BEFORE and TEST AFTER statements while using loop constructs to ensure desired results.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "1. Write a COBOL program example for demonstrating the DELETE concept from a file based on a matching record.",
        "answer": "IDENTIFICATION DIVISION.\nPROGRAM-ID.   \nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.                                 \nFILE-CONTROL.          \n      SELECT RECORD-FILE ASSIGN TO DISK1. \n      ORGANIZATION IS INDEXED.                       \n      ACCESS MODE IS RANDOM.\n      RECORD KEY  IS STD-ID.\n      FILE STATUS IS WS-FS.            \nDATA DIVISION. \n    FILE SECTION.\n    FD  RECORD-FILE.   \n    01 STD-RECORD. \n    02 STD-ID          PIC 9(03).  \n    02 STD-NAME        PIC X(20).  \n\nWORKING-STORAGE SECTION.                            \n    77 WS-FS               PIC 9(02).  \n    01 WS-EOF-SW           PIC X(01) VALUE 'N'. \n    88 EOF-SW              VALUE 'Y'.      \n\nPROCEDURE DIVISION.\n    DISPLAY 'ENTER THE STUDENT ID TO BE MATCHED'\n    ACCEPT STD-ID.     \n    DISPLAY 'OPENING FILE TO DELETE MATCHING RECORD..'.  \n    OPEN INPUT RECORD-FILE. \n        PERFORM UNTIL EOF-SW   \n            READ RECORD-FILE     \n            KEY IS STD-ID      \n            AT END MOVE 'Y'  TO WS-EOF-SW  \n            IF WS-FS = 00   \n                DELETE STD-RECORD \n                MOVE 'Y'  TO WS-EOF-SW    \n            ELSE \n                DISPLAY 'RECORD NOT AVAILABLE'   \n            END-IF \n        END-PERFORM.   \n    CLOSE RECORD-FILE.  \n    DISPLAY STD-RECORD .    \n    STOP RUN. IDENTIFICATION DIVISION.\nPROGRAM-ID.   \nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.                                 \nFILE-CONTROL.          \n      SELECT RECORD-FILE ASSIGN TO DISK1. \n      ORGANIZATION IS INDEXED.                       \n      ACCESS MODE IS RANDOM.\n      RECORD KEY  IS STD-ID.\n      FILE STATUS IS WS-FS.            \nDATA DIVISION. \n    FILE SECTION.\n    FD  RECORD-FILE.   \n    01 STD-RECORD. \n    02 STD-ID          PIC 9(03).  \n    02 STD-NAME        PIC X(20).  \n\nWORKING-STORAGE SECTION.                            \n    77 WS-FS               PIC 9(02).  \n    01 WS-EOF-SW           PIC X(01) VALUE 'N'. \n    88 EOF-SW              VALUE 'Y'.      \n\nPROCEDURE DIVISION.\n    DISPLAY 'ENTER THE STUDENT ID TO BE MATCHED'\n    ACCEPT STD-ID.     \n    DISPLAY 'OPENING FILE TO DELETE MATCHING RECORD..'.  \n    OPEN INPUT RECORD-FILE. \n        PERFORM UNTIL EOF-SW   \n            READ RECORD-FILE     \n            KEY IS STD-ID      \n            AT END MOVE 'Y'  TO WS-EOF-SW  \n            IF WS-FS = 00   \n                DELETE STD-RECORD \n                MOVE 'Y'  TO WS-EOF-SW    \n            ELSE \n                DISPLAY 'RECORD NOT AVAILABLE'   \n            END-IF \n        END-PERFORM.   \n    CLOSE RECORD-FILE.  \n    DISPLAY STD-RECORD .    \n    STOP RUN. Conclusion COBOL has been around for many decades and has found its use in various business purposes due to its strong computational capabilities. In this article, we have seen the most commonly asked COBOL interview questions for both freshers and experienced professionals.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "2. Write a COBOL program that takes 2 numbers as inputs and performs addition and multiplication on them and displays the result.",
        "answer": "IDENTIFICATION DIVISION.\nPROGRAM-ID. \n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  NUMBER1           PIC 9  VALUE ZEROS.\n01  NUMBER2           PIC 9  VALUE ZEROS.\n01  RESULTANT         PIC 99 VALUE ZEROS.\n01  OPERATOR          PIC X  VALUE SPACE.\n\nPROCEDURE DIVISION.\nADDER-MULTIPLIER.\n       DISPLAY \"FIRST INPUT: \" WITH NO ADVANCING\n       ACCEPT NUMBER1\n       DISPLAY \"SECOND INPUT: \" WITH NO ADVANCING\n       ACCEPT NUMBER2\n       DISPLAY \"ENTER + FOR ADD AND * FROM MULTIPLY: \" WITH NO ADVANCING\n       ACCEPT OPERATOR\n\n       IF OPERATOR = \"+\" THEN\n          ADD NUMBER1, NUMBER2 GIVING RESULTANT\n       END-IF\n       \n       IF OPERATOR = \"*\" THEN\n          MULTIPLY NUMBER1 BY NUMBER2 GIVING RESULTANT\n       END-IF\n       \n       DISPLAY \"RESULT OF OPERATION = \", RESULTANT\n       STOP RUN. IDENTIFICATION DIVISION.\nPROGRAM-ID. \n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  NUMBER1           PIC 9  VALUE ZEROS.\n01  NUMBER2           PIC 9  VALUE ZEROS.\n01  RESULTANT         PIC 99 VALUE ZEROS.\n01  OPERATOR          PIC X  VALUE SPACE.\n\nPROCEDURE DIVISION.\nADDER-MULTIPLIER.\n       DISPLAY \"FIRST INPUT: \" WITH NO ADVANCING\n       ACCEPT NUMBER1\n       DISPLAY \"SECOND INPUT: \" WITH NO ADVANCING\n       ACCEPT NUMBER2\n       DISPLAY \"ENTER + FOR ADD AND * FROM MULTIPLY: \" WITH NO ADVANCING\n       ACCEPT OPERATOR\n\n       IF OPERATOR = \"+\" THEN\n          ADD NUMBER1, NUMBER2 GIVING RESULTANT\n       END-IF\n       \n       IF OPERATOR = \"*\" THEN\n          MULTIPLY NUMBER1 BY NUMBER2 GIVING RESULTANT\n       END-IF\n       \n       DISPLAY \"RESULT OF OPERATION = \", RESULTANT\n       STOP RUN.",
        "reference": "interviewbit.com",
        "role": "cobol"
    },
    {
        "question": "3. Write a COBOL program that allows users to enter the names of students of a class and then displays it. Try to use OCCURS clause for achieving this.",
        "answer": "OCCURS clause is used for specifying the table where the contents can be accessed using indexing. It is advantageous when we do not require different data entries for data of a similar kind.\nCOBOL Program: OCCURS clause is used for specifying the table where the contents can be accessed using indexing. It is advantageous when we do not require different data entries for data of a similar kind. OCCURS clause COBOL Program: IDENTIFICATION DIVISION \nPROGRAM-ID\nENVIRONMENT DIVISION\nDATA DIVISION\nWORKING-STORAGE SECTION\n    01 N PIC 9(2) VALUE 0\n    01 I PIC 9(2) VALUE 0\n    01 NAME-IN\n    02 NAME PIC X(10) OCCURS 10 times\n    01 KEY-IN PIC X VALUE SPACE\nPROCEDURE DIVISION\n    P-1\n    DISPLAY(1 1) ERASE\n    DISPLAY(3 5) \"HOW MANY STUDENTS?\"\n    ACCEPT N\n    DISPLAY(1 1) ERASE\n    PERFORM GET-DATA-PROC N TIMES\n    DISPLAY(1 1) ERASE\n    MOVE 0 to I\n    PERFORM DISPLAY-DATA-PROC N TIMES\n    STOP RUN\nGET-DATA-PROC\n    ACCEPT NAME(I)\n    ADD 1 TO I\nDISPLAY-DATA-PROC\n    DISPLAY NAME(I)\n    ACCEPT KEY-IN\n    ADD 1 TO I IDENTIFICATION DIVISION \nPROGRAM-ID\nENVIRONMENT DIVISION\nDATA DIVISION\nWORKING-STORAGE SECTION\n    01 N PIC 9(2) VALUE 0\n    01 I PIC 9(2) VALUE 0\n    01 NAME-IN\n    02 NAME PIC X(10) OCCURS 10 times\n    01 KEY-IN PIC X VALUE SPACE\nPROCEDURE DIVISION\n    P-1\n    DISPLAY(1 1) ERASE\n    DISPLAY(3 5) \"HOW MANY STUDENTS?\"\n    ACCEPT N\n    DISPLAY(1 1) ERASE\n    PERFORM GET-DATA-PROC N TIMES\n    DISPLAY(1 1) ERASE\n    MOVE 0 to I\n    PERFORM DISPLAY-DATA-PROC N TIMES\n    STOP RUN\nGET-DATA-PROC\n    ACCEPT NAME(I)\n    ADD 1 TO I\nDISPLAY-DATA-PROC\n    DISPLAY NAME(I)\n    ACCEPT KEY-IN\n    ADD 1 TO I",
        "reference": "interviewbit.com",
        "role": "cobol"
    }
]