[
    {
        "question": "1. Differentiate between HashSet and TreeSet. When would you prefer TreeSet to HashSet?",
        "answer": "Following are the differences between HashSet and TreeSet:- Internal implementation and speed\nHashSet: For search, insert, and remove operations, it takes constant time on average. TreeSet is slower than HashSet. A hash table is used to implement HashSet.\nTreeSet: For search, insert, and delete, TreeSet takes O(Log n), which is higher than HashSet. TreeSet, on the other hand, preserves ordered data. Higher() (Returns the least higher element), floor(), ceiling(), and other operations are also supported. In TreeSet, these operations are likewise O(Log n), and HashSet does not implement them. A Self-Balancing Binary Search Tree is used to implement TreeSet (Red Black Tree). In Java, TreeSet is backed by TreeMap.\nWay of storing elements \nThe elements of a HashSet are not ordered. In Java, the TreeSet class keeps objects in a Sorted order defined by the Comparable or Comparator methods. By default, TreeSet components are sorted in ascending order. It has a number of methods for dealing with ordered sets, including first(), last(), headSet(), tailSet(), and so on.\nAllowing Null values \nNull objects are allowed in HashSet. TreeSet does not allow null objects and throws a NullPointerException. This is because TreeSet compares keys using the compareTo() method, which throws java.lang. NullPointerException.\nComparison\nHashSet compares two objects in a Set and detects duplicates using the equals() method. For the same purpose, TreeSet employs the compareTo() method. If equals() and compareTo() are not consistent, that is, if equals() returns true for two equal objects but compareTo() returns zero, the contract of the Set interface will be broken, allowing duplicates in Set implementations like TreeSet. Internal implementation and speed\nHashSet: For search, insert, and remove operations, it takes constant time on average. TreeSet is slower than HashSet. A hash table is used to implement HashSet.\nTreeSet: For search, insert, and delete, TreeSet takes O(Log n), which is higher than HashSet. TreeSet, on the other hand, preserves ordered data. Higher() (Returns the least higher element), floor(), ceiling(), and other operations are also supported. In TreeSet, these operations are likewise O(Log n), and HashSet does not implement them. A Self-Balancing Binary Search Tree is used to implement TreeSet (Red Black Tree). In Java, TreeSet is backed by TreeMap. Internal implementation and speed HashSet: For search, insert, and remove operations, it takes constant time on average. TreeSet is slower than HashSet. A hash table is used to implement HashSet.\nTreeSet: For search, insert, and delete, TreeSet takes O(Log n), which is higher than HashSet. TreeSet, on the other hand, preserves ordered data. Higher() (Returns the least higher element), floor(), ceiling(), and other operations are also supported. In TreeSet, these operations are likewise O(Log n), and HashSet does not implement them. A Self-Balancing Binary Search Tree is used to implement TreeSet (Red Black Tree). In Java, TreeSet is backed by TreeMap. HashSet: For search, insert, and remove operations, it takes constant time on average. TreeSet is slower than HashSet. A hash table is used to implement HashSet. HashSet: TreeSet: For search, insert, and delete, TreeSet takes O(Log n), which is higher than HashSet. TreeSet, on the other hand, preserves ordered data. Higher() (Returns the least higher element), floor(), ceiling(), and other operations are also supported. In TreeSet, these operations are likewise O(Log n), and HashSet does not implement them. A Self-Balancing Binary Search Tree is used to implement TreeSet (Red Black Tree). In Java, TreeSet is backed by TreeMap. TreeSet: Way of storing elements \nThe elements of a HashSet are not ordered. In Java, the TreeSet class keeps objects in a Sorted order defined by the Comparable or Comparator methods. By default, TreeSet components are sorted in ascending order. It has a number of methods for dealing with ordered sets, including first(), last(), headSet(), tailSet(), and so on. Way of storing elements  Allowing Null values \nNull objects are allowed in HashSet. TreeSet does not allow null objects and throws a NullPointerException. This is because TreeSet compares keys using the compareTo() method, which throws java.lang. NullPointerException. Allowing Null values  Comparison\nHashSet compares two objects in a Set and detects duplicates using the equals() method. For the same purpose, TreeSet employs the compareTo() method. If equals() and compareTo() are not consistent, that is, if equals() returns true for two equal objects but compareTo() returns zero, the contract of the Set interface will be broken, allowing duplicates in Set implementations like TreeSet. Comparison  Following are the cases when TreeSet is preferred to HashSet : Following are the cases when TreeSet is preferred to HashSet : Instead of unique elements, sorted unique elements are required. TreeSet returns a sorted list that is always in ascending order.\nThe locality of TreeSet is higher than that of HashSet. If two entries are close in order, TreeSet places them in the same data structure and hence in memory, but HashSet scatters the entries over memory regardless of the keys to which they are linked.\nTo sort the components, TreeSet employs the Red-Black tree method. TreeSet is a fantastic solution if you need to do read/write operations regularly. Instead of unique elements, sorted unique elements are required. TreeSet returns a sorted list that is always in ascending order. The locality of TreeSet is higher than that of HashSet. If two entries are close in order, TreeSet places them in the same data structure and hence in memory, but HashSet scatters the entries over memory regardless of the keys to which they are linked. To sort the components, TreeSet employs the Red-Black tree method. TreeSet is a fantastic solution if you need to do read/write operations regularly.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "2. Differentiate between Collection and collections in the context of Java.",
        "answer": "Collection : In the java.util.package, there is an interface called a collection. It's used to represent a collection of separate objects as a single entity. It's equivalent to the container in the C++ programming language. The collection framework's root interface is referred to as the collection. It has a number of classes and interfaces for representing a collection of individual objects as a single unit. The key sub-interfaces of the collection interface are List, Set, and Queue. Although the map interface is part of the Java collection framework, it does not inherit the interface's collection. The Collection interface's most significant functions are add(), remove(), clear(), size(), and contains(). Collection Collections: The java.util.package has a utility class called Collections. It defines various utility methods for working with collections, such as sorting and searching. All of the methods are static. These techniques give developers much-needed convenience, allowing them to interact with Collection Framework more successfully. It provides methods like sort() to sort the collection elements in the normal sorting order, and min() and max() to get the minimum and maximum value in the collection elements, respectively. Collections   Collection Collections\nIt's used to represent a collection of separate objects as a single entity. It defines a number of useful methods for working with collections.\nIt is an interface. It is a utility class.\nSince Java 8, the Collection is an interface with a static function. Abstract and default methods can also be found in the Interface. It only has static methods in it. Collection Collections\nIt's used to represent a collection of separate objects as a single entity. It defines a number of useful methods for working with collections.\nIt is an interface. It is a utility class.\nSince Java 8, the Collection is an interface with a static function. Abstract and default methods can also be found in the Interface. It only has static methods in it. Collection Collections Collection Collections Collection Collections It's used to represent a collection of separate objects as a single entity. It defines a number of useful methods for working with collections.\nIt is an interface. It is a utility class.\nSince Java 8, the Collection is an interface with a static function. Abstract and default methods can also be found in the Interface. It only has static methods in it. It's used to represent a collection of separate objects as a single entity. It defines a number of useful methods for working with collections. It's used to represent a collection of separate objects as a single entity. It defines a number of useful methods for working with collections. It is an interface. It is a utility class. It is an interface. It is a utility class. Since Java 8, the Collection is an interface with a static function. Abstract and default methods can also be found in the Interface. It only has static methods in it. Since Java 8, the Collection is an interface with a static function. Abstract and default methods can also be found in the Interface. It only has static methods in it.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "3. Explain the hierarchy of the Collection framework in Java.",
        "answer": "The entire collection framework hierarchy is made up of four fundamental interfaces: Collection, List, Set, Map, and two specific interfaces for sorting called SortedSet and SortedMap. The java.util package contains all of the collection framework's interfaces and classes. The following diagram depicts the Java collection structure.   Here, e denotes extends, i denotes implements e i Extends: The keyword extends is used to create inheritance between two classes and two interfaces.\nImplements: The keyword implements are used to create inheritance across classes and interfaces. Extends: The keyword extends is used to create inheritance between two classes and two interfaces. Extends Implements: The keyword implements are used to create inheritance across classes and interfaces. Implements",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "4. What are the advantages of the Collection framework?",
        "answer": "Following are the advantages of the Collection framework:- Consistent API: The API has a core set of interfaces like Collection, Set, List, or Map, and all the classes (ArrayList, LinkedList, Vector, and so on) that implement these interfaces have some common set of methods. Consistent API Cuts programming effort: Instead of worrying about the Collection's design, a programmer may concentrate on how best to use it in his program. As a result, the fundamental principle of Object-oriented programming (i.e. abstraction) has been applied successfully. Cuts programming effort Improves program speed and quality by offering high-performance implementations of useful data structures and algorithms, as the programmer does not have to worry about the optimum implementation of a certain data structure in this scenario. They can simply use the best implementation to improve the performance of their program significantly. Improves program speed and quality  ",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "5. Explain the various interfaces used in the Collection framework.",
        "answer": "The collection framework has several interfaces, each of which is used to store a different sort of data. The interfaces included in the framework are listed below. 1. Iterable Interface: This is the collection framework's primary interface. The iterable interface is extended by the collection interface. As a result, all interfaces and classes implement this interface by default. This interface's main purpose is to provide an iterator for the collections. As a result, this interface only has one abstract method, the iterator. 1. Iterable Interface 2. Collection Interface: The collection framework's classes implement this interface, which extends the iterable interface. This interface covers all of the basic methods that every collection has, such as adding data to the collection, removing data from the collection, clearing data, and so on. All of these methods are incorporated in this interface because they are used by all classes, regardless of their implementation style. Furthermore, including these methods in this interface guarantees that the method names are consistent across all collections. In summary, we may conclude that this interface lays the groundwork for the implementation of collection classes. 2. Collection Interface 3. List Interface: The collection interface has a child interface called the list interface. This interface is devoted to list data, in which we can store all of the objects in an ordered collection. This also allows for the presence of redundant data. Various classes, such as ArrayList, Vector, Stack, and others, implement this list interface. We can create a list object with any of these classes because they all implement the list. 3. List Interface 4. Queue Interface: A queue interface, as the name implies, follows the FIFO (First In First Out) order of a real-world queue line. This interface is for storing all elements in which the order of the elements is important. When we try to shop at a store, for example, the bills are issued on a first-come, first-served basis. As a result, the individual whose request is first in line receives the bill first. PriorityQueue, Deque, ArrayDeque, and other classes are available. Because all of these subclasses implement the queue, we can use any of them to create a queue object. 4. Queue Interface 5. Deque Interface: It differs slightly from the queue data structure.  Deque, also known as a double-ended queue, is a data structure in which elements can be added and removed from both ends. The queue interface is extended by this interface. ArrayDeque is the class that implements this interface. Because this class implements the deque, we can use it to create a deque object. 5. Deque Interface 6. Set Interface: A set is an unordered group of objects in which duplicate values cannot be kept. This collection is utilised when we want to avoid duplication of things and only keep the ones that are unique. Various classes, such as HashSet, TreeSet, LinkedHashSet, and others, implement this set interface. We can create a set object with any of these classes because they all implement the set. 6. Set Interface 7. Sorted Set Interface: This interface resembles the set interface in appearance. The only difference is that this interface provides additional methods for maintaining element ordering. The sorted set interface is an extension of the set interface that is used to manage sorted data. TreeSet is the class that implements this interface. We can create a SortedSet object using this class because it implements the SortedSet interface. 7. Sorted Set Interface",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "6. Difference between ArrayList and LinkedList.",
        "answer": "  ArrayList LinkedList\nThe elements of this class are stored in a dynamic array. This class now supports the storage of all types of objects thanks to the addition of generics. The elements of this class are stored in a doubly-linked list. This class, like the ArrayList, allows for the storage of any type of object.\nThe List interface is implemented by this class. As a result, this serves as a list. The List and Deque interfaces are both implemented by this class. As a result, it can be used as both a list and a deque.\nBecause of the internal implementation, manipulating an ArrayList takes longer. Internally, the array is scanned and the memory bits are shifted whenever we remove an element. Because there is no concept of changing memory bits in a doubly-linked list, manipulating it takes less time than manipulating an ArrayList. The reference link is changed after traversing the list.\nThis class is more useful when the application requires data storage and access. This class is more useful when the application requires data manipulation. ArrayList LinkedList\nThe elements of this class are stored in a dynamic array. This class now supports the storage of all types of objects thanks to the addition of generics. The elements of this class are stored in a doubly-linked list. This class, like the ArrayList, allows for the storage of any type of object.\nThe List interface is implemented by this class. As a result, this serves as a list. The List and Deque interfaces are both implemented by this class. As a result, it can be used as both a list and a deque.\nBecause of the internal implementation, manipulating an ArrayList takes longer. Internally, the array is scanned and the memory bits are shifted whenever we remove an element. Because there is no concept of changing memory bits in a doubly-linked list, manipulating it takes less time than manipulating an ArrayList. The reference link is changed after traversing the list.\nThis class is more useful when the application requires data storage and access. This class is more useful when the application requires data manipulation. ArrayList LinkedList ArrayList LinkedList ArrayList LinkedList The elements of this class are stored in a dynamic array. This class now supports the storage of all types of objects thanks to the addition of generics. The elements of this class are stored in a doubly-linked list. This class, like the ArrayList, allows for the storage of any type of object.\nThe List interface is implemented by this class. As a result, this serves as a list. The List and Deque interfaces are both implemented by this class. As a result, it can be used as both a list and a deque.\nBecause of the internal implementation, manipulating an ArrayList takes longer. Internally, the array is scanned and the memory bits are shifted whenever we remove an element. Because there is no concept of changing memory bits in a doubly-linked list, manipulating it takes less time than manipulating an ArrayList. The reference link is changed after traversing the list.\nThis class is more useful when the application requires data storage and access. This class is more useful when the application requires data manipulation. The elements of this class are stored in a dynamic array. This class now supports the storage of all types of objects thanks to the addition of generics. The elements of this class are stored in a doubly-linked list. This class, like the ArrayList, allows for the storage of any type of object. The elements of this class are stored in a dynamic array. This class now supports the storage of all types of objects thanks to the addition of generics. The elements of this class are stored in a doubly-linked list. This class, like the ArrayList, allows for the storage of any type of object. The List interface is implemented by this class. As a result, this serves as a list. The List and Deque interfaces are both implemented by this class. As a result, it can be used as both a list and a deque. The List interface is implemented by this class. As a result, this serves as a list. The List and Deque interfaces are both implemented by this class. As a result, it can be used as both a list and a deque. Because of the internal implementation, manipulating an ArrayList takes longer. Internally, the array is scanned and the memory bits are shifted whenever we remove an element. Because there is no concept of changing memory bits in a doubly-linked list, manipulating it takes less time than manipulating an ArrayList. The reference link is changed after traversing the list. Because of the internal implementation, manipulating an ArrayList takes longer. Internally, the array is scanned and the memory bits are shifted whenever we remove an element. Because there is no concept of changing memory bits in a doubly-linked list, manipulating it takes less time than manipulating an ArrayList. The reference link is changed after traversing the list. This class is more useful when the application requires data storage and access. This class is more useful when the application requires data manipulation. This class is more useful when the application requires data storage and access. This class is more useful when the application requires data manipulation.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "7. Differentiate between ArrayList and Vector in java.",
        "answer": "Following are the differences between ArrayList and Vector in java : Vector is synchronized, which means that only one thread can access the code at a time, however, ArrayList is not synchronized, which means that multiple threads can operate on ArrayList at the same time. In a multithreading system, for example, if one thread is executing an add operation, another thread can be performing a removal action. \nIf multiple threads access ArrayList at the same time, we must either synchronize the code that updates the list fundamentally or enable simple element alterations. The addition or deletion of element(s) from the list is referred to as structural change. It is not a structural change to change the value of an existing element. Vector is synchronized, which means that only one thread can access the code at a time, however, ArrayList is not synchronized, which means that multiple threads can operate on ArrayList at the same time. In a multithreading system, for example, if one thread is executing an add operation, another thread can be performing a removal action. \nIf multiple threads access ArrayList at the same time, we must either synchronize the code that updates the list fundamentally or enable simple element alterations. The addition or deletion of element(s) from the list is referred to as structural change. It is not a structural change to change the value of an existing element.    Data Growth: Both ArrayList and Vector dynamically expand and shrink to make the most use of storage space, but the manner they do it is different. If the number of elements in an array exceeds its limit, ArrayList increments 50% of the current array size, while vector increments 100%, thereby doubling the current array size.\nPerformance: ArrayList is faster than vector operations because it is non-synchronized, but vector operations are slower since they are synchronized (thread-safe). When one thread works on a vector, it acquires a lock on it, requiring any other threads working on it to wait until the lock is released.\nVector can traverse over its elements using both Enumeration and Iterator, whereas ArrayList can only traverse using Iterator. Data Growth: Both ArrayList and Vector dynamically expand and shrink to make the most use of storage space, but the manner they do it is different. If the number of elements in an array exceeds its limit, ArrayList increments 50% of the current array size, while vector increments 100%, thereby doubling the current array size. Data Growth Performance: ArrayList is faster than vector operations because it is non-synchronized, but vector operations are slower since they are synchronized (thread-safe). When one thread works on a vector, it acquires a lock on it, requiring any other threads working on it to wait until the lock is released. Performance Vector can traverse over its elements using both Enumeration and Iterator, whereas ArrayList can only traverse using Iterator.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "8. Differentiate between List and Set in Java.",
        "answer": "The List interface is used to keep track of an ordered collection. It is the Collection's child interface. It is an ordered collection of objects that allows for the storage of duplicate values. The insertion order is preserved in a list, which enables positional access and element insertion. The set interface is part of java.util package and extends the Collection interface. It is an unordered collection of objects in which duplicate values cannot be stored. It's an interface for using the mathematical set. This interface inherits the Collection interface's methods and adds a feature that prevents duplicate elements from being inserted. Set List\nIt is an unordered sequence. It is an ordered sequence.\nDuplicate elements are not permitted in Set. Duplicate elements are allowed in the list\nAccess to items from a certain position is not permitted. Elements can be accessed based on their position.\nA null element can only be stored once. It is possible to store several null elements. Set List\nIt is an unordered sequence. It is an ordered sequence.\nDuplicate elements are not permitted in Set. Duplicate elements are allowed in the list\nAccess to items from a certain position is not permitted. Elements can be accessed based on their position.\nA null element can only be stored once. It is possible to store several null elements. Set List Set List Set List It is an unordered sequence. It is an ordered sequence.\nDuplicate elements are not permitted in Set. Duplicate elements are allowed in the list\nAccess to items from a certain position is not permitted. Elements can be accessed based on their position.\nA null element can only be stored once. It is possible to store several null elements. It is an unordered sequence. It is an ordered sequence. It is an unordered sequence. It is an ordered sequence. Duplicate elements are not permitted in Set. Duplicate elements are allowed in the list Duplicate elements are not permitted in Set. Duplicate elements are allowed in the list Access to items from a certain position is not permitted. Elements can be accessed based on their position. Access to items from a certain position is not permitted. Elements can be accessed based on their position. A null element can only be stored once. It is possible to store several null elements. A null element can only be stored once. It is possible to store several null elements.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "9. Differentiate between Iterator and ListIterator in Java.",
        "answer": "In Java's Collection framework, iterators are used to obtain elements one by one. It can be used on any type of Collection object. We can execute both read and remove operations using Iterator. Iterator must be used whenever we want to iterate elements in all Collection framework implemented interfaces, such as Set, List, Queue, and Deque, as well as all Map interface implemented classes. The only cursor accessible for the entire collection framework is the iterator. ListIterator is only useful for classes that implement List collections, such as array lists and linked lists. It can iterate in both directions. When we wish to enumerate List elements, we must use ListIterator. This cursor has additional methods and capabilities than the iterator.   Iterator ListIterator\nOnly has the ability to traverse components in a Collection in a forward direction. In both forward and backward orientations, can traverse components in a Collection.\nIterators cannot be used to obtain indexes. It offers methods to get element indexes at any time while traversing List, such as next Index() and previous Index().\nIt aids in the traversal of Maps, Lists, and Sets. Only List may be traversed, not the other two.\nIt throws a Concurrent Modification Exception since it can't add elements. At any time, you can quickly add elements to a collection.\nnext(), remove(), and has Next are some of the Iterator's functions (). next(), previous(), has Next(), has Previous(), and add() are some of the List Iterator's methods Iterator ListIterator\nOnly has the ability to traverse components in a Collection in a forward direction. In both forward and backward orientations, can traverse components in a Collection.\nIterators cannot be used to obtain indexes. It offers methods to get element indexes at any time while traversing List, such as next Index() and previous Index().\nIt aids in the traversal of Maps, Lists, and Sets. Only List may be traversed, not the other two.\nIt throws a Concurrent Modification Exception since it can't add elements. At any time, you can quickly add elements to a collection.\nnext(), remove(), and has Next are some of the Iterator's functions (). next(), previous(), has Next(), has Previous(), and add() are some of the List Iterator's methods Iterator ListIterator Iterator ListIterator Iterator ListIterator Only has the ability to traverse components in a Collection in a forward direction. In both forward and backward orientations, can traverse components in a Collection.\nIterators cannot be used to obtain indexes. It offers methods to get element indexes at any time while traversing List, such as next Index() and previous Index().\nIt aids in the traversal of Maps, Lists, and Sets. Only List may be traversed, not the other two.\nIt throws a Concurrent Modification Exception since it can't add elements. At any time, you can quickly add elements to a collection.\nnext(), remove(), and has Next are some of the Iterator's functions (). next(), previous(), has Next(), has Previous(), and add() are some of the List Iterator's methods Only has the ability to traverse components in a Collection in a forward direction. In both forward and backward orientations, can traverse components in a Collection. Only has the ability to traverse components in a Collection in a forward direction. In both forward and backward orientations, can traverse components in a Collection. Iterators cannot be used to obtain indexes. It offers methods to get element indexes at any time while traversing List, such as next Index() and previous Index(). Iterators cannot be used to obtain indexes. It offers methods to get element indexes at any time while traversing List, such as next Index() and previous Index(). It aids in the traversal of Maps, Lists, and Sets. Only List may be traversed, not the other two. It aids in the traversal of Maps, Lists, and Sets. Only List may be traversed, not the other two. It throws a Concurrent Modification Exception since it can't add elements. At any time, you can quickly add elements to a collection. It throws a Concurrent Modification Exception since it can't add elements. At any time, you can quickly add elements to a collection. next(), remove(), and has Next are some of the Iterator's functions (). next(), previous(), has Next(), has Previous(), and add() are some of the List Iterator's methods next(), remove(), and has Next are some of the Iterator's functions (). next(), previous(), has Next(), has Previous(), and add() are some of the List Iterator's methods",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "10. What is the difference between Array and Collection in java?",
        "answer": "Array and Collection are equivalent in terms of storing object references and manipulating data, but they differ in a number of ways. The following are the primary distinctions between an array and a Collection: Array Collection\nArrays have a set size, which means that once we build one, we can't change it to meet our needs. Collection are naturally grow-able and can be customized to meet our needs. We can change its size as per our requirement.\nWhen it comes to performance, Arrays are the preferred to Collection. Considering performance, Collection are not preferred to Arrays.\nOnly homogeneous data type elements can be stored in arrays. Both homogeneous and heterogeneous components can be stored in a collection.\nBecause arrays have no underlying data structure, there is no ready-made method support. Any collection class is built on a standard data structure, and so there is ready-made method support for every demand as a performance. These methods can be used directly, and we are not responsible for their implementation.\nObjects and primitives can both be stored in arrays. Only object types can be stored in a collection.\nWhen it comes to memory, Arrays are not preferred to Collection. Considering memory, Collection are preferred to Arrays. Array Collection\nArrays have a set size, which means that once we build one, we can't change it to meet our needs. Collection are naturally grow-able and can be customized to meet our needs. We can change its size as per our requirement.\nWhen it comes to performance, Arrays are the preferred to Collection. Considering performance, Collection are not preferred to Arrays.\nOnly homogeneous data type elements can be stored in arrays. Both homogeneous and heterogeneous components can be stored in a collection.\nBecause arrays have no underlying data structure, there is no ready-made method support. Any collection class is built on a standard data structure, and so there is ready-made method support for every demand as a performance. These methods can be used directly, and we are not responsible for their implementation.\nObjects and primitives can both be stored in arrays. Only object types can be stored in a collection.\nWhen it comes to memory, Arrays are not preferred to Collection. Considering memory, Collection are preferred to Arrays. Array Collection Array Collection Array Collection Arrays have a set size, which means that once we build one, we can't change it to meet our needs. Collection are naturally grow-able and can be customized to meet our needs. We can change its size as per our requirement.\nWhen it comes to performance, Arrays are the preferred to Collection. Considering performance, Collection are not preferred to Arrays.\nOnly homogeneous data type elements can be stored in arrays. Both homogeneous and heterogeneous components can be stored in a collection.\nBecause arrays have no underlying data structure, there is no ready-made method support. Any collection class is built on a standard data structure, and so there is ready-made method support for every demand as a performance. These methods can be used directly, and we are not responsible for their implementation.\nObjects and primitives can both be stored in arrays. Only object types can be stored in a collection.\nWhen it comes to memory, Arrays are not preferred to Collection. Considering memory, Collection are preferred to Arrays. Arrays have a set size, which means that once we build one, we can't change it to meet our needs. Collection are naturally grow-able and can be customized to meet our needs. We can change its size as per our requirement. Arrays have a set size, which means that once we build one, we can't change it to meet our needs. Collection are naturally grow-able and can be customized to meet our needs. We can change its size as per our requirement. When it comes to performance, Arrays are the preferred to Collection. Considering performance, Collection are not preferred to Arrays. When it comes to performance, Arrays are the preferred to Collection. Considering performance, Collection are not preferred to Arrays. Only homogeneous data type elements can be stored in arrays. Both homogeneous and heterogeneous components can be stored in a collection. Only homogeneous data type elements can be stored in arrays. Both homogeneous and heterogeneous components can be stored in a collection. Because arrays have no underlying data structure, there is no ready-made method support. Any collection class is built on a standard data structure, and so there is ready-made method support for every demand as a performance. These methods can be used directly, and we are not responsible for their implementation. Because arrays have no underlying data structure, there is no ready-made method support. Any collection class is built on a standard data structure, and so there is ready-made method support for every demand as a performance. These methods can be used directly, and we are not responsible for their implementation. Objects and primitives can both be stored in arrays. Only object types can be stored in a collection. Objects and primitives can both be stored in arrays. Only object types can be stored in a collection. When it comes to memory, Arrays are not preferred to Collection. Considering memory, Collection are preferred to Arrays. When it comes to memory, Arrays are not preferred to Collection. Considering memory, Collection are preferred to Arrays.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "11. Can you add a null element into a TreeSet or HashSet?",
        "answer": "We can add null elements in a HashSet but we cannot add null elements in a TreeSet. The reason is that TreeSet uses the compareTo() method for comparing and it throws a NullPointerException when it encounters a null element.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "12. What is a priority queue in Java?",
        "answer": "When the objects are meant to be processed in order of priority, a PriorityQueue is used. A Queue is known to follow the First-In-First-Out method, however, there are occasions when the components of the queue must be handled in order of priority, which is where the PriorityQueue comes into play. The priority heap is the foundation of the PriorityQueue. The members of the priority queue are ordered according to natural ordering or by a Comparator provided at queue construction time. Serializable, Iterable<E>, Collection<E>, Queue<E> interfaces are implemented by the PriorityQueue class in Java.  ",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "13. What are some of the best practices while using Java Collections?",
        "answer": "Following are some of the best practices while using Java Collections : Selecting the appropriate Collection:\nBefore we use a collection, we must choose the most relevant collection for the problem we are seeking to solve. If we pick the wrong one, our program may still run, but it will be inefficient. On the other hand, if we pick the right one, our solution will be a lot simpler and our program will run much faster.\nSpecifying the initial capacity of the Collection :\nAlmost all collection classes contain an overloaded constructor that determines the collection's initial capacity. That is, if we know exactly how many pieces will be added to the collection, we can define the initial capacity when establishing a new instance.\nUsing isEmpty() instead of size():\nTo check if a collection is empty or not we should use the isEmpty() method rather than finding the size of the collection and comparing it with zero. This enhances the readability of the code.\nUsing Iterators for iterating over the collections:\nWe should use iterators for traversing over the collection elements instead of using a for loop for the same. The reason is that the iterator may throw ConcurrentModificationException if any other thread tries to modify the collection after the iterator has been created. This saves us from bugs.\nUsing Concurrent Collections over synchronized wrappers:\nInstead of utilizing the synchronized collections generated by the Collections.synchronizedXXX() methods, we should consider using concurrent collections from the java.util.concurrent package in multi-threaded applications. Because concurrent collections employ various synchronization strategies such as copy-on-write, compare-and-swap, and specific locks, they are designed to give maximum performance in concurrent applications.\nEliminating Unchecked warnings:\nWe should not disregard unchecked warnings from the Java compiler. The ideal practice is to get rid of any warnings that aren't checked.\nFavoring Generic types:\nWe should build new methods with generic parameters in mind, and convert existing methods to use type parameters, just as we should with generic types because generic methods are safer and easier to use than non-generic ones. Generic methods also aid in the creation of APIs that are both general and reusable. Selecting the appropriate Collection:\nBefore we use a collection, we must choose the most relevant collection for the problem we are seeking to solve. If we pick the wrong one, our program may still run, but it will be inefficient. On the other hand, if we pick the right one, our solution will be a lot simpler and our program will run much faster. Selecting the appropriate Collection:  Specifying the initial capacity of the Collection :\nAlmost all collection classes contain an overloaded constructor that determines the collection's initial capacity. That is, if we know exactly how many pieces will be added to the collection, we can define the initial capacity when establishing a new instance. Specifying the initial capacity of the Collection :  Using isEmpty() instead of size():\nTo check if a collection is empty or not we should use the isEmpty() method rather than finding the size of the collection and comparing it with zero. This enhances the readability of the code. Using isEmpty() instead of size():  Using Iterators for iterating over the collections:\nWe should use iterators for traversing over the collection elements instead of using a for loop for the same. The reason is that the iterator may throw ConcurrentModificationException if any other thread tries to modify the collection after the iterator has been created. This saves us from bugs. Using Iterators for iterating over the collections:  Using Concurrent Collections over synchronized wrappers:\nInstead of utilizing the synchronized collections generated by the Collections.synchronizedXXX() methods, we should consider using concurrent collections from the java.util.concurrent package in multi-threaded applications. Because concurrent collections employ various synchronization strategies such as copy-on-write, compare-and-swap, and specific locks, they are designed to give maximum performance in concurrent applications. Using Concurrent Collections over synchronized wrappers:  Eliminating Unchecked warnings:\nWe should not disregard unchecked warnings from the Java compiler. The ideal practice is to get rid of any warnings that aren't checked. Eliminating Unchecked warnings:  Favoring Generic types:\nWe should build new methods with generic parameters in mind, and convert existing methods to use type parameters, just as we should with generic types because generic methods are safer and easier to use than non-generic ones. Generic methods also aid in the creation of APIs that are both general and reusable. Favoring Generic types: ",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "14. Differentiate between Set and Map in Java.",
        "answer": "The Set interface is provided by the Java.util package. The set interface is established by extending the collection interface. We can't add the same element to it since it won't let us. Because it contains elements in a sorted order, it does not keep the insertion order. The Set interface in Java is used to build the mathematical Set. Set Map is similar to Set in that it is used to store a collection of objects as a single entity. A key-value pair is used to store each object. Because each value is associated with a unique key, we can quickly obtain the value using just the key. Map Set Map\nIt cannot have values that are repeated. It is not possible to add the same elements to a set. Only the unique value is stored in each class that implements the Set interface. It is possible for different keys to have the same value. The map has a unique key and values that are repeated. \nUsing the keyset() and entryset() methods, we can quickly iterate the Set items. It is not possible to iterate across map elements. To iterate the elements, we must convert Map to Set.\nThe Set interface does not keep track of insertion order. Some of its classes, such as LinkedHashSet, however, keep the insertion order.  The Map does not keep track of the insertion sequence. Some Map classes, such as TreeMap and LinkedHashMap, do the same thing. Set Map\nIt cannot have values that are repeated. It is not possible to add the same elements to a set. Only the unique value is stored in each class that implements the Set interface. It is possible for different keys to have the same value. The map has a unique key and values that are repeated. \nUsing the keyset() and entryset() methods, we can quickly iterate the Set items. It is not possible to iterate across map elements. To iterate the elements, we must convert Map to Set.\nThe Set interface does not keep track of insertion order. Some of its classes, such as LinkedHashSet, however, keep the insertion order.  The Map does not keep track of the insertion sequence. Some Map classes, such as TreeMap and LinkedHashMap, do the same thing. Set Map Set Map Set Map It cannot have values that are repeated. It is not possible to add the same elements to a set. Only the unique value is stored in each class that implements the Set interface. It is possible for different keys to have the same value. The map has a unique key and values that are repeated. \nUsing the keyset() and entryset() methods, we can quickly iterate the Set items. It is not possible to iterate across map elements. To iterate the elements, we must convert Map to Set.\nThe Set interface does not keep track of insertion order. Some of its classes, such as LinkedHashSet, however, keep the insertion order.  The Map does not keep track of the insertion sequence. Some Map classes, such as TreeMap and LinkedHashMap, do the same thing. It cannot have values that are repeated. It is not possible to add the same elements to a set. Only the unique value is stored in each class that implements the Set interface. It is possible for different keys to have the same value. The map has a unique key and values that are repeated. It cannot have values that are repeated. It is not possible to add the same elements to a set. Only the unique value is stored in each class that implements the Set interface. It is possible for different keys to have the same value. The map has a unique key and values that are repeated. Using the keyset() and entryset() methods, we can quickly iterate the Set items. It is not possible to iterate across map elements. To iterate the elements, we must convert Map to Set. Using the keyset() and entryset() methods, we can quickly iterate the Set items. It is not possible to iterate across map elements. To iterate the elements, we must convert Map to Set. The Set interface does not keep track of insertion order. Some of its classes, such as LinkedHashSet, however, keep the insertion order.  The Map does not keep track of the insertion sequence. Some Map classes, such as TreeMap and LinkedHashMap, do the same thing. The Set interface does not keep track of insertion order. Some of its classes, such as LinkedHashSet, however, keep the insertion order. The Map does not keep track of the insertion sequence. Some Map classes, such as TreeMap and LinkedHashMap, do the same thing.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "15. Differentiate between HashSet and HashMap.",
        "answer": "HashSet is a Set Interface implementation that does not allow duplicate values. The essential point is that objects stored in HashSet must override equals() and hashCode() methods to ensure that no duplicate values are stored in our set. HashSet HashMap is a Map Interface implementation that maps a key to a value. In a map, duplicate keys are not permitted. HashMap   HashSet HashMap\nIt implements the Set Interface. It implements the Map Interface.\nIt does not allow duplicate values. The key needs to be unique while two different keys can have the same value.\nWhile adding an element it requires only one object as a parameter. While adding an entry, it requires two object values, the Key and the Value as the parameter.\nInternally, HashSet uses HashMap to add entries. The key K in a HashSet is the argument supplied in the add(Object) method. For each value supplied in the add(Object) method, Java assigns a dummy value. There is no concept of duplicate values.\nIt is slower than HashMap. It is faster than HashSet.\nIt uses the add() method for adding elements. It uses the put() method for adding data elements. HashSet HashMap\nIt implements the Set Interface. It implements the Map Interface.\nIt does not allow duplicate values. The key needs to be unique while two different keys can have the same value.\nWhile adding an element it requires only one object as a parameter. While adding an entry, it requires two object values, the Key and the Value as the parameter.\nInternally, HashSet uses HashMap to add entries. The key K in a HashSet is the argument supplied in the add(Object) method. For each value supplied in the add(Object) method, Java assigns a dummy value. There is no concept of duplicate values.\nIt is slower than HashMap. It is faster than HashSet.\nIt uses the add() method for adding elements. It uses the put() method for adding data elements. HashSet HashMap HashSet HashMap HashSet HashMap It implements the Set Interface. It implements the Map Interface.\nIt does not allow duplicate values. The key needs to be unique while two different keys can have the same value.\nWhile adding an element it requires only one object as a parameter. While adding an entry, it requires two object values, the Key and the Value as the parameter.\nInternally, HashSet uses HashMap to add entries. The key K in a HashSet is the argument supplied in the add(Object) method. For each value supplied in the add(Object) method, Java assigns a dummy value. There is no concept of duplicate values.\nIt is slower than HashMap. It is faster than HashSet.\nIt uses the add() method for adding elements. It uses the put() method for adding data elements. It implements the Set Interface. It implements the Map Interface. It implements the Set Interface. It implements the Map Interface. It does not allow duplicate values. The key needs to be unique while two different keys can have the same value. It does not allow duplicate values. The key needs to be unique while two different keys can have the same value. While adding an element it requires only one object as a parameter. While adding an entry, it requires two object values, the Key and the Value as the parameter. While adding an element it requires only one object as a parameter. While adding an entry, it requires two object values, the Key and the Value as the parameter. Key Value Internally, HashSet uses HashMap to add entries. The key K in a HashSet is the argument supplied in the add(Object) method. For each value supplied in the add(Object) method, Java assigns a dummy value. There is no concept of duplicate values. Internally, HashSet uses HashMap to add entries. The key K in a HashSet is the argument supplied in the add(Object) method. For each value supplied in the add(Object) method, Java assigns a dummy value. There is no concept of duplicate values. It is slower than HashMap. It is faster than HashSet. It is slower than HashMap. It is faster than HashSet. It uses the add() method for adding elements. It uses the put() method for adding data elements. It uses the add() method for adding elements. It uses the put() method for adding data elements.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "16. What is the default size of the load factor in hashing based collection?",
        "answer": "The default load factor size is 0.75. The default capacity is calculated by multiplying the initial capacity by the load factor. 0.75",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "17. Differentiate between Array and ArrayList in Java.",
        "answer": "Following are the differences between Arrays and ArrayLists in Java : differences between Arrays and ArrayLists   Java provides arrays as a fundamental functionality. ArrayList is a component of Java's collection system. As a result, It is used to access array members, while ArrayList provides a set of methods for accessing and modifying components.\nArrayList is not a fixed-size data structure, but Array is. When creating an ArrayList object, there is no need to provide its size. Even if we set a maximum capacity, we can add more parts afterward.\nArrays can include both primitive data types and class objects, depending on the array's definition. ArrayList, on the other hand, only accepts object entries and not primitive data types. Note that when we use arraylist.add(1);, the primitive int data type is converted to an Integer object.\nMembers of ArrayList are always referencing to objects at various memory locations since ArrayList can't be constructed for primitive data types  As a result, the actual objects in an ArrayList are never kept in the same place. The references to the real items are maintained in close proximity. Whether an array is primitive or an object depends on the type of the array. Actual values for primitive kinds are continuous regions, whereas allocation for objects is equivalent to ArrayList.\nMany other operations, such as indexOf() and delete(), are supported by Java ArrayList. Arrays do not support these functions. Java provides arrays as a fundamental functionality. ArrayList is a component of Java's collection system. As a result, It is used to access array members, while ArrayList provides a set of methods for accessing and modifying components. ArrayList is not a fixed-size data structure, but Array is. When creating an ArrayList object, there is no need to provide its size. Even if we set a maximum capacity, we can add more parts afterward. Arrays can include both primitive data types and class objects, depending on the array's definition. ArrayList, on the other hand, only accepts object entries and not primitive data types. Note that when we use arraylist.add(1);, the primitive int data type is converted to an Integer object. Members of ArrayList are always referencing to objects at various memory locations since ArrayList can't be constructed for primitive data types  As a result, the actual objects in an ArrayList are never kept in the same place. The references to the real items are maintained in close proximity. Whether an array is primitive or an object depends on the type of the array. Actual values for primitive kinds are continuous regions, whereas allocation for objects is equivalent to ArrayList. Many other operations, such as indexOf() and delete(), are supported by Java ArrayList. Arrays do not support these functions.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "18. How can you make an ArrayList read-only in Java?",
        "answer": "With the help of Collections.unmodifiableList() method, we can easily make an ArrayList read-only.  This function takes a changeable ArrayList as an input and returns the ArrayList's read-only, unmodified view. Example: Example: import java.util.*;\n \npublic class InterviewBit {\n   public static void main(String[] args)\n       throws Exception\n   {\n       try {\n \n           // creating object of ArrayList<String>\n           List<String> sample_list = new ArrayList<String>();\n \n           sample_list.add(practice);\n           sample_list.add(solve);\n           sample_list.add(interview);\n \n           // displaying the initial list\n           System.out.println(\"The initial list is : \"\n                              + sample_list);\n \n           // using unmodifiableList() method\n           List<String>\n               read_only_list = Collections\n                                   .unmodifiableList(sample_list);\n \n           // displaying the read-only list\n           System.out.println(\"The ReadOnly ArrayList is : \"\n                              + read_only_list);\n \n           // Trying to add an element to the read-only list\n           System.out.println(\"Trying to modify the ReadOnly ArrayList.\");                       \n           read_only_list.add(job);\n       }\n \n       catch (UnsupportedOperationException e) {\n           System.out.println(\"The exception thrown is : \" + e);\n       }\n   }\n} import java.util.*;\n \npublic class InterviewBit {\n   public static void main(String[] args)\n       throws Exception\n   {\n       try {\n \n           // creating object of ArrayList<String>\n           List<String> sample_list = new ArrayList<String>();\n \n           sample_list.add(practice);\n           sample_list.add(solve);\n           sample_list.add(interview);\n \n           // displaying the initial list\n           System.out.println(\"The initial list is : \"\n                              + sample_list);\n \n           // using unmodifiableList() method\n           List<String>\n               read_only_list = Collections\n                                   .unmodifiableList(sample_list);\n \n           // displaying the read-only list\n           System.out.println(\"The ReadOnly ArrayList is : \"\n                              + read_only_list);\n \n           // Trying to add an element to the read-only list\n           System.out.println(\"Trying to modify the ReadOnly ArrayList.\");                       \n           read_only_list.add(job);\n       }\n \n       catch (UnsupportedOperationException e) {\n           System.out.println(\"The exception thrown is : \" + e);\n       }\n   }\n} import public class InterviewBit class InterviewBit public static void main(String[] args)\n       throws Exception public static void main (String[] args) throws try // creating object of ArrayList<String> new // displaying the initial list \"The initial list is : \" // using unmodifiableList() method // displaying the read-only list \"The ReadOnly ArrayList is : \" // Trying to add an element to the read-only list \"Trying to modify the ReadOnly ArrayList.\" catch \"The exception thrown is : \" Output: Output: The initial list is : [practice, solve, interview]\nThe ReadOnly ArrayList is : [practice, solve, interview]\nTrying to modify th eReadOnly ArrayList.\nException thrown : java.lang.UnsupportedOperationException The initial list is : [practice, solve, interview]\nThe ReadOnly ArrayList is : [practice, solve, interview]\nTrying to modify th eReadOnly ArrayList.\nException thrown : java.lang.UnsupportedOperationException We can see that as we try to add an element to a read-only ArrayList we get an exception thrown.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "1. Why do we need synchronized ArrayList when we have Vectors (which are synchronized) in Java?",
        "answer": "Following are the reasons why we need synchronized ArrayLists even though we have Vectors : Vector is slightly slower than ArrayList due to the fact that it is synchronized and thread-safe.\nVector's functionality is that it synchronizes each individual action. A programmer's preference is to synchronize an entire sequence of actions. Individual operations are less safe and take longer to synchronize.\nVectors are considered outdated in Java and have been unofficially deprecated. Vector also synchronizes on a per-operation basis, which is almost never done. Most java programmers prefer to use ArrayList since they will almost certainly synchronize the arrayList explicitly if they need to do so. Vector is slightly slower than ArrayList due to the fact that it is synchronized and thread-safe. Vector's functionality is that it synchronizes each individual action. A programmer's preference is to synchronize an entire sequence of actions. Individual operations are less safe and take longer to synchronize. Vectors are considered outdated in Java and have been unofficially deprecated. Vector also synchronizes on a per-operation basis, which is almost never done. Most java programmers prefer to use ArrayList since they will almost certainly synchronize the arrayList explicitly if they need to do so.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "2. What do you understand about BlockingQueue in Java?",
        "answer": "BlockingQueue is an interface that has been included along with a number of other concurrent Utility classes such as ConcurrentHashMap, Counting Semaphore, CopyOnWriteArrayList, and so on. In addition to queueing, the BlockingQueue interface enables flow control by adding blocking if either BlockingQueue is full or empty. A thread attempting to enqueue an element in a full queue will be blocked until another thread clears the queue, either by dequeuing one or more elements or by clearing the queue entirely. It also prevents a thread from deleting from an empty queue until another thread inserts an item. A null value is not accepted by BlockingQueue. Implementations of the Java BlockingQueue interface are thread-safe. BlockingQueue's methods are all atomic and use internal locks or other forms of concurrency management.   There are two types of BlockingQueue in Java. They are as follows : Unbounded Queue: The blocked queue's capacity will be set to Integer. MAX VALUE. An unbounded blocking queue will never block since it has the potential to grow to a very big size. As you add more pieces, the size of the queue grows. Unbounded Queue Example : Example : Example : BlockingQueue unbounded_queue = new LinkedBlockingDeque(); BlockingQueue unbounded_queue = new LinkedBlockingDeque(); new Bounded Queue: The bounded queue is the second type of queue. In the case of a bounded queue, the capacity of the queue can be passed to the constructor when the blocking queue is created. Bounded Queue Example: Example: Example: // Creates a Blocking Queue with capacity 10\nBlockingQueue bounded_queue = new LinkedBlockingDeque(10); // Creates a Blocking Queue with capacity 10\nBlockingQueue bounded_queue = new LinkedBlockingDeque(10); // Creates a Blocking Queue with capacity 10 new 10",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "3. Explain fail-fast and fail-safe iterators. Differentiate between them.",
        "answer": "If the collection's structure is changed, Fail-Fast iterators immediately throw ConcurrentModificationException. While a thread is iterating over a collection, structural alteration includes adding or deleting any element. Fail-safe Iterator classes include ArrayList Iterator and HashMap Iterator. Fail-fast iterators use an internal indicator called modCount, which is updated each time a collection is modified, to determine if the collection has been structurally modified or not. When a fail-fast iterator gets the next item (through the next() method), it checks the modCount flag, and if it discovers that the modCount has been changed after the iterator was generated, it throws a ConcurrentModificationException. Fail-Fast If a collection is structurally updated while iterating over it, fail-safe iterators don't throw any exceptions. Because they operate on a clone of the collection rather than the original collection, they are referred to as fail-safe iterators. Fail-safe Iterators include the CopyOnWriteArrayList and ConcurrentHashMap classes. fail-safe   Fail-Fast Fail-Safe\nThese types of iterators do not allow modifying the collection while iterating over it. These types of iterators allow modifying the collection while iterating over it.\nIt throws ConcurrentModificationException if the collection is modified while iterating over it. No exception is thrown if the collection is modified while iterating over it.\nIt uses the original collection while traversing the elements. It uses a copy of the original collection while traversing over it.\nNo extra memory is required in this case. Extra memory is required in this case. Fail-Fast Fail-Safe\nThese types of iterators do not allow modifying the collection while iterating over it. These types of iterators allow modifying the collection while iterating over it.\nIt throws ConcurrentModificationException if the collection is modified while iterating over it. No exception is thrown if the collection is modified while iterating over it.\nIt uses the original collection while traversing the elements. It uses a copy of the original collection while traversing over it.\nNo extra memory is required in this case. Extra memory is required in this case. Fail-Fast Fail-Safe Fail-Fast Fail-Safe Fail-Fast Fail-Safe These types of iterators do not allow modifying the collection while iterating over it. These types of iterators allow modifying the collection while iterating over it.\nIt throws ConcurrentModificationException if the collection is modified while iterating over it. No exception is thrown if the collection is modified while iterating over it.\nIt uses the original collection while traversing the elements. It uses a copy of the original collection while traversing over it.\nNo extra memory is required in this case. Extra memory is required in this case. These types of iterators do not allow modifying the collection while iterating over it. These types of iterators allow modifying the collection while iterating over it. These types of iterators do not allow modifying the collection while iterating over it. These types of iterators allow modifying the collection while iterating over it. It throws ConcurrentModificationException if the collection is modified while iterating over it. No exception is thrown if the collection is modified while iterating over it. It throws ConcurrentModificationException if the collection is modified while iterating over it. No exception is thrown if the collection is modified while iterating over it. It uses the original collection while traversing the elements. It uses a copy of the original collection while traversing over it. It uses the original collection while traversing the elements. It uses a copy of the original collection while traversing over it. No extra memory is required in this case. Extra memory is required in this case. No extra memory is required in this case. Extra memory is required in this case.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "4. What is the purpose of RandomAccess Interface? Name a collection type which implements this interface.",
        "answer": "RandomAccess, like the Serializable and Cloneable interfaces, is a marker interface. There are no methods defined in any of these marker interfaces. Rather, they designate a class as having a specific capability. The RandomAccess interface indicates whether or not a given java.util.List implementation supports random access. This interface seeks to define a vague concept: what does it mean to be fast? A simple guide is provided in the documentation: The List has fast random access if repeated access using the List.get( ) method is faster than repeated access using the Iterator.next( ) method. Repeated access using List.get( ): Object obj;\nfor (int i=0, n=list.size(  ); i < n; i++)\n obj = list.get(i); Object obj;\nfor (int i=0, n=list.size(  ); i < n; i++)\n obj = list.get(i); for int 0 Repeated access using Iterator.next( ): Object obj;\nfor (Iterator itr=list.iterator(  ); itr.hasNext(  ); )\n obj = itr.next( ); Object obj;\nfor (Iterator itr=list.iterator(  ); itr.hasNext(  ); )\n obj = itr.next( ); for",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "5. Differentiate between Iterator and Enumeration.",
        "answer": "Iterator: Because it can be applied to any Collection object, it is a universal iterator. We can execute both read and remove operations using Iterator. It's an enhanced version of Enumeration that adds the ability to remove an element from the list. Iterator Enumeration: An enumeration (or enum) is a data type that is defined by the user. It's mostly used to give integral constants names, which make a program easier to comprehend and maintain. Enums are represented in Java (since 1.5) through the enum data type. Enumeration Iterator Enumeration\nIterator is a universal cursor since it works with all collection classes. Because it only applies to legacy classes, enumeration is not a universal cursor.\nIterators can make changes (for example, the delete() method removes an element from a Collection during traversal). The Enumeration interface is a read-only interface, which means you can't make any changes to the Collection while traversing its elements.\nThe remove() method is available in the Iterator class. The remove() method is not available in the enumeration.\nIterator is not a legacy interface. Iterator can traverse HashMaps, LinkedLists, ArrayLists, HashSets, TreeMaps, and TreeSets. Enumeration is a legacy interface for traversing Hashtables and Vectors. Iterator Enumeration\nIterator is a universal cursor since it works with all collection classes. Because it only applies to legacy classes, enumeration is not a universal cursor.\nIterators can make changes (for example, the delete() method removes an element from a Collection during traversal). The Enumeration interface is a read-only interface, which means you can't make any changes to the Collection while traversing its elements.\nThe remove() method is available in the Iterator class. The remove() method is not available in the enumeration.\nIterator is not a legacy interface. Iterator can traverse HashMaps, LinkedLists, ArrayLists, HashSets, TreeMaps, and TreeSets. Enumeration is a legacy interface for traversing Hashtables and Vectors. Iterator Enumeration Iterator Enumeration Iterator Enumeration Iterator is a universal cursor since it works with all collection classes. Because it only applies to legacy classes, enumeration is not a universal cursor.\nIterators can make changes (for example, the delete() method removes an element from a Collection during traversal). The Enumeration interface is a read-only interface, which means you can't make any changes to the Collection while traversing its elements.\nThe remove() method is available in the Iterator class. The remove() method is not available in the enumeration.\nIterator is not a legacy interface. Iterator can traverse HashMaps, LinkedLists, ArrayLists, HashSets, TreeMaps, and TreeSets. Enumeration is a legacy interface for traversing Hashtables and Vectors. Iterator is a universal cursor since it works with all collection classes. Because it only applies to legacy classes, enumeration is not a universal cursor. Iterator is a universal cursor since it works with all collection classes. Because it only applies to legacy classes, enumeration is not a universal cursor. Iterators can make changes (for example, the delete() method removes an element from a Collection during traversal). The Enumeration interface is a read-only interface, which means you can't make any changes to the Collection while traversing its elements. Iterators can make changes (for example, the delete() method removes an element from a Collection during traversal). The Enumeration interface is a read-only interface, which means you can't make any changes to the Collection while traversing its elements. The remove() method is available in the Iterator class. The remove() method is not available in the enumeration. The remove() method is available in the Iterator class. The remove() method is not available in the enumeration. Iterator is not a legacy interface. Iterator can traverse HashMaps, LinkedLists, ArrayLists, HashSets, TreeMaps, and TreeSets. Enumeration is a legacy interface for traversing Hashtables and Vectors. Iterator is not a legacy interface. Iterator can traverse HashMaps, LinkedLists, ArrayLists, HashSets, TreeMaps, and TreeSets. Enumeration is a legacy interface for traversing Hashtables and Vectors.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "6. What is the use of Properties class in Java? What is the advantage of the Properties file?",
        "answer": "The key and value pair are both strings in the properties object. The java.util.Properties class is a Hashtable subclass. It can be used to calculate the value of a property based on its key. The Properties class has methods for reading and writing data to and from the properties file. It can also be used to obtain a system's attributes. Advantage of the Properties file: Advantage of the Properties file If the information in a properties file is modified, no recompilation is required: You don't need to recompile the java class if any information in the properties file changes. It is used to keep track of information that needs to be updated frequently. Example: Example: Example: Let us first create a properties file named info.properties having the following content : user = success password = determination Let us now create a java class to read data from the properties file import java.util.*;  \nimport java.io.*;  \npublic class Sample {  \npublic static void main(String[] args)throws Exception{  \n   FileReader reader = new FileReader(\"info.properties\");  \n   Properties obj_p = new Properties();  \n   obj_p.load(reader);  \n   System.out.println(obj_p.getProperty(\"user\"));  \n   System.out.println(obj_p.getProperty(\"password\"));  \n}  \n} import java.util.*;  \nimport java.io.*;  \npublic class Sample {  \npublic static void main(String[] args)throws Exception{  \n   FileReader reader = new FileReader(\"info.properties\");  \n   Properties obj_p = new Properties();  \n   obj_p.load(reader);  \n   System.out.println(obj_p.getProperty(\"user\"));  \n   System.out.println(obj_p.getProperty(\"password\"));  \n}  \n} import import public class Sample class Sample public static void main(String[] args)throws Exception public static void main (String[] args) throws new \"info.properties\" new \"user\" \"password\" Output: Output: Output: success\ndetermination success\ndetermination",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "7. Differentiate between HashMap and HashTable.",
        "answer": "Following are the differences between HashMap and HashTable: differences between HashMap and HashTable   HashMap is a non-synchronized data structure. It is not thread-safe and cannot be shared across many threads without the use of synchronization code, while Hashtable is synchronized. It's thread-safe and can be used by several threads.\nHashMap supports one null key and numerous null values, whereas Hashtable does not.\nIf thread synchronization is not required, HashMap is often preferable over HashTable. HashMap is a non-synchronized data structure. It is not thread-safe and cannot be shared across many threads without the use of synchronization code, while Hashtable is synchronized. It's thread-safe and can be used by several threads. HashMap supports one null key and numerous null values, whereas Hashtable does not. If thread synchronization is not required, HashMap is often preferable over HashTable.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "8. Why does HashMap allow null whereas HashTable does not allow null?",
        "answer": "The objects used as keys must implement the hashCode and equals methods in order to successfully save and retrieve objects from a HashTable. These methods cannot be implemented by null because it is not an object. HashMap is a more advanced and improved variant of Hashtable.HashMap was invented after HashTable to overcome the shortcomings of HashTable.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "9. How can you synchronize an ArrayList in Java?",
        "answer": "An ArrayList can be synchronized using the following two ways : Using Collections.synchronizedList() method:\nAll access to the backup list must be done through the returning list in order to perform serial access. When iterating over the returned list, it is critical that the user manually synchronizes.\nExample: Using Collections.synchronizedList() method:\nAll access to the backup list must be done through the returning list in order to perform serial access. When iterating over the returned list, it is critical that the user manually synchronizes.\nExample: Using Collections.synchronizedList() method:   Example: Example: import java.util.*;\n \nclass InterviewBit\n{\n   public static void main (String[] args)\n   {\n       List<String> synchronized_list =\n          Collections.synchronizedList(new ArrayList<String>());\n \n       synchronized_list.add(\"learn\");\n       synchronized_list.add(\"practice\");\n       synchronized_list.add(\"solve\");\n       synchronized_list.add(\"interview\");\n       \n       synchronized(synchronized_list)// must be declared\n       {\n          \n           Iterator it = synchronized_list.iterator();\n \n           while (it.hasNext())\n               System.out.println(it.next());\n       }\n   }\n} import java.util.*;\n \nclass InterviewBit\n{\n   public static void main (String[] args)\n   {\n       List<String> synchronized_list =\n          Collections.synchronizedList(new ArrayList<String>());\n \n       synchronized_list.add(\"learn\");\n       synchronized_list.add(\"practice\");\n       synchronized_list.add(\"solve\");\n       synchronized_list.add(\"interview\");\n       \n       synchronized(synchronized_list)// must be declared\n       {\n          \n           Iterator it = synchronized_list.iterator();\n \n           while (it.hasNext())\n               System.out.println(it.next());\n       }\n   }\n} import class InterviewBit class InterviewBit public static void main (String[] args) public static void main (String[] args) new \"learn\" \"practice\" \"solve\" \"interview\" synchronized // must be declared while Output: Output: Output: learn\npractice\nsolve\ninterview learn\npractice\nsolve\ninterview Using CopyOnWriteArrayList: Using CopyOnWriteArrayList: Using CopyOnWriteArrayList: Syntax: Syntax: Syntax: CopyOnWriteArrayList<T> list_name = new CopyOnWriteArrayList<T>(); CopyOnWriteArrayList<T> list_name = new CopyOnWriteArrayList<T>(); Here, a thread-safe variant of ArrayList is created. T represents generic. All mutative actions (e.g. add, set, remove, etc.) are implemented by generating a separate copy of the underlying array in this thread-safe variation of ArrayList. It accomplishes thread safety by generating a second copy of List, which differs from how vectors and other collections achieve thread-safety. Even if copyOnWriteArrayList is modified after an iterator is formed, the iterator does not raise ConcurrentModificationException because the iterator is iterating over a separate copy of ArrayList while a write operation is occurring on another copy of ArrayList. Example: Example: Example: import java.io.*;\nimport java.util.Iterator;\nimport java.util.concurrent.CopyOnWriteArrayList;\n \nclass InterviewBit\n{\n   public static void main (String[] args)\n   {\n      \n       CopyOnWriteArrayList<String> synchronized_list\n           = new CopyOnWriteArrayList<String>();// creating a thread-safe Arraylist.\n \n       // Adding strings to the synchronized ArrayList\n       synchronized_list.add(\"learn\");\n       synchronized_list.add(\"practice\");\n       synchronized_list.add(\"solve\");\n       synchronized_list.add(\"interview\");\n \n       System.out.println(\"The synchronized ArrayList has the following elements :\");\n \n       // Iterating on the synchronized ArrayList using an iterator.\n       Iterator<String> it = synchronized_list.iterator();\n \n       while (it.hasNext())\n           System.out.println(it.next());\n   }\n} import java.io.*;\nimport java.util.Iterator;\nimport java.util.concurrent.CopyOnWriteArrayList;\n \nclass InterviewBit\n{\n   public static void main (String[] args)\n   {\n      \n       CopyOnWriteArrayList<String> synchronized_list\n           = new CopyOnWriteArrayList<String>();// creating a thread-safe Arraylist.\n \n       // Adding strings to the synchronized ArrayList\n       synchronized_list.add(\"learn\");\n       synchronized_list.add(\"practice\");\n       synchronized_list.add(\"solve\");\n       synchronized_list.add(\"interview\");\n \n       System.out.println(\"The synchronized ArrayList has the following elements :\");\n \n       // Iterating on the synchronized ArrayList using an iterator.\n       Iterator<String> it = synchronized_list.iterator();\n \n       while (it.hasNext())\n           System.out.println(it.next());\n   }\n} import import import class InterviewBit class InterviewBit public static void main (String[] args) public static void main (String[] args) new // creating a thread-safe Arraylist. // Adding strings to the synchronized ArrayList \"learn\" \"practice\" \"solve\" \"interview\" \"The synchronized ArrayList has the following elements :\" // Iterating on the synchronized ArrayList using an iterator. while Output: Output: Output: The synchronized ArrayList has the following elements :\nlearn\npractice\nsolve\ninterview The synchronized ArrayList has the following elements :\nlearn\npractice\nsolve\ninterview synchronized",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "10. Differentiate between Comparable and Comparator in the context of Java.",
        "answer": "  Comparable Comparator\nA single sorting sequence is provided by Comparable. To put it another way, we can sort the collection by a single attribute such as id, name, or price. Multiple sorting sequences are available in the Comparator. To put it another way, we can sort the collection based on different criteria such as id, name, and price.\nTo sort elements, Comparable provides the compareTo() method. To order elements, the Comparator provides the compare() method.\nIt is present in the java.lang package. It is present in the java.util package.\nThe original class is affected by Comparable, i.e. the real class is changed.  The original class is unaffected by the comparator, i.e. the real class is unaffected.\nThe Collections.sort(List) method can be used to sort Comparable type list members. The Collections.sort(List, Comparator) method can be used to sort the list components of the Comparator type. Comparable Comparator\nA single sorting sequence is provided by Comparable. To put it another way, we can sort the collection by a single attribute such as id, name, or price. Multiple sorting sequences are available in the Comparator. To put it another way, we can sort the collection based on different criteria such as id, name, and price.\nTo sort elements, Comparable provides the compareTo() method. To order elements, the Comparator provides the compare() method.\nIt is present in the java.lang package. It is present in the java.util package.\nThe original class is affected by Comparable, i.e. the real class is changed.  The original class is unaffected by the comparator, i.e. the real class is unaffected.\nThe Collections.sort(List) method can be used to sort Comparable type list members. The Collections.sort(List, Comparator) method can be used to sort the list components of the Comparator type. Comparable Comparator Comparable Comparator Comparable Comparator A single sorting sequence is provided by Comparable. To put it another way, we can sort the collection by a single attribute such as id, name, or price. Multiple sorting sequences are available in the Comparator. To put it another way, we can sort the collection based on different criteria such as id, name, and price.\nTo sort elements, Comparable provides the compareTo() method. To order elements, the Comparator provides the compare() method.\nIt is present in the java.lang package. It is present in the java.util package.\nThe original class is affected by Comparable, i.e. the real class is changed.  The original class is unaffected by the comparator, i.e. the real class is unaffected.\nThe Collections.sort(List) method can be used to sort Comparable type list members. The Collections.sort(List, Comparator) method can be used to sort the list components of the Comparator type. A single sorting sequence is provided by Comparable. To put it another way, we can sort the collection by a single attribute such as id, name, or price. Multiple sorting sequences are available in the Comparator. To put it another way, we can sort the collection based on different criteria such as id, name, and price. A single sorting sequence is provided by Comparable. To put it another way, we can sort the collection by a single attribute such as id, name, or price. Multiple sorting sequences are available in the Comparator. To put it another way, we can sort the collection based on different criteria such as id, name, and price. To sort elements, Comparable provides the compareTo() method. To order elements, the Comparator provides the compare() method. To sort elements, Comparable provides the compareTo() method. To order elements, the Comparator provides the compare() method. It is present in the java.lang package. It is present in the java.util package. It is present in the java.lang package. It is present in the java.util package. The original class is affected by Comparable, i.e. the real class is changed.  The original class is unaffected by the comparator, i.e. the real class is unaffected. The original class is affected by Comparable, i.e. the real class is changed. The original class is unaffected by the comparator, i.e. the real class is unaffected. The Collections.sort(List) method can be used to sort Comparable type list members. The Collections.sort(List, Comparator) method can be used to sort the list components of the Comparator type. The Collections.sort(List) method can be used to sort Comparable type list members. The Collections.sort(List, Comparator) method can be used to sort the list components of the Comparator type.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "11. Why does not the Map interface extend the Collection Interface or vice-versa?",
        "answer": "If Map extends the Collection Interface, \"Key-value pairs\" can be the only element type for this type of Collection, although this provides a very limited (and not really useful) Map abstraction. You can't inquire what value a specific key corresponds to, and you can't delete an entry without knowing what value it corresponds to. The three \"Collection view procedures\" on Maps represent the fact that Maps can be viewed as Collections (of keys, values, or pairs) (keySet, entrySet, and values). While it is theoretically feasible to see a List as a Map mapping indices to items, this has the unfortunate side effect of changing the Key associated with every element in the List prior to the deleted member. This is the reason why Collection can not be made to extend the Map Interface either.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "12. Differentiate between HashMap and TreeMap in the context of Java.",
        "answer": "  HashMap TreeMap\nThe Java HashMap implementation of the Map interface is based on hash tables. Java TreeMap is a Map interface implementation based on a Tree structure.\nThe Map, Cloneable, and Serializable interfaces are implemented by HashMap. NavigableMap, Cloneable, and Serializable interfaces are implemented by TreeMap.\nBecause HashMap does not order on keys, it allows for heterogeneous elements. Because of the sorting, TreeMap allows homogenous values to be used as a key.\nHashMap is quicker than TreeMap because it offers O(1) constant-time performance for basic operations such as to get() and put(). TreeMap is slower than HashMap because it performs most operations with O(log(n)) performance, such as add(), remove(), and contains().\nA single null key and numerous null values are allowed in HashMap. TreeMap does not allow null keys, however multiple null values are allowed.\nTo compare keys, it uses the Object class's equals() method. It is overridden by the Map class's equals() function. It compares keys using the compareTo() method.\nHashMap does not keep track of any sort of order. The elements are arranged in chronological sequence (ascending).\nWhen we don't need a sorted key-value pair, we should use the HashMap.  When we need a key-value pair in sorted (ascending) order, we should use the TreeMap. HashMap TreeMap\nThe Java HashMap implementation of the Map interface is based on hash tables. Java TreeMap is a Map interface implementation based on a Tree structure.\nThe Map, Cloneable, and Serializable interfaces are implemented by HashMap. NavigableMap, Cloneable, and Serializable interfaces are implemented by TreeMap.\nBecause HashMap does not order on keys, it allows for heterogeneous elements. Because of the sorting, TreeMap allows homogenous values to be used as a key.\nHashMap is quicker than TreeMap because it offers O(1) constant-time performance for basic operations such as to get() and put(). TreeMap is slower than HashMap because it performs most operations with O(log(n)) performance, such as add(), remove(), and contains().\nA single null key and numerous null values are allowed in HashMap. TreeMap does not allow null keys, however multiple null values are allowed.\nTo compare keys, it uses the Object class's equals() method. It is overridden by the Map class's equals() function. It compares keys using the compareTo() method.\nHashMap does not keep track of any sort of order. The elements are arranged in chronological sequence (ascending).\nWhen we don't need a sorted key-value pair, we should use the HashMap.  When we need a key-value pair in sorted (ascending) order, we should use the TreeMap. HashMap TreeMap HashMap TreeMap HashMap TreeMap The Java HashMap implementation of the Map interface is based on hash tables. Java TreeMap is a Map interface implementation based on a Tree structure.\nThe Map, Cloneable, and Serializable interfaces are implemented by HashMap. NavigableMap, Cloneable, and Serializable interfaces are implemented by TreeMap.\nBecause HashMap does not order on keys, it allows for heterogeneous elements. Because of the sorting, TreeMap allows homogenous values to be used as a key.\nHashMap is quicker than TreeMap because it offers O(1) constant-time performance for basic operations such as to get() and put(). TreeMap is slower than HashMap because it performs most operations with O(log(n)) performance, such as add(), remove(), and contains().\nA single null key and numerous null values are allowed in HashMap. TreeMap does not allow null keys, however multiple null values are allowed.\nTo compare keys, it uses the Object class's equals() method. It is overridden by the Map class's equals() function. It compares keys using the compareTo() method.\nHashMap does not keep track of any sort of order. The elements are arranged in chronological sequence (ascending).\nWhen we don't need a sorted key-value pair, we should use the HashMap.  When we need a key-value pair in sorted (ascending) order, we should use the TreeMap. The Java HashMap implementation of the Map interface is based on hash tables. Java TreeMap is a Map interface implementation based on a Tree structure. The Java HashMap implementation of the Map interface is based on hash tables. Java TreeMap is a Map interface implementation based on a Tree structure. The Map, Cloneable, and Serializable interfaces are implemented by HashMap. NavigableMap, Cloneable, and Serializable interfaces are implemented by TreeMap. The Map, Cloneable, and Serializable interfaces are implemented by HashMap. NavigableMap, Cloneable, and Serializable interfaces are implemented by TreeMap. Because HashMap does not order on keys, it allows for heterogeneous elements. Because of the sorting, TreeMap allows homogenous values to be used as a key. Because HashMap does not order on keys, it allows for heterogeneous elements. Because of the sorting, TreeMap allows homogenous values to be used as a key. HashMap is quicker than TreeMap because it offers O(1) constant-time performance for basic operations such as to get() and put(). TreeMap is slower than HashMap because it performs most operations with O(log(n)) performance, such as add(), remove(), and contains(). HashMap is quicker than TreeMap because it offers O(1) constant-time performance for basic operations such as to get() and put(). TreeMap is slower than HashMap because it performs most operations with O(log(n)) performance, such as add(), remove(), and contains(). A single null key and numerous null values are allowed in HashMap. TreeMap does not allow null keys, however multiple null values are allowed. A single null key and numerous null values are allowed in HashMap. TreeMap does not allow null keys, however multiple null values are allowed. To compare keys, it uses the Object class's equals() method. It is overridden by the Map class's equals() function. It compares keys using the compareTo() method. To compare keys, it uses the Object class's equals() method. It is overridden by the Map class's equals() function. It compares keys using the compareTo() method. HashMap does not keep track of any sort of order. The elements are arranged in chronological sequence (ascending). HashMap does not keep track of any sort of order. The elements are arranged in chronological sequence (ascending). When we don't need a sorted key-value pair, we should use the HashMap.  When we need a key-value pair in sorted (ascending) order, we should use the TreeMap. When we don't need a sorted key-value pair, we should use the HashMap. When we need a key-value pair in sorted (ascending) order, we should use the TreeMap.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "1. Given an array in Java, convert it to a collection.",
        "answer": "We can convert an array to a collection using the asList() method of the Arrays class in Java. //including the required header files\nimport java.util.*;\npublic class Convert_Array_To_Collection {\n   public static void main(String args[])\n   {\n       //creating a sample array\n       String sample_array[]\n           = { \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\" };\n       \n       int length_array = sample_array.length;\n       System.out.println(\"The input elements are as follows : \");\n       for(int i = 0; i < length_array; i ++)\n       {\n           System.out.print(sample_array[i] + \" \");\n       }\n       System.out.println();// setting the print cursor to the next line\n   \n       List converted_list = Arrays.asList(sample_array);// converting the array to a list\n       \n       // print converted elements\n       System.out.println(\"The converted list is as follows : \"\n                          + converted_list);\n   }\n} //including the required header files\nimport java.util.*;\npublic class Convert_Array_To_Collection {\n   public static void main(String args[])\n   {\n       //creating a sample array\n       String sample_array[]\n           = { \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\" };\n       \n       int length_array = sample_array.length;\n       System.out.println(\"The input elements are as follows : \");\n       for(int i = 0; i < length_array; i ++)\n       {\n           System.out.print(sample_array[i] + \" \");\n       }\n       System.out.println();// setting the print cursor to the next line\n   \n       List converted_list = Arrays.asList(sample_array);// converting the array to a list\n       \n       // print converted elements\n       System.out.println(\"The converted list is as follows : \"\n                          + converted_list);\n   }\n} //including the required header files import public class Convert_Array_To_Collection class Convert_Array_To_Collection public static void main(String args[]) public static void main (String args[]) //creating a sample array \"Monday\" \"Tuesday\" \"Wednesday\" \"Thursday\" \"Friday\" \"Saturday\" \"Sunday\" int \"The input elements are as follows : \" for int 0 \" \" // setting the print cursor to the next line // converting the array to a list // print converted elements \"The converted list is as follows : \" Output: Output: Output: The input elements are as follows : \nMonday Tuesday Wednesday Thursday Friday Saturday Sunday \nThe converted list is as follows : [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday] The input elements are as follows : \nMonday Tuesday Wednesday Thursday Friday Saturday Sunday \nThe converted list is as follows : [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday]",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "2. Write a program in Java to display the contents of a HashTable using enumeration.",
        "answer": "We use the hasMoreElements and the nextElement methods of the Enumeration class to iterate through the HashMap. //including the necessary header files\nimport java.util.Enumeration;\nimport java.util.Hashtable;\npublic class Iterate_HashTable {\n  public static void main(String[] args) {\n     Hashtable hash_table = new Hashtable();//creating a hash table\n     hash_table.put(\"1\", \"Monday\");\n     hash_table.put(\"2\", \"Tuesday\");\n     hash_table.put(\"3\", \"Wednesday\");\n     hash_table.put(\"4\", \"Thursday\");\n     hash_table.put(\"5\", \"Friday\");\n     hash_table.put(\"6\", \"Saturday\");\n     hash_table.put(\"7\", \"Sunday\");\n     Enumeration enumeration_hash_table = hash_table.elements();//creating an enumeration object\n     \n     //while loop runs until the hashtable has more entries in it\n     while(enumeration_hash_table.hasMoreElements()) {\n        System.out.println(enumeration_hash_table.nextElement());\n     }\n  }\n} //including the necessary header files\nimport java.util.Enumeration;\nimport java.util.Hashtable;\npublic class Iterate_HashTable {\n  public static void main(String[] args) {\n     Hashtable hash_table = new Hashtable();//creating a hash table\n     hash_table.put(\"1\", \"Monday\");\n     hash_table.put(\"2\", \"Tuesday\");\n     hash_table.put(\"3\", \"Wednesday\");\n     hash_table.put(\"4\", \"Thursday\");\n     hash_table.put(\"5\", \"Friday\");\n     hash_table.put(\"6\", \"Saturday\");\n     hash_table.put(\"7\", \"Sunday\");\n     Enumeration enumeration_hash_table = hash_table.elements();//creating an enumeration object\n     \n     //while loop runs until the hashtable has more entries in it\n     while(enumeration_hash_table.hasMoreElements()) {\n        System.out.println(enumeration_hash_table.nextElement());\n     }\n  }\n} //including the necessary header files import import public class Iterate_HashTable class Iterate_HashTable public static void main(String[] args) public static void main (String[] args) new //creating a hash table \"1\" \"Monday\" \"2\" \"Tuesday\" \"3\" \"Wednesday\" \"4\" \"Thursday\" \"5\" \"Friday\" \"6\" \"Saturday\" \"7\" \"Sunday\" //creating an enumeration object //while loop runs until the hashtable has more entries in it while Output: Saturday\nFriday\nThursday\nWednesday\nTuesday\nMonday\nSunday Saturday\nFriday\nThursday\nWednesday\nTuesday\nMonday\nSunday We notice that the order of the values is not the same as that of the order in which we inserted the key-value pair in the hashtable. This is because the elements of a Hashtable are not guaranteed to be in any particular sequence. The hashtable's implementation divides values into multiple buckets based on their Hashcode and internal implementation, which means that the same values may appear in a different order on different machines, runs, or versions of the framework. This is because Hashtables are designed to retrieve data by key rather than by order.",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "3. Write a program to shuffle all the elements of a collection in Java.",
        "answer": "We use the shuffle() method of the Collections class. //importing the required header files\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\npublic class Shuffle_collection {\n  public static void main(String[] argv) throws Exception {\n      \n     ArrayList<String> array_list = new ArrayList<String>();//creating an arraylist of strings\n     \n     array_list.add(\"Monday\");\n     array_list.add(\"Tuesday\");\n     array_list.add(\"Wednesday\");\n     array_list.add(\"Thursday\");\n     array_list.add(\"Friday\");\n     array_list.add(\"Saturday\");\n     array_list.add(\"Sunday\");\n     \n     Collections.shuffle(array_list);//shuffling the arraylist\n     \n     System.out.println(\"The shuffled array list is as follows : \" + array_list);//printing the shuffled array list\n     \n  }   \n} //importing the required header files\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\npublic class Shuffle_collection {\n  public static void main(String[] argv) throws Exception {\n      \n     ArrayList<String> array_list = new ArrayList<String>();//creating an arraylist of strings\n     \n     array_list.add(\"Monday\");\n     array_list.add(\"Tuesday\");\n     array_list.add(\"Wednesday\");\n     array_list.add(\"Thursday\");\n     array_list.add(\"Friday\");\n     array_list.add(\"Saturday\");\n     array_list.add(\"Sunday\");\n     \n     Collections.shuffle(array_list);//shuffling the arraylist\n     \n     System.out.println(\"The shuffled array list is as follows : \" + array_list);//printing the shuffled array list\n     \n  }   \n} //importing the required header files import import import public class Shuffle_collection class Shuffle_collection public static void main(String[] argv) throws Exception public static void main (String[] argv) throws new //creating an arraylist of strings \"Monday\" \"Tuesday\" \"Wednesday\" \"Thursday\" \"Friday\" \"Saturday\" \"Sunday\" //shuffling the arraylist \"The shuffled array list is as follows : \" //printing the shuffled array list Output: Output: The shuffled array list is as follows : [Thursday, Friday, Saturday, Wednesday, Tuesday, Sunday, Monday] The shuffled array list is as follows : [Thursday, Friday, Saturday, Wednesday, Tuesday, Sunday, Monday]",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "4. Write a program in Java to clone a Treeset to another Treeset.",
        "answer": "We use the clone() method of the TreeSet class to clone one TreeSet into another. //importing the required header files\nimport java.util.TreeSet;\nimport java.util.Iterator;\n public class Clone_Tree_Set {\n public static void main(String[] args) {\n   \n     TreeSet<String> tree_set = new TreeSet<String>();//creating an empty tree set\n     //adding values in the tree set\n     tree_set.add(\"Monday\");\n     tree_set.add(\"Tuesday\");\n     tree_set.add(\"Wednesday\");\n     tree_set.add(\"Thursday\");\n     tree_set.add(\"Friday\");\n     tree_set.add(\"Saturday\");\n     tree_set.add(\"Sunday\");\n    \n     //printing the original tree set\n     System.out.println(\"The original tree set is as follows : \" + tree_set); \n     //cloning the tree set\n     TreeSet<String> cloned_tree_set = (TreeSet<String>)tree_set.clone();\n     //printing the cloned tree set\n     System.out.println(\"The cloned tree set is as follows : \" + cloned_tree_set);      \n    }\n} //importing the required header files\nimport java.util.TreeSet;\nimport java.util.Iterator;\n public class Clone_Tree_Set {\n public static void main(String[] args) {\n   \n     TreeSet<String> tree_set = new TreeSet<String>();//creating an empty tree set\n     //adding values in the tree set\n     tree_set.add(\"Monday\");\n     tree_set.add(\"Tuesday\");\n     tree_set.add(\"Wednesday\");\n     tree_set.add(\"Thursday\");\n     tree_set.add(\"Friday\");\n     tree_set.add(\"Saturday\");\n     tree_set.add(\"Sunday\");\n    \n     //printing the original tree set\n     System.out.println(\"The original tree set is as follows : \" + tree_set); \n     //cloning the tree set\n     TreeSet<String> cloned_tree_set = (TreeSet<String>)tree_set.clone();\n     //printing the cloned tree set\n     System.out.println(\"The cloned tree set is as follows : \" + cloned_tree_set);      \n    }\n} //importing the required header files import import public class Clone_Tree_Set class Clone_Tree_Set public static void main(String[] args) public static void main (String[] args) new //creating an empty tree set //adding values in the tree set \"Monday\" \"Tuesday\" \"Wednesday\" \"Thursday\" \"Friday\" \"Saturday\" \"Sunday\" //printing the original tree set \"The original tree set is as follows : \" //cloning the tree set //printing the cloned tree set \"The cloned tree set is as follows : \" Output: Output: Output: The original tree set is as follows : [Friday, Monday, Saturday, Sunday, Thursday, Tuesday, Wednesday]\nThe cloned tree set is as follows : [Friday, Monday, Saturday, Sunday, Thursday, Tuesday, Wednesday] The original tree set is as follows : [Friday, Monday, Saturday, Sunday, Thursday, Tuesday, Wednesday]\nThe cloned tree set is as follows : [Friday, Monday, Saturday, Sunday, Thursday, Tuesday, Wednesday]",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "5. Write a program in java to get the collection view of the values present in a HashMap.",
        "answer": "We use the values() function of the HashMap to get the collection view. //importing the required header files\nimport java.util.*;  \npublic class Collection_View {  \n   public static void main(String args[]){  \n\n   HashMap<String,String> hash_map = new HashMap<String,String>();//creating an empty hash map\n   //adding key values to the hash map\n   hash_map.put(\"1\",\"Monday\");\n   hash_map.put(\"2\",\"Tuesday\");\n   hash_map.put(\"3\",\"Wednesday\");\n   hash_map.put(\"4\",\"Thursday\");\n   hash_map.put(\"5\",\"Friday\");\n   hash_map.put(\"6\",\"Saturday\");\n   hash_map.put(\"7\",\"Sunday\");\n   //printing the original hash map\n   System.out.println(\"The original hash map is as follows : \" + hash_map);\n   //printing the collection view of the hash map\n   System.out.println(\"The collection view is as follows : \" + hash_map.values());\n }\n} //importing the required header files\nimport java.util.*;  \npublic class Collection_View {  \n   public static void main(String args[]){  \n\n   HashMap<String,String> hash_map = new HashMap<String,String>();//creating an empty hash map\n   //adding key values to the hash map\n   hash_map.put(\"1\",\"Monday\");\n   hash_map.put(\"2\",\"Tuesday\");\n   hash_map.put(\"3\",\"Wednesday\");\n   hash_map.put(\"4\",\"Thursday\");\n   hash_map.put(\"5\",\"Friday\");\n   hash_map.put(\"6\",\"Saturday\");\n   hash_map.put(\"7\",\"Sunday\");\n   //printing the original hash map\n   System.out.println(\"The original hash map is as follows : \" + hash_map);\n   //printing the collection view of the hash map\n   System.out.println(\"The collection view is as follows : \" + hash_map.values());\n }\n} //importing the required header files import public class Collection_View class Collection_View public static void main(String args[]) public static void main (String args[]) new //creating an empty hash map //adding key values to the hash map \"1\" \"Monday\" \"2\" \"Tuesday\" \"3\" \"Wednesday\" \"4\" \"Thursday\" \"5\" \"Friday\" \"6\" \"Saturday\" \"7\" \"Sunday\" //printing the original hash map \"The original hash map is as follows : \" //printing the collection view of the hash map \"The collection view is as follows : \" Output: Output: The original hash map is as follows: {1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday, 7=Sunday}\nThe collection view is as follows : [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday] The original hash map is as follows: {1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday, 7=Sunday}\nThe collection view is as follows : [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday] 1 2 3 4 5 6 7",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "6. Write a program in java to join two arraylists into one arraylist.",
        "answer": "We use the addAll() method of the ArrayList class to add the contents of both the given arraylists into a new arraylist. //importing the required header files\nimport java.util.ArrayList;\nimport java.util.Collections;\n public class Join_Lists {\n public static void main(String[] args) {\n       //creating the first array list\n       ArrayList<String> list_1 = new ArrayList<String>();\n       list_1.add(\"Monday\");\n       list_1.add(\"Tuesday\");\n       list_1.add(\"Wednesday\");\n       list_1.add(\"Thursday\");\n       //printing the first array list\n       System.out.println(\"The elements of the first array list is as follows : \" + list_1);\n       //creating the second array list\n       ArrayList<String> list_2 = new ArrayList<String>();\n       list_2.add(\"Friday\");\n       list_2.add(\"Saturday\");\n       list_2.add(\"Sunday\");\n       //printing the second array list\n       System.out.println(\"The elements of the second array list is as follows : \" + list_2);\n        \n       //creating the third array list\n       ArrayList<String> joined_list = new ArrayList<String>();\n       joined_list.addAll(list_1);//adding the elements of the first array list\n       joined_list.addAll(list_2);//adding the elements of the second array list\n       \n       System.out.println(\"The elements of the joined array list is as follows : \" + joined_list);\n       \n    }\n} //importing the required header files\nimport java.util.ArrayList;\nimport java.util.Collections;\n public class Join_Lists {\n public static void main(String[] args) {\n       //creating the first array list\n       ArrayList<String> list_1 = new ArrayList<String>();\n       list_1.add(\"Monday\");\n       list_1.add(\"Tuesday\");\n       list_1.add(\"Wednesday\");\n       list_1.add(\"Thursday\");\n       //printing the first array list\n       System.out.println(\"The elements of the first array list is as follows : \" + list_1);\n       //creating the second array list\n       ArrayList<String> list_2 = new ArrayList<String>();\n       list_2.add(\"Friday\");\n       list_2.add(\"Saturday\");\n       list_2.add(\"Sunday\");\n       //printing the second array list\n       System.out.println(\"The elements of the second array list is as follows : \" + list_2);\n        \n       //creating the third array list\n       ArrayList<String> joined_list = new ArrayList<String>();\n       joined_list.addAll(list_1);//adding the elements of the first array list\n       joined_list.addAll(list_2);//adding the elements of the second array list\n       \n       System.out.println(\"The elements of the joined array list is as follows : \" + joined_list);\n       \n    }\n} //importing the required header files import import public class Join_Lists class Join_Lists public static void main(String[] args) public static void main (String[] args) //creating the first array list new \"Monday\" \"Tuesday\" \"Wednesday\" \"Thursday\" //printing the first array list \"The elements of the first array list is as follows : \" //creating the second array list new \"Friday\" \"Saturday\" \"Sunday\" //printing the second array list \"The elements of the second array list is as follows : \" //creating the third array list new //adding the elements of the first array list //adding the elements of the second array list \"The elements of the joined array list is as follows : \" Output: Output: Output: The elements of the first array list is as follows : [Monday, Tuesday, Wednesday, Thursday]\nThe elements of the second array list is as follows : [Friday, Saturday, Sunday]\nThe elements of the joined array list is as follows : [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday] The elements of the first array list is as follows : [Monday, Tuesday, Wednesday, Thursday]\nThe elements of the second array list is as follows : [Friday, Saturday, Sunday]\nThe elements of the joined array list is as follows : [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday] Useful Resources: Basics of Java Basics of Java Java Developer Skills Java Developer Skills Online Java Compiler Online Java Compiler Java MCQ Java MCQ Java Developer Salary Java Developer Salary ArrayList vs LinkedList ArrayList vs LinkedList",
        "reference": "interviewbit.com",
        "role": "java-collections"
    },
    {
        "question": "1) What is the Collection framework in Java?",
        "answer": "Collection Framework is a combination of classes and interface, which is used to store and manipulate the data in the form of objects. It provides various classes such as ArrayList, Vector, Stack, and HashSet, etc. and interfaces such as List, Queue, Set, etc. for this purpose.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "2) What are the main differences between array and collection?",
        "answer": "Array and Collection are somewhat similar regarding storing the references of objects and manipulating the data, but they differ in many ways. The main differences between the array and Collection are defined below:\nADVERTISEMENT\nArrays are always of fixed size, i.e., a user can not increase or decrease the length of the array according to their requirement or at runtime, but In Collection, size can be changed dynamically as per need.\nArrays can only store homogeneous or similar type objects, but in Collection, heterogeneous objects can be stored.\nArrays cannot provide the ?ready-made? methods for user requirements as sorting, searching, etc. but Collection includes readymade methods to use.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "3) Explain various interfaces used in Collection framework?",
        "answer": "Collection framework implements various interfaces, Collection interface and Map interface (java.util.Map) are the mainly used interfaces of Java Collection Framework. List of interfaces of Collection Framework is given below:\nADVERTISEMENT\n\n1. Collection interface: Collection (java.util.Collection) is the primary interface, and every collection must implement this interface.\nSyntax:\npublic interface Collection<E>extends Iterable  \nWhere <E> represents that this interface is of Generic type\n2. List interface: List interface extends the Collection interface, and it is an ordered collection of objects. It contains duplicate elements. It also allows random access of elements.\nSyntax:\npublic interface List<E> extends Collection<E>  \n3. Set interface: Set (java.util.Set) interface is a collection which cannot contain duplicate elements. It can only include inherited methods of Collection interface\n\nSyntax:\npublic interface Set<E> extends Collection<E>  \nQueue interface: Queue (java.util.Queue) interface defines queue data structure, which stores the elements in the form FIFO (first in first out).\nSyntax:\npublic interface Queue<E> extends Collection<E>  \n4. Dequeue interface: it is a double-ended-queue. It allows the insertion and removal of elements from both ends. It implants the properties of both Stack and queue so it can perform LIFO (Last in first out) stack and FIFO (first in first out) queue, operations.\nSyntax:\npublic interface Dequeue<E> extends Queue<E>  \n5. Map interface: A Map (java.util.Map) represents a key, value pair storage of elements. Map interface does not implement the Collection interface. It can only contain a unique key but can have duplicate elements. There are two interfaces which implement Map in java that are Map interface and Sorted Map.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "4) What is the difference between ArrayList and Vector?",
        "answer": "No. ArrayList Vector\n1) ArrayList is not synchronized. Vector is synchronized.\n2) ArrayList is not a legacy class. Vector is a legacy class.\n3) ArrayList increases its size by 50% of the array size. Vector increases its size by doubling the array size.\n4) ArrayList is not ?thread-safe? as it is not synchronized. Vector list is ?thread-safe? as it?s every method is synchronized.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "5) What is the difference between ArrayList and LinkedList?",
        "answer": "No. ArrayList LinkedList\n1) ArrayList uses a dynamic array. LinkedList uses a doubly linked list.\n2) ArrayList is not efficient for manipulation because too much is required. LinkedList is efficient for manipulation.\n3) ArrayList is better to store and fetch data. LinkedList is better to manipulate data.\n4) ArrayList provides random access.\nLinkedList does not provide random access.\n5)\nArrayList takes less memory overhead as it stores only object LinkedList takes more memory overhead, as it stores the object as well as the address of that object.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "6) What is the difference between Iterator and ListIterator?",
        "answer": "Iterator traverses the elements in the forward direction only whereas ListIterator traverses the elements into forward and backward direction.\nNo. Iterator ListIterator\n1) The Iterator traverses the elements in the forward direction only. ListIterator traverses the elements in backward and forward directions both.\n2) The Iterator can be used in List, Set, and Queue. ListIterator can be used in List only.\n3) The Iterator can only perform remove operation while traversing the collection. ListIterator can perform ?add,? ?remove,? and ?set? operation while traversing the collection.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "7) What is the difference between Iterator and Enumeration?",
        "answer": "No. Iterator Enumeration\n1) The Iterator can traverse legacy and non-legacy elements. Enumeration can traverse only legacy elements.\n2) The Iterator is fail-fast. Enumeration is not fail-fast.\n3) The Iterator is slower than Enumeration. Enumeration is faster than Iterator.\n4) The Iterator can perform remove operation while traversing the collection. The Enumeration can perform only traverse operation on the collection.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "8) What is the difference between List and Set?",
        "answer": "The List and Set both extend the collection interface. However, there are some differences between the both which are listed below.\nThe List can contain duplicate elements whereas Set includes unique items.\nThe List is an ordered collection which maintains the insertion order whereas Set is an unordered collection which does not preserve the insertion order.\nThe List interface contains a single legacy class which is Vector class whereas Set interface does not have any legacy class.\nThe List interface can allow n number of null values whereas Set interface only allows a single null value.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "9) What is the difference between HashSet and TreeSet?",
        "answer": "The HashSet and TreeSet, both classes, implement Set interface. The differences between the both are listed below.\nHashSet maintains no order whereas TreeSet maintains ascending order.\nHashSet impended by hash table whereas TreeSet implemented by a Tree structure.\nHashSet performs faster than TreeSet.\nHashSet is backed by HashMap whereas TreeSet is backed by TreeMap.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "10) What is the difference between Set and Map?",
        "answer": "The differences between the Set and Map are given below.\nSet contains values only whereas Map contains key and values both.\nSet contains unique values whereas Map can contain unique Keys with duplicate values.\nSet holds a single number of null value whereas Map can include a single null key with n number of null values.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "11) What is the difference between HashSet and HashMap?",
        "answer": "The differences between the HashSet and HashMap are listed below.\nHashSet contains only values whereas HashMap includes the entry (key, value). HashSet can be iterated, but HashMap needs to convert into Set to be iterated.\nHashSet implements Set interface whereas HashMap implements the Map interface\nHashSet cannot have any duplicate value whereas HashMap can contain duplicate values with unique keys.\nHashSet contains the only single number of null value whereas HashMap can hold a single null key with n number of null values.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "12) What is the difference between HashMap and TreeMap?",
        "answer": "The differences between the HashMap and TreeMap are given below.\nHashMap maintains no order, but TreeMap maintains ascending order.\nHashMap is implemented by hash table whereas TreeMap is implemented by a Tree structure.\nHashMap can be sorted by Key or value whereas TreeMap can be sorted by Key.\nHashMap may contain a null key with multiple null values whereas TreeMap cannot hold a null key but can have multiple null values.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "13) What is the difference between HashMap and Hashtable?",
        "answer": "No. HashMap Hashtable\n1) HashMap is not synchronized. Hashtable is synchronized.\n2) HashMap can contain one null key and multiple null values. Hashtable cannot contain any null key or null value.\n3) HashMap is not ?thread-safe,? so it is useful for non-threaded applications. Hashtable is thread-safe, and it can be shared between various threads.\n4) 4) HashMap inherits the AbstractMap class Hashtable inherits the Dictionary class.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "14) What is the difference between Collection and Collections?",
        "answer": "The differences between the Collection and Collections are given below.\nThe Collection is an interface whereas Collections is a class.\nThe Collection interface provides the standard functionality of data structure to List, Set, and Queue. However, Collections class is to sort and synchronize the collection elements.\nThe Collection interface provides the methods that can be used for data structure whereas Collections class provides the static methods which can be used for various operation on a collection.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "15) What is the difference between Comparable and Comparator?",
        "answer": "No. Comparable Comparator\n1) Comparable provides only one sort of sequence. The Comparator provides multiple sorts of sequences.\n2) It provides one method named compareTo(). It provides one method named compare().\n3) It is found in java.lang package. It is located in java.util package.\n4) If we implement the Comparable interface, The actual class is modified. The actual class is not changed.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "16) What do you understand by BlockingQueue?",
        "answer": "BlockingQueue is an interface which extends the Queue interface. It provides concurrency in the operations like retrieval, insertion, deletion. While retrieval of any element, it waits for the queue to be non-empty. While storing the elements, it waits for the available space. BlockingQueue cannot contain null elements, and implementation of BlockingQueue is thread-safe.\nSyntax:\npublic interface BlockingQueue<E> extends Queue <E>",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "17) What is the advantage of Properties file?",
        "answer": "If you change the value in the properties file, you don't need to recompile the java class. So, it makes the application easy to manage. It is used to store information which is to be changed frequently. Consider the following example.\nimport java.util.*;  \nimport java.io.*;  \npublic class Test {  \npublic static void main(String[] args)throws Exception{  \n    FileReader reader=new FileReader(\"db.properties\");  \n          Properties p=new Properties();  \n    p.load(reader);  \n          System.out.println(p.getProperty(\"user\"));  \n    System.out.println(p.getProperty(\"password\"));  \n}  \n}  \nOutput\nsystem\noracle",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "18) What does the hashCode() method?",
        "answer": "The hashCode() method returns a hash code value (an integer number).\n\nThe hashCode() method returns the same integer number if two keys (by calling equals() method) are identical.\nHowever, it is possible that two hash code numbers can have different or the same keys.\nIf two objects do not produce an equal result by using the equals() method, then the hashcode() method will provide the different integer result for both the objects.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "19) Why we override equals() method?",
        "answer": "The equals method is used to check whether two objects are the same or not. It needs to be overridden if we want to check the objects based on the property.\nFor example, Employee is a class that has 3 data members: id, name, and salary. However, we want to check the equality of employee object by the salary. Then, we need to override the equals() method.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "20) How to synchronize List, Set and Map elements?",
        "answer": "Yes, Collections class provides methods to make List, Set or Map elements as synchronized:\npublic static List synchronizedList(List l){}\npublic static Set synchronizedSet(Set s){}\npublic static SortedSet synchronizedSortedSet(SortedSet s){}\npublic static Map synchronizedMap(Map m){}\npublic static SortedMap synchronizedSortedMap(SortedMap m){}",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "21) What is the advantage of the generic collection?",
        "answer": "There are three main advantages of using the generic collection.\nIf we use the generic class, we don't need typecasting.\nIt is type-safe and checked at compile time.\nGeneric confirms the stability of the code by making it bug detectable at compile time.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "22) What is hash-collision in Hashtable and how it is handled in Java?",
        "answer": "Two different keys with the same hash value are known as hash-collision. Two separate entries will be kept in a single hash bucket to avoid the collision. There are two ways to avoid hash-collision.\nSeparate Chaining\nOpen Addressing",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "23) What is the Dictionary class?",
        "answer": "The Dictionary class provides the capability to store key-value pairs.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "24) What is the default size of load factor in hashing based collection?",
        "answer": "The default size of load factor is 0.75. The default capacity is computed as initial capacity * load factor. For example, 16 * 0.75 = 12. So, 12 is the default capacity of Map.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "25) What do you understand by fail-fast?",
        "answer": "The Iterator in java which immediately throws ConcurrentmodificationException, if any structural modification occurs in, is called as a Fail-fast iterator. Fail-fats iterator does not require any extra space in memory.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "26) What is the difference between Array and ArrayList?",
        "answer": "The main differences between the Array and ArrayList are given below.\nSN Array ArrayList\n1 The Array is of fixed size, means we cannot resize the array as per need. ArrayList is not of the fixed size we can change the size dynamically.\n2 Arrays are of the static type. ArrayList is of dynamic size.\n3 Arrays can store primitive data types as well as objects. ArrayList cannot store the primitive data types it can only store the objects.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "27) What is the difference between the length of an Array and size of ArrayList?",
        "answer": "The length of an array can be obtained using the property of length whereas ArrayList does not support length property, but we can use size() method to get the number of objects in the list.\nFinding the length of the array\nInt [] array = new int[4];  \nSystem.out.println(\"The size of the array is \" + array.length);  \n          \nFinding the size of the ArrayList\nArrayList<String> list=new ArrayList<String>();    \nlist.add(\"ankit\");    \nlist.add(\"nippun\");  \nSystem.out.println(list.size());",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "28) How to convert ArrayList to Array and Array to ArrayList?",
        "answer": "We can convert an Array to ArrayList by using the asList() method of Arrays class. asList() method is the static method of Arrays class and accepts the List object. Consider the following syntax:\nArrays.asList(item)  \nWe can convert an ArrayList to Array using toArray() method of the ArrayList class. Consider the following syntax to convert the ArrayList to the List object.\nList_object.toArray(new String[List_object.size()])",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "29) How to make Java ArrayList Read-Only?",
        "answer": "We can obtain java ArrayList Read-only by calling the Collections.unmodifiableCollection() method. When we define an ArrayList as Read-only then we cannot perform any modification in the collection through  add(), remove() or set() method.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "30) How to remove duplicates from ArrayList?",
        "answer": "There are two ways to remove duplicates from the ArrayList.\nUsing HashSet: By using HashSet we can remove the duplicate element from the ArrayList, but it will not then preserve the insertion order.\nUsing LinkedHashSet: We can also maintain the insertion order by using LinkedHashSet instead of HashSet.\nThe Process to remove duplicate elements from ArrayList using the LinkedHashSet:\nCopy all the elements of ArrayList to LinkedHashSet.\nEmpty the ArrayList using clear() method, which will remove all the elements from the list.\nNow copy all the elements of LinkedHashset to ArrayList.",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "31) How to reverse ArrayList?",
        "answer": "To reverse an ArrayList, we can use reverse() method of Collections class. Consider the following example.\nimport java.util.ArrayList;  \nimport java.util.Collection;  \nimport java.util.Collections;  \nimport java.util.Iterator;  \nimport java.util.List;  \npublic class ReverseArrayList {  \npublic static void main(String[] args) {  \n     List list = new ArrayList<>();  \n     list.add(10);  \n     list.add(50);  \n     list.add(30);  \n     Iterator i = list.iterator();  \n     System.out.println(\"printing the list....\");  \n     while(i.hasNext())  \n     {  \n         System.out.println(i.next());  \n     }  \n     Iterator i2 = list.iterator();  \n     Collections.reverse(list);  \n     System.out.println(\"printing list in reverse order....\");  \n     while(i2.hasNext())  \n     {  \n         System.out.println(i2.next());  \n     }  \n    }  \n}  \nOutput\nprinting the list....\n10\n50\n30\nprinting list in reverse order....\n30\n50\n10",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "32) How to sort ArrayList in descending order?",
        "answer": "To sort the ArrayList in descending order, we can use the reverseOrder method of Collections class. Consider the following example.\nimport java.util.ArrayList;  \nimport java.util.Collection;  \nimport java.util.Collections;  \nimport java.util.Comparator;  \nimport java.util.Iterator;  \nimport java.util.List;  \n  public class ReverseArrayList {  \npublic static void main(String[] args) {  \n     List list = new ArrayList<>();  \n     list.add(10);  \n     list.add(50);  \n     list.add(30);  \n     list.add(60);  \n     list.add(20);  \n     list.add(90);  \n            Iterator i = list.iterator();  \n     System.out.println(\"printing the list....\");  \n     while(i.hasNext())  \n     {  \n         System.out.println(i.next());  \n     }  \n          Comparator cmp = Collections.reverseOrder();  \n    Collections.sort(list,cmp);  \n     System.out.println(\"printing list in descending order....\");  \n     Iterator i2 = list.iterator();  \n     while(i2.hasNext())  \n     {  \n         System.out.println(i2.next());  \n     }  \n       }  \n}  \nOutput\nprinting the list....\n10\n50\n30\n60\n20\n90\nprinting list in descending order....\n90\n60\n50\n30\n20\n10",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "33) How to synchronize ArrayList?",
        "answer": "We can synchronize ArrayList in two ways.\nUsing Collections.synchronizedList() method\nUsing CopyOnWriteArrayList<T>",
        "reference": "javatpoint.com",
        "role": "java-collections"
    },
    {
        "question": "34) When to use ArrayList and LinkedList?",
        "answer": "LinkedLists are better to use for the update operations whereas ArrayLists are better to use for the search operations.\n\n\n Prev\nNext ",
        "reference": "javatpoint.com",
        "role": "java-collections"
    }
]