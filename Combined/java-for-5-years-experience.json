[
    {
        "question": "1. Differentiate between Volatile and Transient Variable in Java.",
        "answer": "Volatile Variable Transient Variable\nThe volatile keyword against the variable indicates that the content of the variable is stored in the main memory and every read of the variable should be done from the main memory and not the CPU cache and every write should be written to the main memory and not just to the CPU cache. Transient is used when we do not want the variable to be serialised.\nVolatile ensures that the JVM does not re-order the variables and ensures that the synchronization issues are avoided. Transient provides flexibility and control over the attributes of objects from being serialized.\nVolatile variables do not have any default values. Transient variables are initialized with default value corresponding to the data type at the time of deserialization.\nVolatile variables can be used along with the static keyword. Transient variables cant be used along with static keywords because the static variables are class-level variables and not related to the individual instances. This matters during serialization.\nVolatile variables can be used along with the final keyword. It is not recommended to use final with transient variables as it would cause problems for re-initializing the variables once the values are populated by default at the time of deserialization. Volatile Variable Transient Variable\nThe volatile keyword against the variable indicates that the content of the variable is stored in the main memory and every read of the variable should be done from the main memory and not the CPU cache and every write should be written to the main memory and not just to the CPU cache. Transient is used when we do not want the variable to be serialised.\nVolatile ensures that the JVM does not re-order the variables and ensures that the synchronization issues are avoided. Transient provides flexibility and control over the attributes of objects from being serialized.\nVolatile variables do not have any default values. Transient variables are initialized with default value corresponding to the data type at the time of deserialization.\nVolatile variables can be used along with the static keyword. Transient variables cant be used along with static keywords because the static variables are class-level variables and not related to the individual instances. This matters during serialization.\nVolatile variables can be used along with the final keyword. It is not recommended to use final with transient variables as it would cause problems for re-initializing the variables once the values are populated by default at the time of deserialization. Volatile Variable Transient Variable Volatile Variable Transient Variable Volatile Variable Transient Variable The volatile keyword against the variable indicates that the content of the variable is stored in the main memory and every read of the variable should be done from the main memory and not the CPU cache and every write should be written to the main memory and not just to the CPU cache. Transient is used when we do not want the variable to be serialised.\nVolatile ensures that the JVM does not re-order the variables and ensures that the synchronization issues are avoided. Transient provides flexibility and control over the attributes of objects from being serialized.\nVolatile variables do not have any default values. Transient variables are initialized with default value corresponding to the data type at the time of deserialization.\nVolatile variables can be used along with the static keyword. Transient variables cant be used along with static keywords because the static variables are class-level variables and not related to the individual instances. This matters during serialization.\nVolatile variables can be used along with the final keyword. It is not recommended to use final with transient variables as it would cause problems for re-initializing the variables once the values are populated by default at the time of deserialization. The volatile keyword against the variable indicates that the content of the variable is stored in the main memory and every read of the variable should be done from the main memory and not the CPU cache and every write should be written to the main memory and not just to the CPU cache. Transient is used when we do not want the variable to be serialised. The volatile keyword against the variable indicates that the content of the variable is stored in the main memory and every read of the variable should be done from the main memory and not the CPU cache and every write should be written to the main memory and not just to the CPU cache. Transient is used when we do not want the variable to be serialised. Volatile ensures that the JVM does not re-order the variables and ensures that the synchronization issues are avoided. Transient provides flexibility and control over the attributes of objects from being serialized. Volatile ensures that the JVM does not re-order the variables and ensures that the synchronization issues are avoided. Transient provides flexibility and control over the attributes of objects from being serialized. Volatile variables do not have any default values. Transient variables are initialized with default value corresponding to the data type at the time of deserialization. Volatile variables do not have any default values. Transient variables are initialized with default value corresponding to the data type at the time of deserialization. Volatile variables can be used along with the static keyword. Transient variables cant be used along with static keywords because the static variables are class-level variables and not related to the individual instances. This matters during serialization. Volatile variables can be used along with the static keyword. Transient variables cant be used along with static keywords because the static variables are class-level variables and not related to the individual instances. This matters during serialization. Volatile variables can be used along with the final keyword. It is not recommended to use final with transient variables as it would cause problems for re-initializing the variables once the values are populated by default at the time of deserialization. Volatile variables can be used along with the final keyword. It is not recommended to use final with transient variables as it would cause problems for re-initializing the variables once the values are populated by default at the time of deserialization.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "2. Differentiate between the Vector and ArrayList collections in Java.",
        "answer": "ArrayList and Vector collection classes both implement the List interface and are derived from AbstractList. Both these classes are index-based, meaning objects can be retrieved from the collection based on the index using the get(index) method. get(index) Category Vector ArrayList\nSynchronization Vector is synchronized and thread-safe by default. This means that the internal state of the Vector is not compromised even if multiple threads are operating on it. ArrayList is neither thread-safe nor synchronized.\nSpeed Since Vector is synchronized, it works relatively slower than ArrayList. ArrayList is faster than Vector because there is no overhead of maintaining synchronization. Category Vector ArrayList\nSynchronization Vector is synchronized and thread-safe by default. This means that the internal state of the Vector is not compromised even if multiple threads are operating on it. ArrayList is neither thread-safe nor synchronized.\nSpeed Since Vector is synchronized, it works relatively slower than ArrayList. ArrayList is faster than Vector because there is no overhead of maintaining synchronization. Category Vector ArrayList Category Vector ArrayList Category Vector ArrayList Synchronization Vector is synchronized and thread-safe by default. This means that the internal state of the Vector is not compromised even if multiple threads are operating on it. ArrayList is neither thread-safe nor synchronized.\nSpeed Since Vector is synchronized, it works relatively slower than ArrayList. ArrayList is faster than Vector because there is no overhead of maintaining synchronization. Synchronization Vector is synchronized and thread-safe by default. This means that the internal state of the Vector is not compromised even if multiple threads are operating on it. ArrayList is neither thread-safe nor synchronized. Synchronization Vector is synchronized and thread-safe by default. This means that the internal state of the Vector is not compromised even if multiple threads are operating on it. ArrayList is neither thread-safe nor synchronized. Speed Since Vector is synchronized, it works relatively slower than ArrayList. ArrayList is faster than Vector because there is no overhead of maintaining synchronization. Speed Since Vector is synchronized, it works relatively slower than ArrayList. ArrayList is faster than Vector because there is no overhead of maintaining synchronization.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "3. How is Collection different from Collections in Java?",
        "answer": "Collection is an interface whereas Collections is a java utility class containing only static methods that can operate on collections like ArrayList, Set, Queue, etc. and both belong to Collection Framework and are present in the java.util package. java.util   Since Collection is an interface dealing with the data type of iterable objects, the interface extends the Iterable interface as shown below: public interface Collection<E> \nextends Iterable<E> public interface Collection<E> \nextends Iterable<E> public interface Collection<E> \nextends Iterable<E> interface Collection E extends Iterable E Since Collections is a java class, it extends the Object class as shown below: public class Collections\nextends Object public class Collections\nextends Object public class Collections\nextends Object class Collections extends Object",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "4. What do you understand by the ... in the below method parameters?",
        "answer": "public void someMethod(String... info){\n   // method body\n} public void someMethod(String... info){\n   // method body\n} public void someMethod(String... info) public void someMethod (String... info) // method body The 3 dots feature was started in Java 5 and the feature is known as varargs (variable arguments). This simply means that the method can receive one or more/multiple String arguments as shown below: someMethod(\"Java\", \"Interview\");\nsomeMethod(\"Java\", \"Interview\", \"Questions\");\nsomeMethod(new String[]{\"Java\", \"Interview\", \"Questions\"}); someMethod(\"Java\", \"Interview\"); someMethod(\"Java\", \"Interview\"); someMethod(\"Java\", \"Interview\", \"Questions\"); someMethod(\"Java\", \"Interview\", \"Questions\"); someMethod(new String[]{\"Java\", \"Interview\", \"Questions\"}); someMethod(new String[]{\"Java\", \"Interview\", \"Questions\"}); These received arguments can be used as an array and can be accessed by iterating through loops as shown below: public void someMethod(String... info){\n   for(String someInfo : info){\n       // any operation\n   }\n   // The info can be accessed using index based loops too\n   for( int i = 0; i < info.length; i++){\n       String s = info[i];\n       //some operation\n   }\n} public void someMethod(String... info){\n   for(String someInfo : info){\n       // any operation\n   }\n   // The info can be accessed using index based loops too\n   for( int i = 0; i < info.length; i++){\n       String s = info[i];\n       //some operation\n   }\n} public void someMethod(String... info) public void someMethod (String... info) for // any operation // The info can be accessed using index based loops too for int 0 //some operation",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "5. Can you write a code for representing thread-safe singleton patterns in Java?",
        "answer": "A thread-safe singleton class is created which helps in object initialization in the presence of multiple threads. It can be done using multiple ways: Using Enums: Enums are the simplest means of creating a thread-safe singleton class in Java because the synchronization support is inherently done by Java itself. Enums are by default final and this also helps in preventing multiple initializations at the time of serialization. Using Enums: Enums are the simplest means of creating a thread-safe singleton class in Java because the synchronization support is inherently done by Java itself. Enums are by default final and this also helps in preventing multiple initializations at the time of serialization. Using Enums: public enum ThreadSafeSingleton{\n   SINGLETON_INSTANCE;\n   public void display(){\n       System.out.println(\"Thread-safe singleton Display\");\n   }\n}\n// The Singleton class methods can be invoked as below\nThreadSafeSingleton.SINGLETON_INSTANCE.show(); public enum ThreadSafeSingleton{\n   SINGLETON_INSTANCE;\n   public void display(){\n       System.out.println(\"Thread-safe singleton Display\");\n   }\n}\n// The Singleton class methods can be invoked as below\nThreadSafeSingleton.SINGLETON_INSTANCE.show(); public enum ThreadSafeSingleton enum ThreadSafeSingleton public void display() public void display () \"Thread-safe singleton Display\" // The Singleton class methods can be invoked as below Using Static Field Initialization: Thread-safe singleton can also be created by creating the instance at the time of class loading. This is achieved by making use of static fields as the Classloader guarantees that the instances are initialized during class loading and the instance is not visible until that has been fully created. Using Static Field Initialization: Thread-safe singleton can also be created by creating the instance at the time of class loading. This is achieved by making use of static fields as the Classloader guarantees that the instances are initialized during class loading and the instance is not visible until that has been fully created. Using Static Field Initialization: public class ThreadSafeSingleton{\n   private static final ThreadSafeSingleton INSTANCE = new ThreadSafeSingleton();\n   private ThreadSafeSingleton(){ }\n   public static ThreadSafeSingleton getInstance(){\n       return INSTANCE;\n   }\n   public void display(){\n       System.out.println(\"Thread-safe Singleon\");\n   }\n}\nThreadSafeSingleton.getInstance().display(); public class ThreadSafeSingleton{\n   private static final ThreadSafeSingleton INSTANCE = new ThreadSafeSingleton();\n   private ThreadSafeSingleton(){ }\n   public static ThreadSafeSingleton getInstance(){\n       return INSTANCE;\n   }\n   public void display(){\n       System.out.println(\"Thread-safe Singleon\");\n   }\n}\nThreadSafeSingleton.getInstance().display(); public class ThreadSafeSingleton class ThreadSafeSingleton private static final new private ThreadSafeSingleton() private ThreadSafeSingleton () public static ThreadSafeSingleton getInstance() public static getInstance () return public void display() public void display () \"Thread-safe Singleon\" But the disadvantage of this way is that the initialization cannot be done lazily and the getInstance() method is called even before any client can call. Using synchronized keyword: We can make use of the synchronized keyword upon the getInstance method as shown below:\nIn this method, we can achieve lazy initialization, and also since we use synchronized keywords, the object initialization is also thread-safe.\nThe only problem is that since the whole method is synchronized, the performance is impacted in the presence of multiple threads. Using synchronized keyword: We can make use of the synchronized keyword upon the getInstance method as shown below:\nIn this method, we can achieve lazy initialization, and also since we use synchronized keywords, the object initialization is also thread-safe.\nThe only problem is that since the whole method is synchronized, the performance is impacted in the presence of multiple threads. Using synchronized keyword: In this method, we can achieve lazy initialization, and also since we use synchronized keywords, the object initialization is also thread-safe.\nThe only problem is that since the whole method is synchronized, the performance is impacted in the presence of multiple threads. In this method, we can achieve lazy initialization, and also since we use synchronized keywords, the object initialization is also thread-safe. The only problem is that since the whole method is synchronized, the performance is impacted in the presence of multiple threads. public class ThreadSafeSingleton\n{\n // Creating private instance to make it accessible only by getInstance() method\n private static ThreadSafeSingleton instance;\n private ThreadSafeSingleton()\n {\n   // Making constructor private so that objects cant be initialized outside the class\n }\n //synchronized getInstance method\n synchronized public static ThreadSafeSingleton getInstance(){\n   if (this.instance == null)\n   {\n     // if instance is null, initialize\n     this.instance = new ThreadSafeSingleton();\n   }\n   return this.instance;\n }\n} public class ThreadSafeSingleton\n{\n // Creating private instance to make it accessible only by getInstance() method\n private static ThreadSafeSingleton instance;\n private ThreadSafeSingleton()\n {\n   // Making constructor private so that objects cant be initialized outside the class\n }\n //synchronized getInstance method\n synchronized public static ThreadSafeSingleton getInstance(){\n   if (this.instance == null)\n   {\n     // if instance is null, initialize\n     this.instance = new ThreadSafeSingleton();\n   }\n   return this.instance;\n }\n} public class ThreadSafeSingleton class ThreadSafeSingleton // Creating private instance to make it accessible only by getInstance() method private static private ThreadSafeSingleton() private ThreadSafeSingleton () // Making constructor private so that objects cant be initialized outside the class //synchronized getInstance method synchronized public static ThreadSafeSingleton getInstance() synchronized public static getInstance () if this null // if instance is null, initialize this new return this Double-check locking: Here, we will be using a synchronized block of code within the getInstance method instead of making the whole method synchronized. This ensures that only a handful of threads have to wait only for the first time thereby not impacting the performance. Double-check locking: Here, we will be using a synchronized block of code within the getInstance method instead of making the whole method synchronized. This ensures that only a handful of threads have to wait only for the first time thereby not impacting the performance. Double-check locking: public class ThreadSafeSingleton {\n \n // Creating private instance to make it accessible only by getInstance() method\n private static ThreadSafeSingleton instance;\n private ThreadSafeSingleton(){\n   // Making constructor private so that objects cant be initialized outside the class\n }\n\n public static ThreadSafeSingleton getInstance(){\n   if (instance == null){\n     //synchronized block of code\n     synchronized (ThreadSafeSingleton.class){\n       if(instance==null)\n       {\n         // initialize only if instance is null\n         instance = new ThreadSafeSingleton();\n       }\n      \n     }\n   }\n   return instance;\n }\n} public class ThreadSafeSingleton {\n \n // Creating private instance to make it accessible only by getInstance() method\n private static ThreadSafeSingleton instance;\n private ThreadSafeSingleton(){\n   // Making constructor private so that objects cant be initialized outside the class\n }\n\n public static ThreadSafeSingleton getInstance(){\n   if (instance == null){\n     //synchronized block of code\n     synchronized (ThreadSafeSingleton.class){\n       if(instance==null)\n       {\n         // initialize only if instance is null\n         instance = new ThreadSafeSingleton();\n       }\n      \n     }\n   }\n   return instance;\n }\n} public class ThreadSafeSingleton class ThreadSafeSingleton // Creating private instance to make it accessible only by getInstance() method private static private ThreadSafeSingleton() private ThreadSafeSingleton () // Making constructor private so that objects cant be initialized outside the class public static ThreadSafeSingleton getInstance() public static getInstance () if null //synchronized block of code synchronized if null // initialize only if instance is null new return",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "6. What is the importance of the hashCode() and equals() contract?",
        "answer": "Consider the scenario of the HashMap object. We know that the Key of the HashMap uses the hashCode() and equals() methods for finding index or finding the value of a given key by uniquely identify the key-value pair in the map. If these methods are not implemented properly, then there are chances where two keys would produce the same output for these methods resulting in inaccuracy and a wrong key’s value might get updated at the time of updation. Hence, it is very much important to implement the hashCode and the equals method correctly. This can be done properly if we follow the hashCode-equals contract. The contract states that If two objects are equal, then the hashCode method should produce the same result for both objects.\nTo ensure this, we have to override the hashCode() method whenever we override the equals() method. If two objects are equal, then the hashCode method should produce the same result for both objects.\nTo ensure this, we have to override the hashCode() method whenever we override the equals() method. ",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "7. How is the classpath variable different from the path variables?",
        "answer": "The classpath variables are specific to the Java executables and are used for locating the class files. Whereas, the path variable is a variable present in the operating system and is used for locating the system executables.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "8. What is the result of the below code and Why?",
        "answer": "public class TestClass {\npublic static void main(String[] args) {\n     someMethod(null);\n}\npublic static void someMethod(Object o) {\n System.out.println(\"Object method Invoked\");\n}\npublic static void someMethod(String s) {\n System.out.println(\"String method Invoked\");\n}\n} public class TestClass {\npublic static void main(String[] args) {\n     someMethod(null);\n}\npublic static void someMethod(Object o) {\n System.out.println(\"Object method Invoked\");\n}\npublic static void someMethod(String s) {\n System.out.println(\"String method Invoked\");\n}\n} public class TestClass class TestClass public static void main(String[] args) public static void main (String[] args) null public static void someMethod(Object o) public static void someMethod (Object o) \"Object method Invoked\" public static void someMethod(String s) public static void someMethod (String s) \"String method Invoked\" The output of this code is “String method Invoked”. We know that null is a value that can be assigned to any kind of object reference type in Java. It is not an object in Java. Secondly, the Java compiler chooses the method with the most specific parameters in method overloading. this means that since the String class is more specific, the method with String input parameter is called.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "9. How would you help a colleague with lesser Java experience who has trouble in serializing a class?",
        "answer": "I would first check if the colleague has implemented the java.io.serializable interface. If this is done, I will check if they are trying to serialize only non-static members since the static members cannot be serialized. I would also check if the fields that are not serialized are defined as transient accidentally.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "10. What is the best possible way to call the wait() method - by using the if construct or the loop construct?",
        "answer": "wait() should be called in loop construct always because whenever a thread gets resources to execute again, it is always better to check the condition before execution. The standard way of wait and notify usage is as shown below: synchronized (resource) {\n   while (wait condition)\n     resource.wait(); // release the resource lock and reacquire it post wait\n   // operations to perform\n} synchronized (resource) {\n   while (wait condition)\n     resource.wait(); // release the resource lock and reacquire it post wait\n   // operations to perform\n} synchronized while // release the resource lock and reacquire it post wait // operations to perform",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "11. Can we use HashMap in a multi-threaded environment?",
        "answer": "You can use the HashMap but the probability of working fine depends on the way we use it. For instance, consider the HashMap of configuration properties, if the HashMap initialization was done by using just one thread, and the remaining threads do the task of reading from the map, then HashMap would work perfectly well. The problem arises when there is at least one thread that updates the Map by means of adding, updating, or deleting the map content. The put() method of the map resizes the map that can cause a deadlock or infinite loop while the threads operate. Hence, during such scenarios, we can use the HashTable or ConcurrentHashMap.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "12. What is the result of the below code?",
        "answer": "public class InterviewbitProblem{\npublic static void main(String[] arr){\n   System.out.println(0.1*3 == 0.3);\n   System.out.println(0.1*2 == 0.2);\n}\n} public class InterviewbitProblem{\npublic static void main(String[] arr){\n   System.out.println(0.1*3 == 0.3);\n   System.out.println(0.1*2 == 0.2);\n}\n} public class InterviewbitProblem class InterviewbitProblem public static void main(String[] arr) public static void main (String[] arr) 0.1 3 0.3 0.1 2 0.2 The statements result in:\nSystem.out.println(0.1*3 == 0.3); -> Prints false\nSystem.out.println(0.1*2 == 0.2); -> Prints true  System.out.println(0.1*3 == 0.3);  System.out.println(0.1*2 == 0.2); This expectation mismatch is due to the error that occurs while rounding float-point numbers and the fact that in Java, only the floating-point numbers that are powers of 2 are represented accurately by the binary representation. The rest of the numbers should be rounded to accommodate the limited bits as required.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "13. What is the result of the below Java code?",
        "answer": "public class InterviewbitProblem{\n   public static void main(String[] args) {\n       System.out.println(Math.min(Double.MIN_VALUE, 0.0d));\n   }\n} public class InterviewbitProblem{\n   public static void main(String[] args) {\n       System.out.println(Math.min(Double.MIN_VALUE, 0.0d));\n   }\n} public class InterviewbitProblem class InterviewbitProblem public static void main(String[] args) public static void main (String[] args) 0.0d We should know that in Java, for the type Double, the MIN_VALUE and MAX_VALUE are positive numbers. The Double.MIN_VALUE has the value of  \n2\n-\n1074\n which is a positive number but the least of all values belonging to the Double class. 2\n-\n1074 2\n-\n1074 2\n-\n1074 2 -\n1074 - 1074  Hence the program results in printing 0.0 as obviously the Double.MIN_VALUE > 0 Hence the program results in printing 0.0 as obviously the Double.MIN_VALUE > 0",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "14. What will happen if you run 1.0/0.0?",
        "answer": "The double class provides certain rules like Double.INFINITY, NaN, -0.0, etc which aids in arithmetic calculations. The given problem will return Double.INFINITY without throwing any Arithmetic Exception.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "15. Is it possible to override a method to throw RuntimeException from throwing NullPointerException in the parent class?",
        "answer": "Yes, this is possible. But it is not possible if the parent class has a checked Exception. This is due to the below rule of method overriding in cases of checked exceptions: The method that wants to override a parent class method can not throw a higher Exception than the overridden method. The method that wants to override a parent class method can not throw a higher Exception than the overridden method. This means that if the overridden method is throwing IOException, then the overriding child class method can only throw IOException or its sub-classes. This overriding method can not throw a higher Exception than the original or overridden method.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "16. Is there any difference in defining or creating a String by using String literal and by using the new() operator?",
        "answer": "Creating string using the new operator ensures that the String is created in the heap alone and not into the string pool. Whereas, creating string using literal ensures that the string is created in the string pool. String pool exists as part of the perm area in the heap. This ensures that the multiple Strings created using literal having same values are pointed to one object and prevents duplicate objects with the same value from being created.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "17. What is the output of the below code?",
        "answer": "public class InterviewbitProblem{\n   public static void main(String[] args) {\n       Integer num1 = 1000, num2 = 1000;  \n       System.out.println(num1 == num2);//1\n       Integer num3 = 20, num4 = 20;  \n       System.out.println(num3 == num4);//2\n   }\n} public class InterviewbitProblem{\n   public static void main(String[] args) {\n       Integer num1 = 1000, num2 = 1000;  \n       System.out.println(num1 == num2);//1\n       Integer num3 = 20, num4 = 20;  \n       System.out.println(num3 == num4);//2\n   }\n} public class InterviewbitProblem class InterviewbitProblem public static void main(String[] args) public static void main (String[] args) 1000 1000 //1 20 20 //2 Line 1 results in false, whereas line 2 results in true. Let us see why.\nIn Java, if the references point to different objects and have the same content, they are not equal in terms of using double equals. By this logic, the statement num3==num4 should have resulted in false. But, the Integer.java class in Java has a private inner class called IntegerCache.java which helps to cache the Integer objects ranging from -128 to 127. All the numbers lying between this range are cached internally by the Integer class. While defining an object as:  num3==num4 Integer.java IntegerCache.java -128 to 127 Integer num3 = 20; Integer num3 = 20; 20 Internally, it is converted to Integer by using: Integer num = Integer.valueOf(20); Integer num = Integer.valueOf(20); 20 The valueOf method from the Integer class is defined like: public static Integer valueOf(int i) {\n if (i >= IntegerCache.low && i<=IntegerCache.high)\n     return IntegerCache.cache[i + (-IntegerCache.low)];\n return new Integer(i);\n} public static Integer valueOf(int i) {\n if (i >= IntegerCache.low && i<=IntegerCache.high)\n     return IntegerCache.cache[i + (-IntegerCache.low)];\n return new Integer(i);\n} public static Integer valueOf(int i) public static valueOf (int i) int if return return new This means that if the value lies in the range -128 to 127, then it returns the Integer instance from the cache, else it creates a new instance. This means that the num3 and num4 point to the same object in the IntegerCache and thereby the comparison results in true.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "18. What is the result of the below program?",
        "answer": "class X {\n   static int i = 1111;\n\n   static{\n       i = i-- - --i;    //L1\n   }\n\n   {\n       i = i++ + ++i;    //L2\n   }\n}\n\nclass Y extends X{\n   static{\n       i = --i - i--;    //L3\n   }\n   {\n       i = ++i + i++;    //L4\n   }\n}\n\npublic class DriverClass{\n   public static void main(String[] args){\n       Y y = new Y();\n       System.out.println(y.i);    //L5\n   }\n} class X {\n   static int i = 1111;\n\n   static{\n       i = i-- - --i;    //L1\n   }\n\n   {\n       i = i++ + ++i;    //L2\n   }\n}\n\nclass Y extends X{\n   static{\n       i = --i - i--;    //L3\n   }\n   {\n       i = ++i + i++;    //L4\n   }\n}\n\npublic class DriverClass{\n   public static void main(String[] args){\n       Y y = new Y();\n       System.out.println(y.i);    //L5\n   }\n} class X class X static int 1111 static //L1 //L2 class Y extends X class Y extends X static //L3 //L4 public class DriverClass class DriverClass public static void main(String[] args) public static void main (String[] args) new //L5 Let us evaluate the expressions one by one:\nL1 ->  i = i-- - --i; \ni = 1111 - 1109 = 2 i = i-- - --i; \ni = 1111 - 1109 = 2 1111 1109 2 L2 -> i = i++ + ++i; \ni = 0 + 2 = 2 i = i++ + ++i; \ni = 0 + 2 = 2 0 2 2 L3 -> i = --i - i--;\ni = 1 - 1 = 0 i = --i - i--;\ni = 1 - 1 = 0 1 1 0 L4 -> i = ++i + i++;\ni = 3 + 3 = 6 = y.i i = ++i + i++;\ni = 3 + 3 = 6 = y.i 3 3 6 L5 ->\ny.i = i from class Y which is 6.\nHence the output is 6.   Hence the output is 6.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "19. What is the output of the below code and why?",
        "answer": "public class InterviewbitTest {\n   private static int counter = 0;\n   void InterviewbitTest() {\n       counter = 20;\n   }\n   InterviewbitTest(int x){\n       counter = x;\n   }\n   public static void main(String[] args) {\n       InterviewbitTest interviewbitTest = new InterviewbitTest();\n       System.out.println(counter);\n   }\n} public class InterviewbitTest {\n   private static int counter = 0;\n   void InterviewbitTest() {\n       counter = 20;\n   }\n   InterviewbitTest(int x){\n       counter = x;\n   }\n   public static void main(String[] args) {\n       InterviewbitTest interviewbitTest = new InterviewbitTest();\n       System.out.println(counter);\n   }\n} public class InterviewbitTest class InterviewbitTest private static int 0 void InterviewbitTest() void InterviewbitTest () 20 int public static void main(String[] args) public static void main (String[] args) new The output of the code is “Compile Error” This is because the code is not able to find any constructor that matches InterviewbitTest().",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "20. Is it necessary to declare all immutable objects as final?",
        "answer": "This is not necessary. The functionality of achieving immutability can also be achieved by defining the members of a class as private and not providing any setter methods to modify/update the values. Any references to the members should not be leaked and the only source of initializing the members should be by using the parameterized constructor. We should note that the variables declared as final only takes care of not re-assigning the variable to a different value. The individual properties of an object can still be changed.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "21. What do you know about Factory Design Pattern in Java?",
        "answer": "Factory design pattern is the most commonly used pattern in Java. They belong to Creational Patterns because it provides means of creating an object of different instances. Here, the logic of object creation is not exposed to the client. It is implemented by using a standard interface. It gives provision to select object types that we need for creation. This is why, they are also known as Virtual Constructors. For more information regarding the implementation, you can refer here.",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    },
    {
        "question": "1. Conclusion",
        "answer": "In this section, we have seen that a lot of questions have been asked on polymorphism (Method overloading & overriding), inheritance, collections, strings, and threads. One has to know the concepts and the working of each of these in-depth to ensure you ace the Java Interview. Additional Resources Additional Resources Practice Coding\nFeatures of Java 9\nTop Features of Java\nJava MCQs\nJava IDE\nJava Frameworks\nJava Interview Programs\nJava 11 Features\nJava 8 Features\nJava MCQ\nJava Projects\nJava Developer Salary\nInterview Questions on Manual Testing\nSelenium Interview Questions for Experienced Practice Coding Practice Coding Features of Java 9 Features of Java 9 Top Features of Java Top Features of Java Java MCQs Java MCQs Java IDE Java IDE Java Frameworks Java Frameworks Java Interview Programs Java Interview Programs Java 11 Features Java 11 Features Java 8 Features Java 8 Features Java MCQ Java MCQ Java Projects Java Projects Java Developer Salary Java Developer Salary Interview Questions on Manual Testing Interview Questions on Manual Testing Selenium Interview Questions for Experienced Selenium Interview Questions for Experienced",
        "reference": "interviewbit.com",
        "role": "java-for-5-years-experience"
    }
]