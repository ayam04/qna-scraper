[
    {
        "question": "1. Why is C called a mid-level programming language?",
        "answer": "C has characteristics of both assembly-level i.e. low-level and higher-level languages. So as a result, C is commonly called a middle-level language. Using C, a user can write an operating system as well as create a menu-driven consumer billing system.  ",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "2. What are the features of the C language?",
        "answer": "Some features of the C language are- It is Simple And Efficient. \nC language is portable or Machine Independent.\nC is a mid-level Programming Language. \nIt is a structured Programming Language.\nIt has a function-rich library. \nDynamic Memory Management.\nC is super fast.\nWe can use pointers in C.\nIt is extensible. It is Simple And Efficient. C language is portable or Machine Independent. C is a mid-level Programming Language. It is a structured Programming Language. It has a function-rich library. Dynamic Memory Management. C is super fast. We can use pointers in C. It is extensible.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "3. What is a token?",
        "answer": "The individual elements of a program are called Tokens. There are following 6 types of tokens are available in C: Identifiers\nKeywords\nConstants\nOperators\nSpecial Characters\nStrings Identifiers Keywords Constants Operators Special Characters Strings",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "4. What is the use of printf() and scanf() functions? Also explain format specifiers?",
        "answer": "printf() is used to print the output on the display.\nscanf() is used to read formatted data from the keyboard. printf() is used to print the output on the display. printf() scanf() is used to read formatted data from the keyboard. scanf() Some datatype format specifiers for both printing and scanning purposes are as follows: %d: It's a datatype format specifier for printing and scanning an integer value. \n%s: It's a datatype format specifier for printing and scanning a string. \n%c: It's a datatype format specifier for displaying and scanning a character value.\n%f: The datatype format specifier %f is used to display and scan a float value. %d: It's a datatype format specifier for printing and scanning an integer value. %d %s: It's a datatype format specifier for printing and scanning a string. %s %c: It's a datatype format specifier for displaying and scanning a character value. %c %f: The datatype format specifier %f is used to display and scan a float value. %f",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "5. What's the value of the expression 5[\"abxdef\"]?",
        "answer": "The answer is 'f'. 'f'. Explanation: The string mentioned \"abxdef\" is an array, and the  expression is equal to \"abxdef\"[5]. Why is the inside-out expression equivalent?  Because a[b] is equivalent to *(a + b) which is equivalent to *(b + a) which is equivalent to b[a].",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "6. What is a built-in function in C?",
        "answer": "The most commonly used built-in functions in C are scanf(), printf(), strcpy, strlwr, strcmp, strlen, strcat, and many more. Built-function is also known as library functions that are provided by the system to make the life of a developer easy by assisting them to do certain commonly used predefined tasks. For example, if you need to print output or your program into the terminal, we use printf() in C.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "7. What is a Preprocessor?",
        "answer": "A preprocessor is a software program that processes a source file before sending it to be compiled. Inclusion of header files, macro expansions, conditional compilation, and line control are all possible with the preprocessor.  ",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "8. In C, What is the #line used for?",
        "answer": "In C, #line is used as a preprocessor to re-set the line number in the code, which takes a parameter as line number. Here is an example for the same. #include <stdio.h>        /*line 1*/\n            /*line 2*/\n int main(){         /*line 3*/\n            /*line 4*/\n printf(\"Hello world\\n\");     /*line 5*/\n //print current line      /*line 6*/\n printf(\"Line: %d\\n\",__LINE__);    /*line 7*/\n //reset the line number by 36    /*line 8*/\n #line 36 /*reseting*/\n //print current line      /*line 36*/\n printf(\"Line: %d\\n\",__LINE__);    /*line 37*/\n printf(\"Bye bye!!!\\n\");      /*line 39*/\n            /*line 40*/\n return 0;         /*line 41*/\n}            /*line 42*/ #include <stdio.h>        /*line 1*/\n            /*line 2*/\n int main(){         /*line 3*/\n            /*line 4*/\n printf(\"Hello world\\n\");     /*line 5*/\n //print current line      /*line 6*/\n printf(\"Line: %d\\n\",__LINE__);    /*line 7*/\n //reset the line number by 36    /*line 8*/\n #line 36 /*reseting*/\n //print current line      /*line 36*/\n printf(\"Line: %d\\n\",__LINE__);    /*line 37*/\n printf(\"Bye bye!!!\\n\");      /*line 39*/\n            /*line 40*/\n return 0;         /*line 41*/\n}            /*line 42*/ #include <stdio.h>        /*line 1*/ include <stdio.h> /*line 1*/ /*line 2*/ int main() int main () /*line 3*/ /*line 4*/ printf \"Hello world\\n\" /*line 5*/ //print current line      /*line 6*/ printf \"Line: %d\\n\" /*line 7*/ //reset the line number by 36    /*line 8*/ #line 36 /*reseting*/ line /*reseting*/ //print current line      /*line 36*/ printf \"Line: %d\\n\" /*line 37*/ printf \"Bye bye!!!\\n\" /*line 39*/ /*line 40*/ return 0 /*line 41*/ /*line 42*/",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "9. How can a string be converted to a number?",
        "answer": "The function takes the string as an input that needs to be converted to an integer. int atoi(const char *string) int atoi(const char *string) int atoi(const char *string) int atoi (const char *string) const char string Return Value: Return Value: On successful conversion, it returns the desired integer value\nIf the string starts with alpha-numeric char or only contains alpha-num char, 0 is returned.\nIn case string starts with numeric character but is followed by alpha-num char, the string is converted to integer till the first occurrence of alphanumeric char. On successful conversion, it returns the desired integer value If the string starts with alpha-numeric char or only contains alpha-num char, 0 is returned. In case string starts with numeric character but is followed by alpha-num char, the string is converted to integer till the first occurrence of alphanumeric char. Converting String to Number  Converting String to Number",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "10. How can a number be converted to a string?",
        "answer": "The function takes a pointer to an array of char elements that need to be converted, and a format string needs to be written in a buffer as a string int sprintf(char *str, const char *format, ...) int sprintf(char *str, const char *format, ...)    The output after running the above code: Output: Value of Pi = 3.141593",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "11. What is recursion in C?",
        "answer": "When a function in C calls a copy of itself, this is known as recursion. To put it another way, when a function calls itself, this technique is called Recursion. Also, this function is known as recursive function. Syntax of Recursive Function: Syntax of Recursive Function: void do_recursion()\n{ \n... .. ... \ndo_recursion();\n... .. ...]\n} \nint main() \n{\n... .. ...\ndo_recursion();\n... .. ...\n} void do_recursion()\n{ \n... .. ... \ndo_recursion();\n... .. ...]\n} \nint main() \n{\n... .. ...\ndo_recursion();\n... .. ...\n}",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "12. Why doesn’t C support function overloading?",
        "answer": "After you compile the C source, the symbol names need to be intact in the object code. If we introduce function overloading in our source, we should also provide name mangling as a preventive measure to avoid function name clashes. Also, as C is not a strictly typed language many things(ex: data types) are convertible to each other in C. Therefore, the complexity of overload resolution can introduce confusion in a language such as C. function overloading When you compile a C source, symbol names will remain intact. If you introduce function overloading, you should provide a name mangling technique to prevent name clashes. Consequently, like C++, you'll have machine-generated symbol names in the compiled binary. Additionally, C does not feature strict typing. Many things are implicitly convertible to each other in C. The complexity of overload resolution rules could introduce confusion in such kind of language",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "13. What is the difference between global int and static int declaration?",
        "answer": "The difference between this is in scope. A truly global variable has a global scope and is visible everywhere in your program. #include <stdio.h> \n \nint my_global_var = 0; \n \nint \nmain(void) \n \n{ \n  printf(\"%d\\n\", my_global_var); \n  return 0; \n} #include <stdio.h> \n \nint my_global_var = 0; \n \nint \nmain(void) \n \n{ \n  printf(\"%d\\n\", my_global_var); \n  return 0; \n} #include <stdio.h> include <stdio.h> int 0 int \nmain(void) int main (void) void printf \"%d\\n\" return 0 global_temp is a global variable that is visible to everything in your program, although to make it visible in other modules, you'd need an ”extern int global_temp; ” in other source files if you have a multi-file project. A static variable has a local scope but its variables are not allocated in the stack segment of the memory. It can have less than global scope, although - like global variables - it resides in the .bss segment of your compiled binary. #include <stdio.h> \n \nint \nmyfunc(int val) \n \n{ \n    static int my_static_var = 0; \n \n    my_static_var += val; \n    return my_static_var; \n} \n \nint \nmain(void) \n \n{ \n   int myval; \n \n   myval = myfunc(1); \n   printf(\"first call %d\\n\", myval); \n \n   myval = myfunc(10); \n \n   printf(\"second call %d\\n\", myval); \n \n   return 0; \n} #include <stdio.h> \n \nint \nmyfunc(int val) \n \n{ \n    static int my_static_var = 0; \n \n    my_static_var += val; \n    return my_static_var; \n} \n \nint \nmain(void) \n \n{ \n   int myval; \n \n   myval = myfunc(1); \n   printf(\"first call %d\\n\", myval); \n \n   myval = myfunc(10); \n \n   printf(\"second call %d\\n\", myval); \n \n   return 0; \n} #include <stdio.h> include <stdio.h> int \nmyfunc(int val) int myfunc (int val) int static int 0 return int \nmain(void) int main (void) void int 1 printf \"first call %d\\n\" 10 printf \"second call %d\\n\" return 0",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "14. What is a pointer in C?",
        "answer": "A pointer is a variable that stores or points to another variable's address. The value of a variable is stored in a normal variable, whereas the address of a variable is stored in a pointer variable.  ",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "15. Difference between const char* p and char const* p?",
        "answer": "const char* p is a pointer to a const char.\nchar const* p is a pointer to a char const. const char* p is a pointer to a const char. char const* p is a pointer to a char const. Since const char and char const are the same, it's the same.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "16. What is pointer to pointer in C?",
        "answer": "In C, a pointer can also be used to store the address of another pointer. A double pointer or pointer to pointer is such a pointer. The address of a variable is stored in the first pointer, whereas the address of the first pointer is stored in the second pointer. The syntax of declaring a double pointer is given below: int **p; // pointer to a pointer which is pointing to an integer int **p; // pointer to a pointer which is pointing to an integer",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "17. Why n++ executes faster than n+1 ?",
        "answer": "n++ being a unary operation, it just needs one variable. Whereas, n = n + 1 is a binary operation that adds overhead to take more time (also binary operation: n += 1). However, in modern platforms, it depends on few things such as processor architecture, C compiler, usage in your code, and other factors such as hardware problems. While in the modern compiler even if you write n = n + 1 it will get converted into n++ when it goes into the optimized binary, and it will be equivalently efficient.  ",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "18. What is typecasting in C?",
        "answer": "Typecasting is the process to convert a variable from one datatype to another.  If we want to store the large type value to an int type, then we will convert the data type into another data type explicitly. Syntax: (data_type)expression; Syntax: (data_type)expression; For Example: For Example: int x;\nfor(x=97; x<=122; x++)\n{\n   printf(\"%c\", (char)x);   /*Explicit casting from int to char*/\n} int x;\nfor(x=97; x<=122; x++)\n{\n   printf(\"%c\", (char)x);   /*Explicit casting from int to char*/\n}",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "19. What are the advantages of Macro over function?",
        "answer": "Macro on a high-level copy-paste, its definitions to places wherever it is called. Due to which it saves a lot of time, as no time is spent while passing the control to a new function and the control is always with the callee function. However, one downside is the size of the compiled binary is large but once compiled the program comparatively runs faster.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "20. What are Enumerations?",
        "answer": "Enumeration, also known as Enum in C, is a user-defined data type. It consists of constant integrals or integers that have names assigned to them by the user. Because the integer values are named with enum in C, the whole program is simple to learn, understand, and maintain by the same or even different programmer.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "21. When should we use the register storage specifier?",
        "answer": "If a variable is used frequently, it should be declared with the register storage specifier, and the compiler may allocate a CPU register for its storage to speed up variable lookup.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "1. Specify different types of decision control statements?",
        "answer": "All statements written in a program are executed from top to bottom one by one. Control statements are used to execute/transfer the control from one part of the program to another depending on the condition. If-else statement.\nnormal if-else statement.\nElse-if statement\nnested if-else statement.\nSwitch statement. If-else statement.\nnormal if-else statement.\nElse-if statement\nnested if-else statement. normal if-else statement.\nElse-if statement\nnested if-else statement. normal if-else statement. Else-if statement nested if-else statement. Switch statement.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "2. What is an r-value and l-value?",
        "answer": "The term \"r-value\" refers to a data value stored in memory at a given address. An r-value is an expression that cannot have a value assigned to it, hence it can only exist on the right side of an assignment operator(=).\nThe term \"l-value\" refers to a memory location that is used to identify an object. The l-value can be found on either the left or right side of an assignment operator(=). l-value is frequently used as an identifier. The term \"r-value\" refers to a data value stored in memory at a given address. An r-value is an expression that cannot have a value assigned to it, hence it can only exist on the right side of an assignment operator(=). The term \"l-value\" refers to a memory location that is used to identify an object. The l-value can be found on either the left or right side of an assignment operator(=). l-value is frequently used as an identifier.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "3. What is the difference between malloc() and calloc()?",
        "answer": "calloc() and malloc() are memory dynamic memory allocating functions. The main difference is that malloc() only takes one argument, which is the number of bytes, but calloc() takes two arguments, which are the number of blocks and the size of each block. calloc() and malloc()",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "4. What is the difference between struct and union in C?",
        "answer": "A struct is a group of complex data structures stored in a block of memory where each member on the block gets a separate memory location to make them accessible at once\n\nWhereas in the union, all the member variables are stored at the same location on the memory as a result to which while assigning a value to a member variable will change the value of all other members.   /* struct & union definations*/\nstruct bar {\n int a; // we can use a & b both simultaneously\n char b;\n} bar;\n\nunion foo {\n int a; // we can't use both a and b simultaneously\n char b;\n} foo;\n\n/* using struc and union variables*/\n\nstruct bar y;\ny.a = 3; // OK to use\ny.b = 'c'; // OK to use\n\nunion foo x;\nx.a = 3; // OK\nx.b = 'c'; // NOl this affects the value of x.a! /* struct & union definations*/\nstruct bar {\n int a; // we can use a & b both simultaneously\n char b;\n} bar;\n\nunion foo {\n int a; // we can't use both a and b simultaneously\n char b;\n} foo;\n\n/* using struc and union variables*/\n\nstruct bar y;\ny.a = 3; // OK to use\ny.b = 'c'; // OK to use\n\nunion foo x;\nx.a = 3; // OK\nx.b = 'c'; // NOl this affects the value of x.a! /* struct & union definations*/ struct bar { struct bar int // we can use a & b both simultaneously char union foo { union foo int // we can't use both a and b simultaneously char /* using struc and union variables*/ struct bar y; struct bar y 3 // OK to use 'c' // OK to use union foo x; union foo x 3 // OK 'c' // NOl this affects the value of x.a!",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "5. What is call by reference in functions?",
        "answer": "When we caller function makes a function call bypassing the addresses of actual parameters being passed, then this is called call by reference. In incall by reference, the operation performed on formal parameters affects the value of actual parameters because all the operations performed on the value stored in the address of actual parameters.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "6. What is pass by reference in functions?",
        "answer": "In Pass by reference, the callee receives the address and makes a copy of the address of an argument into the formal parameter. Callee function uses the address to access the actual argument (to do some manipulation). If the callee function changes the value addressed at the passed address it will be visible to the caller function as well. Pass By Reference  Pass By Reference",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "7. What is a memory leak? How to avoid it?",
        "answer": "When we assign a variable it takes space of our RAM (either heap or RAM)dependent on the size of data type, however, if a programmer uses a memory available on the heap and forgets to a delta it, at some point all the memory available on the ram will be occupied with no memory left this can lead to a memory leak. int main()\n{\n    char * ptr = malloc(sizeof(int));\n    \n    /* Do some work */\n    /*Not freeing the allocated memory*/\n    return 0;\n} int main()\n{\n    char * ptr = malloc(sizeof(int));\n    \n    /* Do some work */\n    /*Not freeing the allocated memory*/\n    return 0;\n} int main() int main () char malloc sizeof int /* Do some work */ /*Not freeing the allocated memory*/ return 0 To avoid memory leaks, you can trace all your memory allocations and think forward, where you want to destroy (in a good sense) that memory and place delete there. Another way is to use C++ smart pointer in C linking it to GNU compilers.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "8. What is Dynamic memory allocation in C? Name the dynamic allocation functions.",
        "answer": "C is a language known for its low-level control over the memory allocation of variables in DMA there are two major standard library malloc() and free. The malloc() function takes a single input parameter which tells the size of the memory requested It returns a pointer to the allocated memory. If the allocation fails, it returns NULL. The prototype for the standard library function is like this: void *malloc(size_t size);\nThe free() function takes the pointer returned by malloc() and de-allocates the memory. No indication of success or failure is returned. The function prototype is like this:  void free(void *pointer);\nThere are 4 library functions provided by C defined under <stdlib.h> header file to facilitate dynamic memory allocation in C programming. They are:  malloc()\ncalloc()\nfree()\nrealloc() malloc() calloc() free() realloc()",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "9. What is typedef?",
        "answer": "typedef is a C keyword, used to define alias/synonyms for an existing type in C language. In most cases, we use typedef's to simplify the existing type declaration syntax. Or to provide specific descriptive names to a type. typedef <existing-type> <new-type-identifiers>; typedef <existing-type> <new-type-identifiers>; typedef new typedef provides an alias name to the existing complex type definition. With typedef, you can simply create an alias for any type. Whether it is a simple integer to complex function pointer or structure declaration, typedef will shorten your code.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "10. Why is it usually a bad idea to use gets()? Suggest a workaround.",
        "answer": "The standard input library gets() reads user input till it encounters a new line character. However, it does not check on the size of the variable being provided by the user is under the maximum size of the data type which makes the system vulnerable to buffer overflow and the input being written into memory where it isn’t supposed to. We, therefore, use gets() to achieve the same with a restricted range of input Bonus: It remained an official part of the language up to the 1999 ISO C standard, but it was officially removed by the 2011 standard. Most C implementations still support it, but at least GCC issues a warning for any code that uses it. Bonus: It remained an official part of the language up to the 1999 ISO C standard, but it was officially removed by the 2011 standard. Most C implementations still support it, but at least GCC issues a warning for any code that uses it.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "11. What is the difference between #include \"...\" and #include <...>?",
        "answer": "In practice, the difference is in the location where the preprocessor searches for the included file. For #include <filename> the C preprocessor looks for the filename in the predefined list of system directories first and then to the directories told by the user(we can use -I option to add directories to the mentioned predefined list). For #include \"filename\" the preprocessor searches first in the same directory as the file containing the directive, and then follows the search path used for the #include <filename> form. This method is normally used to include programmer-defined header files.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "12. What are dangling pointers? How are dangling pointers different from memory leaks?",
        "answer": "The dangling pointer points to a memory that has already been freed. The storage is no longer allocated. Trying to access it might cause a Segmentation fault. A common way to end up with a dangling pointer: #include<stdio.h>\n#include<string.h>\n\nchar *func()\n{\n    char str[10];\n    strcpy(str,\"Hello!\");\n    return(str);\n} #include<stdio.h>\n#include<string.h>\n\nchar *func()\n{\n    char str[10];\n    strcpy(str,\"Hello!\");\n    return(str);\n} #include<stdio.h> include <stdio.h> #include<string.h> include <string.h> char *func() char func () char 10 strcpy \"Hello!\" return You are returning an address that was a local variable, which would have gone out of scope by the time control was returned to the calling function. (Undefined behavior) *c = malloc(5izeof(int));\nfree(c);\n*c = 3; //writing to freed location! *c = malloc(5izeof(int));\nfree(c);\n*c = 3; //writing to freed location! malloc 5 int free 3 //writing to freed location! In the figure shown above writing to a memory that has been freed is an example of the dangling pointer, which makes the program crash. A memory leak is something where the memory allocated is not freed which causes the program to use an undefined amount of memory from the ram making it unavailable for every other running program(or daemon) which causes the programs to crash. There are various tools like O profile testing which is useful to detect memory leaks on your programs. void function(){\n char *leak = malloc (10); //leak assigned but not freed\n} void function(){\n char *leak = malloc (10); //leak assigned but not freed\n} void function() void function () char malloc 10 //leak assigned but not freed",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "13. What is the difference between ‘g’ and “g” in C?",
        "answer": "In C double-quotes variables are identified as a string whereas single-quoted variables are identified as the character. Another major difference being the string (double-quoted) variables end with a null terminator that makes it a 2 character array.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "14. Which is better #define or enum?",
        "answer": "If we let it, the compiler can build enum values automatically. However, each of the defined values must be given separately.\nBecause macros are preprocessors, unlike enums, which are compile-time entities, the source code is unaware of these macros. So, if we use a debugger to debug the code, the enum is superior.\nSome compilers will give a warning if we use enum values in a switch and the default case is missing.\nEnum always generates int-type identifiers. The macro, on the other hand, allowed us to pick between various integral types.\nUnlike enum, the macro does not have a defined scope constraint. If we let it, the compiler can build enum values automatically. However, each of the defined values must be given separately. Because macros are preprocessors, unlike enums, which are compile-time entities, the source code is unaware of these macros. So, if we use a debugger to debug the code, the enum is superior. Some compilers will give a warning if we use enum values in a switch and the default case is missing. Enum always generates int-type identifiers. The macro, on the other hand, allowed us to pick between various integral types. Unlike enum, the macro does not have a defined scope constraint.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "15. Suppose a global variable and local variable have the same name. Is it possible to access a global variable from a block where local variables are defined?",
        "answer": "No. This isn’t possible in C. It’s always the most local variable that gets preference.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "16. Which structure is used to link the program and the operating system?",
        "answer": "The file structure is used to link the operating system and a program. The header file \"stdio.h\" (standard input/output header file) defines the file. It contains information about the file being used like its current size and its memory location. It contains a character pointer that points to the character which is currently being opened. When you open a file, it establishes a link between the program and the operating system about which file is to be accessed.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "17. What is a near pointer and a far pointer in C?",
        "answer": "Near Pointer: In general, the near pointer can be considered because it is used to hold the address, which has a maximum size of just 16 bits. We can't store an address with a size larger than 16 bits using the near pointer. All other smaller addresses that are within the 16-bit limit, on the other hand, can be stored. Because we can only access 64kb of data at a time, you might assume the 16 bits are insufficient. As a result, it is regarded as one of the near-pointer's biggest drawbacks, which is why it is no longer commonly used.\nFar Pointer: A far pointer is considered a pointer of size 32 bits. It can, however, use the current segment to access information stored outside the computer's memory. Although, in order to use this type of pointer, we usually need to allocate the sector register to store the data address in the current segment. Near Pointer: In general, the near pointer can be considered because it is used to hold the address, which has a maximum size of just 16 bits. We can't store an address with a size larger than 16 bits using the near pointer. All other smaller addresses that are within the 16-bit limit, on the other hand, can be stored. Because we can only access 64kb of data at a time, you might assume the 16 bits are insufficient. As a result, it is regarded as one of the near-pointer's biggest drawbacks, which is why it is no longer commonly used. Near Pointer Far Pointer: A far pointer is considered a pointer of size 32 bits. It can, however, use the current segment to access information stored outside the computer's memory. Although, in order to use this type of pointer, we usually need to allocate the sector register to store the data address in the current segment. Far Pointer:",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "1. How can you remove duplicates in an array?",
        "answer": "The following program will help you to remove duplicates from an array. #include <stdio.h>\nint main() {\n    int n, a[100], b[100], calc = 0, i, j,count;\n    printf(\"Enter no. of elements in array: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter %d integers: \", n);\n    for (i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n          \n    for (i = 0; i<n; i++) {\n        for (j = 0; j<calc; j++) {\n           if(a[i] == b[j])\n           break;  \n        }\n        if (j== calc) {\n             b[calc] = a[i];\n             calc++; \n        }\n     }\n     \n     printf(\"Array obtained after removing duplicate elements: \");\n     for (i = 0; i<calc; i++) { \n            printf(\"%d \", b[i]);\n     }\n     return 0;\n} #include <stdio.h>\nint main() {\n    int n, a[100], b[100], calc = 0, i, j,count;\n    printf(\"Enter no. of elements in array: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter %d integers: \", n);\n    for (i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n          \n    for (i = 0; i<n; i++) {\n        for (j = 0; j<calc; j++) {\n           if(a[i] == b[j])\n           break;  \n        }\n        if (j== calc) {\n             b[calc] = a[i];\n             calc++; \n        }\n     }\n     \n     printf(\"Array obtained after removing duplicate elements: \");\n     for (i = 0; i<calc; i++) { \n            printf(\"%d \", b[i]);\n     }\n     return 0;\n}",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "2. Can we compile a program without a main() function?",
        "answer": "Yes, we can compile a program without main() function Using Macro. E.g. #include<studio.h>\n#define abc main\nint abc ()\n{\nprintf(\"Hello World \");\nreturn 0;\n} #include<studio.h>\n#define abc main\nint abc ()\n{\nprintf(\"Hello World \");\nreturn 0;\n}",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "3. Write a program to get the higher and lower nibble of a byte without using shift operator?",
        "answer": "#include<stdio.h>\nstruct full_byte\n{\nchar first : 4;\nchar second : 4;\n};\n\nunion A\n{\nchar x;\nstruct full_byte by;\n};\n\nmain()\n{\nchar c = 100;\nunion A a;\na.x = c;\nprintf(\"the two nibbles are: %d and %d\\n\", a.by.first, a.by.second);\n} #include<stdio.h>\nstruct full_byte\n{\nchar first : 4;\nchar second : 4;\n};\n\nunion A\n{\nchar x;\nstruct full_byte by;\n};\n\nmain()\n{\nchar c = 100;\nunion A a;\na.x = c;\nprintf(\"the two nibbles are: %d and %d\\n\", a.by.first, a.by.second);\n}",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "4. How do you override a defined macro?",
        "answer": "To override a defined macro we can use #ifdef and #undef preprocessors as follows: #ifdef A\n#undef A\n#endif\n#define A 10 #ifdef A #undef A #endif #define A 10 If macro A is defined, it will be undefined using undef and then defined again using define.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "5. Write a C program to check if it is a palindrome number or not using a recursive method.",
        "answer": "#include <stdio.h>\n#include <conio.h>\nint reverse(int num);\nint isPalindrome(int num);\nint main()\n{\n    int num;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &num);\nif(isPalindrome(num) == 1)\n{\n printf(\"the given number is a palindrome\");\n    }\n    else\n    {\n        printf(\"the given number is not a palindrome number\");\n   }\n    return 0;\n}\n\nint isPalindrome(int num)\n{\n    if(num == reverse(num))\n    {\n        return 1;\n    }\n    return 0;\n}\nint reverse(int num)\n{\nint rem;\n    static int sum=0;\n    if(num!=0){\n            rem=num%10;\n            sum=sum*10+rem;\n            reverse(num/10);\n    }\n        else\n             return sum;\n    return sum;\n} #include <stdio.h>\n#include <conio.h>\nint reverse(int num);\nint isPalindrome(int num);\nint main()\n{\n    int num;\n    printf(\"Enter a number: \");\n    scanf(\"%d\", &num);\nif(isPalindrome(num) == 1)\n{\n printf(\"the given number is a palindrome\");\n    }\n    else\n    {\n        printf(\"the given number is not a palindrome number\");\n   }\n    return 0;\n}\n\nint isPalindrome(int num)\n{\n    if(num == reverse(num))\n    {\n        return 1;\n    }\n    return 0;\n}\nint reverse(int num)\n{\nint rem;\n    static int sum=0;\n    if(num!=0){\n            rem=num%10;\n            sum=sum*10+rem;\n            reverse(num/10);\n    }\n        else\n             return sum;\n    return sum;\n}",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "6. C program to check the given number format is in binary or not.",
        "answer": "#include<stdio.h>\n#include<conio.h>\nint main() {\n int j,num;\n printf(\"Please enter a number :\");\n scanf(\"%d\",&num);\n    while(num>0)\n    {\n        j=num%10;\n        if( j!=0 && j!=1 )\n        {\n           printf(\"num is not binary\");\n           break;\n        }\n        num=num/10;\n        if(num==0)\n        {\n            printf(\"num is binary\");\n        }\n    }\n getch();\n} #include<stdio.h>\n#include<conio.h>\nint main() {\n int j,num;\n printf(\"Please enter a number :\");\n scanf(\"%d\",&num);\n    while(num>0)\n    {\n        j=num%10;\n        if( j!=0 && j!=1 )\n        {\n           printf(\"num is not binary\");\n           break;\n        }\n        num=num/10;\n        if(num==0)\n        {\n            printf(\"num is binary\");\n        }\n    }\n getch();\n}",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "7. C Program to find a sum of digits of a number using recursion.",
        "answer": "#include<stdio.h>\n#include<conio.h>\n\nint sumOfDigits(int num)\n    {\n            static int sum = 0;\n            int rem;\n            sum = sum + (num%10);\n            rem = num/10;\n            if(rem > 0)\n            {\n                sumOfDigits(rem);\n            }\n            return sum;\n    }\nint main() {\n int j,num;\n printf(\"Please enter a number :\");\n scanf(\"%d\",&num);\n    printf(\"sum of digits of the number = %d \",sumOfDigits(num));\n    getch();\n} #include<stdio.h>\n#include<conio.h>\n\nint sumOfDigits(int num)\n    {\n            static int sum = 0;\n            int rem;\n            sum = sum + (num%10);\n            rem = num/10;\n            if(rem > 0)\n            {\n                sumOfDigits(rem);\n            }\n            return sum;\n    }\nint main() {\n int j,num;\n printf(\"Please enter a number :\");\n scanf(\"%d\",&num);\n    printf(\"sum of digits of the number = %d \",sumOfDigits(num));\n    getch();\n}",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "8. Can you tell me how to check whether a linked list is circular?",
        "answer": "Single Linked List Single Linked List Single Linked List  Single Linked List Circular Linked List Circular Linked List Circular linked list is a variation of a linked list where the last node is pointing to the first node's information part. Therefore the last node does not point to null. Algorithm to find whether the given linked list is circular A very simple way to determine whether the linked list is circular or not Traverse the linked list\nCheck if the node is pointing to the head.\nIf yes then it is circular. Traverse the linked list Check if the node is pointing to the head. If yes then it is circular. Let's look at the snippet where we code this algorithm. Create a structure for a linked list\nDeclare\n-Variable to store data of the node.\n-Pointer variable of struct type to store the address of next node.\n\nfunction of datatype tool isCircular(firstgode){\n\n-Store the value of first node in temp variable and make it traverse all nodes.\n-temp-firstgode\n-tempenext node pointed by temp(temp->next)\n-run until temp is at null or firstNode\n\nif (temp at null)\n not circular and returns false \nif (temp points first node)\n return true as its circular.\n }\n \nfunction of datatype node newNode(data){\n\n-To insert new nodes and link each one of them to the previous node by storing the address of the new node to the previous one.\n-Then make them point to NULL.\n}\n\nIn int main function\n\n-First insert nodes for circular linked list and check its nature by calling isCircular function.\n-Since it is true through if statement it prints \"yes..\n-Second insert a normal linked list and check its nature by calling isCircular function. As its not circular it prints \"no\", Create a structure for a linked list\nDeclare\n-Variable to store data of the node.\n-Pointer variable of struct type to store the address of next node.\n\nfunction of datatype tool isCircular(firstgode){\n\n-Store the value of first node in temp variable and make it traverse all nodes.\n-temp-firstgode\n-tempenext node pointed by temp(temp->next)\n-run until temp is at null or firstNode\n\nif (temp at null)\n not circular and returns false \nif (temp points first node)\n return true as its circular.\n }\n \nfunction of datatype node newNode(data){\n\n-To insert new nodes and link each one of them to the previous node by storing the address of the new node to the previous one.\n-Then make them point to NULL.\n}\n\nIn int main function\n\n-First insert nodes for circular linked list and check its nature by calling isCircular function.\n-Since it is true through if statement it prints \"yes..\n-Second insert a normal linked list and check its nature by calling isCircular function. As its not circular it prints \"no\", for list struct type to store the address of next node.\n\nfunction of datatype tool isCircular(firstgode){ struct type to store the address of next node function of datatype tool isCircular firstgode and tempenext node pointed by temp(temp->next)\n-run until temp is at null or firstNode\n\nif (temp at null)\n not circular and returns false \nif (temp points first node)\n return true as its circular.\n }\n \nfunction of datatype node newNode(data) temp (temp->next) or if (temp at null) not and false if (temp points first node) return true newNode (data) new and new NULL int for list and true if \"yes..\n-Second insert a normal linked list and check its nature by calling isCircular function. As its not circular it prints \" \",",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "9. What is the use of a semicolon (;) at the end of every program statement?",
        "answer": "It is majorly related to how the compiler reads( or parses) the entire code and breaks it into a set of instructions(or statements), to which semicolon in C acts as a boundary between two sets of instructions.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "10. How to call a function before main()?",
        "answer": "To call a function before the main(), pragma startup directive should be used. E.g.- #pragma startup fun\nvoid fun()\n{\nprintf(\"In fun\\n\");\n}\nmain()\n{\nprintf(\"In main\\n\");\n} #pragma startup fun\nvoid fun()\n{\nprintf(\"In fun\\n\");\n}\nmain()\n{\nprintf(\"In main\\n\");\n} The output of the above program will be - In fun\nIn main In fun\nIn main This pragma directive, on the other hand, is compiler-dependent. This is not supported by gcc. As a result, it will ignore the startup directive and produce no error. But the output, in that case, will be - In main In main",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "11. Differentiate between the macros and the functions.",
        "answer": "The differences between macros and functions can be explained as follows: Macros Functions\nIt is preprocessed rather than compiled. It is compiled not preprocessed.\nIt is preprocessed rather than compiled. Function checks for compilation errors.\nCode length is increased. Code length remains the same.\nMacros are faster in execution. Functions are a bit slower in execution.\nMacros are useful when a small piece of code is used multiple times in a program. Functions are helpful when a large piece of code is repeated a number of times. Macros Functions\nIt is preprocessed rather than compiled. It is compiled not preprocessed.\nIt is preprocessed rather than compiled. Function checks for compilation errors.\nCode length is increased. Code length remains the same.\nMacros are faster in execution. Functions are a bit slower in execution.\nMacros are useful when a small piece of code is used multiple times in a program. Functions are helpful when a large piece of code is repeated a number of times. Macros Functions Macros Functions Macros Functions It is preprocessed rather than compiled. It is compiled not preprocessed.\nIt is preprocessed rather than compiled. Function checks for compilation errors.\nCode length is increased. Code length remains the same.\nMacros are faster in execution. Functions are a bit slower in execution.\nMacros are useful when a small piece of code is used multiple times in a program. Functions are helpful when a large piece of code is repeated a number of times. It is preprocessed rather than compiled. It is compiled not preprocessed. It is preprocessed rather than compiled. It is compiled not preprocessed. It is preprocessed rather than compiled. Function checks for compilation errors. It is preprocessed rather than compiled. Function checks for compilation errors. Code length is increased. Code length remains the same. Code length is increased. Code length remains the same. Macros are faster in execution. Functions are a bit slower in execution. Macros are faster in execution. Functions are a bit slower in execution. Macros are useful when a small piece of code is used multiple times in a program. Functions are helpful when a large piece of code is repeated a number of times. Macros are useful when a small piece of code is used multiple times in a program. Functions are helpful when a large piece of code is repeated a number of times.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "12. Differentiate Source Codes from Object Codes",
        "answer": "Source Code and Object Code Difference  Source Code and Object Code Difference The difference between the Source Code and Object Code is that Source Code is a collection of computer instructions written using a human-readable programming language while Object Code is a sequence of statements in machine language, and is the output after the compiler or an assembler converts the Source Code. The last point about Object Code is the way the changes are reflected. When the Source Code is modified, each time the Source Code needs to be compiled to reflect the changes in the Object Code.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "13. What are header files and what are its uses in C programming?",
        "answer": "Header Files in C  Header Files in C In C header files must have the extension as .h, which contains function definitions, data type definitions, macro, etc. The header is useful to import the above definitions to the source code using the #include directive. For example, if your source code needs to take input from the user do some manipulation and print the output on the terminal, it should have stdio.h file included as #include <stdio.h>, with which we can take input using scanf() do some manipulation and print using printf().",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "14. When is the \"void\" keyword used in a function",
        "answer": "The keyword “void” is a data type that literally represents no data at all. The most obvious use of this is a function that returns nothing: void PrintHello() \n{ \n printf(\"Hello\\n\"); \n return;  // the function does \"return\", but no value is returned \n} void PrintHello() \n{ \n printf(\"Hello\\n\"); \n return;  // the function does \"return\", but no value is returned \n} void PrintHello() void PrintHello () printf \"Hello\\n\" return // the function does \"return\", but no value is returned Here we’ve declared a function, and all functions have a return type. In this case, we’ve said the return type is “void”, and that means, “no data at all” is returned. \nThe other use for the void keyword is a void pointer. A void pointer points to the memory location where the data type is undefined at the time of variable definition. Even you can define a function of return type void* or void pointer meaning “at compile time we don’t know what it will return” Let’s see an example of that.  void MyMemCopy(void* dst, const void* src, int numBytes) \n{ \n char* dst_c = reinterpret_cast<char*>(dst); \n const char* src_c = reinterpret_cast<const char*>(src); \n for (int i = 0; i < numBytes; ++i) \n  dst_c[i] = src_c[i]; \n} void MyMemCopy(void* dst, const void* src, int numBytes) \n{ \n char* dst_c = reinterpret_cast<char*>(dst); \n const char* src_c = reinterpret_cast<const char*>(src); \n for (int i = 0; i < numBytes; ++i) \n  dst_c[i] = src_c[i]; \n} void MyMemCopy(void* dst, const void* src, int numBytes) void MyMemCopy (void* dst, const void* src, int numBytes) void const void int char reinterpret_cast char const char reinterpret_cast const char for int 0",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "15. What is dynamic data structure?",
        "answer": "A dynamic data structure (DDS) refers to an organization or collection of data in memory that has the flexibility to grow or shrink in size, enabling a programmer to control exactly how much memory is utilized. Dynamic data structures change in size by having unused memory allocated or de-allocated from the heap as needed. Dynamic data structures play a key role in programming languages like C, C++, and Java because they provide the programmer with the flexibility to adjust the memory consumption of software programs.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "16. Add Two Numbers Without Using the Addition Operator",
        "answer": "For the sum of two numbers, we use the addition (+) operator. In these tricky C programs, we will write a C program to add two numbers without using the addition operator. #include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n  int x, y;\n  printf(\"Enter two number: \");\n  scanf(\"%d %d\",&x,&y);\n\n  // method 1\n  printf(\"%d\\n\", x-(-y));\n\n  // method 2\n  printf(\"%d\\n\", -(-x-y));\n\n  // method 3\n  printf(\"%d\\n\", abs(-x-y));\n\n  // method 4\n  printf(\"%d\", x-(~y)-1);\n\n  return 0;\n} #include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n  int x, y;\n  printf(\"Enter two number: \");\n  scanf(\"%d %d\",&x,&y);\n\n  // method 1\n  printf(\"%d\\n\", x-(-y));\n\n  // method 2\n  printf(\"%d\\n\", -(-x-y));\n\n  // method 3\n  printf(\"%d\\n\", abs(-x-y));\n\n  // method 4\n  printf(\"%d\", x-(~y)-1);\n\n  return 0;\n} #include<stdio.h> include <stdio.h> #include<stdlib.h> include <stdlib.h> int main() int main () int printf \"Enter two number: \" scanf \"%d %d\" // method 1 printf \"%d\\n\" // method 2 printf \"%d\\n\" // method 3 printf \"%d\\n\" abs // method 4 printf \"%d\" -1 return 0",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "17. Subtract Two Number Without Using Subtraction Operator",
        "answer": "#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n   int x, y;\n   printf(\"Enter two number: \");\n   scanf(\"%d %d\",&x,&y);\n   printf(\"%d\", x+(~y)+1);\n   return 0;\n} #include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n   int x, y;\n   printf(\"Enter two number: \");\n   scanf(\"%d %d\",&x,&y);\n   printf(\"%d\", x+(~y)+1);\n   return 0;\n} #include<stdio.h> include <stdio.h> #include<stdlib.h> include <stdlib.h> int main() int main () int printf \"Enter two number: \" scanf \"%d %d\" printf \"%d\" 1 return 0 The bitwise complement operator is used in this program. The bitwise complement of number ~y=-(y+1). So, expression will become x+(-(y+1))+1=x-y-1+1=x-y",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "18. Multiply an Integer Number by 2 Without Using Multiplication Operator",
        "answer": "#include<stdio.h>\nint main()\n{\n   int x;\n   printf(\"Enter a number: \");\n   scanf(\"%d\",&x);\n   printf(\"%d\", x<<1);\n   return 0;\n} #include<stdio.h>\nint main()\n{\n   int x;\n   printf(\"Enter a number: \");\n   scanf(\"%d\",&x);\n   printf(\"%d\", x<<1);\n   return 0;\n} #include<stdio.h> include <stdio.h> int main() int main () int printf \"Enter a number: \" scanf \"%d\" printf \"%d\" 1 return 0 The left shift operator shifts all bits towards the left by a certain number of specified bits. The expression x<<1 always returns x*2. Note that the shift operator doesn’t work on floating-point values. For multiple of x by 4, use x<<2. Similarly x<<3 multiply x by 8. For multiple of the number x by 2^n, use x<<n.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "19. Check whether the number is EVEN or ODD, without using any arithmetic or relational operators",
        "answer": "#include<stdio.h>\nint main()\n{\n   int x;\n   printf(\"Enter a number: \");\n   scanf(\"%d\", &x);\n   (x&1)?printf(\"Odd\"):printf(\"Even\");\n   return 0;\n} #include<stdio.h>\nint main()\n{\n   int x;\n   printf(\"Enter a number: \");\n   scanf(\"%d\", &x);\n   (x&1)?printf(\"Odd\"):printf(\"Even\");\n   return 0;\n} #include<stdio.h> include <stdio.h> int main() int main () int printf \"Enter a number: \" scanf \"%d\" 1 printf \"Odd\" printf \"Even\" return 0 The bitwise and(&) operator can be used to quickly check the number is odd or even.",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "20. Reverse the Linked List. Input: 1->2->3->4->5->NULL Output: 5->4->3->2->1->NULL",
        "answer": "Assume that we have linked list 1 → 2 → 3 → Ø, we would like to change it to Ø ← 1 ← 2 ← 3.   While you travel the linked list, change the current node's next pointer to point to its previous element. reference to the previous nodes should be stored into a temp variable as shown so that we don’t lose track of the swapped node. You also need another pointer to store the next node before changing the reference. Also when we are done return the new head of the reversed list. /* Function to reverse the linked list */\nstatic void reverse(struct Node** head_ref) \n{ \n    struct Node* prev   = NULL; \n    struct Node* current = *head_ref; \n    struct Node* next; \n    while (current != NULL) \n    { \n        // store next\n        next  = current->next;   \n\n        // reverse curr node pointer \n        current->next = prev;    \n\n        // move pointer one position ahead\n        prev = current; \n        current = next; \n    } \n    *head_ref = prev; \n} /* Function to reverse the linked list */\nstatic void reverse(struct Node** head_ref) \n{ \n    struct Node* prev   = NULL; \n    struct Node* current = *head_ref; \n    struct Node* next; \n    while (current != NULL) \n    { \n        // store next\n        next  = current->next;   \n\n        // reverse curr node pointer \n        current->next = prev;    \n\n        // move pointer one position ahead\n        prev = current; \n        current = next; \n    } \n    *head_ref = prev; \n} /* Function to reverse the linked list */ static void reverse(struct Node** head_ref) static void reverse (struct Node** head_ref) struct Node* prev   = struct Node prev NULL struct Node* current = struct Node current struct Node* next; struct Node next while NULL // store next // reverse curr node pointer // move pointer one position ahead",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "21. Check for Balanced Parentheses using Stack",
        "answer": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order. Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Example 1:\n Input: s = \"()\"\n Output: true\n\nExample 2:\n Input: s = \"()[]{}\"\n Output: true\n\nExample 3:\n Input: s = \"(]\"\n Output: false Example 1:     Example 2:     Example 3:     Below is the source code for C Program to Check for Balanced Parentheses using Stack which is successfully compiled and run on Windows System to produce desired output as shown below : int check(char exp[] )\n{\n        int i;\n        char temp;\n        for(i=0;i<strlen(exp);i++)\n        {\n                if(exp[i]=='(' || exp[i]=='{' || exp[i]=='[')\n                        push(exp[i]);\n                if(exp[i]==')' || exp[i]=='}' || exp[i]==']')\n                        if(top==-1)    /*stack empty*/\n                        {\n                                printf(\"Right parentheses are more than left parentheses\\n\");\n                                return 0;\n                        }\n                        else\n                        {\n                                temp=pop();\n                                if(!match(temp, exp[i]))\n                                {\n                                        printf(\"Mismatched parentheses are : \");\n                                        printf(\"%c and %c\\n\",temp,exp[i]);\n                                        return 0;\n                                }\n                        }\n        }\n        if(top==-1) /*stack empty*/\n        {\n                printf(\"Balanced Parentheses\\n\");\n                return 1;\n        }\n        else\n        {\n                printf(\"Left parentheses more than right parentheses\\n\");\n                return 0;\n        }\n} int check(char exp[] )\n{\n        int i;\n        char temp;\n        for(i=0;i<strlen(exp);i++)\n        {\n                if(exp[i]=='(' || exp[i]=='{' || exp[i]=='[')\n                        push(exp[i]);\n                if(exp[i]==')' || exp[i]=='}' || exp[i]==']')\n                        if(top==-1)    /*stack empty*/\n                        {\n                                printf(\"Right parentheses are more than left parentheses\\n\");\n                                return 0;\n                        }\n                        else\n                        {\n                                temp=pop();\n                                if(!match(temp, exp[i]))\n                                {\n                                        printf(\"Mismatched parentheses are : \");\n                                        printf(\"%c and %c\\n\",temp,exp[i]);\n                                        return 0;\n                                }\n                        }\n        }\n        if(top==-1) /*stack empty*/\n        {\n                printf(\"Balanced Parentheses\\n\");\n                return 1;\n        }\n        else\n        {\n                printf(\"Left parentheses more than right parentheses\\n\");\n                return 0;\n        }\n} int check(char exp[] ) int check (char exp[] ) char exp int char for 0 strlen exp if exp '(' exp '{' exp '[' exp if exp ')' exp '}' exp ']' if -1 /*stack empty*/ printf \"Right parentheses are more than left parentheses\\n\" return 0 else if exp printf \"Mismatched parentheses are : \" printf \"%c and %c\\n\" exp return 0 if -1 /*stack empty*/ printf \"Balanced Parentheses\\n\" return 1 else printf \"Left parentheses more than right parentheses\\n\" return 0  ",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "22. Program to find n’th Fibonacci number",
        "answer": "Fibonacci sequence is characterized by the fact that every number after the first two is the sum of the two preceding ones. For example, consider below sequence 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . .. and so on Where in F{n} = F{n-1} + F{n-2} with base values F(0) = 0 and <code>F(1) = 1 Below is naive implementation for finding the nth member of the Fibonacci sequence // Function to find the nth Fibonacci number\nint fib(int n)\n{\n    if (n <= 1) {\n        return n;\n    }\n \n    return fib(n - 1) + fib(n - 2);\n}\n \nint main()\n{\n    int n = 8;\n \n    printf(\"nth Fibonacci number is %d\", fib(8));\n \n    return 0;\n} // Function to find the nth Fibonacci number\nint fib(int n)\n{\n    if (n <= 1) {\n        return n;\n    }\n \n    return fib(n - 1) + fib(n - 2);\n}\n \nint main()\n{\n    int n = 8;\n \n    printf(\"nth Fibonacci number is %d\", fib(8));\n \n    return 0;\n} // Function to find the nth Fibonacci number int fib(int n) int fib (int n) int if 1 return return 1 2 int main() int main () int 8 printf \"nth Fibonacci number is %d\" 8 return 0",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "23. Write a program to find the node at which the intersection of two singly linked lists begins.",
        "answer": "Let's take an example of the following two linked lists which intersect at node c1. Intersection of Two Linked List  Intersection of Two Linked List Solution - Solution - Get count of the nodes in the first list, let count be c1.\nGet count of the nodes in the second list, let count be c2.\nGet the difference of counts d = abs(c1 – c2)\nNow traverse the bigger list from the first node till d nodes so that from here onwards both the lists have an equal no of nodes\nThen we can traverse both the lists in parallel till we come across a common node. (Note that getting a common node is done by comparing the address of the nodes) Get count of the nodes in the first list, let count be c1. Get count of the nodes in the second list, let count be c2. Get the difference of counts d = abs(c1 – c2) Now traverse the bigger list from the first node till d nodes so that from here onwards both the lists have an equal no of nodes Then we can traverse both the lists in parallel till we come across a common node. (Note that getting a common node is done by comparing the address of the nodes) // Function to get the intersection point \n// of the given linked lists \nint getIntersectionNode(Node* head1, Node* head2) \n{ \n    Node *curr1 = head1, *curr2 = head2; \n  \n    // While both the pointers are not equal \n    while (curr1 != curr2) { \n  \n        // If the first pointer is null then \n        // set it to point to the head of \n        // the second linked list \n        if (curr1 == NULL) { \n            curr1 = head2; \n        } \n  \n        // Else point it to the next node \n        else { \n            curr1 = curr1->next; \n        } \n  \n        // If the second pointer is null then \n        // set it to point to the head of \n        // the first linked list \n        if (curr2 == NULL) { \n            curr2 = head1; \n        } \n  \n        // Else point it to the next node \n        else { \n            curr2 = curr2->next; \n        } \n    } \n  \n    // Return the intersection node \n    return curr1->data; \n} // Function to get the intersection point \n// of the given linked lists \nint getIntersectionNode(Node* head1, Node* head2) \n{ \n    Node *curr1 = head1, *curr2 = head2; \n  \n    // While both the pointers are not equal \n    while (curr1 != curr2) { \n  \n        // If the first pointer is null then \n        // set it to point to the head of \n        // the second linked list \n        if (curr1 == NULL) { \n            curr1 = head2; \n        } \n  \n        // Else point it to the next node \n        else { \n            curr1 = curr1->next; \n        } \n  \n        // If the second pointer is null then \n        // set it to point to the head of \n        // the first linked list \n        if (curr2 == NULL) { \n            curr2 = head1; \n        } \n  \n        // Else point it to the next node \n        else { \n            curr2 = curr2->next; \n        } \n    } \n  \n    // Return the intersection node \n    return curr1->data; \n} // Function to get the intersection point // of the given linked lists int getIntersectionNode(Node* head1, Node* head2) int getIntersectionNode (Node* head1, Node* head2) // While both the pointers are not equal while // If the first pointer is null then // set it to point to the head of // the second linked list if NULL // Else point it to the next node else // If the second pointer is null then // set it to point to the head of // the first linked list if NULL // Else point it to the next node else // Return the intersection node return",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "24. Merge Two sorted Linked List",
        "answer": "Merge two sorted linked lists and return them as a sorted list. The list should be made by splicing together the nodes of the first two lists. Merging Two Sorted Linked List  Merging Two Sorted Linked List NodePtr merge_sorted(NodePtr head1, NodePtr head2) {\n  \n  // if both lists are empty then merged list is also empty\n  // if one of the lists is empty then other is the merged list\n  if (head1 == nullptr) {\n    return head2;\n  } else if (head2 == nullptr) {\n    return head1;\n  }\n\n\n  NodePtr mergedHead = nullptr;\n  if (head1->data <= head2->data) {\n    mergedHead = head1;\n    head1 = head1->next;\n  } else {\n    mergedHead = head2;\n    head2 = head2->next;\n  }\n\n  NodePtr mergedTail = mergedHead;\n  \n  while (head1 != nullptr && head2 != nullptr) {\n    NodePtr temp = nullptr;\n    if (head1->data <= head2->data) {\n      temp = head1;\n      head1 = head1->next;\n    } else {\n      temp = head2;\n      head2 = head2->next;\n    }\n\n    mergedTail->next = temp;\n    mergedTail = temp;\n  }\n\n  if (head1 != nullptr) {\n    mergedTail->next = head1;\n  } else if (head2 != nullptr) {\n    mergedTail->next = head2;\n  }\n\n  return mergedHead;\n} NodePtr merge_sorted(NodePtr head1, NodePtr head2) {\n  \n  // if both lists are empty then merged list is also empty\n  // if one of the lists is empty then other is the merged list\n  if (head1 == nullptr) {\n    return head2;\n  } else if (head2 == nullptr) {\n    return head1;\n  }\n\n\n  NodePtr mergedHead = nullptr;\n  if (head1->data <= head2->data) {\n    mergedHead = head1;\n    head1 = head1->next;\n  } else {\n    mergedHead = head2;\n    head2 = head2->next;\n  }\n\n  NodePtr mergedTail = mergedHead;\n  \n  while (head1 != nullptr && head2 != nullptr) {\n    NodePtr temp = nullptr;\n    if (head1->data <= head2->data) {\n      temp = head1;\n      head1 = head1->next;\n    } else {\n      temp = head2;\n      head2 = head2->next;\n    }\n\n    mergedTail->next = temp;\n    mergedTail = temp;\n  }\n\n  if (head1 != nullptr) {\n    mergedTail->next = head1;\n  } else if (head2 != nullptr) {\n    mergedTail->next = head2;\n  }\n\n  return mergedHead;\n} NodePtr merge_sorted(NodePtr head1, NodePtr head2) merge_sorted (NodePtr head1, NodePtr head2) // if both lists are empty then merged list is also empty // if one of the lists is empty then other is the merged list if nullptr return else if nullptr return nullptr if else while nullptr nullptr nullptr if else if nullptr else if nullptr return Runtime Complexity Linear, O(m + n) where m and n are lengths of both linked lists. Memory Complexity Constant, O(1) Maintain a head and a tail pointer on the merged linked list. Then choose the head of the merged linked list by comparing the first node of both linked lists. For all subsequent nodes in both lists, you choose the smaller current node and link it to the tail of the merged list, moving the current pointer of that list one step forward. You keep doing this while there are some remaining elements in both lists. If there are still some elements in only one of the lists, you link this remaining list to the tail of the merged list. Initially, the merged linked list is NULL. Compare the value of the first two nodes and make the node with the smaller value the head node of the merged linked list. In this example, it is 4 from head1. Since it’s the first and only node in the merged list, it will also be the tail. Then move head1 one step forward. Conclusion C is the foundational language from which practically all other languages are built. C is the programming language's base. For writing system applications, it is a very popular and frequently used language. Even if new languages have surpassed it in popularity, it remains one of the most popular programming languages. The C questions listed here will aid you in interviews as well as improve your learning. I hope you found these to be helpful! Additional Interview Resources C++ Interview Questions\nPractice Coding\nDifference Between C and C++\nDifference Between C and Java\nFeatures of C Language\nC Programming MCQs\nC IDE\nC Projects\nTechnical Interview Questions\nCoding Interview Questions C++ Interview Questions C++ Interview Questions Practice Coding Practice Coding Difference Between C and C++ Difference Between C and C++ Difference Between C and Java Difference Between C and Java Features of C Language Features of C Language C Programming MCQs C Programming MCQs C IDE C IDE C Projects C Projects Technical Interview Questions Technical Interview Questions Coding Interview Questions Coding Interview Questions",
        "reference": "interviewbit.com",
        "role": "c"
    },
    {
        "question": "1) What is C language?",
        "answer": "C is a mid-level and procedural programming language. The Procedural programming language is also known as the structured programming language is a technique in which large programs are broken down into smaller modules, and each module uses structured code. This technique minimizes error and misinterpretation. More details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "2) Why is C known as a mother language?",
        "answer": "C is known as a mother language because most of the compilers and JVMs are written in C language. Most of the languages which are developed after C language has borrowed heavily from it like C++, Python, Rust, javascript, etc. It introduces new core concepts like arrays, functions, file handling which are used in these languages. More details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "3) Why is C called a mid-level programming language?",
        "answer": "C is called a mid-level programming language because it binds the low level and high -level programming language. We can use C language as a System programming to develop the operating system as well as an Application programming to generate menu driven customer driven billing system. More details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "4) Who is the founder of C language?",
        "answer": "Dennis Ritchie. More details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "5) When was C language developed?",
        "answer": "C language was developed in 1972 at bell laboratories of AT&T. More details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "6) What are the features of the C language?",
        "answer": "The main features of C language are given below:\nADVERTISEMENT\nSimple: C is a simple language because it follows the structured approach, i.e., a program is broken into parts\nPortable: C is highly portable means that once the program is written can be run on any machine with little or no modifications.\nMid Level: C is a mid-level programming language as it combines the low- level language with the features of the high-level language.\nStructured: C is a structured language as the C program is broken into parts.\nFast Speed: C language is very fast as it uses a powerful set of data types and operators.\nMemory Management: C provides an inbuilt memory function that saves the memory and improves the efficiency of our program.\nExtensible: C is an extensible language as it can adopt new features in the future.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "7) What is the use of printf() and scanf() functions?",
        "answer": "printf(): The printf() function is used to print the integer, character, float and string values on to the screen.\nFollowing are the format specifier:\n%d: It is a format specifier used to print an integer value.\n%s: It is a format specifier used to print a string.\n%c: It is a format specifier used to display a character value.\n%f: It is a format specifier used to display a floating point value.\nscanf(): The scanf() function is used to take input from the user.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "8) What is the difference between the local variable and global variable in C?",
        "answer": "Following are the differences between a local variable and global variable:\nBasis for comparison Local variable Global variable\nDeclaration A variable which is declared inside function or block is known as a local variable. A variable which is declared outside function or block is known as a global variable.\nScope The scope of a variable is available within a function in which they are declared. The scope of a variable is available throughout the program.\nAccess Variables can be accessed only by those statements inside a function in which they are declared. Any statement in the entire program can access variables.\nLife Life of a variable is created when the function block is entered and destroyed on its exit. Life of a variable exists until the program is executing.\nStorage Variables are stored in a stack unless specified. The compiler decides the storage location of a variable.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "9) What is the use of a static variable in C?",
        "answer": "Following are the uses of a static variable:\nA variable which is declared as static is known as a static variable. The static variable retains its value between multiple function calls.\nStatic variables are used because the scope of the static variable is available in the entire program. So, we can access a static variable anywhere in the program.\nThe static variable is initially initialized to zero. If we update the value of a variable, then the updated value is assigned.\nThe static variable is used as a common value which is shared by all the methods.\nThe static variable is initialized only once in the memory heap to reduce the memory usage.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "10) What is the use of the function in C?",
        "answer": "Uses of C function are:\nC functions are used to avoid the rewriting the same code again and again in our program.\nC functions can be called any number of times from any place of our program.\nWhen a program is divided into functions, then any part of our program can easily be tracked.\nC functions provide the reusability concept, i.e., it breaks the big task into smaller tasks so that it makes the C program more understandable.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "11) What is the difference between call by value and call by reference in C?",
        "answer": "Following are the differences between a call by value and call by reference are:\nCall by value Call by reference\nDescription When a copy of the value is passed to the function, then the original value is not modified. When a copy of the value is passed to the function, then the original value is modified.\nMemory location Actual arguments and formal arguments are created in separate memory locations. Actual arguments and formal arguments are created in the same memory location.\nSafety In this case, actual arguments remain safe as they cannot be modified. In this case, actual arguments are not reliable, as they are modified.\nArguments The copies of the actual arguments are passed to the formal arguments. The addresses of actual arguments are passed to their respective formal arguments.\nExample of call by value:\n#include <stdio.h>  \nvoid change(int,int);  \nint main()  \n{  \n    int a=10,b=20;  \n    change(a,b); //calling a function by passing the values of variables.  \n    printf(\"Value of a is: %d\",a);  \n    printf(\"\\n\");  \n    printf(\"Value of b is: %d\",b);  \n    return 0;  \n}  \nvoid change(int x,int y)  \n{  \n    x=13;  \n    y=17;  \n}  \nOutput:\nValue of a is: 10\nValue of b is: 20\nExample of call by reference:\n#include <stdio.h>  \nvoid change(int*,int*);  \nint main()  \n{  \n    int a=10,b=20;  \n    change(&a,&b); // calling a function by passing references of variables.  \n    printf(\"Value of a is: %d\",a);  \n    printf(\"\\n\");  \n    printf(\"Value of b is: %d\",b);  \n    return 0;  \n}  \nvoid change(int *x,int *y)  \n{  \n    *x=13;  \n    *y=17;  \n}  \nOutput:\nValue of a is: 13\nValue of b is: 17\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "12) What is recursion in C?",
        "answer": "When a function calls itself, and this process is known as recursion. The function that calls itself is known as a recursive function.\nRecursive function comes in two phases:\nWinding phase\nUnwinding phase\nWinding phase: When the recursive function calls itself, and this phase ends when the condition is reached.\n\nUnwinding phase: Unwinding phase starts when the condition is reached, and the control returns to the original call.\nExample of recursion\n#include <stdio.h>  \nint calculate_fact(int);  \nint main()  \n{  \n int n=5,f;  \n f=calculate_fact(n); // calling a function  \n printf(\"factorial of a number is %d\",f);  \n  return 0;  \n}  \nint calculate_fact(int a)  \n{  \n  if(a==1)  \n  {  \n      return 1;  \n  }  \n  else  \n  return a*calculate_fact(a-1); //calling a function recursively.  \n   }  \nOutput:\nfactorial of a number is 120\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "13) What is an array in C?",
        "answer": "An Array is a group of similar types of elements. It has a contiguous memory location. It makes the code optimized, easy to traverse and easy to sort. The size and type of arrays cannot be changed after its declaration.\nArrays are of two types:\nOne-dimensional array: One-dimensional array is an array that stores the elements one after the another.\n\nSyntax:\ndata_type array_name[size];  \nMultidimensional array: Multidimensional array is an array that contains more than one array.\nSyntax:\ndata_type array_name[size];  \nExample of an array:\n#include <stdio.h>  \nint main()  \n{  \n   int arr[5]={1,2,3,4,5}; //an array consists of five integer values.  \n   for(int i=0;i<5;i++)  \n   {  \n       printf(\"%d \",arr[i]);  \n   }  \n    return 0;  \n}  \nOutput:\n1 2 3 4 5\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "14) What is a pointer in C?",
        "answer": "A pointer is a variable that refers to the address of a value. It makes the code optimized and makes the performance fast. Whenever a variable is declared inside a program, then the system allocates some memory to a variable. The memory contains some address number. The variables that hold this address number is known as the pointer variable.\nFor example:\nData_type *p;  \nThe above syntax tells that p is a pointer variable that holds the address number of a given data type value.\nExample of pointer\n#include <stdio.h>  \nint main()  \n{  \n   int *p; //pointer of type integer.  \n   int a=5;  \n   p=&a;  \n   printf(\"Address value of 'a' variable is %u\",p);  \n    return 0;  \n}  \nOutput:\nAddress value of 'a' variable is 428781252\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "15) What is the usage of the pointer in C?",
        "answer": "Accessing array elements: Pointers are used in traversing through an array of integers and strings. The string is an array of characters which is terminated by a null character '\\0'.\nDynamic memory allocation: Pointers are used in allocation and deallocation of memory during the execution of a program.\nCall by Reference: The pointers are used to pass a reference of a variable to other function.\nData Structures like a tree, graph, linked list, etc.: The pointers are used to construct different data structures like tree, graph, linked list, etc.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "16) What is a NULL pointer in C?",
        "answer": "A pointer that doesn't refer to any address of value but NULL is known as a NULL pointer. When we assign a '0' value to a pointer of any type, then it becomes a Null pointer.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "17) What is a far pointer in C?",
        "answer": "A pointer which can access all the 16 segments (whole residence memory) of RAM is known as far pointer. A far pointer is a 32-bit pointer that obtains information outside the memory in a given section.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "18) What is dangling pointer in C?",
        "answer": "If a pointer is pointing any memory location, but meanwhile another pointer deletes the memory occupied by the first pointer while the first pointer still points to that memory location, the first pointer will be known as a dangling pointer. This problem is known as a dangling pointer problem.\nDangling pointer arises when an object is deleted without modifying the value of the pointer. The pointer points to the deallocated memory.\nLet's see this through an example.\n#include<stdio.h>  \nvoid main()  \n{  \n        int *ptr = malloc(constant value); //allocating a memory space.  \n        free(ptr); //ptr becomes a dangling pointer.  \n}  \nIn the above example, initially memory is allocated to the pointer variable ptr, and then the memory is deallocated from the pointer variable. Now, pointer variable, i.e., ptr becomes a dangling pointer.\nHow to overcome the problem of a dangling pointer\nThe problem of a dangling pointer can be overcome by assigning a NULL value to the dangling pointer. Let's understand this through an example:\n#include<stdio.h>  \n      void main()  \n      {  \n              int *ptr = malloc(constant value); //allocating a memory space.  \n              free(ptr); //ptr becomes a dangling pointer.  \n              ptr=NULL; //Now, ptr is no longer a dangling pointer.  \n      }  \nIn the above example, after deallocating the memory from a pointer variable, ptr is assigned to a NULL value. This means that ptr does not point to any memory location. Therefore, it is no longer a dangling pointer.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "19) What is pointer to pointer in C?",
        "answer": "In case of a pointer to pointer concept, one pointer refers to the address of another pointer. The pointer to pointer is a chain of pointers. Generally, the pointer contains the address of a variable. The pointer to pointer contains the address of a first pointer. Let's understand this concept through an example:\n#include <stdio.h>  \n int main()  \n{  \n    int a=10;  \n    int *ptr,**pptr; // *ptr is a pointer and **pptr is a double pointer.  \n    ptr=&a;  \n    pptr=&ptr;  \n    printf(\"value of a is:%d\",a);  \n    printf(\"\\n\");  \n    printf(\"value of *ptr is : %d\",*ptr);  \n    printf(\"\\n\");  \n    printf(\"value of **pptr is : %d\",**pptr);  \n    return 0;  \n}  \nIn the above example, pptr is a double pointer pointing to the address of the ptr variable and ptr points to the address of 'a' variable.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "20) What is static memory allocation?",
        "answer": "In case of static memory allocation, memory is allocated at compile time, and memory can't be increased while executing the program. It is used in the array.\nThe lifetime of a variable in static memory is the lifetime of a program.\nThe static memory is allocated using static keyword.\nThe static memory is implemented using stacks or heap.\nThe pointer is required to access the variable present in the static memory.\nThe static memory is faster than dynamic memory.\nIn static memory, more memory space is required to store the variable.\nFor example:  \nint a[10];  \nThe above example creates an array of integer type, and the size of an array is fixed, i.e., 10.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "21) What is dynamic memory allocation?",
        "answer": "In case of dynamic memory allocation, memory is allocated at runtime and memory can be increased while executing the program. It is used in the linked list.\nThe malloc() or calloc() function is required to allocate the memory at the runtime.\nAn allocation or deallocation of memory is done at the execution time of a program.\nNo dynamic pointers are required to access the memory.\nThe dynamic memory is implemented using data segments.\nLess memory space is required to store the variable.\nFor example  \nint *p= malloc(sizeof(int)*10);  \nThe above example allocates the memory at runtime.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "22) What functions are used for dynamic memory allocation in C language?",
        "answer": "malloc()\nThe malloc() function is used to allocate the memory during the execution of the program.\nIt does not initialize the memory but carries the garbage value.\nIt returns a null pointer if it could not be able to allocate the requested space.\nSyntax\nptr = (cast-type*) malloc(byte-size) // allocating the memory using malloc() function.  \ncalloc()\nThe calloc() is same as malloc() function, but the difference only is that it initializes the memory with zero value.\nSyntax\nptr = (cast-type*)calloc(n, element-size);// allocating the memory using calloc() function.  \nrealloc()\nThe realloc() function is used to reallocate the memory to the new size.\nIf sufficient space is not available in the memory, then the new block is allocated to accommodate the existing data.\nSyntax\nptr = realloc(ptr, newsize); // updating the memory size using realloc() function.  \nIn the above syntax, ptr is allocated to a new size.\nfree():The free() function releases the memory allocated by either calloc() or malloc() function.\nSyntax\nfree(ptr); // memory is released using free() function.  \nThe above syntax releases the memory from a pointer variable ptr.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "23) What is the difference between malloc() and calloc()?",
        "answer": "calloc() malloc()\nDescription The malloc() function allocates a single block of requested memory. The calloc() function allocates multiple blocks of requested memory.\nInitialization It initializes the content of the memory to zero. It does not initialize the content of memory, so it carries the garbage value.\nNumber of arguments It consists of two arguments. It consists of only one argument.\nReturn value It returns a pointer pointing to the allocated memory. It returns a pointer pointing to the allocated memory.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "24) What is the structure?",
        "answer": "The structure is a user-defined data type that allows storing multiple types of data in a single unit. It occupies the sum of the memory of all members.\nThe structure members can be accessed only through structure variables.\nStructure variables accessing the same structure but the memory allocated for each variable will be different.\nSyntax of structure\nstruct structure_name  \n{  \n  Member_variable1;  \n Member_variable2  \n.  \n.  \n}[structure variables];  \nLet's see a simple example.\n#include <stdio.h>  \nstruct student  \n{  \n    char name[10];       // structure members declaration.  \n    int age;  \n}s1;      //structure variable  \nint main()  \n{  \n    printf(\"Enter the name\");  \n    scanf(\"%s\",s1.name);  \n    printf(\"\\n\");  \n    printf(\"Enter the age\");  \n    scanf(\"%d\",&s1.age);  \n    printf(\"\\n\");  \n    printf(\"Name and age of a student: %s,%d\",s1.name,s1.age);  \n    return 0;  \n}  \nOutput:\nEnter the name shikha\nEnter the age 26\nName and age of a student: shikha,26  \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "25) What is a union?",
        "answer": "The union is a user-defined data type that allows storing multiple types of data in a single unit. However, it doesn't occupy the sum of the memory of all members. It holds the memory of the largest member only.\nIn union, we can access only one variable at a time as it allocates one common space for all the members of a union.\nSyntax of union\nunion union_name  \n{  \nMember_variable1;  \nMember_variable2;  \n.  \n.  \nMember_variable n;  \n}[union variables];  \nLet's see a simple example\n#include<stdio.h>  \nunion data  \n{  \n    int a;      //union members declaration.  \n    float b;  \n    char ch;  \n};  \nint main()  \n{  \n  union data d;       //union variable.  \n  d.a=3;  \n  d.b=5.6;  \n  d.ch='a';  \n  printf(\"value of a is %d\",d.a);  \n  printf(\"\\n\");  \n  printf(\"value of b is %f\",d.b);  \n  printf(\"\\n\");  \n  printf(\"value of ch is %c\",d.ch);  \n  return 0;  \n}  \nOutput:\nvalue of a is 1085485921\nvalue of b is 5.600022\nvalue of ch is a\nIn the above example, the value of a and b gets corrupted, and only variable ch shows the actual output. This is because all the members of a union share the common memory space. Hence, the variable ch whose value is currently updated.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "26) What is an auto keyword in C?",
        "answer": "In C, every local variable of a function is known as an automatic (auto) variable. Variables which are declared inside the function block are known as a local variable. The local variables are also known as an auto variable. It is optional to use an auto keyword before the data type of a variable. If no value is stored in the local variable, then it consists of a garbage value.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "27) What is the purpose of sprintf() function?",
        "answer": "The sprintf() stands for \"string print.\" The sprintf() function does not print the output on the console screen. It transfers the data to the buffer. It returns the total number of characters present in the string.\nSyntax\nint sprintf ( char * str, const char * format, ... );  \nLet's see a simple example\n #include<stdio.h>  \nint main()  \n{  \n char a[20];  \n int n=sprintf(a,\"javaToint\");  \n printf(\"value of n is %d\",n);  \n return 0;}  \nOutput:\nvalue of n is 9",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "28) Can we compile a program without main() function?",
        "answer": "Yes, we can compile, but it can't be executed.\nBut, if we use #define, we can compile and run a C program without using the main() function. For example:\n#include<stdio.h>    \n#define start main    \nvoid start() {    \n   printf(\"Hello\");    \n}    \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "29) What is a token?",
        "answer": "The Token is an identifier. It can be constant, keyword, string literal, etc. A token is the smallest individual unit in a program. C has the following tokens:\nIdentifiers: Identifiers refer to the name of the variables.\nKeywords: Keywords are the predefined words that are explained by the compiler.\nConstants: Constants are the fixed values that cannot be changed during the execution of a program.\nOperators: An operator is a symbol that performs the particular operation.\nSpecial characters: All the characters except alphabets and digits are treated as special characters.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "30) What is command line argument?",
        "answer": "The argument passed to the main() function while executing the program is known as command line argument. For example:\nmain(int count, char *args[]){  \n//code to  be executed  \n}",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "31) What is the acronym for ANSI?",
        "answer": "The ANSI stands for \" American National Standard Institute.\" It is an organization that maintains the broad range of disciplines including photographic film, computer languages, data encoding, mechanical parts, safety and more.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "32) What is the difference between getch() and getche()?",
        "answer": "The getch() function reads a single character from the keyboard. It doesn't use any buffer, so entered data will not be displayed on the output screen.\nThe getche() function reads a single character from the keyword, but data is displayed on the output screen. Press Alt+f5 to see the entered character.\nLet's see a simple example\n#include<stdio.h>  \n#include<conio.h>  \nint main()  \n{  \n       char ch;  \n printf(\"Enter a character \");  \n ch=getch(); // taking an user input without printing the value.  \n printf(\"\\nvalue of ch is %c\",ch);  \n printf(\"\\nEnter a character again \");  \n ch=getche(); // taking an user input and then displaying it on the screen.  \n  printf(\"\\nvalue of ch is %c\",ch);  \n return 0;  \n}  \nOutput:\nEnter a character\nvalue of ch is a\nEnter a character again a\nvalue of ch is a\nIn the above example, the value entered through a getch() function is not displayed on the screen while the value entered through a getche() function is displayed on the screen.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "33) What is the newline escape sequence?",
        "answer": "The new line escape sequence is represented by \"\\n\". It inserts a new line on the output screen.\nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "34) Who is the main contributor in designing the C language after Dennis Ritchie?",
        "answer": "Brain Kernighan.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "35) What is the difference between near, far and huge pointers?",
        "answer": "A virtual address is composed of the selector and offset.\nA near pointer doesn't have explicit selector whereas far, and huge pointers have explicit selector. When you perform pointer arithmetic on the far pointer, the selector is not modified, but in case of a huge pointer, it can be modified.\nThese are the non-standard keywords and implementation specific. These are irrelevant in a modern platform.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "36) What is the maximum length of an identifier?",
        "answer": "It is 32 characters ideally but implementation specific.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "37) What is typecasting?",
        "answer": "The typecasting is a process of converting one data type into another is known as typecasting. If we want to store the floating type value to an int type, then we will convert the data type into another data type explicitly.\nSyntax\n(type_name) expression;",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "38) What are the functions to open and close the file in C language?",
        "answer": "The fopen() function is used to open file whereas fclose() is used to close file.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "39) Can we access the array using a pointer in C language?",
        "answer": "Yes, by holding the base address of array into a pointer, we can access the array using a pointer.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "40) What is an infinite loop?",
        "answer": "A loop running continuously for an indefinite number of times is called the infinite loop.\nInfinite For Loop:\nfor(;;){  \n//code to be executed  \n}  \nInfinite While Loop:\nwhile(1){  \n//code to be executed  \n}  \nInfinite Do-While Loop:\ndo{  \n//code to be executed  \n}while(1);",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "41) Write a program to print \"hello world\" without using a semicolon?",
        "answer": "#include<stdio.h>      \nvoid main(){      \n if(printf(\"hello world\")){} // It prints the ?hello world? on the screen.  \n}     \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "42) Write a program to swap two numbers without using the third variable?",
        "answer": "#include<stdio.h>      \n#include<conio.h>      \nmain()      \n{      \nint a=10, b=20;    //declaration of variables.  \nclrscr();        //It clears the screen.  \nprintf(\"Before swap a=%d b=%d\",a,b);        \n      a=a+b;//a=30 (10+20)       \nb=a-b;//b=10 (30-20)      \na=a-b;//a=20 (30-10)      \n      printf(\"\\nAfter swap a=%d b=%d\",a,b);      \ngetch();      \n}  \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "43) Write a program to print Fibonacci series without using recursion?",
        "answer": "#include<stdio.h>    \n#include<conio.h>    \nvoid main()    \n{    \n int n1=0,n2=1,n3,i,number;    \n clrscr();    \n printf(\"Enter the number of elements:\");    \n scanf(\"%d\",&number);    \n printf(\"\\n%d %d\",n1,n2);//printing 0 and 1    \n     for(i=2;i<number;++i)//loop starts from 2 because 0 and 1 are already printed    \n {    \n  n3=n1+n2;    \n  printf(\" %d\",n3);    \n  n1=n2;    \n  n2=n3;    \n }    \ngetch();    \n}    \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "44) Write a program to print Fibonacci series using recursion?",
        "answer": "#include<stdio.h>      \n#include<conio.h>      \nvoid printFibonacci(int n) // function to calculate the fibonacci series of a given number.  \n{      \nstatic int n1=0,n2=1,n3;    // declaration of static variables.  \n    if(n>0){      \n         n3 = n1 + n2;      \n         n1 = n2;      \n        n2 = n3;      \n         printf(\"%d \",n3);      \n         printFibonacci(n-1);    //calling the function recursively.  \n    }      \n}      \nvoid main(){      \n    int n;      \n    clrscr();      \n    printf(\"Enter the number of elements: \");      \n    scanf(\"%d\",&n);      \n    printf(\"Fibonacci Series: \");      \n    printf(\"%d %d \",0,1);      \n    printFibonacci(n-2);//n-2 because 2 numbers are already printed      \n    getch();      \n}      \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "45) Write a program to check prime number in C Programming?",
        "answer": "#include<stdio.h>      \n#include<conio.h>      \nvoid main()      \n{      \nint n,i,m=0,flag=0;    //declaration of variables.  \nclrscr();    //It clears the screen.  \nprintf(\"Enter the number to check prime:\");      \nscanf(\"%d\",&n);      \nm=n/2;      \nfor(i=2;i<=m;i++)      \n{      \nif(n%i==0)      \n{      \nprintf(\"Number is not prime\");      \nflag=1;      \nbreak;    //break keyword used to terminate from the loop.  \n}      \n}      \nif(flag==0)      \nprintf(\"Number is prime\");      \ngetch();    //It reads a character from the keyword.  \n}  \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "46) Write a program to check palindrome number in C Programming?",
        "answer": "#include<stdio.h>    \n#include<conio.h>    \nmain()    \n{    \nint n,r,sum=0,temp;    \nclrscr();    \nprintf(\"enter the number=\");    \nscanf(\"%d\",&n);    \ntemp=n;    \nwhile(n>0)    \n{    \nr=n%10;    \nsum=(sum*10)+r;    \nn=n/10;    \n}    \nif(temp==sum)    \nprintf(\"palindrome number \");    \nelse    \nprintf(\"not palindrome\");    \ngetch();    \n}    \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "47) Write a program to print factorial of given number without using recursion?",
        "answer": "#include<stdio.h>    \n#include<conio.h>    \nvoid main(){    \n  int i,fact=1,number;    \n  clrscr();    \n  printf(\"Enter a number: \");    \n  scanf(\"%d\",&number);    \n      for(i=1;i<=number;i++){    \n      fact=fact*i;    \n  }    \n  printf(\"Factorial of %d is: %d\",number,fact);    \n  getch();    \n}    \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "48) Write a program to print factorial of given number using recursion?",
        "answer": "#include<stdio.h>      \n#include<conio.h>      \n long factorial(int n)    // function to calculate the factorial of a given number.   \n{      \n  if (n == 0)      \n    return 1;      \nelse      \nreturn(n * factorial(n-1));    //calling the function recursively.  \n}      \n void main()      \n{      \n  int number;    //declaration of variables.  \n  long fact;      \n clrscr();      \n  printf(\"Enter a number: \");      \nscanf(\"%d\", &number);       \n fact = factorial(number);    //calling a function.  \nprintf(\"Factorial of %d is %ld\\n\", number, fact);      \n getch();   //It reads a character from the keyword.   \n}  \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    },
    {
        "question": "49) Write a program to check Armstrong number in C?",
        "answer": "#include<stdio.h>      \n#include<conio.h>      \nmain()      \n{      \nint n,r,sum=0,temp;    //declaration of variables.  \nclrscr(); //It clears the screen.     \nprintf(\"enter the number=\");      \nscanf(\"%d\",&n);      \ntemp=n;      \nwhile(n>0)      \n{      \nr=n%10;      \nsum=sum+(r*r*r);      \nn=n/10;      \n}      \nif(temp==sum)      \nprintf(\"armstrong  number \");      \nelse      \nprintf(\"not armstrong number\");      \ngetch();  //It reads a character from the keyword.  \n}    \nMore details.",
        "reference": "javatpoint.com",
        "role": "c"
    }
]