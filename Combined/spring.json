[
    {
        "question": "1. What is Spring?",
        "answer": "Spring is an open-source development framework for enterprise Java. The core features of the Spring Framework can be used in developing any Java application, but there are extensions for building web applications on top of the Java EE platform. Spring Framework targets to make Java EE development easier to use and promotes good programming practices by enabling a POJO-based programming model.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "2. What are Spring beans?",
        "answer": "The objects that form the backbone of the users’ application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. These beans are created with the configuration metadata that the users supply to the container.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "3. Define AOP in Spring.",
        "answer": "AOP stands for Aspect-Oriented Programming. It is a programming technique that increases modularity by allowing the separation of cross-cutting concerns, like logging and transaction management, from the application’s business logic. With AOP, aspects are configured in separate files and can add functionality to multiple classes without changing the classes themselves.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "4. What is the Spring Boot Actuator?",
        "answer": "Spring Boot Actuator is a tool that helps monitor and manage a Spring Boot application. It provides endpoints or web URLs to get information about the app like health, metrics, info, etc. It helps debug issues and understand how the app is running.\nAlso, check our guide on Spring boot interview questions which are specifically developed for boot frameworks.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "5. Explain Dependency Injection (DI) in Spring.",
        "answer": "Dependency Injection (DI) is a design pattern used in Spring where dependencies like services or repositories are provided to a class instead of the class creating them itself. Spring has a container that creates and wires dependencies and injects them into classes that need them. This makes it easier to manage dependencies between classes.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "6. What do you mean by Bean Wiring?",
        "answer": "Bean wiring refers to how Spring connects or wires together the application’s beans and their dependencies. It involves defining the relationships between the beans in the Spring configuration file. Spring handles the process of satisfying the dependencies of each bean by injecting other required beans into it. This wiring allows the beans to work together seamlessly.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "7. What is a Spring Java-based configuration?",
        "answer": "Java-based configuration option enables users to write most of their Spring configuration without XML but with the help of a few Java-based annotations.\nExample:\nAnnotation @Configuration indicates that the class can be used by the Spring IoC container as a source of bean definitions. The @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "8. Describe the Spring Framework.",
        "answer": "The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications—on any kind of deployment platform. A key element of Spring is infrastructural support at the application level: Spring focuses on the ‘plumbing’ of enterprise applications so that teams can focus on the application-level business logic, without having unnecessary ties to specific deployment environments.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "9. What is a Spring IoC container?",
        "answer": "Spring IoC creates objects, wires them together, configures them, and manages their complete life cycle from creation to destruction. The Spring container uses Dependency Injection (DI) to manage the components that make up an application.\nPrepare yourself for the Java Certification with this comprehensive Java Course!",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "10. What is the purpose of the @Autowired annotation?",
        "answer": "The @Autowired annotation is used in Spring to automatically inject dependencies into a class. When Spring sees the @Autowired annotation on a field, constructor, or method, it will lookup a bean of the required type from the Spring container and inject it. This removes the need to manually lookup dependencies and wire them together.\n\nIntermediate Spring Interview Questions",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "11. What are the types of dependency injections that Spring supports?",
        "answer": "Spring supports two types of dependency injections:\nSetter Injection:\nSetter-based DI is realized by calling setter methods on the user’s beans after invoking a no-argument constructor or no-argument static factory method to instantiate their bean.\nConstructor Injection:\nConstructor-based DI is realized by invoking a constructor with several arguments, each representing a collaborator.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "12. What is the difference between BeanFactory and ApplicationContext?",
        "answer": "BeanFactory is the most basic type of Spring container. It manages the basic lifecycle of beans, like creating, configuring, and destroying them. ApplicationContext includes everything that BeanFactory can do plus some extra features like globalization support, validation, and data binding. It is also capable of application-level functions like resource and event handling.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "13. What is the difference between constructor injunction and setter injection?",
        "answer": "Constructor injection involves passing dependencies through a class’s constructor, ensuring they are set when an object is created. On the other hand, setter injection involves setting dependencies using setter methods after the object is created. Constructor injection ensures that required dependencies are available from the start, while setter injection allows for flexibility in changing dependencies later on.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "14. What is the difference between Spring and Spring Boot?",
        "answer": "Spring is a framework for building Java applications. It provides features like dependency injection. Spring Boot makes creating Spring apps easy, and it handles configuration so you don’t have to. Spring Boot also helps you get started quickly and includes useful tools like checking app health and metrics right away, so your app is ready for production use.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "15. What is the difference between singleton and prototype scope in Spring?",
        "answer": "In Spring, the singleton scope creates a single bean instance for the entire application, and the prototype scope creates a new instance every time the bean is requested. Singleton is suitable for stateless beans, while the prototype is useful when you need a fresh instance for each request.\nCheck out this Spring Tutorial video:",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "16. Mention the modules of the Spring Framework.",
        "answer": "The basic modules of the Spring Framework are:\nCore module\nBean module\nContext module\nExpression Language module\nJDBC module\nORM module\nOXM module\nJava Message Service (JMS) module\nTransaction module\nWeb module\nWeb-Servlet module\nWeb-Struts module\nWeb-Portlet module",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "17. What bean scopes does Spring support? Explain them.",
        "answer": "The Spring Framework supports five scopes, three of which are available only if users use a web-aware ApplicationContext.\nSingleton: This scopes the bean definition to a single instance per Spring IoC container.\nPrototype: This scopes a single bean definition to have any number of object instances.\nRequest: This scopes a bean definition to an HTTP request, only valid in the context of a web-aware Spring ApplicationContext.\nSession: This scopes a bean definition to an HTTP session, only valid in the context of a web-aware Spring ApplicationContext.\nGlobal-session: This scopes a bean definition to a global HTTP session, only valid in the context of a web-aware Spring ApplicationContext.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "18. Explain autowiring and name the different modes of it.",
        "answer": "Autowiring in programming automates the process of connecting components in a system. It eliminates the need to manually wire dependencies. The different modes of autowiring include “no autowiring” (default), “byType” (matching data types), “byName” (matching bean names), “constructor” (constructor-based injection), and “autodetect” (combines byType and byName based on the scenario).",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "19. What is the purpose of the @RequestMapping annotation?",
        "answer": "The @RequestMapping annotation in Spring is used to map web requests to specific controller methods. It defines the URL patterns that trigger these methods, allowing developers to create clean and organized mappings between incoming requests and corresponding handler methods in their Spring MVC applications.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "20. Explain the purpose of the @Value annotation in Spring.",
        "answer": "The @Value annotation in Spring is used to inject values from properties files, environment variables, or other sources into Spring Beans. It simplifies configuration by allowing developers to externalize and customize values without modifying code, which promotes flexibility in managing application properties.\n\nAdvanced Spring Interview Questions for Experienced",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "21. Describe the Spring MVC architecture.",
        "answer": "The Spring MVC architecture is a design pattern for building web applications. It consists of three main components:\nModel, which represents the data and business logic\nView, responsible for displaying information to users\nController, which handles user requests, processes them using the Model, and updates the View\nThis separation of concerns promotes modularity and makes it easier to maintain and scale web applications built with Spring MVC.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "22. Explain the concept of Inversion of Control (IoC).",
        "answer": "Inversion of Control (IoC) is a design principle where objects do not create other objects they depend on. Instead, these dependencies are provided to the objects externally by a third party, called the Inversion of Control container. This container manages the lifecycle and configuration of objects. It injects dependencies when an object is initialized.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "23. How does Spring support RESTful web services?",
        "answer": "Spring makes it very easy to create RESTful web APIs. It provides annotations to develop the controller layer that handles web requests and responses. Annotations like @RestController and @RequestMapping are used to map URLs to controller methods. @RequestBody annotation allows accessing request body parameters, and @ResponseBody returns data directly in the response body. Overall, Spring handles all the plumbing work so developers can focus on business logic rather than low-level implementation details of REST.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "24. What is the role of the Hibernate framework in Spring?",
        "answer": "Hibernate is an Object-Relational Mapping (ORM) framework that allows mapping Java objects to database tables. When used with Spring, Hibernate handles all data access operations with the database. Spring provides Hibernate integration through the Hibernate Template and SessionFactory utilities. It manages Hibernate sessions and transactions behind the scenes. This allows developers to write data access code without dealing with raw JDBC or Hibernate API calls.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "25. How does Spring support internationalization (i18n)?",
        "answer": "Spring supports internationalization (i18n) by providing a mechanism to develop applications that can be easily adapted for different languages and regions. It uses a concept called MessageSource, where you store messages in various languages. Developers can then use these messages in the code by referring to keys. This helps in building more inclusive and globally accessible software.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "26. What do you understand by MultipartResolver?",
        "answer": "In Spring, a MultipartResolver is a component that helps handle file uploads in web applications. It deals with requests that include files, like images or documents. The resolver parses the incoming request, identifies the uploaded files, and provides an easy-to-use interface for developers to work with these files in their Spring application. It simplifies the handling of multiple requests, making it convenient for developers to manage file uploads seamlessly in their web applications.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "27. Is thread safety guaranteed for singleton beans?",
        "answer": "Singleton beans in Spring are not thread-safe by default. As they will be shared across the application, concurrent access from multiple threads can cause unexpected behavior if the bean’s state is not synchronized properly. The singleton bean itself is thread-safe, but any mutable state within it may not be. It is the developer’s responsibility to ensure thread safety at the class level if the singleton bean maintains any mutable state. Making the singleton class thread-safe or avoiding mutable states are some ways to achieve thread safety for singleton beans in Spring.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "28. Explain the bean life cycle in Spring Framework.",
        "answer": "The following is the sequence of a bean life cycle in Spring:\nInstantiate: First, the Spring container finds the bean’s definition from the XML file and instantiates the bean.\nPopulate Properties: Using the dependency injection, Spring populates all of the properties as specified in the bean definition.\nSet Bean Name: If the bean implements the BeanNameAware interface, then Spring passes the bean’s ID to the setBeanName() method.\nSet Bean Factory: If the bean implements the BeanFactoryAware interface, then Spring passes the bean factory to the setBeanFactory() method.\nPre-initialization: It is also called the post-process of the bean. If there are any BeanPostProcessors associated with the bean, then Spring calls the postProcesserBeforeInitialization() method.\nInitialize Beans: If the bean implements IntializingBean, its afterPropertySet() method is called. If the bean has the init method declaration, the specified initialization method is called.\nPost Initialization: If there are any BeanPostProcessors associated with the bean, their postProcessAfterInitialization() methods will be called.\nReady to Use: Now, the bean is ready to be used by the application.\nDestroy: If the bean implements DisposableBean, it will call the destroy() method.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "29. What are the features of Spring?",
        "answer": "The features of Spring are mentioned below:\nLightweight: Spring is lightweight when it comes to size and transparency. The basic version of the Spring Framework is around 1 MB. Besides, the processing overhead is also very negligible.\nInversion of Control (IoC): Loose coupling is achieved in Spring using the technique of inversion of control. The objects give their dependencies instead of creating or looking for dependent objects.\nAspect-Oriented Programming (AOP): Spring supports aspect-oriented programming and enables cohesive development by separating the application business logic from system services.\nContainer: Spring contains and manages the life cycle and configuration of application objects.\nMVC Framework: Spring comes with an MVC web application framework built on the core Spring functionality. This framework is highly configurable via strategy interfaces and accommodates multiple view technologies such as JSP, Velocity, Tiles, iText, and POI. However, other frameworks can be easily used instead of Spring MVC Framework.\nJDBC Exception Handling: The JDBC abstraction layer of Spring offers a meaningful exception hierarchy, which simplifies the error-handling strategy.\nIntegration: Spring provides the best integration services with Hibernate, JDO, and iBATIS.\nTransaction Management: Spring Framework provides a generic abstraction layer for transaction management. This allows the developer to add pluggable transaction managers and makes it easy to demarcate transactions without dealing with low-level issues. Spring’s transaction support is not tied to J2EE environments, and it can also be used in container-less environments.",
        "reference": "intellipaat.com",
        "role": "spring"
    },
    {
        "question": "1. What are the bean scopes available in Spring?",
        "answer": "The Spring Framework has five scope supports. They are: Singleton: The scope of bean definition while using this would be a single instance per IoC container.\nPrototype: Here, the scope for a single bean definition can be any number of object instances.\nRequest: The scope of the bean definition is an HTTP request.\nSession: Here, the scope of the bean definition is HTTP-session.\nGlobal-session: The scope of the bean definition here is a Global HTTP session. Singleton: The scope of bean definition while using this would be a single instance per IoC container. Singleton: Prototype: Here, the scope for a single bean definition can be any number of object instances. Prototype: Request: The scope of the bean definition is an HTTP request. Request: Session: Here, the scope of the bean definition is HTTP-session. Session: Global-session: The scope of the bean definition here is a Global HTTP session. Global-session: Note: The last three scopes are available only if the users use web-aware ApplicationContext containers.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "2. What are the limitations of autowiring?",
        "answer": "Overriding possibility: Dependencies are specified using <constructor-arg> and <property>  settings that override autowiring.\nData types restriction: Primitive data types, Strings, and Classes can’t be autowired. Overriding possibility: Dependencies are specified using <constructor-arg> and <property>  settings that override autowiring. Overriding possibility <constructor-arg> <property> Data types restriction: Primitive data types, Strings, and Classes can’t be autowired. Data types restriction",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "3. What is autowiring and name the different modes of it?",
        "answer": "The IoC container autowires relationships between the application beans. Spring lets collaborators resolve which bean has to be wired automatically by inspecting the contents of the BeanFactory.\nDifferent modes of this process are:  no: This means no autowiring and is the default setting. An explicit bean reference should be used for wiring.\nbyName: The bean dependency is injected according to the name of the bean. This matches and wires its properties with the beans defined by the same names as per the configuration.\nbyType: This injects the bean dependency based on type.\nconstructor: Here, it injects the bean dependency by calling the constructor of the class. It has a large number of parameters.\nautodetect: First the container tries to wire using autowire by the constructor, if it isn't possible then it tries to autowire by byType. no: This means no autowiring and is the default setting. An explicit bean reference should be used for wiring. no no autowiring byName: The bean dependency is injected according to the name of the bean. This matches and wires its properties with the beans defined by the same names as per the configuration. byName name of the bean byType: This injects the bean dependency based on type. byType type constructor: Here, it injects the bean dependency by calling the constructor of the class. It has a large number of parameters. constructor by calling the constructor autodetect: First the container tries to wire using autowire by the constructor, if it isn't possible then it tries to autowire by byType. autodetect",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "4. What do you understand by Bean Wiring.",
        "answer": "When beans are combined together within the Spring container, they are said to be wired or the phenomenon is called bean wiring.\nThe Spring container should know what beans are needed and how the beans are dependent on each other while wiring beans. This is given by means of XML / Annotations / Java code-based configuration. When beans are combined together within the Spring container, they are said to be wired or the phenomenon is called bean wiring. The Spring container should know what beans are needed and how the beans are dependent on each other while wiring beans. This is given by means of XML / Annotations / Java code-based configuration.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "5. Explain Bean life cycle in Spring Bean Factory Container.",
        "answer": "The Bean life cycle is as follows: The IoC container instantiates the bean from the bean’s definition in the XML file.\nSpring then populates all of the properties using the dependency injection as specified in the bean definition.\nThe bean factory container calls setBeanName() which take the bean ID and the corresponding bean has to implement BeanNameAware interface.\nThe factory then calls setBeanFactory() by passing an instance of itself (if BeanFactoryAware interface is implemented in the bean).\nIf BeanPostProcessors is associated with a bean, then the preProcessBeforeInitialization() methods are invoked.\nIf an init-method is specified, then it will be called.\nLastly, postProcessAfterInitialization() methods will be called if there are any BeanPostProcessors associated with the bean that needs to be run post creation. The IoC container instantiates the bean from the bean’s definition in the XML file. Spring then populates all of the properties using the dependency injection as specified in the bean definition. The bean factory container calls setBeanName() which take the bean ID and the corresponding bean has to implement BeanNameAware interface. setBeanName() BeanNameAware The factory then calls setBeanFactory() by passing an instance of itself (if BeanFactoryAware interface is implemented in the bean). setBeanFactory() If BeanPostProcessors is associated with a bean, then the preProcessBeforeInitialization() methods are invoked. BeanPostProcessors preProcessBeforeInitialization() If an init-method is specified, then it will be called. Lastly, postProcessAfterInitialization() methods will be called if there are any BeanPostProcessors associated with the bean that needs to be run post creation. postProcessAfterInitialization()  ",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "6. How is the configuration meta data provided to the spring container?",
        "answer": "There are 3 ways of providing the configuration metadata. They are as follows: XML-Based configuration: The bean configurations and their dependencies are specified in XML configuration files. This starts with a bean tag as shown below: XML-Based configuration: The bean configurations and their dependencies are specified in XML configuration files. This starts with a bean tag as shown below: XML-Based configuration: <bean id=\"interviewBitBean\" class=\"org.intervuewBit.firstSpring.InterviewBitBean\">\n    <property name=\"name\" value=\"InterviewBit\"></property>\n   </bean> <bean id=\"interviewBitBean\" class=\"org.intervuewBit.firstSpring.InterviewBitBean\">\n    <property name=\"name\" value=\"InterviewBit\"></property>\n   </bean> Annotation-Based configuration: Instead of the XML approach, the beans can be configured into the component class itself by using annotations on the relevant class, method, or field declaration.\nAnnotation wiring is not active in the Spring container by default. This has to be enabled in the Spring XML configuration file as shown below Annotation-Based configuration: Instead of the XML approach, the beans can be configured into the component class itself by using annotations on the relevant class, method, or field declaration.\nAnnotation wiring is not active in the Spring container by default. This has to be enabled in the Spring XML configuration file as shown below Annotation-Based configuration: Annotation wiring is not active in the Spring container by default. This has to be enabled in the Spring XML configuration file as shown below Annotation wiring is not active in the Spring container by default. This has to be enabled in the Spring XML configuration file as shown below <beans>\n<context:annotation-config/>\n<!-- bean definitions go here -->\n</beans> <beans>\n<context:annotation-config/>\n<!-- bean definitions go here -->\n</beans> Java-based configuration: Spring Framework introduced key features as part of new Java configuration support. This makes use of the @Configuration annotated classes and @Bean annotated methods. Note that:\n@Bean annotation has the same role as the <bean/> element.\nClasses annotated with @Configuration allow to define inter-bean dependencies by simply calling other @Bean methods in the same class. Java-based configuration: Spring Framework introduced key features as part of new Java configuration support. This makes use of the @Configuration annotated classes and @Bean annotated methods. Note that:\n@Bean annotation has the same role as the <bean/> element.\nClasses annotated with @Configuration allow to define inter-bean dependencies by simply calling other @Bean methods in the same class. Java-based configuration: @Configuration @Bean Note that: @Bean annotation has the same role as the <bean/> element.\nClasses annotated with @Configuration allow to define inter-bean dependencies by simply calling other @Bean methods in the same class. @Bean annotation has the same role as the <bean/> element. Classes annotated with @Configuration allow to define inter-bean dependencies by simply calling other @Bean methods in the same class.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "7. What are Spring Beans?",
        "answer": "They are the objects forming the backbone of the user’s application and are managed by the Spring IoC container.\nSpring beans are instantiated, configured, wired, and managed by IoC container.\nBeans are created with the configuration metadata that the users supply to the container (by means of XML or java annotations configurations.) They are the objects forming the backbone of the user’s application and are managed by the Spring IoC container. Spring beans are instantiated, configured, wired, and managed by IoC container. Beans are created with the configuration metadata that the users supply to the container (by means of XML or java annotations configurations.) Check out Scaler Topics' Free Java Spring Boot course to master the fundamentals of Java Spring Boot. Spring Boot course Spring Boot course",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "8. Explain the difference between constructor and setter injection?",
        "answer": "In constructor injection, partial injection is not allowed whereas it is allowed in setter injection.\nThe constructor injection doesn’t override the setter property whereas the same is not true for setter injection.\nConstructor injection creates a new instance if any modification is done. The creation of a new instance is not possible in setter injection.\nIn case the bean has many properties, then constructor injection is preferred. If it has few properties, then setter injection is preferred. In constructor injection, partial injection is not allowed whereas it is allowed in setter injection. The constructor injection doesn’t override the setter property whereas the same is not true for setter injection. Constructor injection creates a new instance if any modification is done. The creation of a new instance is not possible in setter injection. In case the bean has many properties, then constructor injection is preferred. If it has few properties, then setter injection is preferred.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "9. What do you understand by Dependency Injection?",
        "answer": "The main idea in Dependency Injection is that you don’t have to create your objects but you just have to describe how they should be created. The components and services need not be connected by us in the code directly. We have to describe which services are needed by which components in the configuration file. The IoC container present in Spring will wire them up together. The components and services need not be connected by us in the code directly. We have to describe which services are needed by which components in the configuration file. The IoC container present in Spring will wire them up together.   In Java, the 2 major ways of achieving dependency injection are:\nConstructor injection: Here, the IoC container invokes the class constructor with a number of arguments where each argument represents a dependency on the other class.\nSetter injection: Here, the spring container calls the setter methods on the beans after invoking a no-argument static factory method or default constructor to instantiate the bean. In Java, the 2 major ways of achieving dependency injection are:\nConstructor injection: Here, the IoC container invokes the class constructor with a number of arguments where each argument represents a dependency on the other class.\nSetter injection: Here, the spring container calls the setter methods on the beans after invoking a no-argument static factory method or default constructor to instantiate the bean. Constructor injection: Here, the IoC container invokes the class constructor with a number of arguments where each argument represents a dependency on the other class.\nSetter injection: Here, the spring container calls the setter methods on the beans after invoking a no-argument static factory method or default constructor to instantiate the bean. Constructor injection: Here, the IoC container invokes the class constructor with a number of arguments where each argument represents a dependency on the other class. Setter injection: Here, the spring container calls the setter methods on the beans after invoking a no-argument static factory method or default constructor to instantiate the bean.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "10. What do you mean by IoC (Inversion of Control) Container?",
        "answer": "Spring container forms the core of the Spring Framework. The Spring container uses Dependency Injection (DI) for managing the application components by creating objects, wiring them together along with configuring and managing their overall life cycles. The instructions for the spring container to do the tasks can be provided either by XML configuration, Java annotations, or Java code.  ",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "11. What is a Spring configuration file?",
        "answer": "A Spring configuration file is basically an XML file that mainly contains the classes information and describes how those classes are configured and linked to each other. The XML configuration files are verbose and cleaner.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "12. What are the features of Spring Framework?",
        "answer": "Spring framework follows layered architecture pattern that helps in the necessary components selection along with providing a robust and cohesive framework for J2EE applications development.\nThe AOP (Aspect Oriented Programming) part of Spring supports unified development by ensuring separation of application’s business logic from other system services.\nSpring provides highly configurable MVC web application framework which has the ability to switch to other frameworks easily.\nProvides provision of creation and management of the configurations and defining the lifecycle of application objects.\nSpring has a special design principle which is known as IoC (Inversion of Control) that supports objects to give their dependencies rather than looking for creating dependent objects.\nSpring is a lightweight, java based, loosely coupled framework.\nSpring provides generic abstraction layer for transaction management that is also very useful for container-less environments.\nSpring provides a convenient API to translate technology-specific exceptions (thrown by JDBC, Hibernate or other frameworks) into consistent, unchecked exceptions. This introduces abstraction and greatly simplifies exception handling. Spring framework follows layered architecture pattern that helps in the necessary components selection along with providing a robust and cohesive framework for J2EE applications development. layered architecture The AOP (Aspect Oriented Programming) part of Spring supports unified development by ensuring separation of application’s business logic from other system services. separation of application’s business logic Spring provides highly configurable MVC web application framework which has the ability to switch to other frameworks easily. highly configurable Provides provision of creation and management of the configurations and defining the lifecycle of application objects. creation and management Spring has a special design principle which is known as IoC (Inversion of Control) that supports objects to give their dependencies rather than looking for creating dependent objects. Inversion of Control Spring is a lightweight, java based, loosely coupled framework. lightweight, java based, loosely coupled Spring provides generic abstraction layer for transaction management that is also very useful for container-less environments. abstraction layer for transaction management Spring provides a convenient API to translate technology-specific exceptions (thrown by JDBC, Hibernate or other frameworks) into consistent, unchecked exceptions. This introduces abstraction and greatly simplifies exception handling. consistent, unchecked exceptions.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "13. What is Spring Framework?",
        "answer": "Spring is a powerful open-source, loosely coupled, lightweight, java framework meant for reducing the complexity of developing enterprise-level applications. This framework is also called the “framework of frameworks” as spring provides support to various other important frameworks like JSF, Hibernate, Structs, EJB, etc.\nThere are around 20 modules which are generalized into the following types:\nCore Container\nData Access/Integration\nWeb\nAOP (Aspect Oriented Programming)\nInstrumentation\nMessaging\nTest Spring is a powerful open-source, loosely coupled, lightweight, java framework meant for reducing the complexity of developing enterprise-level applications. This framework is also called the “framework of frameworks” as spring provides support to various other important frameworks like JSF, Hibernate, Structs, EJB, etc. java framework There are around 20 modules which are generalized into the following types:\nCore Container\nData Access/Integration\nWeb\nAOP (Aspect Oriented Programming)\nInstrumentation\nMessaging\nTest Core Container\nData Access/Integration\nWeb\nAOP (Aspect Oriented Programming)\nInstrumentation\nMessaging\nTest Core Container Data Access/Integration Web AOP (Aspect Oriented Programming) Instrumentation Messaging Test   Spring handles all the infrastructure-related aspects which lets the programmer to focus mostly on application development. Spring handles all the infrastructure-related aspects which lets the programmer to focus mostly on application development.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "1. What are the features of Spring Boot?",
        "answer": "Spring Boot CLI – This allows you to Groovy / Maven for writing Spring boot application and avoids boilerplate code.\nStarter Dependency – With the help of this feature, Spring Boot aggregates common dependencies together and eventually improves productivity and reduces the burden on\nSpring Initializer – This is a web application that helps a developer in creating an internal project structure. The developer does not have to manually set up the structure of the project while making use of this feature.\nAuto-Configuration – This helps in loading the default configurations according to the project you are working on. In this way, unnecessary WAR files can be avoided.\nSpring Actuator – Spring boot uses actuator to provide “Management EndPoints” which helps the developer in going through the Application Internals, Metrics etc.\nLogging and Security – This ensures that all the applications made using Spring Boot are properly secured without any hassle. Spring Boot CLI – This allows you to Groovy / Maven for writing Spring boot application and avoids boilerplate code. Spring Boot CLI Starter Dependency – With the help of this feature, Spring Boot aggregates common dependencies together and eventually improves productivity and reduces the burden on Starter Dependency Spring Initializer – This is a web application that helps a developer in creating an internal project structure. The developer does not have to manually set up the structure of the project while making use of this feature. Spring Initializer Auto-Configuration – This helps in loading the default configurations according to the project you are working on. In this way, unnecessary WAR files can be avoided. Auto-Configuration Spring Actuator – Spring boot uses actuator to provide “Management EndPoints” which helps the developer in going through the Application Internals, Metrics etc. Spring Actuator Logging and Security – This ensures that all the applications made using Spring Boot are properly secured without any hassle. Logging and Security",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "2. Differentiate between Spring and Spring Boot.",
        "answer": "The Spring Framework provides multiple features like dependency injection, data binding, aspect-oriented programming (AOP), data access, and many more that help easier development of web applications whereas Spring Boot helps in easier usage of the Spring Framework by simplifying or managing various loosely coupled blocks of Spring which are tedious and have a potential of becoming messy.\nSpring boot simplifies commonly used spring dependencies and runs applications straight from a command line. It also doesn’t require an application container and it helps in monitoring several components and configures them externally. The Spring Framework provides multiple features like dependency injection, data binding, aspect-oriented programming (AOP), data access, and many more that help easier development of web applications whereas Spring Boot helps in easier usage of the Spring Framework by simplifying or managing various loosely coupled blocks of Spring which are tedious and have a potential of becoming messy. Spring boot simplifies commonly used spring dependencies and runs applications straight from a command line. It also doesn’t require an application container and it helps in monitoring several components and configures them externally.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "3. Explain the advantages of using Spring Boot for application development.",
        "answer": "Spring Boot helps to create stand-alone applications which can be started using java.jar (Doesn’t require configuring WAR files).\nSpring Boot also offers pinpointed ‘started’ POMs to Maven configuration.\nHas provision to embed Undertow, Tomcat, Jetty, or other web servers directly.\nAuto-Configuration: Provides a way to automatically configure an application based on the dependencies present on the classpath.\nSpring Boot was developed with the intention of lessening the lines of code.\nIt offers production-ready support like monitoring and apps developed using spring boot are easier to launch. Spring Boot helps to create stand-alone applications which can be started using java.jar (Doesn’t require configuring WAR files). Spring Boot also offers pinpointed ‘started’ POMs to Maven configuration. Has provision to embed Undertow, Tomcat, Jetty, or other web servers directly. Auto-Configuration: Provides a way to automatically configure an application based on the dependencies present on the classpath. Spring Boot was developed with the intention of lessening the lines of code. It offers production-ready support like monitoring and apps developed using spring boot are easier to launch.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "4. What do you understand by the term ‘Spring Boot’?",
        "answer": "Spring Boot is an open-source, java-based framework that provides support for Rapid Application Development and gives a platform for developing stand-alone and production-ready spring applications with a need for very few configurations.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "5. What does @SpringBootApplication annotation do internally?",
        "answer": "As per the Spring Boot documentation, the @SpringBootApplication annotation is one point replacement for using @Configuration, @EnableAutoConfiguration and @ComponentScan annotations alongside their default attributes.   This enables the developer to use a single annotation instead of using multiple annotations thus lessening the lines of code. However, Spring provides loosely coupled features which is why we can use these annotations as per our project needs.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "6. What are the uses of @RequestMapping and @RestController annotations in Spring Boot?",
        "answer": "@RequestMapping:\nThis provides the routing information and informs Spring that any HTTP request matching the URL must be mapped to the respective method.\norg.springframework.web.bind.annotation.RequestMapping has to be imported to use this annotation.\n@RestController:\nThis is applied to a class to mark it as a request handler thereby creating RESTful web services using Spring MVC. This annotation adds the @ResponseBody and @Controller annotation to the class.\norg.springframework.web.bind.annotation.RestController has to be imported to use this annotation. @RequestMapping:\nThis provides the routing information and informs Spring that any HTTP request matching the URL must be mapped to the respective method.\norg.springframework.web.bind.annotation.RequestMapping has to be imported to use this annotation. @RequestMapping: This provides the routing information and informs Spring that any HTTP request matching the URL must be mapped to the respective method.\norg.springframework.web.bind.annotation.RequestMapping has to be imported to use this annotation. This provides the routing information and informs Spring that any HTTP request matching the URL must be mapped to the respective method. org.springframework.web.bind.annotation.RequestMapping has to be imported to use this annotation. org.springframework.web.bind.annotation.RequestMapping @RestController:\nThis is applied to a class to mark it as a request handler thereby creating RESTful web services using Spring MVC. This annotation adds the @ResponseBody and @Controller annotation to the class.\norg.springframework.web.bind.annotation.RestController has to be imported to use this annotation. @RestController: This is applied to a class to mark it as a request handler thereby creating RESTful web services using Spring MVC. This annotation adds the @ResponseBody and @Controller annotation to the class.\norg.springframework.web.bind.annotation.RestController has to be imported to use this annotation. This is applied to a class to mark it as a request handler thereby creating RESTful web services using Spring MVC. This annotation adds the @ResponseBody and @Controller annotation to the class. org.springframework.web.bind.annotation.RestController has to be imported to use this annotation. org.springframework.web.bind.annotation.RestController Check out more Interview Questions on Spring Boot here. here",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "7. Can the default web server in the Spring Boot application be disabled?",
        "answer": "Yes! application.properties is used to configure the web application type, by mentioning spring.main.web-application-type=none. application.properties spring.main.web-application-type=none",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "8. How to disable specific auto-configuration class?",
        "answer": "You can use the exclude attribute of @EnableAutoConfiguration for this purpose as shown below: You can use the exclude attribute of @EnableAutoConfiguration for this purpose as shown below: exclude @EnableAutoConfiguration @EnableAutoConfiguration(exclude = {InterviewBitAutoConfiguration.class}) @EnableAutoConfiguration(exclude = {InterviewBitAutoConfiguration.class}) If the class is not specified on the classpath, we can specify the fully qualified name as the value for the excludeName. excludeName //By using \"excludeName\"\n@EnableAutoConfiguration(excludeName={Foo.class}) //By using \"excludeName\"\n@EnableAutoConfiguration(excludeName={Foo.class}) You can add into the application.properties and multiple classes can be added by keeping it comma-separated. You can add into the application.properties and multiple classes can be added by keeping it comma-separated.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "9. Can you tell how to exclude any package without using the basePackages filter?",
        "answer": "We can use the exclude attribute while using the annotation @SpringBootApplication as follows: exclude @SpringBootApplication @SpringBootApplication(exclude= {Student.class})\npublic class InterviewBitAppConfiguration {} @SpringBootApplication(exclude= {Student.class})\npublic class InterviewBitAppConfiguration {}",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "10. Can we change the default port of the embedded Tomcat server in Spring boot?",
        "answer": "Yes, we can change it by using the application properties file by adding a property of server.port and assigning it to any port you wish to.\nFor example, if you want the port to be 8081, then you have to mention server.port=8081. Once the port number is mentioned, the application properties file will be automatically loaded by Spring Boot and the specified configurations will be applied to the application. Yes, we can change it by using the application properties file by adding a property of server.port and assigning it to any port you wish to. server.port For example, if you want the port to be 8081, then you have to mention server.port=8081. Once the port number is mentioned, the application properties file will be automatically loaded by Spring Boot and the specified configurations will be applied to the application. server.port=8081",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "11. What are the possible sources of external configuration?",
        "answer": "Spring Boot allows the developers to run the same application in different environments by making use of its feature of external configuration. This uses environment variables, properties files, command-line arguments, YAML files, and system properties to mention the required configuration properties for its corresponding environments. Following are the sources of external configuration:\nCommand-line properties – Spring Boot provides support for command-line arguments and converts these arguments to properties and then adds them to the set of environment properties.\nApplication Properties – By default, Spring Boot searches for the application properties file or its YAML file in the current directory of the application, classpath root, or config directory to load the properties.\nProfile-specific properties – Properties are loaded from the application-{profile}.properties file or its YAML file. This file resides in the same location as that of the non-specific property files and the {profile} placeholder refers to an active profile or an environment. Spring Boot allows the developers to run the same application in different environments by making use of its feature of external configuration. This uses environment variables, properties files, command-line arguments, YAML files, and system properties to mention the required configuration properties for its corresponding environments. Following are the sources of external configuration:\nCommand-line properties – Spring Boot provides support for command-line arguments and converts these arguments to properties and then adds them to the set of environment properties.\nApplication Properties – By default, Spring Boot searches for the application properties file or its YAML file in the current directory of the application, classpath root, or config directory to load the properties.\nProfile-specific properties – Properties are loaded from the application-{profile}.properties file or its YAML file. This file resides in the same location as that of the non-specific property files and the {profile} placeholder refers to an active profile or an environment. Command-line properties – Spring Boot provides support for command-line arguments and converts these arguments to properties and then adds them to the set of environment properties.\nApplication Properties – By default, Spring Boot searches for the application properties file or its YAML file in the current directory of the application, classpath root, or config directory to load the properties.\nProfile-specific properties – Properties are loaded from the application-{profile}.properties file or its YAML file. This file resides in the same location as that of the non-specific property files and the {profile} placeholder refers to an active profile or an environment. Command-line properties – Spring Boot provides support for command-line arguments and converts these arguments to properties and then adds them to the set of environment properties. Command-line properties Application Properties – By default, Spring Boot searches for the application properties file or its YAML file in the current directory of the application, classpath root, or config directory to load the properties. Application Properties Profile-specific properties – Properties are loaded from the application-{profile}.properties file or its YAML file. This file resides in the same location as that of the non-specific property files and the {profile} placeholder refers to an active profile or an environment. Profile-specific properties application-{profile}.properties file",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "12. What is Spring Boot dependency management system?",
        "answer": "It is basically used to manage dependencies and configuration automatically without the need of specifying the version for any of that dependencies. It is basically used to manage dependencies and configuration automatically without the need of specifying the version for any of that dependencies.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "13. What are the effects of running Spring Boot Application as “Java Application”?",
        "answer": "The application automatically launches the tomcat server as soon as it sees that we are running a web application. The application automatically launches the tomcat server as soon as it sees that we are running a web application.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "1. What is Spring AOP?",
        "answer": "Spring AOP (Aspect Oriented Programming) is similar to OOPs (Object Oriented Programming) as it also provides modularity.\nIn AOP key unit is aspects or concerns which are nothing but stand-alone modules in the application. Some aspects have centralized code but other aspects may be scattered or tangled code like in the case of logging or transactions. These scattered aspects are called cross-cutting concern.\nA cross-cutting concern such as transaction management, authentication, logging, security etc is a concern that could affect the whole application and should be centralized in one location in code as much as possible for security and modularity purposes.\nAOP provides platform to dynamically add these cross-cutting concerns before, after or around the actual logic by using simple pluggable configurations.\nThis results in easy maintainenance of code. Concerns can be added or removed simply by modifying configuration files and therefore without the need for recompiling complete sourcecode.\nThere are 2 types of implementing Spring AOP:\nUsing XML configuration files\nUsing AspectJ annotation style Spring AOP (Aspect Oriented Programming) is similar to OOPs (Object Oriented Programming) as it also provides modularity. In AOP key unit is aspects or concerns which are nothing but stand-alone modules in the application. Some aspects have centralized code but other aspects may be scattered or tangled code like in the case of logging or transactions. These scattered aspects are called cross-cutting concern.\nA cross-cutting concern such as transaction management, authentication, logging, security etc is a concern that could affect the whole application and should be centralized in one location in code as much as possible for security and modularity purposes. aspects concerns cross-cutting concern A cross-cutting concern such as transaction management, authentication, logging, security etc is a concern that could affect the whole application and should be centralized in one location in code as much as possible for security and modularity purposes. A cross-cutting concern such as transaction management, authentication, logging, security etc is a concern that could affect the whole application and should be centralized in one location in code as much as possible for security and modularity purposes. AOP provides platform to dynamically add these cross-cutting concerns before, after or around the actual logic by using simple pluggable configurations. This results in easy maintainenance of code. Concerns can be added or removed simply by modifying configuration files and therefore without the need for recompiling complete sourcecode. There are 2 types of implementing Spring AOP:\nUsing XML configuration files\nUsing AspectJ annotation style Using XML configuration files\nUsing AspectJ annotation style Using XML configuration files Using AspectJ annotation style",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "2. What is HibernateTemplate class?",
        "answer": "Prior to Hibernate 3.0.1, Spring provided 2 classes namely: HibernateDaoSupport to get the Session from Hibernate and HibernateTemplate for Spring transaction management purposes.\nHowever, from Hibernate 3.0.1 onwards, by using HibernateTemplate class we can use SessionFactory getCurrentSession() method to get the current session and then use it to get the transaction management benefits.\nHibernateTemplate has the benefit of exception translation but that can be achieved easily by using @Repository annotation with service classes. Prior to Hibernate 3.0.1, Spring provided 2 classes namely: HibernateDaoSupport to get the Session from Hibernate and HibernateTemplate for Spring transaction management purposes. HibernateDaoSupport HibernateTemplate However, from Hibernate 3.0.1 onwards, by using HibernateTemplate class we can use SessionFactory getCurrentSession() method to get the current session and then use it to get the transaction management benefits. HibernateTemplate SessionFactory getCurrentSession() HibernateTemplate has the benefit of exception translation but that can be achieved easily by using @Repository annotation with service classes. HibernateTemplate",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "3. What is Hibernate Validator Framework?",
        "answer": "Data validation is a crucial part of any application. We can find data validation in:\nUI layer before sending objects to the server\nAt the server-side before processing it\nBefore persisting data into the database\nValidation is a cross-cutting concern/task, so as good practice, we should try to keep it apart from our business logic. JSR303 and JSR349 provide specifications for bean validation by using annotations.\nThis framework provides the reference implementation for JSR303 and JSR349 specifications. Data validation is a crucial part of any application. We can find data validation in:\nUI layer before sending objects to the server\nAt the server-side before processing it\nBefore persisting data into the database UI layer before sending objects to the server\nAt the server-side before processing it\nBefore persisting data into the database UI layer before sending objects to the server At the server-side before processing it Before persisting data into the database Validation is a cross-cutting concern/task, so as good practice, we should try to keep it apart from our business logic. JSR303 and JSR349 provide specifications for bean validation by using annotations. This framework provides the reference implementation for JSR303 and JSR349 specifications.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "4. What are the two ways of accessing Hibernate by using Spring.",
        "answer": "Inversion of Control approach by using Hibernate Template and Callback.\nExtending HibernateDAOSupport and Applying an AOP Interceptor node. Inversion of Control approach by using Hibernate Template and Callback. Extending HibernateDAOSupport and Applying an AOP Interceptor node. HibernateDAOSupport",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "5. What is Hibernate ORM Framework?",
        "answer": "Object-relational mapping (ORM) is the phenomenon of mapping application domain model objects to the relational database tables and vice versa.\nHibernate is the most commonly used java based ORM framework. Object-relational mapping (ORM) is the phenomenon of mapping application domain model objects to the relational database tables and vice versa. Hibernate is the most commonly used java based ORM framework.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "6. How can you fetch records by Spring JdbcTemplate?",
        "answer": "This can be done by using the query method of JdbcTemplate. There are two interfaces that help to do this: ResultSetExtractor:\nIt defines only one method extractData that accepts ResultSet instance as a parameter and returns the list.\nSyntax: ResultSetExtractor:\nIt defines only one method extractData that accepts ResultSet instance as a parameter and returns the list.\nSyntax: ResultSetExtractor: It defines only one method extractData that accepts ResultSet instance as a parameter and returns the list.\nSyntax: It defines only one method extractData that accepts ResultSet instance as a parameter and returns the list. extractData ResultSet Syntax: public T extractData(ResultSet rs) throws SQLException,DataAccessException; public T extractData(ResultSet rs) throws SQLException,DataAccessException; RowMapper:\nThis is an enhanced version of ResultSetExtractor that saves a lot of code.\nIt allows to map a row of the relations with the instance of the user-defined class.\nIt iterates the ResultSet internally and adds it into the result collection thereby saving a lot of code to fetch records. RowMapper:\nThis is an enhanced version of ResultSetExtractor that saves a lot of code.\nIt allows to map a row of the relations with the instance of the user-defined class.\nIt iterates the ResultSet internally and adds it into the result collection thereby saving a lot of code to fetch records. RowMapper: This is an enhanced version of ResultSetExtractor that saves a lot of code.\nIt allows to map a row of the relations with the instance of the user-defined class.\nIt iterates the ResultSet internally and adds it into the result collection thereby saving a lot of code to fetch records. This is an enhanced version of ResultSetExtractor that saves a lot of code. It allows to map a row of the relations with the instance of the user-defined class. It iterates the ResultSet internally and adds it into the result collection thereby saving a lot of code to fetch records.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "7. What are some of the classes for Spring JDBC API?",
        "answer": "Following are the classes\nJdbcTemplate\nSimpleJdbcTemplate\nNamedParameterJdbcTemplate\nSimpleJdbcInsert\nSimpleJdbcCall\nThe most commonly used one is JdbcTemplate. This internally uses the JDBC API and has the advantage that we don’t need to create connection, statement, start transaction, commit transaction, and close connection to execute different queries. All these are handled by JdbcTemplate itself. The developer can focus on executing the query directly. Following are the classes\nJdbcTemplate\nSimpleJdbcTemplate\nNamedParameterJdbcTemplate\nSimpleJdbcInsert\nSimpleJdbcCall JdbcTemplate\nSimpleJdbcTemplate\nNamedParameterJdbcTemplate\nSimpleJdbcInsert\nSimpleJdbcCall JdbcTemplate SimpleJdbcTemplate NamedParameterJdbcTemplate SimpleJdbcInsert SimpleJdbcCall The most commonly used one is JdbcTemplate. This internally uses the JDBC API and has the advantage that we don’t need to create connection, statement, start transaction, commit transaction, and close connection to execute different queries. All these are handled by JdbcTemplate itself. The developer can focus on executing the query directly.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "8. What is Spring AOP Proxy pattern?",
        "answer": "A proxy pattern is a well-used design pattern where a proxy is an object that looks like another object but adds special functionality to it behind the scenes.\nSpring AOP follows proxy-based pattern and this is created by the AOP framework to implement the aspect contracts in runtime.\nThe standard JDK dynamic proxies are default AOP proxies that enables any interface(s) to be proxied. Spring AOP can also use CGLIB proxies that are required to proxy classes, rather than interfaces. In case a business object does not implement an interface, then CGLIB proxies are used by default. A proxy pattern is a well-used design pattern where a proxy is an object that looks like another object but adds special functionality to it behind the scenes. Spring AOP follows proxy-based pattern and this is created by the AOP framework to implement the aspect contracts in runtime. The standard JDK dynamic proxies are default AOP proxies that enables any interface(s) to be proxied. Spring AOP can also use CGLIB proxies that are required to proxy classes, rather than interfaces. In case a business object does not implement an interface, then CGLIB proxies are used by default.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "9. What is an advice? Explain its types in spring.",
        "answer": "An advice is the implementation of cross-cutting concerns can be applied to other modules of the spring application. Advices are of mainly 5 types: Before:\nThis advice executes before a join point, but it does not have the ability to prevent execution flow from proceeding to the join point (unless it throws an exception).\nTo use this, use @Before annotation.\nAfterReturning:\nThis advice is to be executed after a join point completes normally i.e if a method returns without throwing an exception.\nTo use this, use @AfterReturning annotation.\nAfterThrowing:\nThis advice is to be executed if a method exits by throwing an exception.\nTo use this, use @AfterThrowing annotation.\nAfter:\nThis advice is to be executed regardless of the means by which a join point exits (normal return or exception encounter).\nTo use this, use @After annotation.\nAround:\nThis is the most powerful advice surrounds a join point such as a method invocation.\nTo use this, use @Around annotation. Before:\nThis advice executes before a join point, but it does not have the ability to prevent execution flow from proceeding to the join point (unless it throws an exception).\nTo use this, use @Before annotation. Before: This advice executes before a join point, but it does not have the ability to prevent execution flow from proceeding to the join point (unless it throws an exception).\nTo use this, use @Before annotation. This advice executes before a join point, but it does not have the ability to prevent execution flow from proceeding to the join point (unless it throws an exception). before To use this, use @Before annotation. AfterReturning:\nThis advice is to be executed after a join point completes normally i.e if a method returns without throwing an exception.\nTo use this, use @AfterReturning annotation. AfterReturning: This advice is to be executed after a join point completes normally i.e if a method returns without throwing an exception.\nTo use this, use @AfterReturning annotation. This advice is to be executed after a join point completes normally i.e if a method returns without throwing an exception. after completes To use this, use @AfterReturning annotation. AfterThrowing:\nThis advice is to be executed if a method exits by throwing an exception.\nTo use this, use @AfterThrowing annotation. AfterThrowing: This advice is to be executed if a method exits by throwing an exception.\nTo use this, use @AfterThrowing annotation. This advice is to be executed if a method exits by throwing an exception. throwing an exception To use this, use @AfterThrowing annotation. After:\nThis advice is to be executed regardless of the means by which a join point exits (normal return or exception encounter).\nTo use this, use @After annotation. After: This advice is to be executed regardless of the means by which a join point exits (normal return or exception encounter).\nTo use this, use @After annotation. This advice is to be executed regardless of the means by which a join point exits (normal return or exception encounter). regardless To use this, use @After annotation. Around:\nThis is the most powerful advice surrounds a join point such as a method invocation.\nTo use this, use @Around annotation. Around: This is the most powerful advice surrounds a join point such as a method invocation.\nTo use this, use @Around annotation. This is the most powerful advice surrounds a join point such as a method invocation. To use this, use @Around annotation.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "1. How can you achieve thread-safety in beans?",
        "answer": "The thread safety can be achieved by changing the scope of the bean to request, session or prototype but at the cost of performance. This is purely based on the project requirements.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "2. Is there any need to keepspring-mvc.jar on the classpath or is it already present as part of spring-core?",
        "answer": "The spring-mv.jar does not belong to the spring-core. This means that the jar has to be included in the project’s classpath if we have to use the Spring MVC framework in our project. For Java applications, the spring-mvc.jar is placed inside /WEB-INF/lib folder. spring-mv.jar spring-mvc.jar /WEB-INF/lib",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "3. What are Spring Interceptors?",
        "answer": "Spring Interceptors are used to pre-handle and post-handle the web requests in Spring MVC which are handled by Spring Controllers. This can be achieved by the HandlerInterceptor interface. These handlers are used for manipulating the model attributes that are passed to the controllers or the views.\nThe Spring handler interceptor can be registered for specific URL mappings so that it can intercept only those requests. The custom handler interceptor must implement the HandlerInterceptor interface that has 3 callback methods that can be implemented: HandlerInterceptor  HandlerInterceptor preHandle()\npostHandle()\nafterCompletion() preHandle() postHandle() afterCompletion() The only problem with this interface is that all the methods of this interface need to be implemented irrespective of its requirements. This can be avoided if our handler class extends the HandlerInterceptorAdapter class that internally implements the HandlerInterceptor interface and provides default blank implementations. HandlerInterceptorAdapter HandlerInterceptor",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "4. Why do we need BindingResults?",
        "answer": "BindingResults is an important Spring interface that is within the org.Springframework.validation package. This interface has a very simple and easy process of invocation and plays a vital role in detecting errors in the submitted forms. However, care has to be taken by the developer to use the BindingResult parameter just after the object that needs validation. For example: org.Springframework.validation @PostMapping(\"/interviewbit\")\npublic String registerCourse(@Valid RegisterUser registerUser,\n BindingResult bindingResult, Model model) {\n   if (bindingResult.hasErrors()) {\n       return \"home\";\n   }\n   model.addAttribute(\"message\", \"Valid inputs\");\n   return \"home\";\n} @PostMapping(\"/interviewbit\")\npublic String registerCourse(@Valid RegisterUser registerUser,\n BindingResult bindingResult, Model model) {\n   if (bindingResult.hasErrors()) {\n       return \"home\";\n   }\n   model.addAttribute(\"message\", \"Valid inputs\");\n   return \"home\";\n} The Spring will understand to find the corresponding validators by checking the @Valid annotation on the parameter.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "5. Where does the access to the model from the view come from?",
        "answer": "The view requires access to the model to render the output as the model contains the required data meant for rendering. The model is associated with the controller that processes the client requests and finally encapsulates the response into the Model object.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "6. How does the Spring MVC flow look like? In other words, How does a DispatcherServlet know what Controller needs to be called when there is an incoming request to the Spring MVC?",
        "answer": "A Dispatcher Servlet knows which controller to call by means of handler mappings. These mappings have the mapping between the controller and the requests. BeanNameUrlHandlerMapping and SimpleUrlHandlerMapping are the two most commonly used handler mappings. BeanNameUrlHandlerMapping SimpleUrlHandlerMapping BeanNameUrlHandlerMapping: When the URL request matches the bean name, the class corresponding to the bean definition is the actual controller that is responsible for processing the request.\nSimpleUrlHandlerMapping: Here, the mapping is very explicit. The number of URLs can be specified here and each URL is associated explicitly with a controller. BeanNameUrlHandlerMapping: When the URL request matches the bean name, the class corresponding to the bean definition is the actual controller that is responsible for processing the request. SimpleUrlHandlerMapping: Here, the mapping is very explicit. The number of URLs can be specified here and each URL is associated explicitly with a controller. If the Spring MVC is configured using annotations, then @RequestMapping annotations are used for this purpose. The @RequestMapping annotation is configured by making use of the URI path, HTTP methods, query parameters, and the HTTP Headers.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "7. How is the root application context in Spring MVC loaded?",
        "answer": "The root application context is loaded using the ContextLoaderListener that belongs to the entire application. Spring MVC allows instantiating multiple DispatcherServlet and each of them have multiple contexts specific to them. They can have the same root context too.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "8. How is the dispatcher servlet instantiated?",
        "answer": "The dispatcher servlet is instantiated by means of servlet containers such as Tomcat. The Dispatcher Servlet should be defined in web.xml The DispatcherServlet is instantiated by Servlet containers like Tomcat. The Dispatcher Servlet can be defined in web.xml as shown below: <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n\n <!-- Define Dispatcher Servlet -->\n <servlet>\n   <servlet-name>appServlet</servlet-name>\n   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n   <init-param>\n     <param-name>contextConfigLocation</param-name>\n     <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>\n   </init-param>\n   <load-on-startup>1</load-on-startup>\n </servlet>\n\n <servlet-mapping>\n   <servlet-name>InterviewBitServlet</servlet-name>\n   <url-pattern>/</url-pattern>\n </servlet-mapping>\n\n</web-app> <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n\n <!-- Define Dispatcher Servlet -->\n <servlet>\n   <servlet-name>appServlet</servlet-name>\n   <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n   <init-param>\n     <param-name>contextConfigLocation</param-name>\n     <param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>\n   </init-param>\n   <load-on-startup>1</load-on-startup>\n </servlet>\n\n <servlet-mapping>\n   <servlet-name>InterviewBitServlet</servlet-name>\n   <url-pattern>/</url-pattern>\n </servlet-mapping>\n\n</web-app> Here, the load-on-startup tag is 1 which indicates that the DispatcherServlet is instantiated whenever the Spring MVC application to the servlet container. During this process, it looks for the servlet-name-context.xml file and initializes beans that are defined in the file.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "9. What is the significance of @Repository annotation?",
        "answer": "@Repository annotation indicates that a component is used as the repository that acts as a means to store, search or retrieve data. These can be added to the DAO classes.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "10. What are the differences between the <context:annotation-config> vs <context:component-scan> tags?",
        "answer": "<context:annotation-config> is used for activating applied annotations in pre-registered beans in the application context. It also registers the beans defined in the config file and it scans the annotations within the beans and activates them. <context:annotation-config> The <context:component-scan> tag does the task of <context:annotation-config> along with scanning the packages and registering the beans in the application context. <context:component-scan> <context:annotation-config> <context:annotation-config> = Scan and activate annotations in pre-registered beans.\n<context:component-scan> = Register Bean + Scan and activate annotations in package. <context:annotation-config> = Scan and activate annotations in pre-registered beans.\n<context:component-scan> = Register Bean + Scan and activate annotations in package. <context:annotation-config>  <context:component-scan>",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "11. Are singleton beans thread-safe?",
        "answer": "No, the singleton beans are not thread-safe because the concept of thread-safety essentially deals with the execution of the program and the singleton is simply a design pattern meant for the creation of objects. Thread safety nature of a bean depends on the nature of its implementation.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "12. Differentiate between the @Autowired and the @Inject annotations.",
        "answer": "@Autowired @Inject\nThis annotation is part of the Spring framework. This annotation is part of Java CDI.\nHas required attribute. Does not have the required attribute.\nSingleton is the default scope for autowired beans. Prototype is the default scope of inject beans.\nIn case of ambiguity, then @Qualifier annotation is to be used. In case of ambiguity, then @Named qualifier needs to be used.\nSince this annotation is provided by the Spring framework, in case you shift to another Dependency injection framework, there would be a lot of refactoring needed. Since this annotation is part of Java CDI, it is not framework dependent and hence less code refactoring when there are framework changes. @Autowired @Inject\nThis annotation is part of the Spring framework. This annotation is part of Java CDI.\nHas required attribute. Does not have the required attribute.\nSingleton is the default scope for autowired beans. Prototype is the default scope of inject beans.\nIn case of ambiguity, then @Qualifier annotation is to be used. In case of ambiguity, then @Named qualifier needs to be used.\nSince this annotation is provided by the Spring framework, in case you shift to another Dependency injection framework, there would be a lot of refactoring needed. Since this annotation is part of Java CDI, it is not framework dependent and hence less code refactoring when there are framework changes. @Autowired @Inject @Autowired @Inject @Autowired @Inject This annotation is part of the Spring framework. This annotation is part of Java CDI.\nHas required attribute. Does not have the required attribute.\nSingleton is the default scope for autowired beans. Prototype is the default scope of inject beans.\nIn case of ambiguity, then @Qualifier annotation is to be used. In case of ambiguity, then @Named qualifier needs to be used.\nSince this annotation is provided by the Spring framework, in case you shift to another Dependency injection framework, there would be a lot of refactoring needed. Since this annotation is part of Java CDI, it is not framework dependent and hence less code refactoring when there are framework changes. This annotation is part of the Spring framework. This annotation is part of Java CDI. This annotation is part of the Spring framework. This annotation is part of Java CDI. Has required attribute. Does not have the required attribute. Has required attribute. Does not have the required attribute. Singleton is the default scope for autowired beans. Prototype is the default scope of inject beans. Singleton is the default scope for autowired beans. Prototype is the default scope of inject beans. In case of ambiguity, then @Qualifier annotation is to be used. In case of ambiguity, then @Named qualifier needs to be used. In case of ambiguity, then @Qualifier annotation is to be used. In case of ambiguity, then @Named qualifier needs to be used. Since this annotation is provided by the Spring framework, in case you shift to another Dependency injection framework, there would be a lot of refactoring needed. Since this annotation is part of Java CDI, it is not framework dependent and hence less code refactoring when there are framework changes. Since this annotation is provided by the Spring framework, in case you shift to another Dependency injection framework, there would be a lot of refactoring needed. Since this annotation is part of Java CDI, it is not framework dependent and hence less code refactoring when there are framework changes.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "13. What is the importance of @Required annotation?",
        "answer": "The annotation is used for indicating that the property of the bean should be populated via autowiring or any explicit value during the bean definition at the configuration time. For example, consider a code snippet below where we need to have the values of age and the name: import org.Springframework.beans.factory.annotation.Required;\npublic class User {\n   private int age;\n   private String name;\n   \n   @Required\n   public void setAge(int age) {\n       this.age = age;\n   }\n   public Integer getAge() {\n       return this.age;\n   }\n   \n   @Required\n   public void setName(String name) {\n       this.name = name;\n   }\n   public String getName() {\n       return this.name;\n   }\n} import org.Springframework.beans.factory.annotation.Required;\npublic class User {\n   private int age;\n   private String name;\n   \n   @Required\n   public void setAge(int age) {\n       this.age = age;\n   }\n   public Integer getAge() {\n       return this.age;\n   }\n   \n   @Required\n   public void setName(String name) {\n       this.name = name;\n   }\n   public String getName() {\n       return this.name;\n   }\n}",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "14. What is the importance of session scope?",
        "answer": "Session scopes are used to create bean instances for HTTP sessions. This would mean that a single bean can be used for serving multiple HTTP requests. The scope of the bean can be defined by means of using scope attribute or using @Scope or @SessionScope annotations. Using scope attribute: Using scope attribute: <bean id=\"userBean\" class=\"com.interviewbit.UserBean\" scope=\"session\"/> <bean id=\"userBean\" class=\"com.interviewbit.UserBean\" scope=\"session\"/> Using @Scope annotation: Using @Scope annotation: @Component\n@Scope(\"session\")\npublic class UserBean {\n   //some methods and properties\n} @Component\n@Scope(\"session\")\npublic class UserBean {\n   //some methods and properties\n} Using @SessionScope: Using @SessionScope: @Component\n@SessionScope\npublic class UserBean {\n   //some methods and properties\n} @Component\n@SessionScope\npublic class UserBean {\n   //some methods and properties\n}",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "15. What are the types of Spring MVC Dependency Injection?",
        "answer": "There are two types of DI (Dependency Injection): Construction-Based:\nThis type of DI is accomplished when the Spring IoC (Inversion of Control) container invokes parameterized constructor having a dependency on other classes.\nThis cannot instantiate the values partially and ensures that the dependency injection is done fully.\nThere are two possible ways of achieving this: Construction-Based:\nThis type of DI is accomplished when the Spring IoC (Inversion of Control) container invokes parameterized constructor having a dependency on other classes.\nThis cannot instantiate the values partially and ensures that the dependency injection is done fully.\nThere are two possible ways of achieving this: Construction-Based: This type of DI is accomplished when the Spring IoC (Inversion of Control) container invokes parameterized constructor having a dependency on other classes.\nThis cannot instantiate the values partially and ensures that the dependency injection is done fully.\nThere are two possible ways of achieving this: This type of DI is accomplished when the Spring IoC (Inversion of Control) container invokes parameterized constructor having a dependency on other classes. This cannot instantiate the values partially and ensures that the dependency injection is done fully. There are two possible ways of achieving this: Annotation Configuration: This approach uses POJO objects and annotations for configuration. For example, consider the below code snippet: Annotation Configuration: @Configuration\n@ComponentScan(\"com.interviewbit.constructordi\")\npublic class SpringAppConfig {\n   @Bean\n   public Shape shapes() {\n       return new Shapes(\"Rectangle\");\n   }\n   @Bean\n   public Dimension dimensions() {\n       return new Dimension(4,3);\n   }\n} @Configuration\n@ComponentScan(\"com.interviewbit.constructordi\")\npublic class SpringAppConfig {\n   @Bean\n   public Shape shapes() {\n       return new Shapes(\"Rectangle\");\n   }\n   @Bean\n   public Dimension dimensions() {\n       return new Dimension(4,3);\n   }\n} Here, the annotations are used for notifying the Spring runtime that the class specified with @Bean annotation is the provider of beans and the process of context scan needs to be performed on the package com.interviewbit.constructordi by means of @ComponentScan annotation. Next, we will be defining a Figure class component as below: @Bean com.interviewbit.constructordi @ComponentScan @Component\npublic class Figure {\n   private Shape shape;\n   private Dimension dimension;\n   \n   @Autowired\n   public Figure(Shape shape, Dimension dimension) {\n       this.shape = shape;\n       this.dimension = dimension;\n   }\n} @Component\npublic class Figure {\n   private Shape shape;\n   private Dimension dimension;\n   \n   @Autowired\n   public Figure(Shape shape, Dimension dimension) {\n       this.shape = shape;\n       this.dimension = dimension;\n   }\n} Spring encounters this Figure class while performing context scan and it initializes the instance of this class by invoking the constructor annotated with @Autowired. The Shape and Dimension instances are obtained by calling the methods annotated with @Bean in the SpringAppConfig class. Instances of Engine and Transmission will be obtained by calling @Bean annotated methods of the Config class. Finally, we need to bootstrap an ApplicationContext using our POJO configuration: @Autowired @Bean SpringAppConfig ApplicationContext context = new AnnotationConfigApplicationContext(SpringAppConfig.class);\nFigure figure = context.getBean(Figure.class); ApplicationContext context = new AnnotationConfigApplicationContext(SpringAppConfig.class);\nFigure figure = context.getBean(Figure.class); XML Configuration: This is another way of configuring Spring runtime by using the XML configuration file. For example, consider the below code snippet in the springAppConfig.xml file: XML Configuration <bean id=\"toyota\" class=\"com.interviewbit.constructordi.Figure\">\n   <constructor-arg index=\"0\" ref=\"shape\"/>\n   <constructor-arg index=\"1\" ref=\"dimension\"/>\n</bean>\n<bean id=\"shape\" class=\"com.interviewbit.constructordi.Shape\">\n   <constructor-arg index=\"0\" value=\"Rectangle\"/>\n</bean>\n<bean id=\"dimension\" class=\"com.interviewbit.constructordi.Dimension\">\n   <constructor-arg index=\"0\" value=\"4\"/>\n   <constructor-arg index=\"1\" value=\"3\"/>\n</bean> <bean id=\"toyota\" class=\"com.interviewbit.constructordi.Figure\">\n   <constructor-arg index=\"0\" ref=\"shape\"/>\n   <constructor-arg index=\"1\" ref=\"dimension\"/>\n</bean>\n<bean id=\"shape\" class=\"com.interviewbit.constructordi.Shape\">\n   <constructor-arg index=\"0\" value=\"Rectangle\"/>\n</bean>\n<bean id=\"dimension\" class=\"com.interviewbit.constructordi.Dimension\">\n   <constructor-arg index=\"0\" value=\"4\"/>\n   <constructor-arg index=\"1\" value=\"3\"/>\n</bean> The constructor-arg tag can accept either literal value or another bean’s reference and explicit index and type. The index and type arguments are used for resolving conflicts in cases of ambiguity.\nWhile bootstrapping this class, the Spring ApplicationContext needs to use ClassPathXmlApplicationContext as shown below: constructor-arg  ApplicationContext ClassPathXmlApplicationContext ApplicationContext context = new ClassPathXmlApplicationContext(\"springAppConfig.xml\");\nFigure figure = context.getBean(Figure.class); ApplicationContext context = new ClassPathXmlApplicationContext(\"springAppConfig.xml\");\nFigure figure = context.getBean(Figure.class); Setter-Based:\nThis form of DI is achieved when the Spring IoC container calls the bean’s setter method after a non-parameterized constructor is called to perform bean instantiation.\nIt is possible to achieve circular dependency using setter injection.\nFor achieving this type of DI, we need to configure it through the configuration file under the <property> tag. For example, consider a class InterviewBit that sets the property articles as shown below: Setter-Based:\nThis form of DI is achieved when the Spring IoC container calls the bean’s setter method after a non-parameterized constructor is called to perform bean instantiation.\nIt is possible to achieve circular dependency using setter injection.\nFor achieving this type of DI, we need to configure it through the configuration file under the <property> tag. For example, consider a class InterviewBit that sets the property articles as shown below: Setter-Based: This form of DI is achieved when the Spring IoC container calls the bean’s setter method after a non-parameterized constructor is called to perform bean instantiation.\nIt is possible to achieve circular dependency using setter injection.\nFor achieving this type of DI, we need to configure it through the configuration file under the <property> tag. For example, consider a class InterviewBit that sets the property articles as shown below: This form of DI is achieved when the Spring IoC container calls the bean’s setter method after a non-parameterized constructor is called to perform bean instantiation. It is possible to achieve circular dependency using setter injection. For achieving this type of DI, we need to configure it through the configuration file under the <property> tag. For example, consider a class InterviewBit that sets the property articles as shown below: <property> InterviewBit articles package com.interviewbit.model;\nimport com.interviewbit.model.Article;\npublic class InterviewBit {\n   // Object of the Article interface\n   Article article;\n   public void setArticle(Article article)\n   {\n       this.article = article;\n   }\n} package com.interviewbit.model;\nimport com.interviewbit.model.Article;\npublic class InterviewBit {\n   // Object of the Article interface\n   Article article;\n   public void setArticle(Article article)\n   {\n       this.article = article;\n   }\n} In the bean configuration file, we will be setting as below: <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\">\n   <bean id=\"InterviewBit\" class=\"com.interviewbit.model.InterviewBit\">\n       <property name=\"article\">\n           <ref bean=\"JsonArticle\" />\n       </property>\n   </bean>\n   <bean id=\"JsonArticle\" class=\"com.interviewbit.bean.JsonArticle\" />\n</beans> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\">\n   <bean id=\"InterviewBit\" class=\"com.interviewbit.model.InterviewBit\">\n       <property name=\"article\">\n           <ref bean=\"JsonArticle\" />\n       </property>\n   </bean>\n   <bean id=\"JsonArticle\" class=\"com.interviewbit.bean.JsonArticle\" />\n</beans> The ‘JsonArticle’ bean is injected into the InterviewBit class object by means of the setArticle method.\nIn cases where both types of dependencies are used, then the setter dependency injection has more preference by considering the specificity nature. setArticle ",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "16. What is the importance of the web.xml in Spring MVC?",
        "answer": "web.xml is also known as the Deployment Descriptor which has definitions of the servlets and their mappings, filters, and lifecycle listeners. It is also used for configuring the ContextLoaderListener. Whenever the application is deployed, a ContextLoaderListener instance is created by Servlet container which leads to a load of WebApplicationContext. web.xml",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "17. What is the role of @ModelAttribute annotation?",
        "answer": "The annotation plays a very important role in binding method parameters to the respective attribute that corresponds to a model. Then it reflects the same on the presentation page. The role of the annotation also depends on what the developer is using that for. In case, it is used at the method level, then that method is responsible for adding attributes to it. When used at a parameter level, it represents that the parameter value is meant to be retrieved from the model layer.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "18. What is the use of @Autowired annotation?",
        "answer": "@Autowired annotation is meant for the injection of a bean by means of its type along with methods and fields. This helps the Spring framework to resolve dependencies by injecting and collaborating the beans into another bean. For example, consider the below code snippet: @Autowired import org.Springframework.beans.factory.annotation.Autowired;\nimport java.util.*;\npublic class InterviewBit {\n   // Autowiring/Injecting FormatterUtil as dependency to InterviewBit class\n  @Autowired\n  private FormatterUtil formatterUtil;\n  \n  public Date something( String value ){\n     Date dateFormatted = formatterUtil.formatDate(value);\n     return dateFormatted\n   }\n}\n/**\n* Util class to format any string value to valid date format\n*/\npublic class FormatterUtil {\n   \n   public Date formatDate(String value){\n       //code to format date\n   }\n} import org.Springframework.beans.factory.annotation.Autowired;\nimport java.util.*;\npublic class InterviewBit {\n   // Autowiring/Injecting FormatterUtil as dependency to InterviewBit class\n  @Autowired\n  private FormatterUtil formatterUtil;\n  \n  public Date something( String value ){\n     Date dateFormatted = formatterUtil.formatDate(value);\n     return dateFormatted\n   }\n}\n/**\n* Util class to format any string value to valid date format\n*/\npublic class FormatterUtil {\n   \n   public Date formatDate(String value){\n       //code to format date\n   }\n}",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "19. What is the Model in Spring MVC?",
        "answer": "Model is a reference to have the data for rendering.\nIt is always created and passed to the view in Spring MVC. If a mapped controller method has Model as a parameter, then that model instance is automatically injected to that method.\nAny attributes set on the injected model would be preserved and passed to the View. Model is a reference to have the data for rendering. It is always created and passed to the view in Spring MVC. If a mapped controller method has Model as a parameter, then that model instance is automatically injected to that method. Any attributes set on the injected model would be preserved and passed to the View.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "20. What will be the selection state of a checkbox input if the user first checks the checkbox and gets validation errors in other fields and then unchecks the checkbox after getting the errors?",
        "answer": "The validation is generally performed during HTTP POST requests. During HTTP requests, if the state of the checkbox is unchecked, then HTTP includes the request parameter for the checkbox thereby not picking up the updated selection. This can be fixed by making use of a hidden form field that starts with _ in the Spring MVC. _ Conclusion: In this article, we have seen the most commonly asked Spring Interview Questions during an interview. Spring is a very powerful framework that allows building enterprise-level web applications. Applications developed using Spring are generally quick, scalable, and transparent. Due to this, Spring has been embraced by a huge Java Developer’s community thereby making it an inevitable part of any Java Developer’s Job Role. Knowing Spring ensures that an added advantage is with the developers to progress steadily in their careers too. Tip: We also recommend reading guides posted here. here",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "21. How is it possible to use the Tomcat JNDI DataSource in the Spring applications?",
        "answer": "To use the servlet container which is configured in the JNDI (Java Naming and Directory Interface) DataSource, the DataSource bean has to be configured in the spring bean config file and then injected into the beans as dependencies. Post this, the DataSource bean can be used for performing database operations by means of the JdbcTemplate. The syntax for registering a MySQL DataSource bean: <bean id=\"dataSource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\">\n   <property name=\"jndiName\" value=\"java:comp/env/jdbc/MySQLDB\"/>\n</bean> <bean id=\"dataSource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\">\n   <property name=\"jndiName\" value=\"java:comp/env/jdbc/MySQLDB\"/>\n</bean>",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "22. What do you understand by MultipartResolver?",
        "answer": "The MultipartResolver is used for handling the file upload scenarios in the Spring web application. There are 2 concrete implementations of this in Spring, they are: CommonsMultipartResolver meant for Jakarta Commons FileUpload\nStandardServletMultipartResolver meant for for Servlet 3.0 Part API CommonsMultipartResolver meant for Jakarta Commons FileUpload StandardServletMultipartResolver meant for for Servlet 3.0 Part API To implement this, we need to create a bean with id=“multipartResolver” in the application context of DispatcherServlet. Doing this ensures that all the requests handled by the DispatcherServlet have this resolver applied whenever a multipart request is detected. If a multipart request is detected by the DispatcherServlet, it resolves the request by means of the already configured MultipartResolver, and the request is passed on as a wrapped/abstract HttpServletRequest. Controllers then cast this request as the MultipartHttpServletRequest interface to get access to the Multipart files. The following diagram illustrates the flow clearly: MultipartHttpServletRequest  ",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "23. How are i18n and localization supported in Spring MVC?",
        "answer": "Spring MVC has LocaleResolver that supports i18n and localization. for supporting both internationalization and localization. The following beans need to be configured in the application: LocaleResolver SessionLocaleResolver: This bean plays a vital role to get and resolve the locales from the pre-defined attributes in the user session. SessionLocaleResolver: This bean plays a vital role to get and resolve the locales from the pre-defined attributes in the user session. SessionLocaleResolver: Syntax: <bean id=\"localeResolver\"class=\"org.Springframework.web.servlet.i18n.SessionLocaleResolver\">\n   <property name=\"defaultLocale\" value=\"en\" />\n</bean> <bean id=\"localeResolver\"class=\"org.Springframework.web.servlet.i18n.SessionLocaleResolver\">\n   <property name=\"defaultLocale\" value=\"en\" />\n</bean> LocaleChangeInterceptor: This bean is useful to resolve the parameter from the incoming request. LocaleChangeInterceptor: This bean is useful to resolve the parameter from the incoming request. LocaleChangeInterceptor: Syntax: <bean id=\"localeChangeInterceptor\"class=\"org.Springframework.web.servlet.i18n.LocaleChangeInterceptor\">\n   <property name=\"paramName\" value=\"lang\" />\n</bean> <bean id=\"localeChangeInterceptor\"class=\"org.Springframework.web.servlet.i18n.LocaleChangeInterceptor\">\n   <property name=\"paramName\" value=\"lang\" />\n</bean> DefaultAnnotationHandlerMapping: This refers to the HandlerMapping interface implementation which maps the handlers/interceptors based on the HTTP paths specified in the @RequestMapping at type or method level. DefaultAnnotationHandlerMapping: This refers to the HandlerMapping interface implementation which maps the handlers/interceptors based on the HTTP paths specified in the @RequestMapping at type or method level. DefaultAnnotationHandlerMapping: Syntax: <bean class=\"org.Springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\">\n   <property name=\"interceptors\">\n       <list>\n           <ref bean=\"localeChangeInterceptor\" />\n       </list>\n   </property>\n</bean> <bean class=\"org.Springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\">\n   <property name=\"interceptors\">\n       <list>\n           <ref bean=\"localeChangeInterceptor\" />\n       </list>\n   </property>\n</bean>",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "24. Differentiate between a Bean Factory and an Application Context.",
        "answer": "BeanFactory and the ApplicationContext are both Java interfaces. The difference is that the ApplicationContext extends the BeanFactory. BeanFactory provides both IoC and DI basic features whereas the ApplicationContext provides more advanced features. Following are the differences between these two: Category  BeanFactory ApplicationContext\nInternationalization (i18n) Does not provide support for i18n. Provides support for i18n.\nEvent Publishing Provides the ability to publish events to listener beans by using ContextStartedEvent and ContextStoppedEvent to publish context when it is started and stopped respectively. ApplicationContext supports event handling by means of the ApplicationListener interface and ApplicationEvent class.\nImplementations XMLBeanFactory is a popular implementation of BeanFactory. ClassPathXmlApplicationContext is a popular implementation of ApplicationContext. Also, Java uses WebApplicationContext that extends the interface and adds getServletContext() method.\nAutowiring For autowiring, beans have to be registered in the AutoWiredBeanPostProcessor API. Here, XML configuration can be done to achieve autowiring. Category  BeanFactory ApplicationContext\nInternationalization (i18n) Does not provide support for i18n. Provides support for i18n.\nEvent Publishing Provides the ability to publish events to listener beans by using ContextStartedEvent and ContextStoppedEvent to publish context when it is started and stopped respectively. ApplicationContext supports event handling by means of the ApplicationListener interface and ApplicationEvent class.\nImplementations XMLBeanFactory is a popular implementation of BeanFactory. ClassPathXmlApplicationContext is a popular implementation of ApplicationContext. Also, Java uses WebApplicationContext that extends the interface and adds getServletContext() method.\nAutowiring For autowiring, beans have to be registered in the AutoWiredBeanPostProcessor API. Here, XML configuration can be done to achieve autowiring. Category  BeanFactory ApplicationContext Category  BeanFactory ApplicationContext Category BeanFactory ApplicationContext Internationalization (i18n) Does not provide support for i18n. Provides support for i18n.\nEvent Publishing Provides the ability to publish events to listener beans by using ContextStartedEvent and ContextStoppedEvent to publish context when it is started and stopped respectively. ApplicationContext supports event handling by means of the ApplicationListener interface and ApplicationEvent class.\nImplementations XMLBeanFactory is a popular implementation of BeanFactory. ClassPathXmlApplicationContext is a popular implementation of ApplicationContext. Also, Java uses WebApplicationContext that extends the interface and adds getServletContext() method.\nAutowiring For autowiring, beans have to be registered in the AutoWiredBeanPostProcessor API. Here, XML configuration can be done to achieve autowiring. Internationalization (i18n) Does not provide support for i18n. Provides support for i18n. Internationalization (i18n) Does not provide support for i18n. Provides support for i18n. Event Publishing Provides the ability to publish events to listener beans by using ContextStartedEvent and ContextStoppedEvent to publish context when it is started and stopped respectively. ApplicationContext supports event handling by means of the ApplicationListener interface and ApplicationEvent class. Event Publishing Provides the ability to publish events to listener beans by using ContextStartedEvent and ContextStoppedEvent to publish context when it is started and stopped respectively. ApplicationContext supports event handling by means of the ApplicationListener interface and ApplicationEvent class. Implementations XMLBeanFactory is a popular implementation of BeanFactory. ClassPathXmlApplicationContext is a popular implementation of ApplicationContext. Also, Java uses WebApplicationContext that extends the interface and adds getServletContext() method. Implementations XMLBeanFactory is a popular implementation of BeanFactory. ClassPathXmlApplicationContext is a popular implementation of ApplicationContext. Also, Java uses WebApplicationContext that extends the interface and adds getServletContext() method. Autowiring For autowiring, beans have to be registered in the AutoWiredBeanPostProcessor API. Here, XML configuration can be done to achieve autowiring. Autowiring For autowiring, beans have to be registered in the AutoWiredBeanPostProcessor API. Here, XML configuration can be done to achieve autowiring.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "25. How to get ServletConfig and ServletContext objects in spring bean?",
        "answer": "This can be done by either implementing the spring-aware interfaces or by using the @Autowired annotation. @Autowired\nprivate ServletContext servletContext;\n@Autowired\nprivate ServletConfig servletConfig; @Autowired\nprivate ServletContext servletContext;\n@Autowired\nprivate ServletConfig servletConfig;",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "26. How is the form data validation done in Spring Web MVC Framework?",
        "answer": "Spring MVC does the task of data validation using the validator object which implements the Validator interface. In the custom validator class that we have created, we can use the utility methods of the ValidationUtils class like rejectIfEmptyOrWhitespace() or rejectIfEmpty() to perform validation of the form fields. rejectIfEmptyOrWhitespace() rejectIfEmpty() @Component\npublic class UserValidator implements Validator\n{\n   public boolean supports(Class clazz) {\n       return UserVO.class.isAssignableFrom(clazz);\n   }\n \n   public void validate(Object target, Errors errors)\n   {\n       ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\", \"Name is required.\");\n       ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"age\", \"error.age\", \"Age is required.\");\n       ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"phone\", \"error.phone\", \"Phone is required.\");\n   }\n} @Component\npublic class UserValidator implements Validator\n{\n   public boolean supports(Class clazz) {\n       return UserVO.class.isAssignableFrom(clazz);\n   }\n \n   public void validate(Object target, Errors errors)\n   {\n       ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\", \"Name is required.\");\n       ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"age\", \"error.age\", \"Age is required.\");\n       ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"phone\", \"error.phone\", \"Phone is required.\");\n   }\n} In the fields that are subject to validation, in case of errors, the validator methods would create field error and bind that to the field. To activate the custom validator as spring bean, then: We have to add the @Component annotation on the custom validator class and initiate the component scanning of the package containing the validator declarations by adding the below change: We have to add the @Component annotation on the custom validator class and initiate the component scanning of the package containing the validator declarations by adding the below change: <context:component-scan base-package=\"com.interviewbit.validators\"/> <context:component-scan base-package=\"com.interviewbit.validators\"/> OR The validator class can be registered in the context file directly as a bean as shown: <bean id=\"userValidator\" class=\"com.interviewbit.validators.UserValidator\" /> <bean id=\"userValidator\" class=\"com.interviewbit.validators.UserValidator\" />",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "27. What are the differences between @RequestParam and @PathVariable annotations?",
        "answer": "Even though both these annotations are used to extract some data from URL, there is a key difference between them.\nThe @RequestParam is used to extract query parameters that is anything after “?” in the URL.\nThe @PathVariable is used to extract the data present as part of the URI itself.]\nFor example, if the given URL is http://localhost:8080/InterviewBit/Spring/SpringMVC/?format=json, then you can access the query parameter “format” using the @RequestParam annotation and /Spring/{type} using the @PathVariable, which will give you SpringMVC. Even though both these annotations are used to extract some data from URL, there is a key difference between them.\nThe @RequestParam is used to extract query parameters that is anything after “?” in the URL.\nThe @PathVariable is used to extract the data present as part of the URI itself.]\nFor example, if the given URL is http://localhost:8080/InterviewBit/Spring/SpringMVC/?format=json, then you can access the query parameter “format” using the @RequestParam annotation and /Spring/{type} using the @PathVariable, which will give you SpringMVC. The @RequestParam is used to extract query parameters that is anything after “?” in the URL.\nThe @PathVariable is used to extract the data present as part of the URI itself.]\nFor example, if the given URL is http://localhost:8080/InterviewBit/Spring/SpringMVC/?format=json, then you can access the query parameter “format” using the @RequestParam annotation and /Spring/{type} using the @PathVariable, which will give you SpringMVC. The @RequestParam is used to extract query parameters that is anything after “?” in the URL. query parameters The @PathVariable is used to extract the data present as part of the URI itself.] For example, if the given URL is http://localhost:8080/InterviewBit/Spring/SpringMVC/?format=json, then you can access the query parameter “format” using the @RequestParam annotation and /Spring/{type} using the @PathVariable, which will give you SpringMVC. @RequestMapping(\"/Spring/{type}\")\npublic void getQuestions(@PathVariable(\"type\") String type, \n                        @RequestParam(value = \"format\", required = false) String format){\n   /* Some code */\n} @RequestMapping(\"/Spring/{type}\")\npublic void getQuestions(@PathVariable(\"type\") String type, \n                        @RequestParam(value = \"format\", required = false) String format){\n   /* Some code */\n}",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "28. What is ContextLoaderListener and what does it do?",
        "answer": "The ContextLoaderListener loads and creates the ApplicationContext, so a developer need not write explicit code to do create it. In short, it is a listener that aids to bootstrap Spring MVC.\nThe application context is where Spring bean resides. For a web application, there is a subclass called WebAppliationContext.\nThe lifecycle of the ApplicationContext is tied to the lifecycle of the ServletContext by using ContextLoaderListener. The ServletContext from the WebApplicationContext can be obtained using the getServletContext() method. The ContextLoaderListener loads and creates the ApplicationContext, so a developer need not write explicit code to do create it. In short, it is a listener that aids to bootstrap Spring MVC.\nThe application context is where Spring bean resides. For a web application, there is a subclass called WebAppliationContext. The application context is where Spring bean resides. For a web application, there is a subclass called WebAppliationContext. The application context is where Spring bean resides. For a web application, there is a subclass called WebAppliationContext. The lifecycle of the ApplicationContext is tied to the lifecycle of the ServletContext by using ContextLoaderListener. The ServletContext from the WebApplicationContext can be obtained using the getServletContext() method.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "29. Can you create a controller without using @Controller or @RestController annotations?",
        "answer": "Yes! You can create a controller without @Controller or @RestController annotations by annotating the Spring MVC Controller classes using the @Component annotation. In this case, the real job of request mapping to handler method is done using the @RequestMapping annotation. Yes! You can create a controller without @Controller or @RestController annotations by annotating the Spring MVC Controller classes using the @Component annotation. In this case, the real job of request mapping to handler method is done using the @RequestMapping annotation. @Component",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "30. What is the @Controller annotation used for?",
        "answer": "The @Controller is a stereotype Spring MVC annotation to define a Controller. The @Controller is a stereotype Spring MVC annotation to define a Controller.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "31. What is a View Resolver pattern and explain its significance in Spring MVC?",
        "answer": "It is a J2EE pattern that allows the applications to dynamically choose technology for rendering the data on the browser (View).\nAny technology like HTML, JSP, XSLT, JSF, or any other such technology can be used as View.\nThe View Resolver has the information of different views. The Controller returns the name of the View which is then passed to View Resolver by the DispatcherServlet for selecting the appropriate View technology and then the data is displayed.\nThe default ViewResolver used in Spring MVC is InternalResourceViewResolver. It is a J2EE pattern that allows the applications to dynamically choose technology for rendering the data on the browser (View).\nAny technology like HTML, JSP, XSLT, JSF, or any other such technology can be used as View. Any technology like HTML, JSP, XSLT, JSF, or any other such technology can be used as View. Any technology like HTML, JSP, XSLT, JSF, or any other such technology can be used as View. The View Resolver has the information of different views. The Controller returns the name of the View which is then passed to View Resolver by the DispatcherServlet for selecting the appropriate View technology and then the data is displayed. The default ViewResolver used in Spring MVC is InternalResourceViewResolver. InternalResourceViewResolver",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "32. What is DispatcherServlet in Spring MVC? In other words, can you explain the Spring MVC architecture?",
        "answer": "Spring MVC framework is built around a central servlet called DispatcherServlet that handles all the HTTP requests and responses. The DispatcherServlet does a lot more than that: It seamlessly integrates with the IoC container and allows you to use each feature of Spring in an easier manner.\nThe DispatcherServlet contacts HandlerMapping to call the appropriate Controller for processing the request on receiving it. Then, the controller calls appropriate service methods to set or process the Model data. The service processes the data and returns the view name to DispatcherServlet. DispatcherServlet then takes the help of ViewResolver and picks up the defined view for the request. Once the view is decided, the DispatcherServlet passes the Model data to View where it is finally rendered on the browser. It seamlessly integrates with the IoC container and allows you to use each feature of Spring in an easier manner. The DispatcherServlet contacts HandlerMapping to call the appropriate Controller for processing the request on receiving it. Then, the controller calls appropriate service methods to set or process the Model data. The service processes the data and returns the view name to DispatcherServlet. DispatcherServlet then takes the help of ViewResolver and picks up the defined view for the request. Once the view is decided, the DispatcherServlet passes the Model data to View where it is finally rendered on the browser.  ",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "33. What are the benefits of Spring MVC framework over other MVC frameworks?",
        "answer": "Clear separation of roles – There is a specialised dedicated object for every role.\nReusable business code logic – With Spring MVC, there is no need for duplicating the code. Existing objects can be used as commands instead of replicating them in order to extend a particular framework base class.\nSpring MVC framework provides customizable binding and validation.\nAlso provides customizable locale and theme resolution.\nSpring MVC supports customizable handler mapping and view resolution too. Clear separation of roles – There is a specialised dedicated object for every role. Reusable business code logic – With Spring MVC, there is no need for duplicating the code. Existing objects can be used as commands instead of replicating them in order to extend a particular framework base class. Spring MVC framework provides customizable binding and validation. Also provides customizable locale and theme resolution. Spring MVC supports customizable handler mapping and view resolution too.",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "34. What is the Spring MVC framework?",
        "answer": "Spring MVC is a request driven framework and one of the core components of the Spring framework.\nIt comes with ready to use loosely coupled components and elements that greatly aid developers in building flexible and robust web applications.\nThe MVC (Model - View - Controller) architecture separates and provides loose coupling between the different aspects of the application – input logic (Model), business logic (Controller), and UI logic (View). Spring MVC is a request driven framework and one of the core components of the Spring framework. It comes with ready to use loosely coupled components and elements that greatly aid developers in building flexible and robust web applications. The MVC (Model - View - Controller) architecture separates and provides loose coupling between the different aspects of the application – input logic (Model), business logic (Controller), and UI logic (View). MVC (Model - View - Controller) architecture MVC (Model - View - Controller) architecture",
        "reference": "interviewbit.com",
        "role": "spring"
    },
    {
        "question": "1) What is Spring?",
        "answer": "It is a lightweight, loosely coupled and integrated framework for developing enterprise applications in java.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "2) What are the advantages of spring framework?",
        "answer": "Predefined Templates\nLoose Coupling\nEasy to test\nLightweight\nFast Development\nPowerful Abstraction\nDeclarative support\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "3) What are the modules of spring framework?",
        "answer": "Test\nSpring Core Container\nAOP, Aspects and Instrumentation\nData Access/Integration\nWeb\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "4) What is IOC and DI?",
        "answer": "IOC (Inversion of Control) and DI (Dependency Injection) is a design pattern to provide loose coupling. It removes the dependency from the program.\nLet's write a code without following IOC and DI.\npublic class Employee{  \nAddress address;  \nEmployee(){  \naddress=new Address();//creating instance  \n}  \n}  \nNow, there is dependency between Employee and Address because Employee is forced to use the same address instance.\n\nLet's write the IOC or DI code.\npublic class Employee{  \nAddress address;  \nEmployee(Address address){  \nthis.address=address;//not creating instance  \n}  \n}  \nNow, there is no dependency between Employee and Address because Employee is not forced to use the same address instance. It can use any address instance.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "5) What is the role of IOC container in spring?",
        "answer": "IOC container is responsible to:\nADVERTISEMENT\ncreate the instance\nconfigure the instance, and\nassemble the dependencies\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "6) What are the types of IOC container in spring?",
        "answer": "There are two types of IOC containers in spring framework.\nBeanFactory\nApplicationContext\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "7) What is the difference between BeanFactory and ApplicationContext?",
        "answer": "BeanFactory is the basic container whereas ApplicationContext is the advanced container. ApplicationContext extends the BeanFactory interface. ApplicationContext provides more facilities than BeanFactory such as integration with spring AOP, message resource handling for i18n etc.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "8) What is the difference between constructor injection and setter injection?",
        "answer": "No. Constructor Injection Setter Injection\n1) No Partial Injection Partial Injection\n2) Desn't override the setter property Overrides the constructor property if both are defined.\n3) Creates new instance if any modification occurs Doesn't create new instance if you change the property value\n4) Better for too many properties Better for few properties.\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "9) What is autowiring in spring? What are the autowiring modes?",
        "answer": "Autowiring enables the programmer to inject the bean automatically. We don't need to write explicit injection logic.\nLet's see the code to inject bean using dependency injection.\n<bean id=\"emp\" class=\"com.javatpoint.Employee\" autowire=\"byName\" />  \nThe autowiring modes are given below:\nNo. Mode Description\n1) no this is the default mode, it means autowiring is not enabled.\n2) byName\ninjects the bean based on the property name. It uses setter method.\n3) byType injects the bean based on the property type. It uses setter method.\n4) constructor It injects the bean using constructor\nThe \"autodetect\" mode is deprecated since spring 3.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "10) What are the different bean scopes in spring?",
        "answer": "There are 5 bean scopes in spring framework.\nNo. Scope Description\n1) singleton The bean instance will be only once and same instance will be returned by the IOC container. It is the default scope.\n2) prototype The bean instance will be created each time when requested.\n3) request The bean instance will be created per HTTP request.\n4) session The bean instance will be created per HTTP session.\n5) globalsession The bean instance will be created per HTTP global session. It can be used in portlet context only.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "11) In which scenario, you will use singleton and prototype scope?",
        "answer": "Singleton scope should be used with EJB stateless session bean and prototype scope with EJB stateful session bean.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "12) What are the transaction management supports provided by spring?",
        "answer": "Spring framework provides two type of transaction management supports:\nProgrammatic Transaction Management: should be used for few transaction operations.\nDeclarative Transaction Management: should be used for many transaction operations.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "13) What are the advantages of JdbcTemplate in spring?",
        "answer": "Less code: By using the JdbcTemplate class, you don't need to create connection,statement,start transaction,commit transaction and close connection to execute different queries. You can execute the query directly.\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "14) What are classes for spring JDBC API?",
        "answer": "JdbcTemplate\nSimpleJdbcTemplate\nNamedParameterJdbcTemplate\nSimpleJdbcInsert\nSimpleJdbcCall\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "15) How can you fetch records by spring JdbcTemplate?",
        "answer": "You can fetch records from the database by the query method of JdbcTemplate. There are two interfaces to do this:\nResultSetExtractor\nRowMapper",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "16) What is the advantage of NamedParameterJdbcTemplate?",
        "answer": "NamedParameterJdbcTemplate class is used to pass value to the named parameter. A named parameter is better than ? (question mark of PreparedStatement).\nIt is better to remember.\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "17) What is the advantage of SimpleJdbcTemplate?",
        "answer": "The SimpleJdbcTemplate supports the feature of var-args and autoboxing.\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "18) What is AOP?",
        "answer": "AOP is an acronym for Aspect Oriented Programming. It is a methodology that divides the program logic into pieces or parts or concerns.\nIt increases the modularity and the key unit is Aspect.\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "19) What are the advantages of spring AOP?",
        "answer": "AOP enables you to dynamically add or remove concern before or after the business logic. It is pluggable and easy to maintain.\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "20) What are the AOP terminology?",
        "answer": "AOP terminologies or concepts are as follows:\nJoinPoint\nAdvice\nPointcut\nAspect\nIntroduction\nTarget Object\nInterceptor\nAOP Proxy\nWeaving\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "21) What is JoinPoint?",
        "answer": "JoinPoint is any point in your program such as field access, method execution, exception handling etc.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "22) Does spring framework support all JoinPoints?",
        "answer": "No, spring framework supports method execution joinpoint only.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "23) What is Advice?",
        "answer": "Advice represents action taken by aspect.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "24) What are the types of advice in AOP?",
        "answer": "There are 5 types of advices in spring AOP.\nBefore Advice\nAfter Advice\nAfter Returning Advice\nThrows Advice\nAround Advice",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "25) What is Pointcut?",
        "answer": "Pointcut is expression language of Spring AOP.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "26) What is Aspect?",
        "answer": "Aspect is a class in spring AOP that contains advices and joinpoints.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "27) What is Introduction?",
        "answer": "Introduction represents introduction of new fields and methods for a type.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "28) What is target object?",
        "answer": "Target Object is a proxy object that is advised by one or more aspects.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "29) What is interceptor?",
        "answer": "Interceptor is a class like aspect that contains one advice only.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "30) What is weaving?",
        "answer": "Weaving is a process of linking aspect with other application.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "31) Does spring perform weaving at compile time?",
        "answer": "No, spring framework performs weaving at runtime.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "32) What are the AOP implementation?",
        "answer": "There are 3 AOP implementation.\nSpring AOP\nApache AspectJ\nJBoss AOP",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "33) What is the front controller class of Spring MVC?",
        "answer": "The DispatcherServlet class works as the front controller in Spring MVC.\nMore details...",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "34) What does @Controller annotation?",
        "answer": "The @Controller annotation marks the class as controller class. It is applied on the class.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "35) What does @RequestMapping annotation?",
        "answer": "The @RequestMapping annotation maps the request with the method. It is applied on the method.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "36) What does the ViewResolver class?",
        "answer": "The View Resolver class resolves the view component to be invoked for the request. It defines prefix and suffix properties to resolve the view component.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "37) Which ViewResolver class is widely used?",
        "answer": "The org.springframework.web.servlet.view.InternalResourceViewResolver class is widely used.",
        "reference": "javatpoint.com",
        "role": "spring"
    },
    {
        "question": "38) Does spring MVC provide validation support?",
        "answer": "Yes.",
        "reference": "javatpoint.com",
        "role": "spring"
    }
]