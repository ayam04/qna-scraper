[
    {
        "question": "1. Explain about the “when” keyword in the context of Kotlin.",
        "answer": "The “when” keyword is used in Kotlin to substitute the switch operator in other languages such as Java. When a certain condition is met, a specific block of code must be run. Inside the when expression, it compares all of the branches one by one until a match is discovered. After finding the first match, it proceeds to the conclusion of the when block and executes the code immediately following the when block. We do not need a break statement at the end of each case, unlike switch cases in Java or any other programming language.   For example, // KOTLIN\nfun main(args: Array<String>) {\n   \n   var temp = \"Interview\"\n   when(temp) {\n       \"Interview\" -> println(\"Interview Bit is the solution.\")\n       \"Job\" -> println(\"Interview is the solution.\")\n       \"Success\" -> println(\"Hard Work is the solution.\")\n   }\n} // KOTLIN\nfun main(args: Array<String>) {\n   \n   var temp = \"Interview\"\n   when(temp) {\n       \"Interview\" -> println(\"Interview Bit is the solution.\")\n       \"Job\" -> println(\"Interview is the solution.\")\n       \"Success\" -> println(\"Hard Work is the solution.\")\n   }\n} Output:- Output:- Interview Bit is the solution. Interview Bit is the solution. Explanation:- In the above code, the variable temp has the value “Interview”. The when condition matches for the exact value as that of temp’s and executes the corresponding code statements. Thus, “Interview Bit is the solution” is printed. Explanation:-",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "2. What are the advantages of Kotlin over Java?",
        "answer": "Following are the advantages of Kotlin over Java:-   Data class: In Java, you must create getters and setters for each object, as well as properly write hashCode (or allow the IDE to build it for you, which you must do every time you update the class), toString, and equals. Alternatively, you could utilize lombok, but that has its own set of issues. In Kotlin, data classes take care of everything.\nPatterns of getter and setter: In Java, for each variable, you use it for, rewrite the getter and setter methods. You don't have to write getter and setter in kotlin, and if you must, custom getter and setter take a lot less typing. There are additional delegates for identical getters and setters.\nExtension Functions: In Java, there is no support for extension functions. Kotlin on the other hand provides support for extension functions which makes the code more clear and cleaner.\nSupport for one common codebase: You may extract one common codebase that will target all of them at the same time using the Kotlin Multi-Platform framework.\nSupport for Null Safety: Kotlin has built-in null safety support, which is a lifesaver, especially on Android, which is full of old Java-style APIs.\nLess prone to errors: There is less space for error because it is more concise and expressive than Java. Data class: In Java, you must create getters and setters for each object, as well as properly write hashCode (or allow the IDE to build it for you, which you must do every time you update the class), toString, and equals. Alternatively, you could utilize lombok, but that has its own set of issues. In Kotlin, data classes take care of everything. Data class: Patterns of getter and setter: In Java, for each variable, you use it for, rewrite the getter and setter methods. You don't have to write getter and setter in kotlin, and if you must, custom getter and setter take a lot less typing. There are additional delegates for identical getters and setters. Patterns of getter and setter: Extension Functions: In Java, there is no support for extension functions. Kotlin on the other hand provides support for extension functions which makes the code more clear and cleaner. Extension Functions: Support for one common codebase: You may extract one common codebase that will target all of them at the same time using the Kotlin Multi-Platform framework. Support for one common codebase: Support for Null Safety: Kotlin has built-in null safety support, which is a lifesaver, especially on Android, which is full of old Java-style APIs. Support for Null Safety: Less prone to errors: There is less space for error because it is more concise and expressive than Java. Less prone to errors:",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "3. What are the various data types available in Kotlin? Explain them.",
        "answer": "Primitive data types are the most basic data types in Kotlin, and all others are reference types like array and string. Kotlin contains all data types as objects. Following are the different data types available in Kotlin:-   Integer Data Type - Integer Data Type - Data Type Space Required\nbyte 8 bits\nshort 16 bits\nint 32 bits\nlong 64 bits Data Type Space Required\nbyte 8 bits\nshort 16 bits\nint 32 bits\nlong 64 bits Data Type Space Required Data Type Space Required Data Type Space Required byte 8 bits\nshort 16 bits\nint 32 bits\nlong 64 bits byte 8 bits byte 8 bits short 16 bits short 16 bits int 32 bits int 32 bits long 64 bits long 64 bits Floating Point Data Type - Floating Point Data Type - Data Type Space Required\nfloat 32 bits\ndouble 64 bits Data Type Space Required\nfloat 32 bits\ndouble 64 bits Data Type Space Required Data Type Space Required Data Type Space Required float 32 bits\ndouble 64 bits float 32 bits float 32 bits double 64 bits double 64 bits Boolean Data Type - Boolean Data Type - True or false is the only bit of information represented by the Boolean data type. In Kotlin, the Boolean type is the same as in Java. Data Type Space Required\nboolean 1 bit Data Type Space Required\nboolean 1 bit Data Type Space Required Data Type Space Required Data Type Space Required boolean 1 bit boolean 1 bit boolean 1 bit Character Data Type - Character Data Type - Small letters (a-z), capital letters (A-Z), numerals (0-9), and other symbols are represented by the character data type. Data Type Space Required\nchar 8 bits Data Type Space Required\nchar 8 bits Data Type Space Required Data Type Space Required Data Type Space Required char 8 bits char 8 bits char 8 bits String Data Type - String Data Type - Strings are represented in Kotlin by the type String. A string value is often a sequence of characters enclosed in double quotations (\"). The space required in this case depends on the number of characters in the string. Array Data Type - Array Data Type - The Array class in Kotlin is used to represent arrays. It has the get and set functions that, due to operator overloading conventions, can be used as  ‘[]’  as well. The space required by the array also depends on the number of elements it posses. Array class",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "4. Differentiate between open and public keywords in Kotlin.",
        "answer": "The keyword “open” refers to the term \"open for expansion\". The open annotation on a class is the polar opposite of the final annotation in Java: it allows others to inherit from it. By default, a class cannot be inherited in Kotlin. In Kotlin, an open method signifies that it can be overridden, whereas it cannot be by default. Instead, any methods in Java can be overridden by default. In Kotlin, all the classes are final by default. If no visibility modifier is specified, the public is used by default, which means our declarations will be accessible everywhere inside the program.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "5. What do you understand about Companion Object in the context of Kotlin?",
        "answer": "In some languages, such as Java, the static keyword is used to declare class members and utilise them without creating an object, i.e. by simply calling them by their class name. In Kotlin, there is nothing called the “static” keyword. So, if we want to achieve the functionality of static member functions, we use the companion objects. This is also referred to as Object Extension.   We must use the companion keyword in front of the object definition to construct a companion object. // Syntax in KOTLIN\nclass CompanionClass {\n\n    companion object CompanionObjectName {\n      // code\n    }\n}\nval obj = CompanionClass.CompanionObjectName // Syntax in KOTLIN\nclass CompanionClass {\n\n    companion object CompanionObjectName {\n      // code\n    }\n}\nval obj = CompanionClass.CompanionObjectName We can also remove the CompanionObject name and replace it with the term companion, resulting in the companion object's default name being Companion, as shown below: // KOTLIN\nclass CompanionClass {\n   companion object {\n     // code\n   }\n}\nval obj = CompanionClass.Companion // KOTLIN\nclass CompanionClass {\n   companion object {\n     // code\n   }\n}\nval obj = CompanionClass.Companion All the required static member functions and member variables can be kept inside the companion object created. For example, class Sample {\n   companion object Test {\n       var a: Int = 1\n       fun testFunction() = println(\"Companion Object’s Member function called.\")\n   }\n}\nfun main(args: Array<String>) {\n   println(Sample.a)\n   Sample.testFunction()\n} class Sample {\n   companion object Test {\n       var a: Int = 1\n       fun testFunction() = println(\"Companion Object’s Member function called.\")\n   }\n}\nfun main(args: Array<String>) {\n   println(Sample.a)\n   Sample.testFunction()\n} Output:- Output:- 1\nCompanion Object’s Member function called. 1\nCompanion Object’s Member function called.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "6. What do you understand about function extension in the context of Kotlin? Explain.",
        "answer": "In Kotlin, we can add or delete method functionality using extensions, even without inheriting or altering them. Extensions are statistically resolved. It provides a callable function that may be invoked with a dot operation, rather than altering the existing class.   Function Extension - Kotlin allows users to specify a method outside of the main class via function extension. We'll see how the extension is implemented at the functional level in the following example: Function Extension - // KOTLIN\nclass Sample {\n var str : String = \"null\"\n   \n fun printStr() {\n     print(str)\n }        \n}\nfun main(args: Array<String>) {\n var  a = Sample()\n a.str = \"Interview\"\n var  b = Sample()\n b.str = \"Bit\"\n var  c = Sample()\n c.str = a.add(b)\n c.printStr()\n}\n// function extension\nfun Sample.add(a : Sample):String{\n var temp = Sample()\n temp.str = this.str + \" \" +a.str\n return temp.str\n} // KOTLIN\nclass Sample {\n var str : String = \"null\"\n   \n fun printStr() {\n     print(str)\n }        \n}\nfun main(args: Array<String>) {\n var  a = Sample()\n a.str = \"Interview\"\n var  b = Sample()\n b.str = \"Bit\"\n var  c = Sample()\n c.str = a.add(b)\n c.printStr()\n}\n// function extension\nfun Sample.add(a : Sample):String{\n var temp = Sample()\n temp.str = this.str + \" \" +a.str\n return temp.str\n} Output:- Output:- Interview Bit Interview Bit Explanation:- Explanation:- We don't have a method named \"addStr\" inside the \"Sample\" class in the preceding example, but we are implementing the same method outside of the class. This is all because of function extension.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "7. How can you concatenate two strings in Kotlin?",
        "answer": "Following are the different ways by which we can concatenate two strings in Kotlin:   Using String Interpolation:- We use the technique of string interpolation to concatenate the two strings. Basically, we substitute the strings in place of their placeholders in the initialisation of the third string. Using String Interpolation:- val s1 = \"Interview\"\nval s2 = \"Bit\"\nval s3 = \"$s1 $s2\" // stores \"Interview Bit\" val s1 = \"Interview\"\nval s2 = \"Bit\"\nval s3 = \"$s1 $s2\" // stores \"Interview Bit\" Using the + or plus() operator:- We use the ‘+’ operator to concatenate the two strings and store them in a third variable. Using the + or plus() operator:- val s1 = \"Interview\"\nval s2 = \"Bit\"\nval s3 = s1 + s2 // stores \"InterviewBit\"\nval s4 = s1.plus(s2) // stores \"InterviewBit\" val s1 = \"Interview\"\nval s2 = \"Bit\"\nval s3 = s1 + s2 // stores \"InterviewBit\"\nval s4 = s1.plus(s2) // stores \"InterviewBit\" Using StringBuilder:- We concatenate two strings using the StringBuilder object. First, we append the first string and then the second string. Using StringBuilder:- val s1 = \"Interview\"\nval s2 = \"Bit\"\nval s3 =  StringBuilder()     \ns3.append(s1).append(s2)\nval s4 = s3.toString() // stores \"InterviewBit\" val s1 = \"Interview\"\nval s2 = \"Bit\"\nval s3 =  StringBuilder()     \ns3.append(s1).append(s2)\nval s4 = s3.toString() // stores \"InterviewBit\"",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "8. Explain the various methods to iterate over any data structure in Kotlin with examples.",
        "answer": "Following are the different ways to iterate over any data structure in Kotlin : For Loop - The for loop is used to scan any data structure that supplies an iterator in this case. It is not used in the same way as the for loop in other programming languages such as Java or C. For Loop - The for loop is used to scan any data structure that supplies an iterator in this case. It is not used in the same way as the for loop in other programming languages such as Java or C. For Loop - In Kotlin, the for loop has the following Syntax: Syntax for(item in collection) {\n     // code \n} for(item in collection) {\n     // code \n} Here, collection refers to the data structure to be iterated and item refers to each element of the data structure. For example, // KOTLIN\nfun main(args: Array<String>) {\n   var numbersArray = arrayOf(1,2,3,4,5,6,7,8,9,10)\n \n   for (num in numbersArray){\n       if(num % 2 == 0){\n           print(\"$num \")\n       }\n   }\n} // KOTLIN\nfun main(args: Array<String>) {\n   var numbersArray = arrayOf(1,2,3,4,5,6,7,8,9,10)\n \n   for (num in numbersArray){\n       if(num % 2 == 0){\n           print(\"$num \")\n       }\n   }\n} Output - Output - 2 4 6 8 10 2 4 6 8 10 While Loop - It is made up of a code block and a condition to be checked for each iteration. First, the while condition is assessed, and if it is true, the code within the block is executed. Because the condition is verified every time before entering the block, it repeats until the condition turns false. The while loop can be thought of as a series of if statements that are repeated. While Loop - It is made up of a code block and a condition to be checked for each iteration. First, the while condition is assessed, and if it is true, the code within the block is executed. Because the condition is verified every time before entering the block, it repeats until the condition turns false. The while loop can be thought of as a series of if statements that are repeated. While Loop - The while loop's syntax is as follows: while(condition) {\n         // code \n} while(condition) {\n         // code \n} For example, // KOTLIN\nfun main(args: Array<String>) {\n   var number = 1\n   while(number <= 5) {\n       println(number)\n       number++;\n   }\n} // KOTLIN\nfun main(args: Array<String>) {\n   var number = 1\n   while(number <= 5) {\n       println(number)\n       number++;\n   }\n} Output - Output - 1\n2\n3\n4\n5 1\n2\n3\n4\n5 Do While Loop - The condition is assessed after all of the statements inside the block have been executed. If the do-while condition is true, the code block is re-executed. As long as the expression evaluates to true, the code block execution procedure is repeated. The loop ends if the expression becomes false, and control is passed to the sentence following the do-while loop. Because it verifies the condition after the block is executed, it's also known as a post-test loop. Do While Loop - The condition is assessed after all of the statements inside the block have been executed. If the do-while condition is true, the code block is re-executed. As long as the expression evaluates to true, the code block execution procedure is repeated. The loop ends if the expression becomes false, and control is passed to the sentence following the do-while loop. Because it verifies the condition after the block is executed, it's also known as a post-test loop. Do While Loop - The do-while loop's syntax is as follows: do {\n     // code \n{\nwhile(condition) do {\n     // code \n{\nwhile(condition) For example, // KOTLIN\nfun main(args: Array<String>) {\n   var number = 4\n   var sum = 0\n \n   do {\n       sum += number\n       number--\n   }while(number > 0)\n   println(\"Sum of first four natural numbers is $sum\")\n} // KOTLIN\nfun main(args: Array<String>) {\n   var number = 4\n   var sum = 0\n \n   do {\n       sum += number\n       number--\n   }while(number > 0)\n   println(\"Sum of first four natural numbers is $sum\")\n} Output - Output - Sum of first four natural numbers is 10 Sum of first four natural numbers is 10",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "9. What are the different types of constructors available in Kotlin? Explain them with proper examples.",
        "answer": "There are two types of Kotlin constructors:   Primary Constructor  - This type of constructor is initialised in the class header and is provided after the class name. It is declared using the “constructor” keyword. Parameters are optional in this type of constructor. For example, Primary Constructor  - This type of constructor is initialised in the class header and is provided after the class name. It is declared using the “constructor” keyword. Parameters are optional in this type of constructor. For example, Primary Constructor  - class Sample constructor(val a: Int, val b: Int) {\n   // code\n} class Sample constructor(val a: Int, val b: Int) {\n   // code\n} If no annotations or access modifiers are provided, the constructor keyword can be omitted. The initialization code can be placed in a separate initializer block prefixed with the init keyword because the primary constructor cannot contain any code. For example, // KOTLIN\nfun main(args: Array<String>) {\n   val s1 = Sample(1, 2)\n}\nclass Sample(a : Int , b: Int) {\n   val p: Int\n   var q: Int\n   // initializer block\n   init {\n       p = a\n       q = b\n       println(\"The first parameter value is : $p\")\n       println(\"The second parameter value is : $q\")\n   }\n} // KOTLIN\nfun main(args: Array<String>) {\n   val s1 = Sample(1, 2)\n}\nclass Sample(a : Int , b: Int) {\n   val p: Int\n   var q: Int\n   // initializer block\n   init {\n       p = a\n       q = b\n       println(\"The first parameter value is : $p\")\n       println(\"The second parameter value is : $q\")\n   }\n} Output:- Output:- The first parameter value is: 1\nThe second parameter value is: 2 The first parameter value is: 1\nThe second parameter value is: 2 Explanation - The values 1 and 2 are supplied to the constructor arguments a and b when the object s1 is created for the class Sample. In the class p and q, two attributes are specified. The initializer block is called when an object is created, and it not only sets up the attributes but also prints them to the standard output. Explanation - a b s1 p q Secondary Constructor - Secondary constructors allow for the initialization of variables as well as the addition of logic to the class. They have the constructor keyword prefixed to them. For example, Secondary Constructor - Secondary constructors allow for the initialization of variables as well as the addition of logic to the class. They have the constructor keyword prefixed to them. For example, Secondary Constructor - // KOTLIN\nfun main(args: Array<String>) {\n   val s1 = Sample(1, 2)\n}\nclass Sample {\n   constructor(a: Int, b: Int) {\n       println(\"The first parameter value is : $p\")\n       println(\"The second parameter value is : $q\")\n   }\n} // KOTLIN\nfun main(args: Array<String>) {\n   val s1 = Sample(1, 2)\n}\nclass Sample {\n   constructor(a: Int, b: Int) {\n       println(\"The first parameter value is : $p\")\n       println(\"The second parameter value is : $q\")\n   }\n} Output:- Output:- The first parameter value is: 1\nThe second parameter value is: 2 The first parameter value is: 1\nThe second parameter value is: 2 The compiler determines which secondary constructor will be called based on the inputs provided. We don't specify which constructor to use in the above program, so the compiler chooses for us. In Kotlin, a class can contain one or more secondary constructors and at most one primary constructor. The primary constructor initializes the class, while the secondary constructor initialises the class and adds some additional logic.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "10. Differentiate between Kotlin and Java.",
        "answer": "  Following are the differences between Kotlin and Java:- Kotlin and Java Basis Kotlin Java\nNull Safety By default, all sorts of variables in Kotlin are non-nullable (that is, we can't assign null values to any variables or objects). Kotlin code will fail to build if we try to assign or return null values. If we absolutely want a null value for a variable, we can declare it as follows: value num: Int? = null  NullPointerExceptions are a big source of annoyance for Java developers. Users can assign null to any variable, however, when accessing an object reference with a null value, a null pointer exception is thrown, which the user must manage.\nCoroutines Support  We can perform long-running expensive tasks in several threads in Kotlin, but we also have coroutines support, which halt execution at a given moment without blocking threads while doing long-running demanding operations. The corresponding thread in Java will be blocked anytime we launch a long-running network I/0 or CPU-intensive task. Android is a single-threaded operating system by default. Java allows you to create and execute numerous threads in the background, but managing them is a difficult operation.\nData Classes  If we need to have data-holding classes in Kotlin, we may define a class with the keyword \"data\" in the class declaration, and the compiler will take care of everything, including constructing constructors, getter, and setter methods for various fields. Let's say we need a class in Java that only holds data and nothing else. Constructors, variables to store data, getter and setter methods, hashcode(), function toString(), and equals() functions are all required to be written explicitly by the developer.\nFunctional Programming Kotlin is procedural and functional programming (a programming paradigm where we aim to bind everything in functional units) language that has numerous useful features such as lambda expressions, operator overloading, higher-order functions, and lazy evaluation, among others. Java does not allow functional programming until Java 8, however it does support a subset of Java 8 features when developing Android apps.\nExtension Functions Kotlin gives developers the ability to add new functionality to an existing class. By prefixing the name of a class to the name of the new function, we can build extended functions. In Java, we must create a new class and inherit the parent class if we want to enhance the functionality of an existing class. As a result, Java does not have any extension functions.\nData Type Inference  We don't have to declare the type of each variable based on the assignment it will handle in Kotlin. We can specify explicitly if we want to. When declaring variables in Java, we must declare the type of each variable explicitly.\nSmart Casting Smart casts in Kotlin will take care of these casting checks with the keyword \"is-checks,\" which checks for immutable values and conducts implicit casting. We must examine the type of variables in Java and cast them appropriately for our operation.\nChecked Exceptions We don't have checked exceptions in Kotlin. As a result, developers do not need to declare or catch exceptions, which has both benefits and drawbacks. We have checked exceptions support in Java, which enables developers to declare and catch exceptions, resulting in more robust code with better error handling. Basis Kotlin Java\nNull Safety By default, all sorts of variables in Kotlin are non-nullable (that is, we can't assign null values to any variables or objects). Kotlin code will fail to build if we try to assign or return null values. If we absolutely want a null value for a variable, we can declare it as follows: value num: Int? = null  NullPointerExceptions are a big source of annoyance for Java developers. Users can assign null to any variable, however, when accessing an object reference with a null value, a null pointer exception is thrown, which the user must manage.\nCoroutines Support  We can perform long-running expensive tasks in several threads in Kotlin, but we also have coroutines support, which halt execution at a given moment without blocking threads while doing long-running demanding operations. The corresponding thread in Java will be blocked anytime we launch a long-running network I/0 or CPU-intensive task. Android is a single-threaded operating system by default. Java allows you to create and execute numerous threads in the background, but managing them is a difficult operation.\nData Classes  If we need to have data-holding classes in Kotlin, we may define a class with the keyword \"data\" in the class declaration, and the compiler will take care of everything, including constructing constructors, getter, and setter methods for various fields. Let's say we need a class in Java that only holds data and nothing else. Constructors, variables to store data, getter and setter methods, hashcode(), function toString(), and equals() functions are all required to be written explicitly by the developer.\nFunctional Programming Kotlin is procedural and functional programming (a programming paradigm where we aim to bind everything in functional units) language that has numerous useful features such as lambda expressions, operator overloading, higher-order functions, and lazy evaluation, among others. Java does not allow functional programming until Java 8, however it does support a subset of Java 8 features when developing Android apps.\nExtension Functions Kotlin gives developers the ability to add new functionality to an existing class. By prefixing the name of a class to the name of the new function, we can build extended functions. In Java, we must create a new class and inherit the parent class if we want to enhance the functionality of an existing class. As a result, Java does not have any extension functions.\nData Type Inference  We don't have to declare the type of each variable based on the assignment it will handle in Kotlin. We can specify explicitly if we want to. When declaring variables in Java, we must declare the type of each variable explicitly.\nSmart Casting Smart casts in Kotlin will take care of these casting checks with the keyword \"is-checks,\" which checks for immutable values and conducts implicit casting. We must examine the type of variables in Java and cast them appropriately for our operation.\nChecked Exceptions We don't have checked exceptions in Kotlin. As a result, developers do not need to declare or catch exceptions, which has both benefits and drawbacks. We have checked exceptions support in Java, which enables developers to declare and catch exceptions, resulting in more robust code with better error handling. Basis Kotlin Java Basis Kotlin Java Basis Kotlin Java Null Safety By default, all sorts of variables in Kotlin are non-nullable (that is, we can't assign null values to any variables or objects). Kotlin code will fail to build if we try to assign or return null values. If we absolutely want a null value for a variable, we can declare it as follows: value num: Int? = null  NullPointerExceptions are a big source of annoyance for Java developers. Users can assign null to any variable, however, when accessing an object reference with a null value, a null pointer exception is thrown, which the user must manage.\nCoroutines Support  We can perform long-running expensive tasks in several threads in Kotlin, but we also have coroutines support, which halt execution at a given moment without blocking threads while doing long-running demanding operations. The corresponding thread in Java will be blocked anytime we launch a long-running network I/0 or CPU-intensive task. Android is a single-threaded operating system by default. Java allows you to create and execute numerous threads in the background, but managing them is a difficult operation.\nData Classes  If we need to have data-holding classes in Kotlin, we may define a class with the keyword \"data\" in the class declaration, and the compiler will take care of everything, including constructing constructors, getter, and setter methods for various fields. Let's say we need a class in Java that only holds data and nothing else. Constructors, variables to store data, getter and setter methods, hashcode(), function toString(), and equals() functions are all required to be written explicitly by the developer.\nFunctional Programming Kotlin is procedural and functional programming (a programming paradigm where we aim to bind everything in functional units) language that has numerous useful features such as lambda expressions, operator overloading, higher-order functions, and lazy evaluation, among others. Java does not allow functional programming until Java 8, however it does support a subset of Java 8 features when developing Android apps.\nExtension Functions Kotlin gives developers the ability to add new functionality to an existing class. By prefixing the name of a class to the name of the new function, we can build extended functions. In Java, we must create a new class and inherit the parent class if we want to enhance the functionality of an existing class. As a result, Java does not have any extension functions.\nData Type Inference  We don't have to declare the type of each variable based on the assignment it will handle in Kotlin. We can specify explicitly if we want to. When declaring variables in Java, we must declare the type of each variable explicitly.\nSmart Casting Smart casts in Kotlin will take care of these casting checks with the keyword \"is-checks,\" which checks for immutable values and conducts implicit casting. We must examine the type of variables in Java and cast them appropriately for our operation.\nChecked Exceptions We don't have checked exceptions in Kotlin. As a result, developers do not need to declare or catch exceptions, which has both benefits and drawbacks. We have checked exceptions support in Java, which enables developers to declare and catch exceptions, resulting in more robust code with better error handling. Null Safety By default, all sorts of variables in Kotlin are non-nullable (that is, we can't assign null values to any variables or objects). Kotlin code will fail to build if we try to assign or return null values. If we absolutely want a null value for a variable, we can declare it as follows: value num: Int? = null  NullPointerExceptions are a big source of annoyance for Java developers. Users can assign null to any variable, however, when accessing an object reference with a null value, a null pointer exception is thrown, which the user must manage. Null Safety By default, all sorts of variables in Kotlin are non-nullable (that is, we can't assign null values to any variables or objects). Kotlin code will fail to build if we try to assign or return null values. If we absolutely want a null value for a variable, we can declare it as follows: value num: Int? = null NullPointerExceptions are a big source of annoyance for Java developers. Users can assign null to any variable, however, when accessing an object reference with a null value, a null pointer exception is thrown, which the user must manage. Coroutines Support  We can perform long-running expensive tasks in several threads in Kotlin, but we also have coroutines support, which halt execution at a given moment without blocking threads while doing long-running demanding operations. The corresponding thread in Java will be blocked anytime we launch a long-running network I/0 or CPU-intensive task. Android is a single-threaded operating system by default. Java allows you to create and execute numerous threads in the background, but managing them is a difficult operation. Coroutines Support We can perform long-running expensive tasks in several threads in Kotlin, but we also have coroutines support, which halt execution at a given moment without blocking threads while doing long-running demanding operations. The corresponding thread in Java will be blocked anytime we launch a long-running network I/0 or CPU-intensive task. Android is a single-threaded operating system by default. Java allows you to create and execute numerous threads in the background, but managing them is a difficult operation. Data Classes  If we need to have data-holding classes in Kotlin, we may define a class with the keyword \"data\" in the class declaration, and the compiler will take care of everything, including constructing constructors, getter, and setter methods for various fields. Let's say we need a class in Java that only holds data and nothing else. Constructors, variables to store data, getter and setter methods, hashcode(), function toString(), and equals() functions are all required to be written explicitly by the developer. Data Classes If we need to have data-holding classes in Kotlin, we may define a class with the keyword \"data\" in the class declaration, and the compiler will take care of everything, including constructing constructors, getter, and setter methods for various fields. Let's say we need a class in Java that only holds data and nothing else. Constructors, variables to store data, getter and setter methods, hashcode(), function toString(), and equals() functions are all required to be written explicitly by the developer. Functional Programming Kotlin is procedural and functional programming (a programming paradigm where we aim to bind everything in functional units) language that has numerous useful features such as lambda expressions, operator overloading, higher-order functions, and lazy evaluation, among others. Java does not allow functional programming until Java 8, however it does support a subset of Java 8 features when developing Android apps. Functional Programming Kotlin is procedural and functional programming (a programming paradigm where we aim to bind everything in functional units) language that has numerous useful features such as lambda expressions, operator overloading, higher-order functions, and lazy evaluation, among others. Java does not allow functional programming until Java 8, however it does support a subset of Java 8 features when developing Android apps. Extension Functions Kotlin gives developers the ability to add new functionality to an existing class. By prefixing the name of a class to the name of the new function, we can build extended functions. In Java, we must create a new class and inherit the parent class if we want to enhance the functionality of an existing class. As a result, Java does not have any extension functions. Extension Functions Kotlin gives developers the ability to add new functionality to an existing class. By prefixing the name of a class to the name of the new function, we can build extended functions. In Java, we must create a new class and inherit the parent class if we want to enhance the functionality of an existing class. As a result, Java does not have any extension functions. Data Type Inference  We don't have to declare the type of each variable based on the assignment it will handle in Kotlin. We can specify explicitly if we want to. When declaring variables in Java, we must declare the type of each variable explicitly. Data Type Inference We don't have to declare the type of each variable based on the assignment it will handle in Kotlin. We can specify explicitly if we want to. When declaring variables in Java, we must declare the type of each variable explicitly. Smart Casting Smart casts in Kotlin will take care of these casting checks with the keyword \"is-checks,\" which checks for immutable values and conducts implicit casting. We must examine the type of variables in Java and cast them appropriately for our operation. Smart Casting Smart casts in Kotlin will take care of these casting checks with the keyword \"is-checks,\" which checks for immutable values and conducts implicit casting. We must examine the type of variables in Java and cast them appropriately for our operation. Checked Exceptions We don't have checked exceptions in Kotlin. As a result, developers do not need to declare or catch exceptions, which has both benefits and drawbacks. We have checked exceptions support in Java, which enables developers to declare and catch exceptions, resulting in more robust code with better error handling. Checked Exceptions We don't have checked exceptions in Kotlin. As a result, developers do not need to declare or catch exceptions, which has both benefits and drawbacks. We have checked exceptions support in Java, which enables developers to declare and catch exceptions, resulting in more robust code with better error handling.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "11. Explain Safe call, Elvis and Not Null Assertion operator in the context of Kotlin.",
        "answer": "Safe Call operator ( ?. ) -  Null comparisons are trivial, but the number of nested if-else expressions can be exhausting. So, in Kotlin, there's a Safe call operator,?, that simplifies things by only doing an action when a specified reference holds a non-null value. It allows us to use a single expression to perform both a null check and a method call. Safe Call operator ( ?. )   For example, The following expression in Kotlin name?.toLowerCase() name?.toLowerCase() is equivalent to the following if(name != null) \n   name.toLowerCase()\nelse\n   null if(name != null) \n   name.toLowerCase()\nelse\n   null Elvis Operator ( ?: ) - When the original variable is null, the Elvis operator is used to return a non-null value or a default value. In other words, the elvis operator returns the left expression if it is not null, otherwise, it yields the right expression. Only if the left-hand side expression is null is the right-hand side evaluated. Elvis Operator ( ?: )   For example, The following expression in Kotlin val sample1 = sample2 ?: \"Undefined\" val sample1 = sample2 ?: \"Undefined\" is equivalent to the following val sample1 = if(sample2 != null) \n       sample2\n     else \n       \"Undefined\" val sample1 = if(sample2 != null) \n       sample2\n     else \n       \"Undefined\" Furthermore, on the right side of the Elvis operator, we may use throw and return expressions, which is particularly handy in functions. As a result, instead of returning a default value on the right side of the Elvis operator, we can throw an exception. For example, val sample1 = sample2 ?: throw IllegalArgumentException(\"Invalid\") val sample1 = sample2 ?: throw IllegalArgumentException(\"Invalid\") Not Null Assertion Operator ( !! ) - If the value is null, the not null assertion (!!) operator changes it to a non-null type and throws an exception. Not Null Assertion Operator ( !! ) Anyone who wants a NullPointerException can ask for it explicitly with this operator. For example, // KOTLIN\nfun main(args: Array<String>) {\n   var sample : String?  = null\n   str!!.length\n} // KOTLIN\nfun main(args: Array<String>) {\n   var sample : String?  = null\n   str!!.length\n} The above code snippet gives the following output:- Exception in thread \"main\" kotlin.KotlinNullPointerException Exception in thread \"main\" kotlin.KotlinNullPointerException",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "12. Explain the concept of null safety in Kotlin.",
        "answer": "Kotlin's type system aims to eradicate null references from the code. If a program throws NullPointerExceptions at runtime it might result in application failure or system crashes. If the Kotlin compiler finds a null reference it throws a NullPointerException.   The Kotlin type system distinguishes between references that can hold null (nullable references) and those that cannot (non-null references). Null cannot be stored in a String variable. We get a compiler error if we try to assign null to the variable. var a: String = \"interview\"\na = null // results in compilation error var a: String = \"interview\"\na = null // results in compilation error If we want the above string to be able to hold null value as well, we can declare it of type nullable using the ‘?’ operator after the String keyword as follows : var a: String? = \"interview\"\na = null // no compilation error var a: String? = \"interview\"\na = null // no compilation error Kotlin provides Safe Call (?.), Elvis (?:) and Not Null Assertion (!!) operators which define what needs to be done in case of a null encounter. This makes the code more reliable and less prone to errors. Thus, Kotlin enforces null safety by having nullable, non-nullable type variables and the different operators to tackle null encounters.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "13. What are data classes in Kotlin? Explain with a proper example.",
        "answer": "The Data class is a simple class that holds data and provides typical functions. To declare a class as a data class, use the data keyword. Syntax: Syntax: data class className ( list_of_parameters) data class className ( list_of_parameters) The following functions are automatically derived by the compiler for the data classes: equals() - The equals() function returns true if two objects have the identical contents. It operates similarly to \"==,\" although for Float and Double values it works differently.\nhashCode() - The hashCode() function returns the object's hashcode value.\ncopy() - The copy() function is used to duplicate an object, changing only a few of its characteristics while leaving the rest unaltered.\ntoString() - This function returns a string containing all of the data class's parameters. equals() - The equals() function returns true if two objects have the identical contents. It operates similarly to \"==,\" although for Float and Double values it works differently. equals() Float and Double hashCode() - The hashCode() function returns the object's hashcode value. hashCode() copy() - The copy() function is used to duplicate an object, changing only a few of its characteristics while leaving the rest unaltered. copy() toString() - This function returns a string containing all of the data class's parameters. toString() To ensure consistency, data classes must meet the following requirements: At least one parameter is required for the primary constructor.\nval or var must be used for all primary constructor parameters.\nAbstract, open, sealed, or inner data classes are not possible.\nOnly interfaces may be implemented by data classes. At least one parameter is required for the primary constructor. val or var must be used for all primary constructor parameters. Abstract, open, sealed, or inner data classes are not possible. Only interfaces may be implemented by data classes. Example: Example: data class Sample(var input1 : Int, var input2 : Int) data class Sample(var input1 : Int, var input2 : Int) The above code snippet creates a data class Sample with two parameters. fun main(agrs: Array<String>) {  \n   val temp = Sample(1, 2)  \n   println(temp)  \n} fun main(agrs: Array<String>) {  \n   val temp = Sample(1, 2)  \n   println(temp)  \n} Here, we create an instance of the data class Sample and pass the parameters to it. Output:- Output:- Sample(input1=1, input2=2) Sample(input1=1, input2=2)",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "14. How are variables declared in Kotlin? What are the different types of variables in Kotlin? Explain with examples.",
        "answer": "Every variable in Kotlin must be declared before it can be used. An attempt to use a variable without declaring it results in a syntax error. The type of data you are authorised to put in the memory address is determined by the variable type declaration. The type of variable can be determined from the initialised value in the case of local variables. For example, var site = \"interviewbit\" var site = \"interviewbit\" The above code declares a variable “site” of type String because the value with which the variable is initialised is a String. There are broadly two types of variables in Kotlin. They are as follows:-   Immutable Variables — Immutable variables are also known as read-only variables. They are declared using the val keyword. Once these variables have been declared, we cannot change their values. Immutable Variables — Immutable variables are also known as read-only variables. They are declared using the val keyword. Once these variables have been declared, we cannot change their values. Immutable Variables The syntax is as follows : syntax val variableName = value val variableName = value For example, val sample = \"interview\"\nsample = \"interviewbit\"    // results in compile time error val sample = \"interview\"\nsample = \"interviewbit\"    // results in compile time error The second line in the above code snippet would result in a compile-time error as expected. Because it can be initialized with the value of a variable, an immutable variable is not a constant. It means that the value of an immutable variable does not need to be known at compile-time and that if it is defined inside a construct that is called several times, it can take on a different value with each function call. For example, var sample = \"interview\"\nval newSample = sample    // no compile time error var sample = \"interview\"\nval newSample = sample    // no compile time error The above code snippet runs fine and does not produce any errors. Mutable Variables - In a mutable variable, the value of the variable can be changed. We use the keyword “var” to declare such variables. Mutable Variables - In a mutable variable, the value of the variable can be changed. We use the keyword “var” to declare such variables. Mutable Variables The syntax is as follows : syntax var variableName = value var variableName = value For example, var sample = \"interview\"\nsample = \"fun\"    // no compile time error var sample = \"interview\"\nsample = \"fun\"    // no compile time error The above code snippet runs fine and does not produce any errors.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "1. What are some of the disadvantages of Kotlin?",
        "answer": "Following are some of the disadvantages of Kotlin:   In Kotlin, there are a few keywords that have non-obvious meanings: internal, crossinline, expect, reified, sealed, inner, open. Java has none of these.\nChecked exceptions are likewise absent in Kotlin. Although checked exceptions have become less prominent, many programmers believe them to be an effective technique to ensure that their code is stable.\nA lot of what happens in Kotlin is hidden. You can almost always trace the logic of a program in Java. When it comes to bug hunting, this can be really useful. If you define a data class in Kotlin, getters, setters, equality testing, tostring, and hashcode are automatically added for you.\nLearning resources are limited. The number of developers who are moving to Kotlin is growing, yet there is a small developer community accessible to help them understand the language or address problems during development.\nKotlin has variable compilation speed. In some situations, Kotlin outperforms Java, particularly when executing incremental builds. However, we must remember that when it comes to clean builds, Java is the clear winner. In Kotlin, there are a few keywords that have non-obvious meanings: internal, crossinline, expect, reified, sealed, inner, open. Java has none of these. Checked exceptions are likewise absent in Kotlin. Although checked exceptions have become less prominent, many programmers believe them to be an effective technique to ensure that their code is stable. A lot of what happens in Kotlin is hidden. You can almost always trace the logic of a program in Java. When it comes to bug hunting, this can be really useful. If you define a data class in Kotlin, getters, setters, equality testing, tostring, and hashcode are automatically added for you. Learning resources are limited. The number of developers who are moving to Kotlin is growing, yet there is a small developer community accessible to help them understand the language or address problems during development. Kotlin has variable compilation speed. In some situations, Kotlin outperforms Java, particularly when executing incremental builds. However, we must remember that when it comes to clean builds, Java is the clear winner.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "2. Differentiate between launch / join and async / await in Kotlin.",
        "answer": "launch / join:- launch / join:- The launch command is used to start and stop a coroutine. It's as though a new thread has been started. If the code inside the launch throws an exception, it's considered as an uncaught exception in a thread, which is typically written to stderr in backend JVM programs and crashes Android applications. Join is used to wait for the launched coroutine to complete before propagating its exception. A crashed child coroutine, on the other hand, cancels its parent with the matching exception. async / await:- async / await:- The async keyword is used to initiate a coroutine that computes a result. You must use await on the result, which is represented by an instance of Deferred. Uncaught exceptions in async code are held in the resultant Deferred and are not transmitted anywhere else. They are not executed until processed.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "3. What do you understand about the backing field in Kotlin?",
        "answer": "A backing field is an auto-generated field for any property that may only be used inside accessors (getter or setter) and will only be present if it utilizes the default implementation of at least one of the accessors, or if a custom accessor refers to it through the field identifier. This backing field is used to avoid an accessor's recursive call, which would result in a StackOverflowError. Fields are not allowed in Kotlin classes. When employing custom accessors, however, it is occasionally required to have a backing field. Kotlin includes an automatic backing field for these purposes, which may be accessed by the field identifier. For example, var marks: Int = someValue\n       get() = field\n       set(value) {\n           field = value\n       } var marks: Int = someValue\n       get() = field\n       set(value) {\n           field = value\n       } Explanation:-  Here the field identifier acts as a reference to the property “marks” value in the get() and set() method. So, whenever we call the get(), we get the field’s value returned. Similarly, whenever we call the set(), we set the “marks” property value to “value”. Explanation:-",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "4. What do you understand about sealed classes in Kotlin?",
        "answer": "Kotlin introduces a crucial new form of class that isn't seen in Java. These are referred to as \"sealed classes.\" Sealed classes, as the name implies, adhere to constrained or bounded class hierarchies. A sealed class is one that has a set of subclasses. When it is known ahead of time that a type will conform to one of the subclass types, it is employed. Type safety (that is, the compiler will validate types during compilation and throw an exception if a wrong type has been assigned to a variable) is ensured through sealed classes, which limit the types that can be matched at compile time rather than runtime.   The syntax is as follows:- sealed class className sealed class className Another distinguishing aspect of sealed classes is that their constructors are by default private. Due to the fact that a sealed class is automatically abstract, it cannot be instantiated. For example, // KOTLIN\nsealed class Sample {\n    class A : Sample() {\n        fun print()\n        {\n            println(\"This is the subclass A of sealed class Sample\")\n        }\n    }\n    class B : Sample() {\n        fun print()\n        {\n            println(\"This is the subclass B of sealed class Sample\")\n        }\n    }\n}\nfun main()\n{\n    val obj1 = Sample.B()\n    obj1.print()\n  \n    val obj2 = Sample.A()\n    obj2.print()\n} // KOTLIN\nsealed class Sample {\n    class A : Sample() {\n        fun print()\n        {\n            println(\"This is the subclass A of sealed class Sample\")\n        }\n    }\n    class B : Sample() {\n        fun print()\n        {\n            println(\"This is the subclass B of sealed class Sample\")\n        }\n    }\n}\nfun main()\n{\n    val obj1 = Sample.B()\n    obj1.print()\n  \n    val obj2 = Sample.A()\n    obj2.print()\n} Output:- Output:- This is the subclass B of sealed class Sample\nThis is the subclass A of sealed class Sample This is the subclass B of sealed class Sample\nThis is the subclass A of sealed class Sample Explanation:- In the above code, we have created a sealed class named “Sample” and we have created two sub classes within it named “A” and “B”. In the main function, we create an instance of both the sub classes and call their “print” method. Explanation:-",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "5. Explain suspend function in the context of Kotlin.",
        "answer": "A function that may be started, halted, then resumed is known as a suspend function. One of the most important things to remember about the suspend functions is that they can only be invoked from another suspend function or from a coroutine. Suspending functions are merely standard Kotlin functions with the suspend modifier added, indicating that they can suspend coroutine execution without blocking the current thread. This means that the code you're looking at may pause execution when it calls a suspending function and restart execution at a later time. However, it makes no mention of what will happen to the present thread in the meantime.   Suspending functions can call any other ordinary functions, but another suspending function is required to suspend the execution. Because a suspending function cannot be called from a regular function, numerous coroutine builders are supplied, allowing you to call a suspending function from a non-suspending scope like launch, async, or runBlocking. delay() function is an example of suspend function.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "6. Explain scope functions in the context of Kotlin. What are the different types of Scope functions available in Kotlin?",
        "answer": "The Kotlin standard library includes numerous functions that aid in the execution of a block of code within the context of an object. When you use a lambda expression to call these functions on an object, temporary scope is created. These functions are referred to as Scope functions. The object of these functions can be accessed without knowing its name. Scope functions make code more clear, legible, and succinct, which are key qualities of the Kotlin programming language.   Following are the different types of Scope functions available in Kotlin:- let:- \nContext object:   it \nReturn value:   lambda result\nThe let function is frequently used for null safety calls. For null safety, use the safe call operator(?.) with ‘let'. It only runs the block with a non-null value.\napply:-\nContext object:  this\nReturn value:   context object\n“Apply these to the object,” as the name suggests. It can be used to operate on receiver object members, primarily to initialise them.\nwith:-\nContext object:  this\nReturn value:   lambda result\nWhen calling functions on context objects without supplying the lambda result, ‘with' is recommended.\nrun:-\nContext object:  this \nReturn value:   lambda result\nThe ‘run' function is a combination of the ‘let' and ‘with' functions. When the object lambda involves both initialization and computation of the return value, this is the method to use. We can use run to make null safety calls as well as other calculations.\nalso:-\nContext object:  it\nReturn value:   context object\nIt's used when we need to do additional operations after the object members have been initialised. let:- \nContext object:   it \nReturn value:   lambda result\nThe let function is frequently used for null safety calls. For null safety, use the safe call operator(?.) with ‘let'. It only runs the block with a non-null value. let:-    apply:-\nContext object:  this\nReturn value:   context object\n“Apply these to the object,” as the name suggests. It can be used to operate on receiver object members, primarily to initialise them. apply:-    with:-\nContext object:  this\nReturn value:   lambda result\nWhen calling functions on context objects without supplying the lambda result, ‘with' is recommended. with:-    run:-\nContext object:  this \nReturn value:   lambda result\nThe ‘run' function is a combination of the ‘let' and ‘with' functions. When the object lambda involves both initialization and computation of the return value, this is the method to use. We can use run to make null safety calls as well as other calculations. run:-    also:-\nContext object:  it\nReturn value:   context object\nIt's used when we need to do additional operations after the object members have been initialised. also:-   ",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "7. What do you understand about coroutines in the context of Kotlin?",
        "answer": "  Unlike many other languages with equivalent capabilities, async and await are neither keywords nor part of Kotlin's standard library. JetBrains' kotlinx.coroutines library is a comprehensive library for coroutines. It includes a number of high-level coroutine-enabled primitives, such as launch and async. Kotlin Coroutines provide an API for writing asynchronous code in a sequential manner. Coroutines are similar to thin threads. Coroutines are lightweight since they don't allocate new threads when they're created. Instead, they employ pre-defined thread pools as well as intelligent scheduling. The process of deciding which piece of work you will do next is known as scheduling. Coroutines can also be paused and resumed in the middle of their execution. This means you can have a long-term project that you can work on incrementally. You can pause it as many times as you want and continue it whenever you're ready.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "8. Differentiate between lateinit and lazy initialisation. Explain the cases when you should use lateinit and when you should use lazy initialisation.",
        "answer": "Following are the differences between lateinit and lazy initialisation:-   lateinit lazy initialisation\nThe main purpose is to delay the initialisation to a later point in time. The main purpose is to initialise an object only when it is used at a later point in time. Also, a single copy of the object is maintained throughout the program. \nIt's possible to initialise the object from anywhere in the program. Only the initializer lambda can be used to initialise it.\nMultiple initializations are possible in this case. Only a single initialisation is possible in this case.\nIt's not thread-safe. In a multi-threaded system, it is up to the user to correctly initialise. Thread-safety is enabled by default, ensuring that the initializer is only called once.\nIt works only with var. It works only with val.\nThe isInitialized method is added to verify if the value has previously been initialised. It is impossible to uninitialize a property.\nProperties of primitive types are not allowed Allowable on primitive type properties. lateinit lazy initialisation\nThe main purpose is to delay the initialisation to a later point in time. The main purpose is to initialise an object only when it is used at a later point in time. Also, a single copy of the object is maintained throughout the program. \nIt's possible to initialise the object from anywhere in the program. Only the initializer lambda can be used to initialise it.\nMultiple initializations are possible in this case. Only a single initialisation is possible in this case.\nIt's not thread-safe. In a multi-threaded system, it is up to the user to correctly initialise. Thread-safety is enabled by default, ensuring that the initializer is only called once.\nIt works only with var. It works only with val.\nThe isInitialized method is added to verify if the value has previously been initialised. It is impossible to uninitialize a property.\nProperties of primitive types are not allowed Allowable on primitive type properties. lateinit lazy initialisation lateinit lazy initialisation lateinit lazy initialisation The main purpose is to delay the initialisation to a later point in time. The main purpose is to initialise an object only when it is used at a later point in time. Also, a single copy of the object is maintained throughout the program. \nIt's possible to initialise the object from anywhere in the program. Only the initializer lambda can be used to initialise it.\nMultiple initializations are possible in this case. Only a single initialisation is possible in this case.\nIt's not thread-safe. In a multi-threaded system, it is up to the user to correctly initialise. Thread-safety is enabled by default, ensuring that the initializer is only called once.\nIt works only with var. It works only with val.\nThe isInitialized method is added to verify if the value has previously been initialised. It is impossible to uninitialize a property.\nProperties of primitive types are not allowed Allowable on primitive type properties. The main purpose is to delay the initialisation to a later point in time. The main purpose is to initialise an object only when it is used at a later point in time. Also, a single copy of the object is maintained throughout the program. The main purpose is to delay the initialisation to a later point in time. The main purpose is to initialise an object only when it is used at a later point in time. Also, a single copy of the object is maintained throughout the program. It's possible to initialise the object from anywhere in the program. Only the initializer lambda can be used to initialise it. It's possible to initialise the object from anywhere in the program. Only the initializer lambda can be used to initialise it. Multiple initializations are possible in this case. Only a single initialisation is possible in this case. Multiple initializations are possible in this case. Only a single initialisation is possible in this case. It's not thread-safe. In a multi-threaded system, it is up to the user to correctly initialise. Thread-safety is enabled by default, ensuring that the initializer is only called once. It's not thread-safe. In a multi-threaded system, it is up to the user to correctly initialise. Thread-safety is enabled by default, ensuring that the initializer is only called once. It works only with var. It works only with val. It works only with var. It works only with val. The isInitialized method is added to verify if the value has previously been initialised. It is impossible to uninitialize a property. The isInitialized method is added to verify if the value has previously been initialised. It is impossible to uninitialize a property. Properties of primitive types are not allowed Allowable on primitive type properties. Properties of primitive types are not allowed Allowable on primitive type properties. There are a few easy principles to follow when deciding whether to use lateinit or lazy initialisation for property initialization: Use lateInit if properties are mutable (i.e., they may change later).\nUse lateinit if properties are set externally (for example, if you need to pass in an external variable to set it). There is still a way to use lazy, but it isn't as obvious.\nIf they're only meant to be initialised once and shared by everybody, and they're more internally set (depending on a class variable), then lazy is the way to go. We could still use lateinit in a tactical sense, but utilising lazy initialisation would better encapsulate our initialization code. Use lateInit if properties are mutable (i.e., they may change later). Use lateinit if properties are set externally (for example, if you need to pass in an external variable to set it). There is still a way to use lazy, but it isn't as obvious. If they're only meant to be initialised once and shared by everybody, and they're more internally set (depending on a class variable), then lazy is the way to go. We could still use lateinit in a tactical sense, but utilising lazy initialisation would better encapsulate our initialization code.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "9. Explain lazy initialization in the context of Kotlin.",
        "answer": "There are some classes whose object initialization is so time-consuming that it causes the entire class creation process to be delayed. Lazy initialisation helps in such problems. When we declare an object using lazy initialisation, the object is initialised only once when the object is used. If the object is not used throughout, the object is not initialised. This makes the code more efficient and faster. For example, let us imagine you have a SlowClass class and you require an object of that SlowClass in a different class called FastClass: // KOTLIN\nclass FastClass {\n   private val slowObject: SlowClass = SlowClass()\n} // KOTLIN\nclass FastClass {\n   private val slowObject: SlowClass = SlowClass()\n} We are generating a large object here, which will cause the development of the FastClass to be slow or delayed. There may be times where the SlowClass object isn't required. As a result, the lazy keyword can assist you in this situation: class FastClass {\n   private val slowObject: SlowClass by lazy {\n       SlowClass()\n   }  \n} class FastClass {\n   private val slowObject: SlowClass by lazy {\n       SlowClass()\n   }  \n} For example, // KOTLIN\nclass FastClass {\n   private val slowObject: SlowClass by lazy {\n       println(\"Slow Object initialised\")\n       SlowClass()\n   } \n   \n   fun access() {\n       println(slowObject)\n   }\n}\nfun main(args: Array<String>) {\n   val fastClass = FastClass()\n   println(\"FastClass initialised\")\n   fastClass.access()\n   fastClass.access()\n} // KOTLIN\nclass FastClass {\n   private val slowObject: SlowClass by lazy {\n       println(\"Slow Object initialised\")\n       SlowClass()\n   } \n   \n   fun access() {\n       println(slowObject)\n   }\n}\nfun main(args: Array<String>) {\n   val fastClass = FastClass()\n   println(\"FastClass initialised\")\n   fastClass.access()\n   fastClass.access()\n} Output:- Output:- FastClass initialised \nSlow Object initialised \nSlowClass@2b12fkk7 \nSlowClass@2b12fkk7 FastClass initialised \nSlow Object initialised \nSlowClass@2b12fkk7 \nSlowClass@2b12fkk7 Explanation:- In the above code, we have instantiated an object of the SlowClass inside the class structure of the FastClass using lazy initialisation. The object of the SlowClass is generated only when it is accessed in the above code, that is, when we call the access() method of the FastClass object and the same object is present throughout the main() method. Explanation:-",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "10. What do you understand about lateinit in Kotlin? When would you consider using it?",
        "answer": "  lateinit is an abbreviation for late initiation. If you don't want to initialize a variable in the constructor and instead want to do it later, and you can guarantee the initialization before using it, use the lateinit keyword to declare that variable. It won't start allocating memory until it's been initialized. Lateinit cannot be used for primitive type attributes like Int, Long, and so on. Because the lateinit variable will be initialized later, you cannot use val. When a lateinit property is accessed before it has been initialized, a special exception is thrown that explicitly identifies the property and the fact that it hasn't been initialized. For example, // KOTLIN\nlateinit var test: String\nfun testFunction() {\n   test = \"Interview\"\n   println(\"The length of string is \"+test.length)\n   test = \"Bit\"\n} // KOTLIN\nlateinit var test: String\nfun testFunction() {\n   test = \"Interview\"\n   println(\"The length of string is \"+test.length)\n   test = \"Bit\"\n} When the testFunction is called, we get the following output:- 9 9 There are a few scenarios in which this is particularly useful, for example: Variables that are initialized in lifecycle methods in Android;\nUsing Dagger for DI: injected class variables are initialized outside of the constructor and independently;\nSetup for unit tests: in a @Before - annotated function, test environment variables are initialized;\nAnnotations in Spring Boot (for example, @Autowired). Variables that are initialized in lifecycle methods in Android; Using Dagger for DI: injected class variables are initialized outside of the constructor and independently; Setup for unit tests: in a @Before - annotated function, test environment variables are initialized; Annotations in Spring Boot (for example, @Autowired).",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "11. Which one is better to use - val mutableList or var immutableList in the context of Kotlin?",
        "answer": "The program's design clarity is improved by using mutable and immutable lists. This is done to have the developer think about and clarify the collection's purpose. We use a mutable list if the collection will alter as part of the design. On the other hand, we use an immutable list if the model is only meant to be viewed. Val and var serve a distinct purpose than immutable and mutable lists. The val and var keywords specify how a variable's value/reference should be handled. We use var when the value or reference of a variable can be altered at any moment. On the other hand, we use val when a variable's value/reference can only be assigned once and cannot be modified later in the execution. Immutable lists are frequently preferred for a variety of reasons: They promote functional programming, in which state is passed on to the next function, which constructs a new state based on it, rather than being altered. This is evident in Kotlin collection methods like map, filter, reduce, and so forth.\nIt's often easier to understand and debug software that doesn't have any side effects (you can be sure that the value of an object will always be the one at its definition).\nBecause no write access is required in multi-threaded systems, immutable resources cannot induce race conditions. They promote functional programming, in which state is passed on to the next function, which constructs a new state based on it, rather than being altered. This is evident in Kotlin collection methods like map, filter, reduce, and so forth. It's often easier to understand and debug software that doesn't have any side effects (you can be sure that the value of an object will always be the one at its definition). Because no write access is required in multi-threaded systems, immutable resources cannot induce race conditions. However, there are some disadvantages of using immutable lists as well. They are as follows : Copying large collections simply to add/remove a single piece is very expensive.\nWhen you need to alter single fields frequently, immutability can make the code more difficult. Data classes in Kotlin provide a built-in copy() method that allows you to clone an instance while changing only part of the fields' values. Copying large collections simply to add/remove a single piece is very expensive. When you need to alter single fields frequently, immutability can make the code more difficult. Data classes in Kotlin provide a built-in copy() method that allows you to clone an instance while changing only part of the fields' values.",
        "reference": "interviewbit.com",
        "role": "kotlin"
    },
    {
        "question": "",
        "answer": "Kotlin is a general-purpose, statically typed, open-source programming language that runs on the JVM. It runs on JVM and can be used anywhere Java is used today. It can be compiled either using Java source code or LLVM compiler. It is generally used to develop Android apps, server-side apps, and much more.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "2) What do you know about the history of Kotlin?",
        "answer": "Kotlin was developed by the JetBrains team. This project was started in 2010 to develop a language for Android apps development, and officially its first version was released in February 2016. Kotlin was developed under the Apache 2.0 license.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "3) What are the most important features of Kotlin?",
        "answer": "The most popular features of kotlin are:\nADVERTISEMENT\nKotlin is Concise: Kotlin reduces the writing of the extra codes, making Kotlin more concise.\nCompact code: Kotlin is an OOPs-based programming language. Its code lines may be reduced by up to 40% compared to Java, making it an excellent choice for software development.\nKotlin is Simple: Kotlin is a simple language to learn. When working with Kotlin, compiling the code is simple, resulting in improved performance for Android development. It also explains which types of data functions can be used throughout the code.\nOpen Source: Kotlin is open source for Android, and it uses the JVM to combine the benefits of OOPs and functional programming.\nNull safety: Kotlin is null safety language. Kotlin aimed to eliminate the NullPointerException (null reference) from the code.\nA high number of extensions: Kotlin supports various extension functions and extension properties without modifying the code. It means that it can help to extend the functionality of classes without touching their code. Kotlin may support a variety of extension functions to help developers make existing code more appealing and wonderful.\nFull Java Interoperability: Kotlin provides full interoperability for Java code. Java code can utilize Kotlin code, and Kotlin code can use Java code. So, if you are familiar with OOPs programming and good in Java programming language, you can switch to Kotlin development easily. Also, if there are any Java-based applications, they can be used with Kotlin's environment.\nSmart Cast: Kotlin supports the smart cast technique. By using this technique, we can reduce the cost of an application while also improving its speed and performance. It technique uses typecasting or immutable data to manage the efficiency of programming. \\\nLow Learning Curve: Many businesses prefer Kotlin because of its low adoption cost. Most significantly, it is simple for developers to learn, especially if they have programming experience.\nCompilation Time: Kotlin is faster and better than Java in terms of its performance and fast compilation time.\nTools-friendly: Kotlin is Tools-friendly. You can build the Kotlin programs by using the command line as well as any of Java IDE.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "4) Why did you switch to Kotlin from Java? Why do some developers like to switch to Kotlin from Java?",
        "answer": "The Kotlin programing language seems to be simpler and cleaner than Java. It removes a lot of redundancies in code as compared to Java. Kotlin also offers some useful features that Java doesn't yet support, making the code more idiomatic. Kotlin has been added to Android Studio's list of supported languages recently. So, there is much to expect from Kotlin in easing out the development efforts and good support in the future.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "5) How does Kotlin work on Android?",
        "answer": "Kotlin is very much similar to the Java programming language. Like Java, the Kotlin code is also compiled into the Java bytecode and executed at runtime by the Java Virtual Machine, i.e., JVM. For example, when a Kotlin file named Main.kt is compiled, it will eventually turn into a class, and then the bytecode of the class will be generated. The name of the bytecode file will be MainKt.class, and this file will be executed by the JVM.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "6) What is the difference between the variable declaration with var and variable declaration with val?",
        "answer": "The variable declaration with var and the variable declaration with val is used for different purposes. If you want to declare some mutable (changeable) variable, you should use var. If you want to declare the immutable variable, you should use val because val variables can't be changed once you have assigned them.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "7) What is the difference between the variable declaration with val and variable declaration with const?",
        "answer": "Both the variables that are declared with val and const are immutable in nature. But the difference between the variable declaration with val and variable declaration with const is that the value of the const variable must be known at the compile-time. In contrast, the value of the val variable can be assigned at runtime also.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "8) How can you create a singleton in Kotlin?",
        "answer": "We can create a singleton in Kotlin by using an object.\nSyntax:\nobject SomeSingleton  \nThe above Kotlin object will be compiled to the following equivalent Java code:\nADVERTISEMENT\npublic final class SomeSingleton {  \n   public static final SomeSingleton INSTANCE;  \n   private SomeSingleton() {  \n      INSTANCE = (SomeSingleton)this;  \n      System.out.println(\"init complete\");  \n   }  \n   static {  \n      new SomeSingleton();  \n   }  \n}  \nThe above way is preferred to implement singletons on a JVM because it enables thread-safe lazy initialization without relying on a locking algorithm like the complex double-checked locking.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "9) What is a primary constructor in Kotlin?",
        "answer": "In Kotlin, the primary constructor is a part of the class header. Unlike Java, it doesn't need you to declare a constructor in the body of the class.\nKotlin facilitates you to declare the constructor in the class header itself:\nSee the following example:\nclass Person constructor(name: String, age: Int, salary: Int) {  \n}   \nJust like functions or methods, it takes a series of parameters with their type. These parameters initialize the variables present in the class.\nIf you do not have any annotations or modifiers (public, private, protected), you can omit the constructor keyword like the following example.\nclass Person (name: String, age: Int, salary: Int) {  \n}  \nBy removing the constructor keyword, you can get code that is simplified and easy to understand.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "10) What do you understand by Null safety in Kotlin?",
        "answer": "Null safety is one of the major advantages of using Kotlin. Kotlin's type system ensures eliminating the danger of null references from code, also known as The Billion Dollar Mistake. One of the most common pitfalls in many programming languages, including Java, is that accessing a member of a null reference will result in a null reference exception. In Java, this would be the equivalent of a NullPointerException or NPE for short.\nIn Kotlin, the type system distinguishes between references that can hold null (nullable references) and those that cannot (non-null references). For example, a regular variable of type String can not hold null:\nvar a: String = \"abc\"  \na = null // compilation error  \nTo allow nulls, we can declare a variable as nullable string, written \"String?\":\nvar b: String? = \"abc\"  \nb = null // ok  \nprint(b)",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "11) How can you ensure null safety in Kotlin?",
        "answer": "Null safety is a feature introduced in Kotlin. In Java, if you access some null variable, then you will get a NullPointerException. So, the following code in Kotlin will produce a compile-time error:\nvar name: String = \"MindOrks\"  \nname = null //error  \nSo, to overcome this issue, you have to assign null values to a variable, and you need to declare the name variable as a nullable string, and then during the access of this variable, you need to use a safe call operator; i.e.?.\nvar name: String? = \"MindOrks\"  \nprint(name?.length) // ok  \nname = null // ok",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "12) What is a data class in Kotlin?",
        "answer": "In Kotlin, a data class is a class whose main purpose is to hold data. It is marked as \"data\".\nSyntax:\ndata class User(val name: String, val age: Int)   \nThe data classes must have to fulfill the following requirements to ensure consistency and meaningful behavior of the generated code:\nThe primary constructor must have at least one parameter\n, and all primary constructor parameters need to be marked as val or var.\nData classes cannot be abstract, open, sealed, or inner.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "13) What is the default behavior of Kotlin classes?",
        "answer": "By default, all classes are final in Kotlin. That's because Kotlin allows multiple inheritances for classes, and an open class is more expensive than a final class.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "14) Does Kotlin provide support for primitive Datatypes?",
        "answer": "No. Kotlin does not provide support for primitive Data types like in Java.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "15) Does Kotlin provide support for macros?",
        "answer": "No. Kotlin does not provide support for macros because the developers of Kotlin find it difficult to include them in the language.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "16) What is the use of the open keyword in Kotlin?",
        "answer": "In Kotlin, the classes and functions are final by default. So, it is not possible to inherit the class or override the functions. To achieve this, we need to use the open keyword before the class and function.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "17) What do you understand by the Ranges operator in Kotlin?",
        "answer": "Ranges operators help to iterate within a range. Its operator form is (..) For Example:\nfor (i in 1..15)  \nprint(i)  \nThe above example will give the output to print from 1 to 15.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "18) Where should we use var and where val in Kotlin?",
        "answer": "In Kotlin, var is used where value is frequently changing. For example, while getting the location of the android device:\nvar integerVariable : Int? = null  \nIn Kotlin, val is used where there is no change in value in the whole class. For example, when you want to set textview or button's text programmatically:\nval stringVariables : String = \"Button's Constant or final Text\"",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": ") and a null check(!!) in Kotlin?",
        "answer": "Difference between safe calls(?.) and a null check(!!) in Kotlin:\nThe safe call operator i.e. ?. is used to check if the variable's value is null or not. If it is null, then null will be returned otherwise it will return the desired value.\nvar name: String? = \"JavaTpoint\"  \nprintln(name?.length) // 10  \nname = null  \nprintln(name?.length) // null  \nIf you want to throw NullPointerException when the variable's value is null, you can use the null check or !! Operator.\nSee the example:\nvar name: String? = \"JavaTpoint\"  \nprintln(name?.length) // 10  \nname = null  \nprintln(name!!.length) // KotlinNullPointerException",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "20) What is the basic difference between the fold and reduce in Kotlin? Also, specify when to use which?",
        "answer": "Difference between the fold and reduce in Kotlin:\nFold: The fold takes an initial value and the first invocation of the lambda you pass to it. It will receive that initial value and the first element of the collection as parameters.\nlistOf(1, 2, 3).fold(0) { sum, element -> sum + element }  \nThe first call to the lambda will be with parameters 0 and 1. The ability to pass in an initial value is useful if you have to provide a default value or parameter for your operation.\nReduce: The \"reduce\" doesn't take an initial value. Instead, it starts with the first element of the collection as the accumulator.\nlistOf(1, 2, 3).reduce { sum, element -> sum + element }  \nIn the above example, it is denoted by sum. The first call to the lambda here will be with parameters 1 and 2.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "21) What are the advantages of \"when\" over \"switch\" in Kotlin?",
        "answer": "The \"switch\" is used in Java, but in Kotlin, that switch gets converted to \"when\". When has a better design as compared to \"switch\", and it is more concise and powerful than a traditional switch. We can use \"when\" either as an expression or as a statement.\nFollowing are some examples of when usage in Kotlin:\nIn two or more choices:\nwhen(number) {  \n    1 -> println(\"One\")  \n    2, 3 -> println(\"Two or Three\")  \n    4 -> println(\"Four\")  \n    else -> println(\"Number is not between 1 and 4\")  \n}  \n\"when\" without arguments:\nwhen {  \n    number < 1 -> print(\"Number is less than 1\")  \n    number > 1 -> print(\"Number is greater than 1\")  \n}  \nAny type passed in \"when\":\nfun describe(obj: Any): String =  \n    when (obj) {  \n      1 -> \"One\"  \n      \"Hello\" -> \"Greeting\"  \n      is Long -> \"Long\"  \n      !is String -> \"Not a string\"  \n      else -> \"Unknown\"  \n    }  \nSmart casting:\nwhen (x) {  \n    is Int -> print(\"X is integer\")  \n    is String -> print(\"X is string\")  \n}  \nRanges:\nwhen(number) {  \n    1 -> println(\"One\") //statement 1  \n    2 -> println(\"Two\") //statement 2  \n    3 -> println(\"Three\") //statement 3  \n    in 4..8 -> println(\"Number between 4 and 8\") //statement 4  \n    !in 9..12 -> println(\"Number not in between 9 and 12\") //statement 5  \n    else -> println(\"Number is not between 1 and 8\") //statement 6  \n}",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "22) What do you understand by the Null safety in Kotlin?",
        "answer": "In Kotlin, the main motive of the type system is to eliminate the danger of null references from code. It is also known as the Billion Dollar Mistake.\nOne of the most common pitfalls in many programming languages, including Java, is that accessing a member of a null reference will result in a null reference exception. In Java, this would be the equivalent of a NullPointerException.\nIn Kotlin, the type system distinguishes between references that can hold null (nullable references) and those that cannot (non-null references). For example, a regular variable of type String can not hold null:\nvar a: String = \"abc\"  \na = null // compilation error  \nTo allow nulls, we can declare a variable as nullable string, written String?:\nvar b: String? = \"abc\"  \nb = null // ok  \nprint(b)",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "23) Do we have a ternary operator in Kotlin just like Java?",
        "answer": "No. In Kotlin, we don't have a ternary operator like Java, but we can use the functionality of the ternary operator by using if-else or Elvis operator.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "24) What is Elvis operator in Kotlin?",
        "answer": "In Kotlin, we can assign null values to a variable using the null safety property. To check if a value has null value, we can use if-else or can use the Elvis operator i.e. ?:\nFor example:\nvar name:String? = \"Mindorks\"  \nval namenameLength = name?.length ?: -1  \nprintln(nameLength)  \nIn the above example, the Elvis operator(?:) we are using will return the length of the name if the value is not null; otherwise, if the value is null, then it will return -1.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "25) Why is Kotlin interoperable with Java?",
        "answer": "Kotlin is interoperable with Java because it uses JVM bytecode. It provides the facility to compile it directly to bytecode that helps to achieve faster compile-time and makes no difference between Java and Kotlin for JVM.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "26) What do you understand by lazy initialization in Kotlin?",
        "answer": "Kotlin provides the facility of lazy initialization, which specifies that your variable will not be initialized unless you use that variable in your code. It will be initialized only once. After that, you use the same value.\nIn lazy initialization, the lazy() function is used that takes a lambda and returns an instance of lazy, which can serve as a delegate for implementing a lazy property: the first call to get() executes the lambda passed to lazy() and remembers the result, subsequent calls to get() simply return the remembered result.\nval test: String by lazy {  \n    val testString = \"some value\"  \n}",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "27) How many types of constructors are used in Kotlin?",
        "answer": "There are two types of constructors available in Kotlin:\nPrimary constructor\nSecondary constructor",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "28) What is Lateinit in Kotlin, and when is it used?",
        "answer": "Lateinit means late initialization. It is used when you do not want to initialize a variable in the constructor and instead initialize it later.\nYou should declare that variable with lateinit keyword to guarantee the initialization, not before using it. It will not allocate memory until it is initialized. You cannot use lateinit for primitive type properties like Int, Long, etc.\nlateinit var test: String  \nfun doSomething() {  \n    test = \"Some value\"  \n    println(\"Length of string is \"+test.length)  \n    test = \"change value\"  \n}  \nThis is mainly used in the following cases:\nAndroid: variables that get initialized in lifecycle methods.\nUsing Dagger for DI: injected class variables are initialized outside and independently from the constructor.\nSetup for unit tests: test environment variables are initialized in a @Before - annotated method.\nSpring Boot annotations (e.g., @Autowired).",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "29) How can we convert a Kotlin source file to a Java source file?",
        "answer": "Follow the steps given below to convert your Kotlin source file to a Java source file:\nFirst, open your Kotlin project in the IntelliJ IDEA / Android Studio.\nThen navigate to Tools > Kotlin > Show Kotlin Bytecode.\nNow, click on the Decompile button to get your Java code from the bytecode.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "30) What kinds of programming types does Kotlin support?",
        "answer": "Kotlin supports the following programming types:\nProcedural Programming\nObject-Oriented Programming",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "31) What is the use of @JvmStatic, @JvmOverloads, and @JvmFiled in Kotlin?",
        "answer": "Following are the main usage of @JvmStatic, @JvmOverloads, and @JvmFiled in Kotlin:\n@JvmStatic: The @JvmStatic annotation is used to tell the compiler that the method is a static method, and you can use it in Java code.\n@JvmOverloads: The @JvmOverloads annotation is required when we need to use the default values passed as an argument in Kotlin code from the Java code.\n@JvmField: The @JvmField annotation is used to access the fields of a Kotlin class from Java code without any getters and setters. We need to use the @JvmField in the Kotlin code.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "File?",
        "answer": "Following are some extension methods that Kotlin provides to java.io.File:\nbufferedReader(): It is used for reading the contents of a file into BufferedReader.\nreadBytes(): It is used for reading the contents of the file to ByteArray.\nreadText(): It is used for reading contents of the file to a single String.\nforEachLine(): It is used for reading a file line by line in Kotlin.\nreadLines(): It is used for reading lines in the file to List.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "33) What do you understand by data classes in Kotlin?",
        "answer": "Data classes are the type of classes that are made to store some data. In Kotlin, it is marked as data. The following is an example of a data class:\ndata class Developer(val name: String, val age: Int)  \nWhen we mark a class as a data class, we don't have to implement or create the following functions like we have to do in Java: hashCode(), equals(), toString(), copy(). The compiler automatically creates these internally, so it also leads to clean code. Although, there are a few other requirements that data classes need to fulfill.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "34) What is the use of Companion Objects in Kotlin?",
        "answer": "Companion Objects are required in Kotlin because Kotlin doesn't have static members or member functions, unlike Java or C#. If we need to write a function that can be called without having a class instance but needs access to the internals of a class, we can write it as a member of a companion object declaration inside that class.\nFor example:\n\nclass EventManager {  \n    companion object FirebaseManager {  \n    }    \n}  \nval firebaseManager = EventManager.FirebaseManager   \nThe companion object is a singleton, and it is a proper object which you can assign to a variable and pass it around. If you integrate with Java code and need a true static member, you can annotate a member inside a companion object with @JvmStatic.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "35) How can you handle null exceptions in Kotlin?",
        "answer": "In Kotlin, Elvis Operator is used to handling null expectations.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "36) How can we perform String Interpolation in Kotlin?",
        "answer": "In Kotlin, String Interpolation is used when you want to use some variable or perform some operation inside a string. For String Interpolation, we can use the $ sign to use some variable in the string or can perform some operation in between the {} sign.\nFor example:\nvar name = \"JavaTpoint\"  \nprint(\"The best tutorial website is: $name\")",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "37) Name some features which are available in Kotlin but not in Java?",
        "answer": "Following are some important Kotlin features that are not available in Java:\nNull Safety\nOperator Overloading\nCoroutines\nRange expressions\nSmart casts\nCompanion Objects",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "38) What is the difference between == operator and === operator in Kotlin?",
        "answer": "In Kotlin, the == operator is generally used to compare the values stored in variables, and the === operator is used to check if the reference of the variables are equal or not.\nIn the case of primitive types, the === operator is also used to check for the value and not reference.\nExample:\n// primitive example  \nval int1 = 10   \nval int2 = 10  \nprintln(int1 == int2) // true  \nprintln(int1 === int2) // true  \n// wrapper example  \nval num1 = Integer(10)  \nval num2 = Integer(10)  \nprintln(num1 == num2) // true  \nprintln(num1 === num2) //false",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "39) Can we use primitive types such as int, double, float in Kotlin?",
        "answer": "Kotlin doesn't support the primitive types so, we can't use primitive types directly in Kotlin. We can use classes like Int, Double, etc., as an object wrapper for primitives. But the compiled bytecode has these primitive types.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "40) What is the difference between lateinit and lazy in Kotlin?",
        "answer": "Following are the key differences between lateinit and lazy in Kotlin:\nIn Kotlin, lazy can only be used for val properties while lateinit can only be applied to var because it can't be compiled to a final field. Thus no immutability can be guaranteed.\nYou have to use lateinit, if you want your property to be initialized from outside in a way probably unknown beforehand.\nLateinit vs. lazy in Kotlin:\nLateinit Lazy\nThe lateinit can be initialized from anywhere the object is seen. The lazy can only be initialized from the initializer lambda.\nIn lateinit, multiple initializations are possible. The lazy can be initialized a single time only.\nThe lateinit is non-thread safe. It is up to the user to initialize it correctly in a multi-threaded environment. The lazy support thread-safety by default and ensures that the initializer is invoked once.\nIt is not eligible for nonnull properties. It is also not eligible for nonnull properties.\nYou can use it only for var. You can use it only for val.\nIt adds an isInitialized method to check whether the value has been initialized before. In this, the property is never able to un-initialize.\nIt is not allowed on properties of primitive types. It is allowed on properties of primitive types.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "41) What do you understand by destructuring in Kotlin?",
        "answer": "In Kotlin, destructuring is a convenient way to extract multiple values from data stored in objects and Arrays. It can be used in locations that receive data. It is used because sometimes, it is convenient to destructure an object into several variables.\nFor Example:\nval (name, age) = developer  \nNow, we can use name and age independently as follows:\nprintln(name)  \nprintln(age)",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "42) What are coroutines in Kotlin?",
        "answer": "Unlike many other programming languages with similar capabilities, Kotlin doesn't have async and await keywords, and these keywords are not even part of its standard library.\nIn Kotlin, kotlinx.coroutines is a rich library for coroutines developed by JetBrains. This library contains some high-level coroutine-enabled primitives, including launch, async, and others. Kotlin Coroutines provide us with an API to write our asynchronous code sequentially.\nAccording to Kotlin documentation, Coroutines are like lightweight threads. They are lightweight because while creating them, they don't allocate new threads. Instead, they use predefined thread pools and smart scheduling. Scheduling is the process of determining the work in a sequential process, and it decides which piece of work you will execute next. We can suspend and resume the Coroutines while execution. This means we can have a long-running task, which can be executed one by one. We can pause it any number of times and resume it when required.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "43) What is the difference between Launch and Async in Kotlin Coroutines?",
        "answer": "In Kotlin, the main difference between Launch and Async is that the launch{} does not return anything and the async{} returns an instance of Deferred, which has an await() function. In other words, we can say that launch is used to fire and forget, and async is used to perform a task and return a result.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "44) What are the extension functions in Kotlin?",
        "answer": "Extension functions are like extensive properties attached to any class in Kotlin. Extension functions are used to add methods or functionalities to an existing class even without inheriting the class. For example: Suppose, we have views where we need to play with the visibility of the views. So, we can create an extension function for views as follows:\nfun View.show() {  \n this.visibility = View.VISIBLE  \n}  \nfun View.hide() {  \n this.visibility = View.GONE  \n}  \nand to use it, we use, like,  \ntoolbar.hide()",
        "reference": "javatpoint.com",
        "role": "kotlin"
    },
    {
        "question": "45) What do you understand by the Kotlin double-bang (!!) operator?",
        "answer": "The Kotlin double-bang (!!) operator converts any value to a non-null type and throws a KotlinNullPointerException exception if the value is null. It is also called the not-null assertion operator.\nExample:   \nfun main(args: Array<String>) {  \n    var email: String?  \n    email = null  \n    println(email!!)  \n}  \nThis operator should be used in cases where the developer is 100% sure that its value is not null.",
        "reference": "javatpoint.com",
        "role": "kotlin"
    }
]