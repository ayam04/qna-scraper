[
    {
        "question": "1. What are the features of PL/SQL?",
        "answer": "Following are the features of PL/SQL: PL/SQL provides the feature of decision making, looping, and branching by making use of its procedural nature.\nMultiple queries can be processed in one block by making use of a single command using PL/SQL.\nThe PL/SQL code can be reused by applications as they can be grouped and stored in databases as PL/SQL units like functions, procedures, packages, triggers, and types.\nPL/SQL supports exception handling by making use of an exception handling block.\nAlong with exception handling, PL/SQL also supports error checking and validation of data before data manipulation.\nApplications developed using PL/SQL are portable across computer hardware or operating system where there is an Oracle engine. PL/SQL provides the feature of decision making, looping, and branching by making use of its procedural nature. Multiple queries can be processed in one block by making use of a single command using PL/SQL. The PL/SQL code can be reused by applications as they can be grouped and stored in databases as PL/SQL units like functions, procedures, packages, triggers, and types. PL/SQL supports exception handling by making use of an exception handling block. Along with exception handling, PL/SQL also supports error checking and validation of data before data manipulation. Applications developed using PL/SQL are portable across computer hardware or operating system where there is an Oracle engine.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "2. What is the purpose of WHEN clause in the trigger?",
        "answer": "WHEN clause specifies for what condition the trigger has to be triggered. WHEN clause specifies for what condition the trigger has to be triggered.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "3. How do you write comments in a PL/SQL code?",
        "answer": "Comments are those sentences that have no effect on the functionality and are used for the purpose of enhancing the readability of the code. They are of two types:\nSingle Line Comment: This can be created by using the symbol -- and writing what we want to mention as a comment next to it.\nMulti-Line comment: These are the comments that can be specified over multiple lines and the syntax goes like /* comment information */\nExample: Comments are those sentences that have no effect on the functionality and are used for the purpose of enhancing the readability of the code. They are of two types:\nSingle Line Comment: This can be created by using the symbol -- and writing what we want to mention as a comment next to it.\nMulti-Line comment: These are the comments that can be specified over multiple lines and the syntax goes like /* comment information */ Single Line Comment: This can be created by using the symbol -- and writing what we want to mention as a comment next to it.\nMulti-Line comment: These are the comments that can be specified over multiple lines and the syntax goes like /* comment information */ Single Line Comment: This can be created by using the symbol -- and writing what we want to mention as a comment next to it. Single Line Comment: -- Multi-Line comment: These are the comments that can be specified over multiple lines and the syntax goes like /* comment information */ Multi-Line comment: /* comment information */ Example: Example: SET SERVEROUTPUT ON; \nDECLARE \n \n-- Hi There! I am a single line comment.\nvar_name varchar2(40) := 'I love PL/SQL' ;  \nBEGIN \n /* \n Hi! I am a multi line\n comment. I span across\n multiple lines\n */\ndbms_output.put_line(var_name);\nEND; \n/\nOutput:\nI love PL/SQL SET SERVEROUTPUT ON; \nDECLARE \n \n-- Hi There! I am a single line comment.\nvar_name varchar2(40) := 'I love PL/SQL' ;  \nBEGIN \n /* \n Hi! I am a multi line\n comment. I span across\n multiple lines\n */\ndbms_output.put_line(var_name);\nEND; \n/\nOutput:\nI love PL/SQL",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "4. When does a DECLARE block become mandatory?",
        "answer": "This statement is used by anonymous blocks of PL/SQL such as non-stored and stand-alone procedures. When they are being used, the statement should come first in the stand-alone file. This statement is used by anonymous blocks of PL/SQL such as non-stored and stand-alone procedures. When they are being used, the statement should come first in the stand-alone file.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "5. What is a Trigger? Name some instances when “Triggers” can be used.",
        "answer": "As the name indicates, ‘Trigger’ means to ‘activate’ something. In the case of PL/SQL, a trigger is a stored procedure that specifies what action has to be taken by the database when an event related to the database is performed. As the name indicates, ‘Trigger’ means to ‘activate’ something. In the case of PL/SQL, a trigger is a stored procedure that specifies what action has to be taken by the database when an event related to the database is performed. Trigger Trigger   Syntax: Syntax: Syntax: TRIGGER trigger_name\n trigger_event\n [ restrictions ]\nBEGIN\n actions_of_trigger;\nEND; TRIGGER trigger_name\n trigger_event\n [ restrictions ]\nBEGIN\n actions_of_trigger;\nEND; In the above syntax, if the trigger_name the trigger is in the enabled state, the trigger_event causes the database to fire actions_of_trigger if the restrictions are TRUE or unavailable. trigger_name trigger_event actions_of_trigger restrictions They are mainly used in the following scenarios:\nIn order to maintain complex integrity constraints.\nFor the purpose of auditing any table information.\nWhenever changes are done to a table, if we need to signal other actions upon completion of the change, then we use triggers.\nIn order to enforce complex rules of business.\nIt can also be used to prevent invalid transactions.\nYou can refer https://docs.oracle.com/database/121/TDDDG/tdddg_triggers.htm for more information regarding triggers. They are mainly used in the following scenarios:\nIn order to maintain complex integrity constraints.\nFor the purpose of auditing any table information.\nWhenever changes are done to a table, if we need to signal other actions upon completion of the change, then we use triggers.\nIn order to enforce complex rules of business.\nIt can also be used to prevent invalid transactions. In order to maintain complex integrity constraints.\nFor the purpose of auditing any table information.\nWhenever changes are done to a table, if we need to signal other actions upon completion of the change, then we use triggers.\nIn order to enforce complex rules of business.\nIt can also be used to prevent invalid transactions. In order to maintain complex integrity constraints. For the purpose of auditing any table information. Whenever changes are done to a table, if we need to signal other actions upon completion of the change, then we use triggers. In order to enforce complex rules of business. It can also be used to prevent invalid transactions. You can refer https://docs.oracle.com/database/121/TDDDG/tdddg_triggers.htm for more information regarding triggers. https://docs.oracle.com/database/121/TDDDG/tdddg_triggers.htm",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "6. How can a name be assigned to an unnamed PL/SQL Exception Block?",
        "answer": "This can be done by using Pragma called EXCEPTION_INIT.\nThis gives the flexibility to the programmer to instruct the compiler to provide custom error messages based on the business logic by overriding the pre-defined messages during the compilation time.\nSyntax: This can be done by using Pragma called EXCEPTION_INIT. EXCEPTION_INIT This gives the flexibility to the programmer to instruct the compiler to provide custom error messages based on the business logic by overriding the pre-defined messages during the compilation time. Syntax: Syntax: DECLARE \n  exception_name EXCEPTION; \n  PRAGMA EXCEPTION_INIT (exception_name, error_code); \nBEGIN \n// PL/SQL Logic\nEXCEPTION\n WHEN exception_name THEN\n    // Steps to handle exception\nEND; DECLARE \n  exception_name EXCEPTION; \n  PRAGMA EXCEPTION_INIT (exception_name, error_code); \nBEGIN \n// PL/SQL Logic\nEXCEPTION\n WHEN exception_name THEN\n    // Steps to handle exception\nEND;",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "7. What is the use of WHERE CURRENT OF in cursors?",
        "answer": "We use this clause while referencing the current row from an explicit cursor. This clause allows applying updates and deletion of the row currently under consideration without explicitly referencing the row ID.\nSyntax:\nUPDATE table_name SET field=new_value WHERE CURRENT OF cursor_name We use this clause while referencing the current row from an explicit cursor. This clause allows applying updates and deletion of the row currently under consideration without explicitly referencing the row ID. Syntax:\nUPDATE table_name SET field=new_value WHERE CURRENT OF cursor_name Syntax:  UPDATE table_name SET field=new_value WHERE CURRENT OF cursor_name",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "8. What is a PL/SQL cursor?",
        "answer": "A PL/SQL cursor is nothing but a pointer to an area of memory having SQL statements and the information of statement processing. This memory area is called a context area. This special area makes use of a special feature called cursor for the purpose of retrieving and processing more than one row.\nIn short, the cursor selects multiple rows from the database and these selected rows are individually processed within a program.\nThere are two types of cursors:\nImplicit Cursor:\nOracle automatically creates a cursor while running any of the commands - SELECT INTO, INSERT, DELETE or UPDATE implicitly.\nThe execution cycle of these cursors is internally handled by Oracle and returns the information and status of the cursor by making use of the cursor attributes- ROWCOUNT, ISOPEN, FOUND, NOTFOUND.\nExplicit Cursor:\nThis cursor is a SELECT statement that was declared explicitly in the declaration block.\nThe programmer has to control the execution cycle of these cursors starting from OPEN to FETCH and close.\nThe execution cycle while executing the SQL statement is defined by Oracle along with associating a cursor with it.\nExplicit Cursor Execution Cycle:\nDue to the flexibility of defining our own execution cycle, explicit cursors are used in many instances. The following diagram represents the execution flow of an explicit cursor: A PL/SQL cursor is nothing but a pointer to an area of memory having SQL statements and the information of statement processing. This memory area is called a context area. This special area makes use of a special feature called cursor for the purpose of retrieving and processing more than one row. In short, the cursor selects multiple rows from the database and these selected rows are individually processed within a program. There are two types of cursors:\nImplicit Cursor:\nOracle automatically creates a cursor while running any of the commands - SELECT INTO, INSERT, DELETE or UPDATE implicitly.\nThe execution cycle of these cursors is internally handled by Oracle and returns the information and status of the cursor by making use of the cursor attributes- ROWCOUNT, ISOPEN, FOUND, NOTFOUND.\nExplicit Cursor:\nThis cursor is a SELECT statement that was declared explicitly in the declaration block.\nThe programmer has to control the execution cycle of these cursors starting from OPEN to FETCH and close.\nThe execution cycle while executing the SQL statement is defined by Oracle along with associating a cursor with it. Implicit Cursor:\nOracle automatically creates a cursor while running any of the commands - SELECT INTO, INSERT, DELETE or UPDATE implicitly.\nThe execution cycle of these cursors is internally handled by Oracle and returns the information and status of the cursor by making use of the cursor attributes- ROWCOUNT, ISOPEN, FOUND, NOTFOUND.\nExplicit Cursor:\nThis cursor is a SELECT statement that was declared explicitly in the declaration block.\nThe programmer has to control the execution cycle of these cursors starting from OPEN to FETCH and close.\nThe execution cycle while executing the SQL statement is defined by Oracle along with associating a cursor with it. Implicit Cursor:\nOracle automatically creates a cursor while running any of the commands - SELECT INTO, INSERT, DELETE or UPDATE implicitly.\nThe execution cycle of these cursors is internally handled by Oracle and returns the information and status of the cursor by making use of the cursor attributes- ROWCOUNT, ISOPEN, FOUND, NOTFOUND. Implicit Cursor Oracle automatically creates a cursor while running any of the commands - SELECT INTO, INSERT, DELETE or UPDATE implicitly.\nThe execution cycle of these cursors is internally handled by Oracle and returns the information and status of the cursor by making use of the cursor attributes- ROWCOUNT, ISOPEN, FOUND, NOTFOUND. Oracle automatically creates a cursor while running any of the commands - SELECT INTO, INSERT, DELETE or UPDATE implicitly. The execution cycle of these cursors is internally handled by Oracle and returns the information and status of the cursor by making use of the cursor attributes- ROWCOUNT, ISOPEN, FOUND, NOTFOUND. Explicit Cursor:\nThis cursor is a SELECT statement that was declared explicitly in the declaration block.\nThe programmer has to control the execution cycle of these cursors starting from OPEN to FETCH and close.\nThe execution cycle while executing the SQL statement is defined by Oracle along with associating a cursor with it. Explicit Cursor: This cursor is a SELECT statement that was declared explicitly in the declaration block.\nThe programmer has to control the execution cycle of these cursors starting from OPEN to FETCH and close.\nThe execution cycle while executing the SQL statement is defined by Oracle along with associating a cursor with it. This cursor is a SELECT statement that was declared explicitly in the declaration block. The programmer has to control the execution cycle of these cursors starting from OPEN to FETCH and close. The execution cycle while executing the SQL statement is defined by Oracle along with associating a cursor with it. Explicit Cursor Execution Cycle:\nDue to the flexibility of defining our own execution cycle, explicit cursors are used in many instances. The following diagram represents the execution flow of an explicit cursor: Explicit Cursor Execution Cycle: Due to the flexibility of defining our own execution cycle, explicit cursors are used in many instances. The following diagram represents the execution flow of an explicit cursor: Due to the flexibility of defining our own execution cycle, explicit cursors are used in many instances. The following diagram represents the execution flow of an explicit cursor:   Cursor Declaration:\nThe first step to use an explicit cursor is its declaration.\nDeclaration can be done in a package or a block.\nSyntax: CURSOR cursor_name IS query; where cursor_name is the name of the cursor, the query is the query to fetch data from any table.\nOpen Cursor:\nBefore the process of fetching rows from cursor, the cursor has to be opened.\nSyntax to open a cursor: OPEN cursor_name;\nWhen the cursor is opened, the query and the bind variables are parsed by Oracle and the SQL statements are executed.\nThe execution plan is determined by Oracle and the result set is determined after associating the cursor parameters and host variables and post these, the cursor is set to point at the first row of the result set.\nFetch from cursor:\nFETCH statement is used to place the content of the current row into variables.\nSyntax: FETCH cursor_name INTO variable_list;\nIn order to get all the rows of a result set, each row needs to be fetched.\nClose Cursor:\nOnce all the rows are fetched, the cursor needs to be closed using the CLOSE statement.\nSyntax: CLOSE cursor_name;\nThe instructions tell Oracle to release the memory allocated to the cursor.\nCursors declared in procedures or anonymous blocks are by default closed post their execution.\nCursors declared in packages need to be closed explicitly as the scope is global.\nClosing a cursor that is not opened will result in INVALID_CURSOR exception. Cursor Declaration:\nThe first step to use an explicit cursor is its declaration.\nDeclaration can be done in a package or a block.\nSyntax: CURSOR cursor_name IS query; where cursor_name is the name of the cursor, the query is the query to fetch data from any table. Cursor Declaration: The first step to use an explicit cursor is its declaration.\nDeclaration can be done in a package or a block.\nSyntax: CURSOR cursor_name IS query; where cursor_name is the name of the cursor, the query is the query to fetch data from any table. The first step to use an explicit cursor is its declaration. Declaration can be done in a package or a block. Syntax: CURSOR cursor_name IS query; where cursor_name is the name of the cursor, the query is the query to fetch data from any table. Syntax: CURSOR cursor_name IS query; Open Cursor:\nBefore the process of fetching rows from cursor, the cursor has to be opened.\nSyntax to open a cursor: OPEN cursor_name;\nWhen the cursor is opened, the query and the bind variables are parsed by Oracle and the SQL statements are executed.\nThe execution plan is determined by Oracle and the result set is determined after associating the cursor parameters and host variables and post these, the cursor is set to point at the first row of the result set. Open Cursor: Before the process of fetching rows from cursor, the cursor has to be opened.\nSyntax to open a cursor: OPEN cursor_name;\nWhen the cursor is opened, the query and the bind variables are parsed by Oracle and the SQL statements are executed.\nThe execution plan is determined by Oracle and the result set is determined after associating the cursor parameters and host variables and post these, the cursor is set to point at the first row of the result set. Before the process of fetching rows from cursor, the cursor has to be opened. Syntax to open a cursor: OPEN cursor_name; Syntax OPEN cursor_name; When the cursor is opened, the query and the bind variables are parsed by Oracle and the SQL statements are executed. The execution plan is determined by Oracle and the result set is determined after associating the cursor parameters and host variables and post these, the cursor is set to point at the first row of the result set. Fetch from cursor:\nFETCH statement is used to place the content of the current row into variables.\nSyntax: FETCH cursor_name INTO variable_list;\nIn order to get all the rows of a result set, each row needs to be fetched. Fetch from cursor: FETCH statement is used to place the content of the current row into variables.\nSyntax: FETCH cursor_name INTO variable_list;\nIn order to get all the rows of a result set, each row needs to be fetched. FETCH statement is used to place the content of the current row into variables. Syntax: FETCH cursor_name INTO variable_list; Syntax: FETCH cursor_name INTO variable_list; In order to get all the rows of a result set, each row needs to be fetched. Close Cursor:\nOnce all the rows are fetched, the cursor needs to be closed using the CLOSE statement.\nSyntax: CLOSE cursor_name;\nThe instructions tell Oracle to release the memory allocated to the cursor.\nCursors declared in procedures or anonymous blocks are by default closed post their execution.\nCursors declared in packages need to be closed explicitly as the scope is global.\nClosing a cursor that is not opened will result in INVALID_CURSOR exception. Close Cursor: Once all the rows are fetched, the cursor needs to be closed using the CLOSE statement.\nSyntax: CLOSE cursor_name;\nThe instructions tell Oracle to release the memory allocated to the cursor.\nCursors declared in procedures or anonymous blocks are by default closed post their execution.\nCursors declared in packages need to be closed explicitly as the scope is global.\nClosing a cursor that is not opened will result in INVALID_CURSOR exception. Once all the rows are fetched, the cursor needs to be closed using the CLOSE statement. Syntax: CLOSE cursor_name; Syntax CLOSE cursor_name; The instructions tell Oracle to release the memory allocated to the cursor.\nCursors declared in procedures or anonymous blocks are by default closed post their execution.\nCursors declared in packages need to be closed explicitly as the scope is global.\nClosing a cursor that is not opened will result in INVALID_CURSOR exception. Cursors declared in procedures or anonymous blocks are by default closed post their execution.\nCursors declared in packages need to be closed explicitly as the scope is global.\nClosing a cursor that is not opened will result in INVALID_CURSOR exception. Cursors declared in procedures or anonymous blocks are by default closed post their execution. Cursors declared in packages need to be closed explicitly as the scope is global. Closing a cursor that is not opened will result in INVALID_CURSOR exception.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "9. Explain the basic structure followed in PL/SQL?",
        "answer": "The basic structure of PL/SQL follows the BLOCK structure. Each PL/SQL code comprises SQL and PL/SQL statement that constitutes a PL/SQL block.\nEach PL/SQL block consists of 3 sections:\nThe optional Declaration Section\nThe mandatory Execution Section\nThe optional Exception handling Section The basic structure of PL/SQL follows the BLOCK structure. Each PL/SQL code comprises SQL and PL/SQL statement that constitutes a PL/SQL block. Each PL/SQL block consists of 3 sections:\nThe optional Declaration Section\nThe mandatory Execution Section\nThe optional Exception handling Section The optional Declaration Section\nThe mandatory Execution Section\nThe optional Exception handling Section The optional Declaration Section The mandatory Execution Section The optional Exception handling Section [DECLARE]\n--declaration statements (optional)\nBEGIN\n--execution statements\n[EXCEPTION]\n--exception handling statements (optional)\nEND; [DECLARE]\n--declaration statements (optional)\nBEGIN\n--execution statements\n[EXCEPTION]\n--exception handling statements (optional)\nEND;",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "10. What do you understand by PL/SQL table?",
        "answer": "PL/SQL tables are nothing but objects of type tables that are modeled as database tables. They are a way to provide arrays that are nothing but temporary tables in memory for faster processing.\nThese tables are useful for moving bulk data thereby simplifying the process. PL/SQL tables are nothing but objects of type tables that are modeled as database tables. They are a way to provide arrays that are nothing but temporary tables in memory for faster processing. These tables are useful for moving bulk data thereby simplifying the process.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "1. What is the use of SYS.ALL_DEPENDENCIES?",
        "answer": "SYS.ALL_DEPENDENCIES is used for describing all the dependencies between procedures, packages, triggers, functions that are accessible to the current user. It returns the columns like name, dependency_type, type, referenced_owner etc. SYS.ALL_DEPENDENCIES is used for describing all the dependencies between procedures, packages, triggers, functions that are accessible to the current user. It returns the columns like name, dependency_type, type, referenced_owner etc.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "2. What are the virtual tables available during the execution of the database trigger?",
        "answer": "The THEN and NOW tables are the virtual tables that are available during the database trigger execution. The table columns are referred to as THEN.column and NOW.column respectively.\nOnly the NOW.column is available for insert-related triggers.\nOnly the THEN.column values are available for the DELETE-related triggers.\nBoth the virtual table columns are available for UPDATE triggers. The THEN and NOW tables are the virtual tables that are available during the database trigger execution. The table columns are referred to as THEN.column and NOW.column respectively. Only the NOW.column is available for insert-related triggers. Only the THEN.column values are available for the DELETE-related triggers. Both the virtual table columns are available for UPDATE triggers.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "3. Differentiate between the cursors declared in procedures and the cursors declared in the package specifications.",
        "answer": "The cursors that are declared in the procedures will have the local scope and hence they cannot be used by other procedures.\nThe cursors that are declared in package specifications are treated with global scope and hence they can be used and accessed by other procedures. The cursors that are declared in the procedures will have the local scope and hence they cannot be used by other procedures. The cursors that are declared in package specifications are treated with global scope and hence they can be used and accessed by other procedures.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "4. What is the difference between ROLLBACK and ROLLBACK TO statements in PL/SQL?",
        "answer": "ROLLBACK command is used for rolling back all the changes from the beginning of the transaction.\nROLLBACK TO command is used for undoing the transaction only till a SAVEPOINT. The transactions cannot be rolled back before the SAVEPOINT and hence the transaction remains active even before the command is specified. ROLLBACK command is used for rolling back all the changes from the beginning of the transaction. ROLLBACK command ROLLBACK TO command is used for undoing the transaction only till a SAVEPOINT. The transactions cannot be rolled back before the SAVEPOINT and hence the transaction remains active even before the command is specified. ROLLBACK TO command",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "5. What are the various functions available for manipulating the character data?",
        "answer": "The functions that are used for manipulating the character data are called String Functions.\nLEFT: This function returns the specified number of characters from the left part of a string.\nSyntax: LEFT(string_value, numberOfCharacters).\nFor example, LEFT(‘InterviewBit’, 9) will return ‘Interview’.\nRIGHT: This function returns the defined number of characters from the right part of a string.\nSyntax: RIGHT(string_value, numberOfCharacters)\nFor example, RIGHT(‘InterviewBit’,3) would return ‘Bit’.\nSUBSTRING: This function would select the data from a specified start position through the number of characters defined from any part of the string.\nSyntax: SUBSTRING(string_value, start_position, numberOfCharacters)\nFor example, SUBSTRING(‘InterviewBit’,2,4) would return ‘terv’.\nLTRIM: This function would trim all the white spaces on the left part of the string.\nSyntax: LTRIM(string_value)\nFor example, LTRIM(’ InterviewBit’) will return ‘InterviewBit’.\nRTRIM: This function would trim all the white spaces on the right part of the string.\nSyntax: RTRIM(string_value)\nFor example, RTRIM('InterviewBit ') will return ‘InterviewBit’.\nUPPER: This function is used for converting all the characters to the upper case in a string.\nSyntax: UPPER(string_variable)\nFor example, UPPER(‘interviewBit’) would return ‘INTERVIEWBIT’.\nLOWER: This function is used for converting all the characters of a string to lowercase.\nSyntax: LOWER(string_variable)\nFor example, LOWER(‘INterviewBit’) would return ‘interviewbit’. The functions that are used for manipulating the character data are called String Functions.\nLEFT: This function returns the specified number of characters from the left part of a string.\nSyntax: LEFT(string_value, numberOfCharacters).\nFor example, LEFT(‘InterviewBit’, 9) will return ‘Interview’.\nRIGHT: This function returns the defined number of characters from the right part of a string.\nSyntax: RIGHT(string_value, numberOfCharacters)\nFor example, RIGHT(‘InterviewBit’,3) would return ‘Bit’.\nSUBSTRING: This function would select the data from a specified start position through the number of characters defined from any part of the string.\nSyntax: SUBSTRING(string_value, start_position, numberOfCharacters)\nFor example, SUBSTRING(‘InterviewBit’,2,4) would return ‘terv’.\nLTRIM: This function would trim all the white spaces on the left part of the string.\nSyntax: LTRIM(string_value)\nFor example, LTRIM(’ InterviewBit’) will return ‘InterviewBit’.\nRTRIM: This function would trim all the white spaces on the right part of the string.\nSyntax: RTRIM(string_value)\nFor example, RTRIM('InterviewBit ') will return ‘InterviewBit’.\nUPPER: This function is used for converting all the characters to the upper case in a string.\nSyntax: UPPER(string_variable)\nFor example, UPPER(‘interviewBit’) would return ‘INTERVIEWBIT’.\nLOWER: This function is used for converting all the characters of a string to lowercase.\nSyntax: LOWER(string_variable)\nFor example, LOWER(‘INterviewBit’) would return ‘interviewbit’. LEFT: This function returns the specified number of characters from the left part of a string.\nSyntax: LEFT(string_value, numberOfCharacters).\nFor example, LEFT(‘InterviewBit’, 9) will return ‘Interview’.\nRIGHT: This function returns the defined number of characters from the right part of a string.\nSyntax: RIGHT(string_value, numberOfCharacters)\nFor example, RIGHT(‘InterviewBit’,3) would return ‘Bit’.\nSUBSTRING: This function would select the data from a specified start position through the number of characters defined from any part of the string.\nSyntax: SUBSTRING(string_value, start_position, numberOfCharacters)\nFor example, SUBSTRING(‘InterviewBit’,2,4) would return ‘terv’.\nLTRIM: This function would trim all the white spaces on the left part of the string.\nSyntax: LTRIM(string_value)\nFor example, LTRIM(’ InterviewBit’) will return ‘InterviewBit’.\nRTRIM: This function would trim all the white spaces on the right part of the string.\nSyntax: RTRIM(string_value)\nFor example, RTRIM('InterviewBit ') will return ‘InterviewBit’.\nUPPER: This function is used for converting all the characters to the upper case in a string.\nSyntax: UPPER(string_variable)\nFor example, UPPER(‘interviewBit’) would return ‘INTERVIEWBIT’.\nLOWER: This function is used for converting all the characters of a string to lowercase.\nSyntax: LOWER(string_variable)\nFor example, LOWER(‘INterviewBit’) would return ‘interviewbit’. LEFT: This function returns the specified number of characters from the left part of a string.\nSyntax: LEFT(string_value, numberOfCharacters).\nFor example, LEFT(‘InterviewBit’, 9) will return ‘Interview’. LEFT: Syntax: LEFT(string_value, numberOfCharacters).\nFor example, LEFT(‘InterviewBit’, 9) will return ‘Interview’. Syntax: LEFT(string_value, numberOfCharacters). For example, LEFT(‘InterviewBit’, 9) will return ‘Interview’. RIGHT: This function returns the defined number of characters from the right part of a string.\nSyntax: RIGHT(string_value, numberOfCharacters)\nFor example, RIGHT(‘InterviewBit’,3) would return ‘Bit’. RIGHT: Syntax: RIGHT(string_value, numberOfCharacters)\nFor example, RIGHT(‘InterviewBit’,3) would return ‘Bit’. Syntax: RIGHT(string_value, numberOfCharacters) For example, RIGHT(‘InterviewBit’,3) would return ‘Bit’. SUBSTRING: This function would select the data from a specified start position through the number of characters defined from any part of the string.\nSyntax: SUBSTRING(string_value, start_position, numberOfCharacters)\nFor example, SUBSTRING(‘InterviewBit’,2,4) would return ‘terv’. SUBSTRING: Syntax: SUBSTRING(string_value, start_position, numberOfCharacters)\nFor example, SUBSTRING(‘InterviewBit’,2,4) would return ‘terv’. Syntax: SUBSTRING(string_value, start_position, numberOfCharacters) For example, SUBSTRING(‘InterviewBit’,2,4) would return ‘terv’. LTRIM: This function would trim all the white spaces on the left part of the string.\nSyntax: LTRIM(string_value)\nFor example, LTRIM(’ InterviewBit’) will return ‘InterviewBit’. LTRIM: Syntax: LTRIM(string_value)\nFor example, LTRIM(’ InterviewBit’) will return ‘InterviewBit’. Syntax: LTRIM(string_value) For example, LTRIM(’ InterviewBit’) will return ‘InterviewBit’. RTRIM: This function would trim all the white spaces on the right part of the string.\nSyntax: RTRIM(string_value)\nFor example, RTRIM('InterviewBit ') will return ‘InterviewBit’. RTRIM: Syntax: RTRIM(string_value)\nFor example, RTRIM('InterviewBit ') will return ‘InterviewBit’. Syntax: RTRIM(string_value) For example, RTRIM('InterviewBit ') will return ‘InterviewBit’. UPPER: This function is used for converting all the characters to the upper case in a string.\nSyntax: UPPER(string_variable)\nFor example, UPPER(‘interviewBit’) would return ‘INTERVIEWBIT’. UPPER: Syntax: UPPER(string_variable)\nFor example, UPPER(‘interviewBit’) would return ‘INTERVIEWBIT’. Syntax: UPPER(string_variable) For example, UPPER(‘interviewBit’) would return ‘INTERVIEWBIT’. LOWER: This function is used for converting all the characters of a string to lowercase.\nSyntax: LOWER(string_variable)\nFor example, LOWER(‘INterviewBit’) would return ‘interviewbit’. LOWER: Syntax: LOWER(string_variable)\nFor example, LOWER(‘INterviewBit’) would return ‘interviewbit’. Syntax: LOWER(string_variable) For example, LOWER(‘INterviewBit’) would return ‘interviewbit’.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "6. What is the importance of %TYPE and %ROWTYPE data types in PL/SQL?",
        "answer": "%TYPE: This declaration is used for the purpose of anchoring by providing the data type of any variable, column, or constant. It is useful during the declaration of a variable that has the same data type as that of its table column.\nConsider the example of declaring a variable named ib_employeeid which has the data type and its size same as that of the column employeeid in table ib_employee. \nThe syntax would be : ib_employeeid ib_employee.employeeid%TYPE;\n%ROWTYPE: This is used for declaring a variable that has the same data type and size as that of a row in the table. The row of a table is called a record and its fields would have the same data types and names as the columns defined in the table.\nFor example: In order to declare a record named ib_emprecord for storing an entire row in a table called ib_employee, the syntax is:\nib_emprecord ib_employee%ROWTYPE; %TYPE: This declaration is used for the purpose of anchoring by providing the data type of any variable, column, or constant. It is useful during the declaration of a variable that has the same data type as that of its table column.\nConsider the example of declaring a variable named ib_employeeid which has the data type and its size same as that of the column employeeid in table ib_employee. \nThe syntax would be : ib_employeeid ib_employee.employeeid%TYPE; %TYPE: column Consider the example of declaring a variable named ib_employeeid which has the data type and its size same as that of the column employeeid in table ib_employee. \nThe syntax would be : ib_employeeid ib_employee.employeeid%TYPE; Consider the example of declaring a variable named ib_employeeid which has the data type and its size same as that of the column employeeid in table ib_employee. \nThe syntax would be : ib_employeeid ib_employee.employeeid%TYPE; ib_employeeid employeeid ib_employee  ib_employeeid ib_employee.employeeid%TYPE; %ROWTYPE: This is used for declaring a variable that has the same data type and size as that of a row in the table. The row of a table is called a record and its fields would have the same data types and names as the columns defined in the table.\nFor example: In order to declare a record named ib_emprecord for storing an entire row in a table called ib_employee, the syntax is:\nib_emprecord ib_employee%ROWTYPE; %ROWTYPE: For example: In order to declare a record named ib_emprecord for storing an entire row in a table called ib_employee, the syntax is:\nib_emprecord ib_employee%ROWTYPE; For example: In order to declare a record named ib_emprecord for storing an entire row in a table called ib_employee, the syntax is:\nib_emprecord ib_employee%ROWTYPE; ib_emprecord ib_employee  ib_emprecord ib_employee%ROWTYPE;",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "7. Differentiate between SQL and PL/SQL.",
        "answer": "SQL PL/SQL\nSQL is a natural language meant for the interactive processing of data in the database. PL/SQL is a procedural extension of SQL.\nDecision-making and looping are not allowed in SQL. PL/SQL supports all features of procedural language such as conditional and looping statements.\nAll SQL statements are executed at a time by the database server which is why it becomes a time-consuming process. PL/SQL statements are executed one block at a time thereby reducing the network traffic.\nThere is no error handling mechanism in SQL. This supports an error handling mechanism. SQL PL/SQL\nSQL is a natural language meant for the interactive processing of data in the database. PL/SQL is a procedural extension of SQL.\nDecision-making and looping are not allowed in SQL. PL/SQL supports all features of procedural language such as conditional and looping statements.\nAll SQL statements are executed at a time by the database server which is why it becomes a time-consuming process. PL/SQL statements are executed one block at a time thereby reducing the network traffic.\nThere is no error handling mechanism in SQL. This supports an error handling mechanism. SQL PL/SQL SQL PL/SQL SQL PL/SQL SQL is a natural language meant for the interactive processing of data in the database. PL/SQL is a procedural extension of SQL.\nDecision-making and looping are not allowed in SQL. PL/SQL supports all features of procedural language such as conditional and looping statements.\nAll SQL statements are executed at a time by the database server which is why it becomes a time-consuming process. PL/SQL statements are executed one block at a time thereby reducing the network traffic.\nThere is no error handling mechanism in SQL. This supports an error handling mechanism. SQL is a natural language meant for the interactive processing of data in the database. PL/SQL is a procedural extension of SQL. SQL is a natural language meant for the interactive processing of data in the database. PL/SQL is a procedural extension of SQL. Decision-making and looping are not allowed in SQL. PL/SQL supports all features of procedural language such as conditional and looping statements. Decision-making and looping are not allowed in SQL. PL/SQL supports all features of procedural language such as conditional and looping statements. All SQL statements are executed at a time by the database server which is why it becomes a time-consuming process. PL/SQL statements are executed one block at a time thereby reducing the network traffic. All SQL statements are executed at a time by the database server which is why it becomes a time-consuming process. PL/SQL statements are executed one block at a time thereby reducing the network traffic. There is no error handling mechanism in SQL. This supports an error handling mechanism. There is no error handling mechanism in SQL. This supports an error handling mechanism.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "8. Differentiate between implicit cursor and explicit cursor.",
        "answer": "Implicit Cursor  Explicit Cursor\nAn implicit cursor is used when a query returns a single row value. When a subquery returns more than one row, an explicit cursor is used. These rows are called Active Set.\nThis is used for all DML operations like DECLARE, OPEN, FETCH, CLOSE. This is used to process Multirow SELECT Statements.\nNO_DATA_FOUND Exception is handled here. NO_DATA_FOUND cannot be handled here. Implicit Cursor  Explicit Cursor\nAn implicit cursor is used when a query returns a single row value. When a subquery returns more than one row, an explicit cursor is used. These rows are called Active Set.\nThis is used for all DML operations like DECLARE, OPEN, FETCH, CLOSE. This is used to process Multirow SELECT Statements.\nNO_DATA_FOUND Exception is handled here. NO_DATA_FOUND cannot be handled here. Implicit Cursor  Explicit Cursor Implicit Cursor  Explicit Cursor Implicit Cursor Explicit Cursor An implicit cursor is used when a query returns a single row value. When a subquery returns more than one row, an explicit cursor is used. These rows are called Active Set.\nThis is used for all DML operations like DECLARE, OPEN, FETCH, CLOSE. This is used to process Multirow SELECT Statements.\nNO_DATA_FOUND Exception is handled here. NO_DATA_FOUND cannot be handled here. An implicit cursor is used when a query returns a single row value. When a subquery returns more than one row, an explicit cursor is used. These rows are called Active Set. An implicit cursor is used when a query returns a single row value. When a subquery returns more than one row, an explicit cursor is used. These rows are called Active Set. This is used for all DML operations like DECLARE, OPEN, FETCH, CLOSE. This is used to process Multirow SELECT Statements. This is used for all DML operations like DECLARE, OPEN, FETCH, CLOSE. This is used to process Multirow SELECT Statements. NO_DATA_FOUND Exception is handled here. NO_DATA_FOUND cannot be handled here. NO_DATA_FOUND Exception is handled here. NO_DATA_FOUND cannot be handled here.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "9. Why is SYSDATE and USER keywords used?",
        "answer": "SYSDATE:\nThis keyword returns the current time and date on the local database server.\nThe syntax is SYSDATE.\nIn order to extract part of the date, we use the TO_CHAR function on SYSDATE and specify the format we need.\nUsage:\nSELECT SYSDATE FROM dual;\nSELECT id, TO_CHAR(SYSDATE, 'yyyy/mm/dd') from InterviewBitEmployeeTable where customer_id < 200;\nUSER:\nThis keyword returns the user id of the current session.\nUsage:\nSELECT USER FROM dual; SYSDATE:\nThis keyword returns the current time and date on the local database server.\nThe syntax is SYSDATE.\nIn order to extract part of the date, we use the TO_CHAR function on SYSDATE and specify the format we need.\nUsage:\nSELECT SYSDATE FROM dual;\nSELECT id, TO_CHAR(SYSDATE, 'yyyy/mm/dd') from InterviewBitEmployeeTable where customer_id < 200; SYSDATE: This keyword returns the current time and date on the local database server.\nThe syntax is SYSDATE.\nIn order to extract part of the date, we use the TO_CHAR function on SYSDATE and specify the format we need.\nUsage:\nSELECT SYSDATE FROM dual;\nSELECT id, TO_CHAR(SYSDATE, 'yyyy/mm/dd') from InterviewBitEmployeeTable where customer_id < 200; This keyword returns the current time and date on the local database server. The syntax is SYSDATE. In order to extract part of the date, we use the TO_CHAR function on SYSDATE and specify the format we need. Usage:\nSELECT SYSDATE FROM dual;\nSELECT id, TO_CHAR(SYSDATE, 'yyyy/mm/dd') from InterviewBitEmployeeTable where customer_id < 200; SELECT SYSDATE FROM dual;\nSELECT id, TO_CHAR(SYSDATE, 'yyyy/mm/dd') from InterviewBitEmployeeTable where customer_id < 200; SELECT SYSDATE FROM dual; SELECT SYSDATE FROM dual; SELECT id, TO_CHAR(SYSDATE, 'yyyy/mm/dd') from InterviewBitEmployeeTable where customer_id < 200; SELECT id, TO_CHAR(SYSDATE, 'yyyy/mm/dd') from InterviewBitEmployeeTable where customer_id < 200; USER:\nThis keyword returns the user id of the current session.\nUsage:\nSELECT USER FROM dual; USER: This keyword returns the user id of the current session.\nUsage:\nSELECT USER FROM dual; This keyword returns the user id of the current session. Usage:\nSELECT USER FROM dual; SELECT USER FROM dual; SELECT USER FROM dual; SELECT USER FROM dual;",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "10. Can you explain the PL/SQL execution architecture?",
        "answer": "The PL/SQL engine does the process of compilation and execution of the PL/SQL blocks and programs and can only work if it is installed on an Oracle server or any application tool that supports Oracle such as Oracle Forms. PL/SQL is one of the parts of Oracle RDBMS, and it is important to know that most of the Oracle applications are developed using the client-server architecture. The Oracle database forms the server-side and requests to the database form a part of the client-side.\nSo based on the above fact and the fact that PL/SQL is not a standalone programming language, we must realize that the PL/SQL engine can reside in either the client environment or the server environment. This makes it easy to move PL/SQL modules and sub-programs between server-side and client-side applications.\nBased on the architecture shown below, we can understand that PL/SQL engine plays an important role in the process and execute the PL/SQL statements and whenever it encounters the SQL statements, they are sent to the SQL Statement Processor. PL/SQL is one of the parts of Oracle RDBMS, and it is important to know that most of the Oracle applications are developed using the client-server architecture. The Oracle database forms the server-side and requests to the database form a part of the client-side. So based on the above fact and the fact that PL/SQL is not a standalone programming language, we must realize that the PL/SQL engine can reside in either the client environment or the server environment. This makes it easy to move PL/SQL modules and sub-programs between server-side and client-side applications. Based on the architecture shown below, we can understand that PL/SQL engine plays an important role in the process and execute the PL/SQL statements and whenever it encounters the SQL statements, they are sent to the SQL Statement Processor.   Case 1: PL/SQL engine is on the server: In this case, the whole PL/SQL block gets passed to the PL/SQL engine present on the Oracle server which is then processed and the response is sent.\nCase 2: PL/SQL engine is on the client: Here the engine lies within the Oracle Developer tools and the processing of the PL/SQL statements is done on the client-side.\nIn case, there are any SQL statements in the PL/SQL block, then they are sent to the Oracle server for SQL processing.\nWhen there are no SQL statements, then the whole block processing occurs at the client-side. Case 1: PL/SQL engine is on the server: In this case, the whole PL/SQL block gets passed to the PL/SQL engine present on the Oracle server which is then processed and the response is sent. Case 1: PL/SQL engine is on the server: Case 2: PL/SQL engine is on the client: Here the engine lies within the Oracle Developer tools and the processing of the PL/SQL statements is done on the client-side.\nIn case, there are any SQL statements in the PL/SQL block, then they are sent to the Oracle server for SQL processing.\nWhen there are no SQL statements, then the whole block processing occurs at the client-side. Case 2: PL/SQL engine is on the client: In case, there are any SQL statements in the PL/SQL block, then they are sent to the Oracle server for SQL processing.\nWhen there are no SQL statements, then the whole block processing occurs at the client-side. In case, there are any SQL statements in the PL/SQL block, then they are sent to the Oracle server for SQL processing. When there are no SQL statements, then the whole block processing occurs at the client-side.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "1. What are COMMIT, ROLLBACK and SAVEPOINT statements in PL/SQL?",
        "answer": "These are the three transaction specifications that are available in PL/SQL.\nCOMMIT: Whenever any DML operations are performed, the data gets manipulated only in the database buffer and not the actual database. In order to save these DML transactions to the database, there is a need to COMMIT these transactions.\nCOMMIT transaction action does saving of all the outstanding changes since the last commit and the below steps take place:\nThe release of affected rows.\nThe transaction is marked as complete.\nThe details of the transaction would be stored in the data dictionary.\nSyntax: COMMIT;\nROLLBACK: In order to undo or erase the changes that were done in the current transaction, the changes need to be rolled back. ROLLBACK statement erases all the changes since the last COMMIT.\nSyntax: ROLLBACK;\nSAVEPOINT: This statement gives the name and defines a point in the current transaction process where any changes occurring before that SAVEPOINT would be preserved whereas all the changes after that point would be released.\nSyntax: SAVEPOINT <savepoint_name>; These are the three transaction specifications that are available in PL/SQL. COMMIT: Whenever any DML operations are performed, the data gets manipulated only in the database buffer and not the actual database. In order to save these DML transactions to the database, there is a need to COMMIT these transactions.\nCOMMIT transaction action does saving of all the outstanding changes since the last commit and the below steps take place:\nThe release of affected rows.\nThe transaction is marked as complete.\nThe details of the transaction would be stored in the data dictionary.\nSyntax: COMMIT; COMMIT: COMMIT transaction action does saving of all the outstanding changes since the last commit and the below steps take place:\nThe release of affected rows.\nThe transaction is marked as complete.\nThe details of the transaction would be stored in the data dictionary.\nSyntax: COMMIT; COMMIT transaction action does saving of all the outstanding changes since the last commit and the below steps take place:\nThe release of affected rows.\nThe transaction is marked as complete.\nThe details of the transaction would be stored in the data dictionary. The release of affected rows.\nThe transaction is marked as complete.\nThe details of the transaction would be stored in the data dictionary. The release of affected rows. The transaction is marked as complete. The details of the transaction would be stored in the data dictionary. Syntax: COMMIT; Syntax: ROLLBACK: In order to undo or erase the changes that were done in the current transaction, the changes need to be rolled back. ROLLBACK statement erases all the changes since the last COMMIT.\nSyntax: ROLLBACK; ROLLBACK: Syntax: ROLLBACK; Syntax: ROLLBACK; Syntax: SAVEPOINT: This statement gives the name and defines a point in the current transaction process where any changes occurring before that SAVEPOINT would be preserved whereas all the changes after that point would be released.\nSyntax: SAVEPOINT <savepoint_name>; SAVEPOINT: Syntax: SAVEPOINT <savepoint_name>; Syntax: SAVEPOINT <savepoint_name>; Syntax:",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "2. How can you debug your PL/SQL code?",
        "answer": "We can use DBMS_OUTPUT and DBMS_DEBUG statements for debugging our code:\nDBMS_OUTPUT prints the output to the standard console.\nDBMS_DEBUG prints the output to the log file. We can use DBMS_OUTPUT and DBMS_DEBUG statements for debugging our code:\nDBMS_OUTPUT prints the output to the standard console.\nDBMS_DEBUG prints the output to the log file. DBMS_OUTPUT prints the output to the standard console.\nDBMS_DEBUG prints the output to the log file. DBMS_OUTPUT prints the output to the standard console. DBMS_DEBUG prints the output to the log file.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "3. What is the difference between a mutating table and a constraining table?",
        "answer": "A table that is being modified by the usage of the DML statement currently is known as a mutating table. It can also be a table that has triggers defined on it.\nA table used for reading for the purpose of referential integrity constraint is called a constraining table. A table that is being modified by the usage of the DML statement currently is known as a mutating table. It can also be a table that has triggers defined on it. A table used for reading for the purpose of referential integrity constraint is called a constraining table.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "4. In what cursor attributes the outcomes of DML statement execution are saved?",
        "answer": "The outcomes of the execution of the DML statement is saved in the following 4 cursor attributes:\nSQL%FOUND: This returns TRUE if at least one row has been processed.\nSQL%NOTFOUND: This returns TRUE if no rows were processed.\nSQL%ISOPEN: This checks whether the cursor is open or not and returns TRUE if open.\nSQL%ROWCOUNT: This returns the number of rows processed by the DML statement. The outcomes of the execution of the DML statement is saved in the following 4 cursor attributes:\nSQL%FOUND: This returns TRUE if at least one row has been processed.\nSQL%NOTFOUND: This returns TRUE if no rows were processed.\nSQL%ISOPEN: This checks whether the cursor is open or not and returns TRUE if open.\nSQL%ROWCOUNT: This returns the number of rows processed by the DML statement. SQL%FOUND: This returns TRUE if at least one row has been processed.\nSQL%NOTFOUND: This returns TRUE if no rows were processed.\nSQL%ISOPEN: This checks whether the cursor is open or not and returns TRUE if open.\nSQL%ROWCOUNT: This returns the number of rows processed by the DML statement. SQL%FOUND: This returns TRUE if at least one row has been processed. SQL%NOTFOUND: This returns TRUE if no rows were processed. SQL%ISOPEN: This checks whether the cursor is open or not and returns TRUE if open. SQL%ROWCOUNT: This returns the number of rows processed by the DML statement.",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "5. Is it possible to declare column which has the number data type and its scale larger than the precision? For example defining columns like: column name NUMBER (10,100), column name NUMBER (10,-84)",
        "answer": "Yes, these type of declarations are possible.\nNumber (9, 12) indicates that there are 12 digits after decimal point. But since the maximum precision is 9, the rest are 0 padded like 0.000999999999.\nNumber (9, -12) indicates there are 21 digits before the decimal point and out of that there are 9 possible digits and the rest are 0 padded like 999999999000000000000.0 Yes, these type of declarations are possible. Number (9, 12) indicates that there are 12 digits after decimal point. But since the maximum precision is 9, the rest are 0 padded like 0.000999999999. Number (9, -12) indicates there are 21 digits before the decimal point and out of that there are 9 possible digits and the rest are 0 padded like 999999999000000000000.0",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "1. Write a PL/SQL program using WHILE loop for calculating the average of the numbers entered by user. Stop the entry of numbers whenever the user enters the number 0.",
        "answer": "DECLARE\n   n NUMBER;\n   average NUMBER :=0 ;\n   sum NUMBER :=0 ;\n   count NUMBER :=0 ;\nBEGIN\n   -- Take input from user\n   n := &input_number;\n   WHILE(n<>0)\n       LOOP\n           -- Increment count to find total elements\n           count := count+1;\n           -- Sum of elements entered\n           sum := sum+n;\n           -- Take input from user\n           n := &input_number;\n       END LOOP;\n   -- Average calculation\n   average := sum/count;\n   DBMS_OUTPUT.PUT_LINE(‘Average of entered numbers is ’||average);\nEND; DECLARE\n   n NUMBER;\n   average NUMBER :=0 ;\n   sum NUMBER :=0 ;\n   count NUMBER :=0 ;\nBEGIN\n   -- Take input from user\n   n := &input_number;\n   WHILE(n<>0)\n       LOOP\n           -- Increment count to find total elements\n           count := count+1;\n           -- Sum of elements entered\n           sum := sum+n;\n           -- Take input from user\n           n := &input_number;\n       END LOOP;\n   -- Average calculation\n   average := sum/count;\n   DBMS_OUTPUT.PUT_LINE(‘Average of entered numbers is ’||average);\nEND;",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "2. Write a PL/SQL procedure for selecting some records from the database using some parameters as filters.",
        "answer": "Consider that we are fetching details of employees from ib_employee table where salary is a parameter for filter. Consider that we are fetching details of employees from ib_employee table where salary is a parameter for filter. CREATE PROCEDURE get_employee_details @salary nvarchar(30)\nAS\nBEGIN\n   SELECT * FROM ib_employee WHERE salary = @salary;\nEND; CREATE PROCEDURE get_employee_details @salary nvarchar(30)\nAS\nBEGIN\n   SELECT * FROM ib_employee WHERE salary = @salary;\nEND;",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "3. Write a PL/SQL code to count the number of Sundays between the two inputted dates.",
        "answer": "--declare 2 dates of type Date\nDECLARE\n   start_date Date; \n   end_date Date; \n   sundays_count Number:=0; \nBEGIN\n   -- input 2 dates\n   start_date:='&input_start_date'; \n   end_date:='&input_end_date';\n   /* \n   Returns the date of the first day after the mentioned date \n   and matching the day specified in second parameter.\n   */\n   start_date:=NEXT_DAY(start_date-1, 'SUNDAY');\n   --check the condition of dates by using while loop. \n   while(start_date<=end_date) \n   LOOP \n       sundays_count:=sundays_count+1; \n       start_date:=start_date+7; \n   END LOOP; \n   \n   -- print the count of sundays\n   dbms_output.put_line('Total number of Sundays between the two dates:'||sundays_count); \nEND; \n/ --declare 2 dates of type Date\nDECLARE\n   start_date Date; \n   end_date Date; \n   sundays_count Number:=0; \nBEGIN\n   -- input 2 dates\n   start_date:='&input_start_date'; \n   end_date:='&input_end_date';\n   /* \n   Returns the date of the first day after the mentioned date \n   and matching the day specified in second parameter.\n   */\n   start_date:=NEXT_DAY(start_date-1, 'SUNDAY');\n   --check the condition of dates by using while loop. \n   while(start_date<=end_date) \n   LOOP \n       sundays_count:=sundays_count+1; \n       start_date:=start_date+7; \n   END LOOP; \n   \n   -- print the count of sundays\n   dbms_output.put_line('Total number of Sundays between the two dates:'||sundays_count); \nEND; \n/ Input:\nstart_date = ‘01-SEP-19’\nend_date = ‘29-SEP-19’ Input:   Output:\nTotal number of Sundays between the two dates: 5 Output: ",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "4. Write PL/SQL code block to increment the employee’s salary by 1000 whose employee_id is 102 from the given table below.",
        "answer": "EMPLOYEE_ID FIRST_NAME LAST_NAME EMAIL_ID PHONE_NUMBER JOIN_DATE JOB_ID  SALARY\n100 ABC DEF abef 9876543210 2020-06-06  AD_PRES 24000.00\n101 GHI JKL ghkl 9876543211  2021-02-08 AD_VP 17000.00\n102 MNO  PQR mnqr 9876543212 2016-05-14 AD_VP 17000.00\n103 STU VWX stwx 9876543213 2019-06-24 IT_PROG 9000.00 EMPLOYEE_ID FIRST_NAME LAST_NAME EMAIL_ID PHONE_NUMBER JOIN_DATE JOB_ID  SALARY\n100 ABC DEF abef 9876543210 2020-06-06  AD_PRES 24000.00\n101 GHI JKL ghkl 9876543211  2021-02-08 AD_VP 17000.00\n102 MNO  PQR mnqr 9876543212 2016-05-14 AD_VP 17000.00\n103 STU VWX stwx 9876543213 2019-06-24 IT_PROG 9000.00 EMPLOYEE_ID FIRST_NAME LAST_NAME EMAIL_ID PHONE_NUMBER JOIN_DATE JOB_ID  SALARY EMPLOYEE_ID FIRST_NAME LAST_NAME EMAIL_ID PHONE_NUMBER JOIN_DATE JOB_ID  SALARY EMPLOYEE_ID FIRST_NAME LAST_NAME EMAIL_ID PHONE_NUMBER JOIN_DATE JOB_ID SALARY 100 ABC DEF abef 9876543210 2020-06-06  AD_PRES 24000.00\n101 GHI JKL ghkl 9876543211  2021-02-08 AD_VP 17000.00\n102 MNO  PQR mnqr 9876543212 2016-05-14 AD_VP 17000.00\n103 STU VWX stwx 9876543213 2019-06-24 IT_PROG 9000.00 100 ABC DEF abef 9876543210 2020-06-06  AD_PRES 24000.00 100 ABC DEF abef 9876543210 2020-06-06 AD_PRES 24000.00 101 GHI JKL ghkl 9876543211  2021-02-08 AD_VP 17000.00 101 GHI JKL ghkl 9876543211 2021-02-08 AD_VP 17000.00 102 MNO  PQR mnqr 9876543212 2016-05-14 AD_VP 17000.00 102 MNO PQR mnqr 9876543212 2016-05-14 AD_VP 17000.00 103 STU VWX stwx 9876543213 2019-06-24 IT_PROG 9000.00 103 STU VWX stwx 9876543213 2019-06-24 IT_PROG 9000.00 DECLARE\n employee_salary  NUMBER(8,2);\n\n PROCEDURE update_salary (\n   emp        NUMBER, \n   salary IN OUT NUMBER\n ) IS\n BEGIN\n   salary := salary + 1000;\n END;\n\nBEGIN\n SELECT salary INTO employee_salary\n FROM ib_employee\n WHERE employee_id = 102;\n\n DBMS_OUTPUT.PUT_LINE\n  ('Before update_salary procedure, salary is: ' || employee_salary);\n\n update_salary (100, employee_salary);\n\n DBMS_OUTPUT.PUT_LINE\n  ('After update_salary procedure, salary is: ' || employee_salary);\nEND;\n/ DECLARE\n employee_salary  NUMBER(8,2);\n\n PROCEDURE update_salary (\n   emp        NUMBER, \n   salary IN OUT NUMBER\n ) IS\n BEGIN\n   salary := salary + 1000;\n END;\n\nBEGIN\n SELECT salary INTO employee_salary\n FROM ib_employee\n WHERE employee_id = 102;\n\n DBMS_OUTPUT.PUT_LINE\n  ('Before update_salary procedure, salary is: ' || employee_salary);\n\n update_salary (100, employee_salary);\n\n DBMS_OUTPUT.PUT_LINE\n  ('After update_salary procedure, salary is: ' || employee_salary);\nEND;\n/ Result: Result: Before update_salary procedure, salary is: 17000\nAfter update_salary procedure, salary is: 18000 Before update_salary procedure, salary is: 17000\nAfter update_salary procedure, salary is: 18000",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "5. Write a PL/SQL code to find whether a given string is palindrome or not.",
        "answer": "DECLARE\n-- Declared variables string, letter, reverse_string where string is the original string. \nstring VARCHAR2(10) := 'abccba'; \nletter VARCHAR2(20); \nreverse_string VARCHAR2(10); \nBEGIN\nFOR i IN REVERSE 1..LENGTH(string) LOOP \n letter := SUBSTR(string, i, 1);\n -- concatenate letter to reverse_string variable\n reverse_string := reverse_string ||''||letter; \nEND LOOP;\nIF reverse_string = string THEN\n       dbms_output.Put_line(reverse_string||''||' is palindrome'); \nELSE\n       dbms_output.Put_line(reverse_string ||'' ||' is not palindrome'); \nEND IF; \nEND; DECLARE\n-- Declared variables string, letter, reverse_string where string is the original string. \nstring VARCHAR2(10) := 'abccba'; \nletter VARCHAR2(20); \nreverse_string VARCHAR2(10); \nBEGIN\nFOR i IN REVERSE 1..LENGTH(string) LOOP \n letter := SUBSTR(string, i, 1);\n -- concatenate letter to reverse_string variable\n reverse_string := reverse_string ||''||letter; \nEND LOOP;\nIF reverse_string = string THEN\n       dbms_output.Put_line(reverse_string||''||' is palindrome'); \nELSE\n       dbms_output.Put_line(reverse_string ||'' ||' is not palindrome'); \nEND IF; \nEND;",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "6. Write PL/SQL program to convert each digit of a given number into its corresponding word format.",
        "answer": "DECLARE\n-- declare necessary variables \n   -- num represents the given number\n   -- number_to_word represents the word format of the number\n   -- str, len and digit are the intermediate variables used for program execution\nnum   INTEGER; \nnumber_to_word VARCHAR2(100); \ndigit_str   VARCHAR2(100); \nlen   INTEGER; \ndigit   INTEGER; \nBEGIN\n   num := 123456; \n   len := LENGTH(num); \n   dbms_output.PUT_LINE('Input: ' ||num);\n   -- Iterate through the number one by one\n   FOR i IN 1..len LOOP \n       digit := SUBSTR(num, i, 1);\n       -- Using DECODE, get the str representation of the digit\n       SELECT Decode(digit, 0, 'Zero ', \n                       1, 'One ', \n                       2, 'Two ', \n                       3, 'Three ', \n                       4, 'Four ', \n                       5, 'Five ', \n                       6, 'Six ', \n                       7, 'Seven ', \n                       8, 'Eight ', \n                       9, 'Nine ') \n       INTO digit_str \n       FROM dual;\n       -- Append the str representation of digit to final result.\n       number_to_word := number_to_word || digit_str; \n   END LOOP;\n   dbms_output.PUT_LINE('Output: ' ||number_to_word); \nEND; DECLARE\n-- declare necessary variables \n   -- num represents the given number\n   -- number_to_word represents the word format of the number\n   -- str, len and digit are the intermediate variables used for program execution\nnum   INTEGER; \nnumber_to_word VARCHAR2(100); \ndigit_str   VARCHAR2(100); \nlen   INTEGER; \ndigit   INTEGER; \nBEGIN\n   num := 123456; \n   len := LENGTH(num); \n   dbms_output.PUT_LINE('Input: ' ||num);\n   -- Iterate through the number one by one\n   FOR i IN 1..len LOOP \n       digit := SUBSTR(num, i, 1);\n       -- Using DECODE, get the str representation of the digit\n       SELECT Decode(digit, 0, 'Zero ', \n                       1, 'One ', \n                       2, 'Two ', \n                       3, 'Three ', \n                       4, 'Four ', \n                       5, 'Five ', \n                       6, 'Six ', \n                       7, 'Seven ', \n                       8, 'Eight ', \n                       9, 'Nine ') \n       INTO digit_str \n       FROM dual;\n       -- Append the str representation of digit to final result.\n       number_to_word := number_to_word || digit_str; \n   END LOOP;\n   dbms_output.PUT_LINE('Output: ' ||number_to_word); \nEND; Input: 12345\nOutput: One Two Three Four Five Input:  Output:",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "7. Write PL/SQL program to find the sum of digits of a number.",
        "answer": "DECLARE\n--Declare variables num, sum_of_digits and remainder of datatype Integer \nnum  INTEGER; \nsum_of_digits INTEGER; \nremainder  INTEGER; \nBEGIN\nnum := 123456; \nsum_of_digits := 0;\n-- Find the sum of digits until original number doesnt become null \nWHILE num <> 0 LOOP \n remainder := MOD(num, 10); \n sum_of_digits := sum_of_digits + remainder; \n num := TRUNC(num / 10); \nEND LOOP; \ndbms_output.PUT_LINE('Sum of digits is '|| sum_of_digits); \nEND; DECLARE\n--Declare variables num, sum_of_digits and remainder of datatype Integer \nnum  INTEGER; \nsum_of_digits INTEGER; \nremainder  INTEGER; \nBEGIN\nnum := 123456; \nsum_of_digits := 0;\n-- Find the sum of digits until original number doesnt become null \nWHILE num <> 0 LOOP \n remainder := MOD(num, 10); \n sum_of_digits := sum_of_digits + remainder; \n num := TRUNC(num / 10); \nEND LOOP; \ndbms_output.PUT_LINE('Sum of digits is '|| sum_of_digits); \nEND; Input: 9874\nOutput: 28 Input:  Output:",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "1. PL SQL Interview",
        "answer": "PL/SQL is a programming extension of SQL developed by Oracle which combines the power of SQL in the field of data manipulation and the power of procedural language for faster and effective processing of data thereby resulting in the creation of powerful queries.\nPL/SQL enhances the security, increases the platform portability, and makes it more robust by means of instructing the compiler ‘what to do’ and ‘how to do’ using SQL and procedural form respectively.\nFinally, it gives more power over the database to the programmers due to the feature of decision making, filtering, and looping abilities thereby making it a more convenient and reliable means for the programmers to work on it. PL/SQL is a programming extension of SQL developed by Oracle which combines the power of SQL in the field of data manipulation and the power of procedural language for faster and effective processing of data thereby resulting in the creation of powerful queries. PL/SQL enhances the security, increases the platform portability, and makes it more robust by means of instructing the compiler ‘what to do’ and ‘how to do’ using SQL and procedural form respectively. Finally, it gives more power over the database to the programmers due to the feature of decision making, filtering, and looping abilities thereby making it a more convenient and reliable means for the programmers to work on it. References:\nhttps://oracle-base.com/articles/misc/introduction-to-plsql References:  https://oracle-base.com/articles/misc/introduction-to-plsql Recommended Tutorials: Recommended Tutorials: SQL Server Interview Questions\nMySQL Interview Questions\nMongoDB Interview Questions\nDBMS Interview Questions SQL Server Interview Questions  MySQL Interview Questions  MongoDB Interview Questions  DBMS Interview Questions",
        "reference": "interviewbit.com",
        "role": "pl-sql"
    },
    {
        "question": "1) What is PL/SQL?",
        "answer": "PL/SQL stands for procedural language extension to SQL. It supports procedural features of programming language and SQL both. It was developed by Oracle Corporation in early of 90's to enhance the capabilities of SQL.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "2) What is the purpose of using PL/SQL?",
        "answer": "PL/SQL is an extension of SQL. While SQL is non-procedural, PL/SQL is a procedural language designed by Oracle. It is invented to overcome the limitations of SQL.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "3) What are the most important characteristics of PL/SQL?",
        "answer": "A list of some notable characteristics:\nADVERTISEMENT\nPL/SQL is a block-structured language.\nIt is portable to all environments that support Oracle.\nPL/SQL is integrated with the Oracle data dictionary.\nStored procedures help better sharing of application.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "4) What is PL/SQL table? Why it is used?",
        "answer": "Objects of type tables are called PL/SQL tables that are modeled as database table. We can also say that PL/SQL tables are a way to providing arrays. Arrays are like temporary tables in memory that are processed very quickly. PL/SQL tables are used to move bulk data. They simplifies moving collections of data.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "5) What are the datatypes available in PL/SQL?",
        "answer": "There are two types of datatypes in PL/SQL:\nScalar datatypes Example are NUMBER, VARCHAR2, DATE, CHAR, LONG, BOOLEAN etc.\nComposite datatypes Example are RECORD, TABLE etc.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "6) What is the basic structure of PL/SQL?",
        "answer": "PL/SQL uses BLOCK structure as its basic structure. Each PL/SQL program consists of SQL and PL/SQL statement which form a PL/SQL block.\nPL/SQL block contains 3 sections.\nThe Declaration Section (optional)\nThe Execution Section (mandatory)\nThe Exception handling Section (optional)",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "7) What is the difference between FUNCTION, PROCEDURE AND PACKAGE in PL/SQL?",
        "answer": "Function: The main purpose of a PL/SQL function is generally to compute and return a single value. A function has a return type in its specification and must return a value specified in that type.\nProcedure: A procedure does not have a return type and should not return any value but it can have a return statement that simply stops its execution and returns to the caller. A procedure is used to return multiple values otherwise it is generally similar to a function.\nPackage: A package is schema object which groups logically related PL/SQL types , items and subprograms. You can also say that it is a group of functions, procedure, variables and record type statement. It provides modularity, due to this facility it aids application development. It is used to hide information from unauthorized users.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "8) What is exception? What are the types of exceptions?",
        "answer": "Exception is an error handling part of PL/SQL. There are two type of exceptions: pre_defined exception and user_defined exception.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "9) How to write a single statement that concatenates the words ?Hello? and ?World? and assign it in a variable named Greeting?",
        "answer": "Greeting := 'Hello' || 'World';",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "10) Does PL/SQL support CREATE command?",
        "answer": "No. PL/SQL doesn't support the data definition commands like CREATE.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "",
        "answer": "A function returns a value while a stored procedure doesn?t return a value.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "12) How exception is different from error?",
        "answer": "Whenever an Error occurs Exception arises. Error is a bug whereas exception is a warning or error condition.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "13) What is the main reason behind using an index?",
        "answer": "Faster access of data blocks in the table.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "",
        "answer": "Too_many_rows\nNo_Data_Found\nValue_error\nZero_error etc.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "15) How do you declare a user-defined exception?",
        "answer": "You can declare the User defined exceptions under the DECLARE section, with the keyword EXCEPTION.\nSyntax:\n<exception_name> EXCEPTION;",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "16) What are some predefined exceptions in PL/SQL?",
        "answer": "A list of predefined exceptions in PL/SQL:\nDUP_VAL_ON_INDEX\nZERO_DIVIDE\nNO_DATA_FOUND\nTOO_MANY_ROWS\nCURSOR_ALREADY_OPEN\nINVALID_NUMBER\nINVALID_CURSOR\nPROGRAM_ERROR\nTIMEOUT _ON_RESOURCE\nSTORAGE_ERROR\nLOGON_DENIED\nVALUE_ERROR\netc.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "17) What is a trigger in PL/SQL?",
        "answer": "A trigger is a PL/SQL program which is stored in the database. It is executed immediately before or after the execution of INSERT, UPDATE, and DELETE commands.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "18) What is the maximum number of triggers, you can apply on a single table?",
        "answer": "12 triggers.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "19) How many types of triggers exist in PL/SQL?",
        "answer": "There are 12 types of triggers in PL/SQL that contains the combination of BEFORE, AFTER, ROW, TABLE, INSERT, UPDATE, DELETE and ALL keywords.\nBEFORE ALL ROW INSERT\nAFTER ALL ROW INSERT\nBEFORE INSERT\nAFTER INSERT etc.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "20) What is the difference between execution of triggers and stored procedures?",
        "answer": "A trigger is automatically executed without any action required by the user, while, a stored procedure is explicitly invoked by the user.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "21) What happens when a trigger is associated to a view?",
        "answer": "When a trigger is associated to a view, the base table triggers are normally enabled.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "22) What is the usage of WHEN clause in trigger?",
        "answer": "A WHEN clause specifies the condition that must be true for the trigger to be triggered.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "23) How to disable a trigger name update_salary?",
        "answer": "ALTER TRIGGER update_salary DISABLE;",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "24) Which command is used to delete a trigger?",
        "answer": "DROP TRIGGER command.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "25) what are the two virtual tables available at the time of database trigger execution?",
        "answer": "Table columns are referred as THEN.column_name and NOW.column_name.\nFor INSERT related triggers, NOW.column_name values are available only.\nFor DELETE related triggers, THEN.column_name values are available only.\nFor UPDATE related triggers, both Table columns are available.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "26) What is stored Procedure?",
        "answer": "A stored procedure is a sequence of statement or a named PL/SQL block which performs one or more specific functions. It is similar to a procedure in other programming languages. It is stored in the database and can be repeatedly executed. It is stored as schema object. It can be nested, invoked and parameterized.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "27) What are the different schemas objects that can be created using PL/SQL?",
        "answer": "Stored procedures and functions\nPackages\nTriggers\nCursors",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "28) What do you know by PL/SQL Cursors?",
        "answer": "Oracle uses workspaces to execute the SQL commands. When Oracle processes a SQL command, it opens an area in the memory called Private SQL Area. This area is identified by the cursor. It allows programmers to name this area and access it?s information.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "29) What is the difference between the implicit and explicit cursors?",
        "answer": "Implicit cursor is implicitly declared by Oracle. This is a cursor to all the DDL and DML commands that return only one row.\nExplicit cursor is created for queries returning multiple rows.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "30) What will you get by the cursor attribute SQL%ROWCOUNT?",
        "answer": "The cursor attribute SQL%ROWCOUNT will return the number of rows that are processed by a SQL statement.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "31) What will you get by the cursor attribute SQL%FOUND?",
        "answer": "It returns the Boolean value TRUE if at least one row was processed.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "32) What will you get by the cursor attribute SQL%NOTFOUND?",
        "answer": "It returns the Boolean value TRUE if no rows were processed.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "33) What do you understand by PL/SQL packages?",
        "answer": "A PL/SQL package can be specified as a file that groups functions, cursors, stored procedures, and variables in one place.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "34) What are the two different parts of the PL/SQL packages?",
        "answer": "PL/SQL packages have the following two parts:\nSpecification part: It specifies the part where the interface to the application is defined.\nBody part: This part specifies where the implementation of the specification is defined.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "35) Which command is used to delete a package?",
        "answer": "The DROP PACKAGE command is used to delete a package.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "36) How to execute a stored procedure?",
        "answer": "There are two way to execute a stored procedure.\nFrom the SQL prompt, write EXECUTE or EXEC followed by procedure_name.\nEXECUTE or [EXEC] procedure_name;  \nSimply use the procedure name\nprocedure_name;",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "37) What are the advantages of stored procedure?",
        "answer": "Modularity, extensibility, reusability, Maintainability and one time compilation.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "38) What are the cursor attributes used in PL/SQL?",
        "answer": "%ISOPEN: it checks whether the cursor is open or not.\n%ROWCOUNT: returns the number of rows affected by DML operations: INSERT,DELETE,UPDATE,SELECT.\n%FOUND: it checks whether cursor has fetched any row. If yes - TRUE.\n%NOTFOUND: it checks whether cursor has fetched any row. If no - TRUE.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "39) What is the difference between syntax error and runtime error?",
        "answer": "A syntax error can be easily detected by a PL/SQL compiler. For example: incorrect spelling etc. while, a runtime error is handled with the help of exception-handling section in a PL/SQL block. For example: SELECT INTO statement, which does not return any rows.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "",
        "answer": "Following conditions are true for the Commit statement:\nOther users can see the data changes made by the transaction.\nThe locks acquired by the transaction are released.\nThe work done by the transaction becomes permanent.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "41) Explain the Rollback statement?",
        "answer": "The Rollback statement is issued when the transaction ends. Following conditions are true for a Rollback statement:\nThe work done in a transition is undone as if it was never issued.\nAll locks acquired by transaction are released.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "",
        "answer": "With SAVEPOINT, only part of transaction can be undone.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "43) What is mutating table error?",
        "answer": "Mutating table error is occurred when a trigger tries to update a row that it is currently using. It is fixed by using views or temporary tables.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "44) What is consistency?",
        "answer": "Consistency simply means that each user sees the consistent view of the data.\nConsider an example: there are two users A and B. A transfers money to B's account. Here the changes are updated in A's account (debit) but until it will be updated to B's account (credit), till then other users can't see the debit of A's account. After the debit of A and credit of B, one can see the updates. That?s consistency.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "45) What is cursor and why it is required?",
        "answer": "A cursor is a temporary work area created in a system memory when an SQL statement is executed.\nA cursor contains information on a select statement and the row of data accessed by it. This temporary work area stores the data retrieved from the database and manipulate this data. A cursor can hold more than one row, but can process only one row at a time. Cursor are required to process rows individually for queries.",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    },
    {
        "question": "46) How many types of cursors are available in PL/SQL?",
        "answer": "There are two types of cursors in PL/SQL.\nImplicit cursor, and\nexplicit cursor",
        "reference": "javatpoint.com",
        "role": "pl-sql"
    }
]