[
    {
        "question": "1) What is RxJS? / What do you understand by RxJS?",
        "answer": "RxJS is an acronym that full form is Reactive Extension for Javascript. It is a JavaScript library that uses observables to work with reactive programming and deals with asynchronous data calls, callbacks and event-based programs. RxJS has introduced the concept of \"reactive programming\" to the web. It implements a reactive extension for TypeScript and JavaScript.\nRxJS works as a combination of the observer pattern, iterator pattern and functional programming.\nRxJS is a library for reactive programming using Observables to make it easier to compose asynchronous or callback-based code. It is a standalone JavaScript library that gives access to programmers to the Observable.\nRxJS can also be used with other JavaScript libraries and frameworks. JavaScript and TypeScript well support it.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "2) What is Reactive Programming?",
        "answer": "Reactive programming is a declarative programming paradigm which deals with asynchronous data streams. Glenn Wadden first developed reactive programming in 1986 as a programming language in the Supervisory Control and Data Acquisition (SCADA) industry. Event buses or typical click events are called asynchronous event streams, used in reactive programming to observe and do some side effects. Reactive programming facilitates us to create data streams of anything, not just from click and hover events.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "3) What should we know before going to learn RxJS?",
        "answer": "Before learning RxJS, we must have a basic knowledge of JavaScript, JavaScript frameworks, and Angular. You can easily understand this technology if you have a basic understanding of JS.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "4) What are the most outstanding features of RxJS?",
        "answer": "Following is the list of some most important features of RxJS that are used to handle the concept of RxJS or reactive programming:\nObserver\nThe Observer is an object with next(), error(), and complete() methods, which are called when we have to interact with the observable, i.e., the source interacts for an example button click, Http request, etc.\nObservable\nIn RxJS, an observable function is used to create an observer and attaches it to the source where values are expected. For example, clicks, mouse events from a DOM element or an Http request, etc.\nSubscription\nThe role of subscription comes in the scene when the observable is created. To execute the observable, we need to subscribe to it. It can also be used to cancel the execution.\nOperators\nOperators are a very important part of RxJS. An operator is a pure function that takes observable input and emits the result in the output form. Input and output both are observable.\nSubject\nA subject is observable that can multicast, i.e., talk to many observers. Suppose we have a button with an event listener. The function attached to the event using addlistener is called every time the user clicks on the button. Similar functionality goes for the subject too.\nSchedulers\nA scheduler controls the execution of when the subscription has to start and be notified.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "5) What are the biggest advantages of Reactive Programming?",
        "answer": "Advantages of using Reactive Programming\nADVERTISEMENT\nReactive programming provides a lot of operators that can simplify our work.\nReactive programming is very simple to compose streams of data.\nIt can be used to avoid \"callback problems\".\nIn Reactive programming, it is very simple to do async and threaded task.\nIt makes complex threading very easy.\nBy using Reactive programming, we can get a more cleaner and readable code base.\nIn Reactive programming, it is easy to implement back-pressure.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "6) What are the biggest advantages and disadvantages of using RxJS?",
        "answer": "Advantages of using RxJS\nFollowing is the list of key advantages of using RxJS:\nRxJS can be used with other Javascript libraries and frameworks. It is supported by javascript and also with typescript. Few examples are Angular, ReactJS, Vuejs, nodejs etc.\nRxJS is an awesome library when it comes to the handling of async tasks. RxJS uses observables to work with reactive programming that deals with asynchronous data calls, callbacks and event-based programs.\nRxJS offers a huge collection of operators in mathematical, transformation, filtering, utility, conditional, error handling, join categories that makes life easy when used with reactive programming.\nDisadvantages of using RxJS\n\nFollowing is the list of the biggest disadvantages of using RxJS:\nDebugging the code with observables is a little difficult.\nAs you start to use Observables, you can end up with your full code wrapped under the observables.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "Advantages of using RxJS",
        "answer": "Following is the list of key advantages of using RxJS:\nRxJS can be used with other Javascript libraries and frameworks. It is supported by javascript and also with typescript. Few examples are Angular, ReactJS, Vuejs, nodejs etc.\nRxJS is an awesome library when it comes to the handling of async tasks. RxJS uses observables to work with reactive programming that deals with asynchronous data calls, callbacks and event-based programs.\nRxJS offers a huge collection of operators in mathematical, transformation, filtering, utility, conditional, error handling, join categories that makes life easy when used with reactive programming.\nDisadvantages of using RxJS\n\nFollowing is the list of the biggest disadvantages of using RxJS:\nDebugging the code with observables is a little difficult.\nAs you start to use Observables, you can end up with your full code wrapped under the observables.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "Disadvantages of using RxJS",
        "answer": "Following is the list of the biggest disadvantages of using RxJS:\nDebugging the code with observables is a little difficult.\nAs you start to use Observables, you can end up with your full code wrapped under the observables.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "7) What is Redux?",
        "answer": "Redux is an open-source JavaScript library which is used to manage the application state. It is most commonly used with libraries such as React, Angular, or RxJS for building user interfaces. Redux is inspired by Facebook's Flux architecture and also very similar to it. It was created by Dan Abramov and Andrew Clark.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "8) What are the core principles of Redux?",
        "answer": "Redux follows the following three fundamental principles:\nSingle source of truth: It stores the state of your whole application in an object tree within a single store. The single state tree makes it easier to keep track of changes over time and debug or inspect the application.\nState is ready only: It emits an action that is the only way to change the state. It ensures and specifies that neither the views nor the network callbacks will ever write directly to the state.\nChanges are made with pure functions: We have to write pure reducers to specify how the state tree is transformed by actions. Reducers are simple pure functions that take the previous state and an action, and return the next state.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "9) What do you understand by RxJS Stream?",
        "answer": "An RxJS stream is a sequence of ongoing events ordered in time. In other words we can say that a stream is a sequence of data elements made available over time. A stream can be thought of as items on a conveyor belt being processed one at a time rather than in large batches. It is called stream because it acts as a data that is continuous and not really having an end, unless you explicitly define an end.\nA stream can emit three different things:\na value (of some type)\nan error\na \"completed\" signal",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "10) What do you understand by the Reactive Manifesto document?",
        "answer": "A document was introduced to define the core principles of reactive programming. That document is known as the Reactive Manifesto. The Reactive Manifesto document was first released in 2013 by a group of developers led by a man called Jonas Boner. The Reactive Manifesto underpins the principles of reactive programming.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "11) Is there any similarity between Redux and RxJS?",
        "answer": "Although Redux and RxJS are very different libraries for very different purposes, but they have some similarity also.\nRedux RxJS\nRedux is a tool used to manage state throughout the application. It is usually used as architecture for UIs. Iyt can be used as an alternative to (half of) Angular. RxJS is a reactive programming library. It is usually used as a tool to accomplish asynchronous tasks in JavaScript. Think of it as an alternative to Promises.\nRedux uses the Reactive paradigm little bit because the Store is reactive. The Store observes actions from a distance, and changes itself. RxJS also uses the Reactive paradigm, but instead of being architecture, it gives you basic building blocks, Observables, to accomplish this \"observing from a distance\" pattern.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "12) What is the difference between Reactive Programming and Imperative Programming?",
        "answer": "In Reactive Programming, observables emit data, and send it to the subscribers. This process can be called as data being PUSHed in reactive programming. On the other hand, data is being PULLed in imperative programming, where we explicitly request data (iterating over collection, requesting data from the DB, etc).",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "13) What is the difference between BehaviorSubject and Observable in RxJS?",
        "answer": "The following table specifies the differences between BehaviourSubject and Observable in RxJS:\nObservable BehaviourSubject\nIn RxJS, observable is stateless. In RxJS, BehaviourSubject is stateful.\nObservable creates copy of data. BehaviourSubject shares data.\nObservable is unidirectional in nature. BehaviourSubject is bidirectional in nature.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "14) What are Operators in RxJS? What are the different types of operators used in RxJS?",
        "answer": "Operators are very important part of RxJS. An RxJS operator is a pure function that takes an observable as input and provides the output also in the form of observable. We have to use a pipe() method to work with operators.\nFollowing is a list of most used operators in RxJS:\nCreation Operator\nMathematical Operator\nJoin Operator\nTransformation Operator\nFiltering Operator\nUtility Operator\nConditional Operator\nMulticasting Operator\nError handling Operator\nFurther, these operators are sub-divided in other types of operators.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "15) What is an Observable in RxJS?",
        "answer": "In RxJS, an observable is a function that is used to create an observer and attaches it to the source where values are expected from. For example, clicks, mouse events from a DOM element or an Http request, etc. afre the example of RxJS observable. Observable gives us the idea of an invokable collection of future values or events. It facilitates us to make asynchronous data streams using observable sequences or just called observables, too.\nWe have to follow the following three steps to complete the RxJS observable:\nCreate Observable\nSubscribe Observable\nExecute Observable",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "16) What is the difference between RxJS Observables and Promises?",
        "answer": "Following is the list of main differences between RxJS Observables and Promises:\nRxJS Observables Promises\nObservables are used to run asynchronously, and we get the return value multiple times. Promises are used to run asynchronously, and we get the return value only once.\nObservables are lazy. Promises are not lazy.\nObservables can be canceled. Promises cannot be canceled.\nObservables provide multiple future values. Promises provide a single future value.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "17) What are the advantages of RXJS Observables over RxJS Promises?",
        "answer": "In RxJS, an Observable has many advantages over Promises. The following list shows some of them:\nAn observable is like a Stream. It is used to pass zero or more events where the callback is called for each event.\nObservable is always preferred over Promise because it provides all the features of Promise and more.\nBy using an observable, we can handle single or multiple events.\nObservables are cancelable, so this is also an advantage over Promises.\nObservable allows lazy initialization.\nObservable allows formatting data.\nObservable provides operators like map, forEach, reduce etc.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "18) What is the difference between React and RxJS?",
        "answer": "React is an open-source JavaScript library that is used to provide a view for data rendered as hypertext markup language. On the other hand, RxJS stands for Reactive Extensions for JavaScript. It is considered a library for composing asynchronous programming in web development and event-based programs using observable sequences and LINQ-style query operators. Let's see the key differences between them.\nDifference between React and RxJS\nReact RxJS\nReact is an open-source JavaScript library. RxJS is a library for composing asynchronous programming.\nBy using React, we can easily create interactive UIs. By using React, we can easily create/compose asynchronous or callback-based code.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "19) What do you understand by the term Non-Blocking in RxJS?",
        "answer": "In RxJS or Reactive programming, an algorithm is called non-blocking if threads competing for a resource do not have their execution indefinitely postponed by mutual exclusion protecting that resource.\nThis concept is used in an API that allows access to the resource if available; otherwise, it immediately returns informing the caller that the resource is not currently available or the operation has been initiated and not yet completed. A non-blocking API to a resource allows the caller to do other work rather than be blocked waiting on the resource to become available. This may be complemented by allowing the client to register for getting notified when the resource is available or the operation has been completed.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "20) What does Asynchronous means in the context of RxJS or Reactive programming?",
        "answer": "According to the Oxford Dictionary, the term asynchronous can be defined as \"not existing or occurring at the same time.\" In the context of Reactive programming, it means that the processing of a request occurs at an arbitrary point in time, sometime after it has been transmitted from client to service. The client cannot directly observe, or synchronize with, the execution that occurs within the service. Asynchronous is the antonym of synchronous processing, which implies that the client only resumes its execution once the service has processed the request.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "21) What is the difference between Cold and Hot Observables in RxJS?",
        "answer": "In simple words, the concept of cold and hot Observable can be defined as the following:\nWhen the data is produced by the Observable itself, t is called the cold Observable. When the data is produced outside the Observable, it is called hot Observable.\nLet's see the differences between Cold Observables and Hot Observables:\nCold Observables Hot Observables\nWe can call an Observable \"cold\" when the data is produced inside the Observable. We call the Observable \"hot\" when the data is produced outside the Observable.\nCold observables start to run upon subscription. Hot observables produce values even before a subscription is made.\nThe Cold observable sequence only starts pushing values to observers when subscribe is called. Hot observables such as mouse move events, stock pickers or WebSocket connections are already produced in values even before the subscription is active.\nThe cold Observable starts running upon subscription. The hot Observable produces values before subscriptions.\nThe cold Observable sequence starts pushing values. In cold Observable, the data producer is outside the Observable.\nIn cold Observable, the data is produced inside the Observable so, we cannot share the data between multiple subscribers. Two Observables that subscribe at more or less the same may receive two different values. We call this behavior \"unicasting.\" As we know that the data is produced outside the Observable in hot Observable, so it can share data between multiple subscribers in hot Observable. This behavior is \"multicasting.\"",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "22) What do you understand by the Actor Model in RxJS?",
        "answer": "An actor model can do the following things:\nAn Actor model specifies that your concurrency primitives are actors.\nIt can send messages to any actors they know about.\nIt can receive a message and decide what to do next depending on the content of the message.\nIt can create new actors and provides certain guarantees, such as any actor will only handle a single message at a time and messages sent by actor X to actor Y will arrive in the order they were sent.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "23) What does a subject do in RxJS?",
        "answer": "RxJS subject is a special type of observable that allows values to be multicast to many observers. RxJS subjects are multicast instead of plain observables, which are unicast. The subject is the equivalent of an event emitter and the only way of multicast in a value or event to multiple observers. Subject implements both observable and observer interfaces. Every subject is observable so that you can subscribe to it. Every subject is an observer. It means that you have next, error, and complete methods, so you can send values, error subject or completed.\nTypes of Subjects\nSubject\nReplaySubject\nBehaviorSubject\nAsyncSubject",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "24) What are the differences between Subject, BehaviorSubject and ReplaySubject in RxJS?",
        "answer": "Subject\nIn the RxJS Subject, Observers who are subscribed later do not obtain the data values emitted before their subscription.\nReplaySubject\nIn RxJS ReplaySubject, Observers who are subscribed at a later point receives data values issued before their subscription. It operates by using a buffer that holds the values emitted and re-emits them once new Observers are subscribed.\nBehaviorSubject\nBehaviorSubject functions similar to ReplaySubject but only re-issues the last emitted values. So, it should be used when you are interested in the observer's last/current value.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "Subject",
        "answer": "In the RxJS Subject, Observers who are subscribed later do not obtain the data values emitted before their subscription.\nReplaySubject\nIn RxJS ReplaySubject, Observers who are subscribed at a later point receives data values issued before their subscription. It operates by using a buffer that holds the values emitted and re-emits them once new Observers are subscribed.\nBehaviorSubject\nBehaviorSubject functions similar to ReplaySubject but only re-issues the last emitted values. So, it should be used when you are interested in the observer's last/current value.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "ReplaySubject",
        "answer": "In RxJS ReplaySubject, Observers who are subscribed at a later point receives data values issued before their subscription. It operates by using a buffer that holds the values emitted and re-emits them once new Observers are subscribed.\nBehaviorSubject\nBehaviorSubject functions similar to ReplaySubject but only re-issues the last emitted values. So, it should be used when you are interested in the observer's last/current value.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "BehaviorSubject",
        "answer": "BehaviorSubject functions similar to ReplaySubject but only re-issues the last emitted values. So, it should be used when you are interested in the observer's last/current value.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "25) What is RxJS Map, and what do you understand by Higher-Order Observable Mapping?",
        "answer": "RxJS map operator facilitates us to project the payload of the Observable into something else. We can see the powerful features of Observables when we start using Rx operators to transform, combine, manipulate, and work with sequences of items emitted by Observables.\nRxJS Higher-Order Observable Mapping\nWe map source observable emitted value into other Observable in higher-order mapping instead of mapping a flat value like 1 to another value like 10.! The result is an Observable higher order.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "RxJS Higher-Order Observable Mapping",
        "answer": "We map source observable emitted value into other Observable in higher-order mapping instead of mapping a flat value like 1 to another value like 10.! The result is an Observable higher order.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "26) When should we use the switchMap, mergeMap and concatMap in RxJS?",
        "answer": "There are mainly four types of mapping operators used in RxJS: concatMap(), mergeMap(), switchMap() and exhaustMap(). All of these operators are mapping or flattening operators used to flatten observables, but they are applicable in very different scenarios. The switchMap and mergeMap are the most powerful and frequently used operators. Let's see when we use these operators:\nconcatMap() Operators\nFollowing is the sample code of concatMap() Operators:\nthis.form.valueChanges  \n.pipe(  \n    concatMap(formValue => this.http.put(\"/api/book/\",formValue))  \n)  \n.subscribe(  \n    response =>  ... handle successful ...,  \n    err => ... handle error ...        \n);  \nThe two main benefits of using concatMap() operator are that we no longer have to use nested subscribes with higher-order mapping operator, and the second is, all http requests are sent to the backend sequentially.\nThis is how the concatMap operator ensures that the requests still occur in sequence:\nconcatMap takes each form value and transforms it into an observer HTTP, known as an inner observer.\nconcatMap subscribes to the inner Observable and sends its output to the Observable result\nThe second form of value can come more quickly than is needed to request in the backend the previous form value. When this occurs, the new form value is not converted to an HTTP request immediately.\nmergeMap() Operator\nUnlike the RxJS concatMap operator, mergeMap() will not wait until the Observable finishes until the next Observable is subscribed.\nThis is how the mergeMap operator works:\nIn mergeMap operator, every Observable source value is mapped in an internal Observable.\nThe inner Observable is then subscribed by mergeMap.\nWhen the inner observables emit new values, the output Observable immediately reflects them.\nIn the mergeMap, unlike the concatMap operator, we do not need to wait until the previous inner observable is completed.\nswitchMap() Operator\nUnlike the mergeMap operator, in the switchMap operator, we unsubscribe the previous Observable before subscribing to the new Observable if the new Observable begins to emit the values.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "concatMap() Operators",
        "answer": "Following is the sample code of concatMap() Operators:\nthis.form.valueChanges  \n.pipe(  \n    concatMap(formValue => this.http.put(\"/api/book/\",formValue))  \n)  \n.subscribe(  \n    response =>  ... handle successful ...,  \n    err => ... handle error ...        \n);  \nThe two main benefits of using concatMap() operator are that we no longer have to use nested subscribes with higher-order mapping operator, and the second is, all http requests are sent to the backend sequentially.\nThis is how the concatMap operator ensures that the requests still occur in sequence:\nconcatMap takes each form value and transforms it into an observer HTTP, known as an inner observer.\nconcatMap subscribes to the inner Observable and sends its output to the Observable result\nThe second form of value can come more quickly than is needed to request in the backend the previous form value. When this occurs, the new form value is not converted to an HTTP request immediately.\nmergeMap() Operator\nUnlike the RxJS concatMap operator, mergeMap() will not wait until the Observable finishes until the next Observable is subscribed.\nThis is how the mergeMap operator works:\nIn mergeMap operator, every Observable source value is mapped in an internal Observable.\nThe inner Observable is then subscribed by mergeMap.\nWhen the inner observables emit new values, the output Observable immediately reflects them.\nIn the mergeMap, unlike the concatMap operator, we do not need to wait until the previous inner observable is completed.\nswitchMap() Operator\nUnlike the mergeMap operator, in the switchMap operator, we unsubscribe the previous Observable before subscribing to the new Observable if the new Observable begins to emit the values.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "mergeMap() Operator",
        "answer": "Unlike the RxJS concatMap operator, mergeMap() will not wait until the Observable finishes until the next Observable is subscribed.\nThis is how the mergeMap operator works:\nIn mergeMap operator, every Observable source value is mapped in an internal Observable.\nThe inner Observable is then subscribed by mergeMap.\nWhen the inner observables emit new values, the output Observable immediately reflects them.\nIn the mergeMap, unlike the concatMap operator, we do not need to wait until the previous inner observable is completed.\nswitchMap() Operator\nUnlike the mergeMap operator, in the switchMap operator, we unsubscribe the previous Observable before subscribing to the new Observable if the new Observable begins to emit the values.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "switchMap() Operator",
        "answer": "Unlike the mergeMap operator, in the switchMap operator, we unsubscribe the previous Observable before subscribing to the new Observable if the new Observable begins to emit the values.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "27) What is Back-Pressure in Reactive Programming?",
        "answer": "According to the Wikipedia definition, Back-Pressure is resistance or force opposing the desired flow of fluid through pipes. But this definition belongs to fluid dynamics. In the context of software, the definition will be changed to flow of data within software instead of fluid through pipes. So, the definition would be-\nBack-Pressure is a resistance or force opposing the desired flow of data through software.\nWhen one component is struggling to keep up, the entire system needs to respond sensibly. It is unacceptable for the component under stress to fail or to drop messages in an uncontrolled fashion. Since it is not easy to handle and can't fail, it should communicate that it is under stress to upstream components and get them to reduce the load. This back-pressure is an important feedback mechanism that facilitates systems to respond to load rather than collapse under such a situation gracefully. The back-pressure may cascade up to the user, at which point responsiveness may degrade. Still, this mechanism will ensure that the system is resilient under load and will provide information that may allow the system to apply other resources to make easy the load by distributing it.\nIn simple words, we can say that Back-pressure provides the strategies for coping with Observables that produce items more rapidly than their observers consume them.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "28) What do you understand by Elasticity in contrast to Scalability?",
        "answer": "In the IT infrastructure, the term \"Elasticity\" can be defined as the ability to quickly expand or cut back capacity and services without obstructing the infrastructure's stability, performance, security, governance or compliance protocols.\nIt means that the throughput of a system scales up or down automatically to meet varying demand as a resource is proportionally added or removed. The system needs to be scalable to allow it to benefit from the dynamic addition or removal of resources at runtime. Elasticity, therefore, builds upon Scalability and expands on it by adding the notion of automatic resource management.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "29) What is the difference between Failure and Error?",
        "answer": "Failure Error\nA failure can be defined as an unexpected event within a service that prevents it from functioning normally. When a failure occurs, it can generally prevent responses to the current and possibly all following client requests. Errors are different from failures. An error is a common condition that can appear during input validation that will be communicated to the client as part of the message's normal processing.\nFailures are unexpected, and they require intervention before the system can resume at the same level of operation as earlier. Errors are an expected part of normal operations. We can deal with errors immediately, and the system will continue to operate at the same capacity following an error.\nIt does not mean that failures are always fatal. Rather, some capacity of the system will be reduced following a failure. Errors are not fatal. They are part of the programming and can be occurred anytime.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "30) What is the difference between Imperative, Functional and Reactive Programming?",
        "answer": "Let's compare them to see the difference:\nImperative Programming: Imperative programming is a programming paradigm where each line of code is sequentially executed to produce the desired result. This programming paradigm forces programmers to write \"how\" a program will solve a certain task.\nFunctional Programming: Functional programming is a programming paradigm where we can set everything as a result of a function that avoids changing states and mutating data.\nReactive Programming: Reactive programming is a programming paradigm with asynchronous data streams or event streams. An event stream can be anything like keyboard inputs, button taps, gestures, GPS location updates, accelerometer, iBeacon etc. Here, we can listen to a stream and react to it according to the situation.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    },
    {
        "question": "31) What do you understand by to be Resilient for a Reactive System?",
        "answer": "To be Resilient for a Reactive System means the system will stay responsive if it gets any chance of failure. Any system that is not resilient will be unresponsive after a failure. Resilience is achieved by replication, containment, isolation and delegation. Failures are contained within each component, isolating components from each other, thereby ensuring that parts of the system can fail and recover without compromising the entire system.",
        "reference": "javatpoint.com",
        "role": "rxjs"
    }
]