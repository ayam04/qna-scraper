[
    {
        "question": "1. Compare Software Testing Vs. Debugging",
        "answer": "Criteria Software testing Debugging\nProcess Known conditions, predefined methods and expected outcome Unknown conditions, not preset method and unpredictable outcome\nPrerequisite No need of design knowledge Need full design knowledge\nGoal Finding error or bug Finding a cause for the error or bug",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "2. Explain Monkey testing.",
        "answer": "A technique of software testing where the application is tested by ingesting inputs randomly. This test does not follow any pre-defined set of rules. It is carried out to check the behavior of the application.\nCheck out our blog on Selenium tutorial to learn how to automate testing using Selenium!",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "3. What is the difference between baseline and benchmark testing?",
        "answer": "While Baseline testing runs a set of tests to determine the performance, Benchmark testing compares the application performance with industry standards. Baseline testing strives to improve performance with the help of collected information, on the other hand, benchmark testing seeks to improve application performance by matching it with benchmarks.\nCrack API testing interviews with the help of our guide on API Testing Interview Questions and Answers.",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "4. Explain bug life cycle.",
        "answer": "When a tester finds a bug, the bug is assigned NEW or OPEN with status.\nThe bug is either assigned to Development Project Managers or is given to Bug Bounty Program. They will check whether it is a valid defect. If not valid, the bug is rejected, and its new status is REJECTED.\nNow, the tester checks whether a similar defect was raised earlier. If yes, the defect is assigned a status ‘DUPLICATE’\nOnce the bug is fixed, the defect is assigned a status ‘FIXED’\nNext, the tester will re-test the code. In case, the test case passes, the defect is CLOSED\nIf the test case fails again, the bug is RE-OPENED and assigned to the developer.\nPreparing for a job interview? Check out our blog on Manual Testing Interview Questions!",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "5. How can we perform Spike testing in JMeter?",
        "answer": "JMeter comes with a synchronizing timer which can handle the requests of multiple threads. It is able to get the required number of threads and release them at once to cause a spike.\n\nCheck out this video on Software Testing Interview Questions:\n\n\n\nIntermediate Software Testing Interview Questions for experienced",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "6. What is Silk Test?",
        "answer": "Silk Test is a tool developed for performing regression and functionality testing of the application. Silk Test is a tool, used when we are testing applications based on Windows, Java, Web, or traditional client/server. Silk Test helps in preparing the test plan and managing those test plans to provide direct access to the database and field validation.\nAlso, check out the blog on End-to-End Testing.",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "7. Define Requirements Traceability Matrix.",
        "answer": "The Requirement Traceability Matrix (RTM) is a bi-directional matrix that captures the details of requirements and their traceability. Created at the initial steps of a project, RTM tracks the requirement by analyzing the deliverables and business requirements\nCheck out our blog to learn about Types of Software Testing!",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "8. What is elementary process?",
        "answer": "Software applications are made up of several elementary processes. There are two types of elementary processes:\nDynamic elementary Process: The dynamic elementary involves the process of moving data from one location to another. The location can be either within the application or outside it.\nStatic elementary Process: It involves maintaining the data of the application.",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "9. Highlight the role of QA in project development.",
        "answer": "QA plays a crucial role in project development. Some of them are outlined here-\nReduce the defects and errors\nPreventing defects from occurring\nMaintain the system quality as per the specifications\nTest the projects on failure parameters to check its fault tolerance\nClick here to learn more about software testing, in this online Software Testing Course.",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "10. What are the tools of performance testing?",
        "answer": "The following are the tools of performance testing:\nLoadRunner(HP): This testing tool contains a wide array of application environments, platforms, and databases. It is typically suitable for web applications and others.\nQA load(Compuware): This tool is used for load testing of web, database, and char-based systems.\nWebLoad(RadView): It is used to compare running tests with test metrics.\nRational Performance Tester (IBM): It allows finding out the presence and cause of bottlenecks.\nSilk Performer (Borland): This testing tool lets you predict the behavior of e-business environment.\nAlso, check out the blog on Test Scenario.",
        "reference": "intellipaat.com",
        "role": "software-testing"
    },
    {
        "question": "1. What is Software testing?",
        "answer": "Software testing involves evaluating and verifying a software product's functionality. Basically, it checks whether the software product matches anticipated requirements and makes sure it is defect-free. It can be said that testing enhances the quality of the product by preventing bugs, reducing development costs, and reducing performance issues.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "2. What are the different types of testing?",
        "answer": "You can test the software in many different ways. Some types of testing are conducted by software developers and some by specialized quality assurance staff. Here are a few different kinds of software testing, along with a brief description of each.   Type Description\nUnit Testing A programmatic test that tests the internal working of a unit of code, such as a method or a function.\nIntegration Testing Ensures that multiple components of systems work as expected when they are combined to produce a result.\nRegression Testing Ensures that existing features/functionality that used to work are not broken due to new code changes.\nSystem Testing Complete end-to-end testing is done on the complete software to make sure the whole system works as expected.\nSmoke Testing A quick test performed to ensure that the software works at the most basic level and doesn’t crash when it’s started. Its name originates from the hardware testing where you just plug the device and see if smoke comes out.\nPerformance Testing Ensures that the software performs according to the user’s expectations by checking the response time and throughput under specific load and environment. \nUser-Acceptance Testing Ensures the software meets the requirements of the clients or users. This is typically the last step before the software is live, i.e. it goes to production.\nStress Testing Ensures that the performance of the software doesn’t degrade when the load increases. In stress testing, the tester subjects the software under heavy loads, such as a high number of requests or stringent memory conditions to verify if it works well.\nUsability Testing Measures how usable the software is. This is typically performed with a sample set of end-users, who use the software and provide feedback on how easy or complicated it is to use the software. \nSecurity Testing Now more important than ever. Security testing tries to break a software’s security checks, to gain access to confidential data. Security testing is crucial for web-based applications or any applications that involve money. Type Description\nUnit Testing A programmatic test that tests the internal working of a unit of code, such as a method or a function.\nIntegration Testing Ensures that multiple components of systems work as expected when they are combined to produce a result.\nRegression Testing Ensures that existing features/functionality that used to work are not broken due to new code changes.\nSystem Testing Complete end-to-end testing is done on the complete software to make sure the whole system works as expected.\nSmoke Testing A quick test performed to ensure that the software works at the most basic level and doesn’t crash when it’s started. Its name originates from the hardware testing where you just plug the device and see if smoke comes out.\nPerformance Testing Ensures that the software performs according to the user’s expectations by checking the response time and throughput under specific load and environment. \nUser-Acceptance Testing Ensures the software meets the requirements of the clients or users. This is typically the last step before the software is live, i.e. it goes to production.\nStress Testing Ensures that the performance of the software doesn’t degrade when the load increases. In stress testing, the tester subjects the software under heavy loads, such as a high number of requests or stringent memory conditions to verify if it works well.\nUsability Testing Measures how usable the software is. This is typically performed with a sample set of end-users, who use the software and provide feedback on how easy or complicated it is to use the software. \nSecurity Testing Now more important than ever. Security testing tries to break a software’s security checks, to gain access to confidential data. Security testing is crucial for web-based applications or any applications that involve money. Type Description Type Description Type Description Unit Testing A programmatic test that tests the internal working of a unit of code, such as a method or a function.\nIntegration Testing Ensures that multiple components of systems work as expected when they are combined to produce a result.\nRegression Testing Ensures that existing features/functionality that used to work are not broken due to new code changes.\nSystem Testing Complete end-to-end testing is done on the complete software to make sure the whole system works as expected.\nSmoke Testing A quick test performed to ensure that the software works at the most basic level and doesn’t crash when it’s started. Its name originates from the hardware testing where you just plug the device and see if smoke comes out.\nPerformance Testing Ensures that the software performs according to the user’s expectations by checking the response time and throughput under specific load and environment. \nUser-Acceptance Testing Ensures the software meets the requirements of the clients or users. This is typically the last step before the software is live, i.e. it goes to production.\nStress Testing Ensures that the performance of the software doesn’t degrade when the load increases. In stress testing, the tester subjects the software under heavy loads, such as a high number of requests or stringent memory conditions to verify if it works well.\nUsability Testing Measures how usable the software is. This is typically performed with a sample set of end-users, who use the software and provide feedback on how easy or complicated it is to use the software. \nSecurity Testing Now more important than ever. Security testing tries to break a software’s security checks, to gain access to confidential data. Security testing is crucial for web-based applications or any applications that involve money. Unit Testing A programmatic test that tests the internal working of a unit of code, such as a method or a function. Unit Testing A programmatic test that tests the internal working of a unit of code, such as a method or a function. Integration Testing Ensures that multiple components of systems work as expected when they are combined to produce a result. Integration Testing Ensures that multiple components of systems work as expected when they are combined to produce a result. Regression Testing Ensures that existing features/functionality that used to work are not broken due to new code changes. Regression Testing Ensures that existing features/functionality that used to work are not broken due to new code changes. System Testing Complete end-to-end testing is done on the complete software to make sure the whole system works as expected. System Testing Complete end-to-end testing is done on the complete software to make sure the whole system works as expected. Smoke Testing A quick test performed to ensure that the software works at the most basic level and doesn’t crash when it’s started. Its name originates from the hardware testing where you just plug the device and see if smoke comes out. Smoke Testing A quick test performed to ensure that the software works at the most basic level and doesn’t crash when it’s started. Its name originates from the hardware testing where you just plug the device and see if smoke comes out. Performance Testing Ensures that the software performs according to the user’s expectations by checking the response time and throughput under specific load and environment. Performance Testing Ensures that the software performs according to the user’s expectations by checking the response time and throughput under specific load and environment. User-Acceptance Testing Ensures the software meets the requirements of the clients or users. This is typically the last step before the software is live, i.e. it goes to production. User-Acceptance Testing Ensures the software meets the requirements of the clients or users. This is typically the last step before the software is live, i.e. it goes to production. Stress Testing Ensures that the performance of the software doesn’t degrade when the load increases. In stress testing, the tester subjects the software under heavy loads, such as a high number of requests or stringent memory conditions to verify if it works well. Stress Testing Ensures that the performance of the software doesn’t degrade when the load increases. In stress testing, the tester subjects the software under heavy loads, such as a high number of requests or stringent memory conditions to verify if it works well. Usability Testing Measures how usable the software is. This is typically performed with a sample set of end-users, who use the software and provide feedback on how easy or complicated it is to use the software. Usability Testing Measures how usable the software is. This is typically performed with a sample set of end-users, who use the software and provide feedback on how easy or complicated it is to use the software. Security Testing Now more important than ever. Security testing tries to break a software’s security checks, to gain access to confidential data. Security testing is crucial for web-based applications or any applications that involve money. Security Testing Now more important than ever. Security testing tries to break a software’s security checks, to gain access to confidential data. Security testing is crucial for web-based applications or any applications that involve money.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "3. What are the principles of software testing?",
        "answer": "Software testing is governed by seven principles: Absence of errors fallacy: Even if the software is 99% bug-free, it is unusable if it does not conform to the user's requirements. Software needs to be bug-free 99% of the time, and it must also meet all customer requirements.\nTesting shows the presence of errors: Testing can verify the presence of defects in software, but it cannot guarantee that the software is defect-free. Testing can minimize the number of defects, but it can't remove them all. \nExhaustive testing is not possible: The software cannot be tested exhaustively, which means all possible test cases cannot be covered. Testing can only be done with a select few test cases, and it's assumed that the software will produce the right output in all cases. Taking the software through every test case will cost more, take more effort, etc., which makes it impractical.\nDefect clustering: The majority of defects are typically found in a small number of modules in a project. According to the Pareto Principle, 80% of software defects arise from 20% of modules.\nPesticide Paradox: It is impossible to find new bugs by re-running the same test cases over and over again. Thus, updating or adding new test cases is necessary in order to find new bugs.\nEarly testing: Early testing is crucial to finding the defect in the software. In the early stages of SDLC, defects will be detected more easily and at a lower cost. Software testing should start at the initial phase of software development, which is the requirement analysis phase.\nTesting is context-dependent: The testing approach varies depending on the software development context. Software needs to be tested differently depending on its type. For instance, an ed-tech site is tested differently than an Android app. Absence of errors fallacy: Even if the software is 99% bug-free, it is unusable if it does not conform to the user's requirements. Software needs to be bug-free 99% of the time, and it must also meet all customer requirements. Absence of errors fallacy: Testing shows the presence of errors: Testing can verify the presence of defects in software, but it cannot guarantee that the software is defect-free. Testing can minimize the number of defects, but it can't remove them all. Testing shows the presence of errors: Exhaustive testing is not possible: The software cannot be tested exhaustively, which means all possible test cases cannot be covered. Testing can only be done with a select few test cases, and it's assumed that the software will produce the right output in all cases. Taking the software through every test case will cost more, take more effort, etc., which makes it impractical. Exhaustive testing is not possible: Defect clustering: The majority of defects are typically found in a small number of modules in a project. According to the Pareto Principle, 80% of software defects arise from 20% of modules. Defect clustering: Pesticide Paradox: It is impossible to find new bugs by re-running the same test cases over and over again. Thus, updating or adding new test cases is necessary in order to find new bugs. Pesticide Paradox: Early testing: Early testing is crucial to finding the defect in the software. In the early stages of SDLC, defects will be detected more easily and at a lower cost. Software testing should start at the initial phase of software development, which is the requirement analysis phase. Early testing: Testing is context-dependent: The testing approach varies depending on the software development context. Software needs to be tested differently depending on its type. For instance, an ed-tech site is tested differently than an Android app. Testing is context-dependent:",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "4. What is regression testing in software testing?",
        "answer": "The dictionary definition of regression is the act of going back to a previous place or state. In software, regression implies that a feature that used to work suddenly stopped working after a developer added a new code or functionality to the software. Regression problems are pervasive in the software industry, as new features are getting added all the time. Developers don't build these features in isolation, separate from the existing code. Instead, the new code interacts with the legacy code and modifies it in various ways, introducing side effects, whether intended or not. As a result, there is always a chance that introducing new changes may negatively impact a working feature. It's important to keep in mind that even a small change has the potential to cause regression. Regression testing helps ensure that the new code or modifications to the existing code don't break the present behaviour. It allows the tester to verify that the new code plays well with the legacy code.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "5. What is exploratory testing?",
        "answer": "Imagine a tourist in a foreign city. There are two ways in which they can explore the city. Follow a map, itinerary, or a list of places they should visit\nExplore randomly, following the streets as they lead them to new places Follow a map, itinerary, or a list of places they should visit Explore randomly, following the streets as they lead them to new places With the first approach, the tourist follows a predetermined plan and executes it. Though they may visit famous spots, they might miss out on hidden, more exciting places in the city. With the second approach, the tourist wanders around the city and might encounter strange and exotic places that the itinerary would have missed. Both approaches have their pros and cons. A tester is similar to a tourist when they are testing software. They can follow a strict set of test cases and test the software according to them, with the provided inputs and outputs, or they can explore the software. When a tester doesn't use the test scripts or a predefined test plan and randomly tests the software, it is called exploratory testing. As the name suggests, the tester is exploring the software as an end-user would. It's a form of black-box testing. In exploratory testing, the tester interacts with the software in whatever manner they want and follows the software's instructions to navigate various paths and functionality. They don't have a strict plan at hand. Exploratory testing primarily focuses on behavioural testing. It is effective for getting familiar with new software features. It also provides a high-level overview of the system that helps evaluate and quickly learn the software. Though it seems random, exploratory testing can be powerful in an experienced and skilled tester's hands. As it's performed without any preconceived notions of what software should and shouldn't do, it allows greater flexibility for the tester to discover hidden paths and problems along those paths.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "6. What is end-to-end testing?",
        "answer": "End to End testing is the process of testing a software system from start to finish. The tester tests the software just like an end-user would. For example, to test a desktop software, the tester would install the software as the user would, open it, use the application as intended, and verify the behavior. Same for a web application. There is an important difference between end-to-end testing vs. other forms of testing that are more isolated, such as unit testing. In end-to-end testing, the software is tested along with all its dependencies and integrations, such as databases, networks, file systems, and other external services.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "7. What is unit testing?",
        "answer": "Unit testing is the process of testing a single unit of code in an isolated manner. The unit of code can be a method, a class, or a module. Unit testing aims to focus on the smallest building blocks of code to get confidence to combine them later to produce fully functioning software. A unit test invokes the code and verifies the result with the expected result. If the expected and actual outcomes match, then the unit test passes. Otherwise, it fails. A good unit test has the following characteristics: It should test a single piece of functionality.\nIt is fully automated and repeatable. \nIt should run quickly and provide immediate feedback.\nIt should be isolated and shouldn’t interact with external dependencies such as network, database, or file system unless needed. You can use the mocking technique to simulate the external dependencies and isolate the code under test. It should test a single piece of functionality. It is fully automated and repeatable. It should run quickly and provide immediate feedback. It should be isolated and shouldn’t interact with external dependencies such as network, database, or file system unless needed. You can use the mocking technique to simulate the external dependencies and isolate the code under test.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "8. What is an API?",
        "answer": "API stands for Application Programming Interface. It is a means of communication between two software components. An API abstracts the internal workings and complexity of a software program and allows the user of that API to solely focus on the inputs and outputs required to use it.   When building software, developers rarely write software from scratch and make use of other third-party libraries. An API allows two software components to talk to each other by providing an interface that they can understand. Another use of an API is to provide data required by an application. Let's say you are building a weather application that displays the temperature. Instead of building the technology to collect the temperature yourself, you'd access the API provided by the meteorological institute.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "9. What is a test environment?",
        "answer": "A test environment consists of a server/computer on which a tester runs their tests. It is different from a development machine and tries to represent the actual hardware on which the software will run; once it’s in production. Whenever a new build of the software is released, the tester updates the test environment with the latest build and runs the regression tests suite. Once it passes, the tester moves on to testing new functionality.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "10. Explain how does a test coverage tool work?",
        "answer": "When software is being tested, the code coverage measures how much of the program's source code is covered by the test plan. Code coverage testing runs in parallel with actual product testing. Using the code coverage tool, you can monitor the execution of statements in your source code. A complete report of the pending statements, along with the coverage percentage, is provided at the end of the final testing.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "11. Can you describe the different types of test coverage techniques?",
        "answer": "Among the different types of test coverage techniques are: Statement/Block Coverage: Measures how many statements in the source code have been successfully executed and tested.\nDecision/Branch Coverage: This metric measures how many decision control structures were successfully executed and tested.\nPath Coverage: This ensures that the tests are conducted on every possible route through a section of the code.\nFunction coverage: It measures how many functions in the source code have been executed and tested at least once. Statement/Block Coverage: Measures how many statements in the source code have been successfully executed and tested. Statement/Block Coverage: Decision/Branch Coverage: This metric measures how many decision control structures were successfully executed and tested. Decision/Branch Coverage: Path Coverage: This ensures that the tests are conducted on every possible route through a section of the code. Path Coverage: Function coverage: It measures how many functions in the source code have been executed and tested at least once. Function coverage:",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "12. Explain black-box testing, white-box testing, and grey-box testing.",
        "answer": "Black-box testing in software testing: In black-box testing, the system is tested only in terms of its external behaviour; it does not consider how the software functions on the inside. This is the only limitation of the black-box test. It is used in Acceptance Testing and System Testing.\nWhite-box testing in software testing: A white-box test is a method of testing a program that takes into account its internal workings as part of its review. It is used in integration testing and unit testing.\nGrey-box testing in software testing: A Gray Box Testing technique can be characterized as a combination of a black box as well as a white box testing technique used in the software testing process. Using this technique, you can test a software product or application with a partial understanding of its internal structure. Black-box testing in software testing: In black-box testing, the system is tested only in terms of its external behaviour; it does not consider how the software functions on the inside. This is the only limitation of the black-box test. It is used in Acceptance Testing and System Testing. Black-box testing in software testing White-box testing in software testing: A white-box test is a method of testing a program that takes into account its internal workings as part of its review. It is used in integration testing and unit testing. White-box testing in software testing: Grey-box testing in software testing: A Gray Box Testing technique can be characterized as a combination of a black box as well as a white box testing technique used in the software testing process. Using this technique, you can test a software product or application with a partial understanding of its internal structure. Grey-box testing in software testing:",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "13. Is Automation testing in agile methodology useful?",
        "answer": "It is extremely beneficial to use automation testing when using the agile model in software testing. It helps in achieving maximum test coverage in a lesser time of the sprint.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "14. Explain test scenarios, test scripts, and test cases in software testing.",
        "answer": "Test Case: Test Cases are a series of actions executed during software development to verify a particular feature or function. A test case consists of test steps, test data, preconditions, and postconditions designed to verify a specific requirement.\nTest Scenario: Usually, a test scenario consists of a set of test cases covering the end-to-end functionality of a software application. A test scenario provides a high-level overview of what needs to be tested.\nTest Scripts: When it comes to software testing, a test script refers to the set of instructions that will be followed in order to verify that the system under test performs as expected. The document outlines each step to be taken and the expected results. Test Case: Test Cases are a series of actions executed during software development to verify a particular feature or function. A test case consists of test steps, test data, preconditions, and postconditions designed to verify a specific requirement. Test Case: Test Scenario: Usually, a test scenario consists of a set of test cases covering the end-to-end functionality of a software application. A test scenario provides a high-level overview of what needs to be tested. Test Scenario: Test Scripts: When it comes to software testing, a test script refers to the set of instructions that will be followed in order to verify that the system under test performs as expected. The document outlines each step to be taken and the expected results. Test Scripts:",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "15. What is a bug in software testing?",
        "answer": "A software bug is an error in the software that produces wrong results. A software tester tests the software to find bugs in it. There are many causes for the bugs—for example, poor design, sloppy programming, lack of version control, or miscommunication. Throughout development, developers introduce hundreds or thousands of bugs in the system. The goal of the tester is to uncover those bugs. You can find a bug in many different ways, regardless of your role. When building the software, the software developer might notice the bug in another module, written by another developer or by themselves. The tester actively tries to find the bugs as part of a routine testing process. Finally, the users could see the bugs when the software is in production. All bugs, no matter how they are found, are recorded into a bug-tracking system. A triage team triages the bugs and assigns a priority to the bug, and assigns the bug to a software developer to fix it. Once the developer resolves the problem, they check in the code and mark that bug as ready for testing. Once a bug is ready for testing, it goes to the tester, who tests the software to verify if it’s indeed fixed. If it is, then it’s closed. If not, they assign it to the same developer with a description of the exact steps to reproduce the bug. Some examples of popular bug-tracking systems include BugZilla, FogBugz, etc. Trivia: Trivia: The first software bug was discovered by Admiral Grace Hopper, on September 9, 1947. After they opened a malfunctioning piece of hardware, they found an insect stuck in the relay. Image Source: Link Image Source: Link Link First Software Bug  First Software Bug",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "16. State the difference between bugs and errors",
        "answer": "Bugs and errors differ in the following ways: Bugs Errors\nSoftware bugs are defects, which occur when the software or an application does not work as intended. A bug occurs when there is a coding error, which causes the program to malfunction.  Errors in code are caused by problems with the code, which means that the developer could have misunderstood the requirement or the requirement was not defined correctly, leading to a mistake. \nThe bug is submitted by the testers. Errors are raised by test engineers and developers.\nLogic bugs, resource bugs, and algorithmic bugs are types of bugs. Syntactic error, error handling error, error handling error, user interface error, flow control error, calculation error, and testing error are types of errors.\nThe software is detected before it is deployed in production. The error occurs when the code is unable to be compiled. Bugs Errors\nSoftware bugs are defects, which occur when the software or an application does not work as intended. A bug occurs when there is a coding error, which causes the program to malfunction.  Errors in code are caused by problems with the code, which means that the developer could have misunderstood the requirement or the requirement was not defined correctly, leading to a mistake. \nThe bug is submitted by the testers. Errors are raised by test engineers and developers.\nLogic bugs, resource bugs, and algorithmic bugs are types of bugs. Syntactic error, error handling error, error handling error, user interface error, flow control error, calculation error, and testing error are types of errors.\nThe software is detected before it is deployed in production. The error occurs when the code is unable to be compiled. Bugs Errors Bugs Errors Bugs Errors Software bugs are defects, which occur when the software or an application does not work as intended. A bug occurs when there is a coding error, which causes the program to malfunction.  Errors in code are caused by problems with the code, which means that the developer could have misunderstood the requirement or the requirement was not defined correctly, leading to a mistake. \nThe bug is submitted by the testers. Errors are raised by test engineers and developers.\nLogic bugs, resource bugs, and algorithmic bugs are types of bugs. Syntactic error, error handling error, error handling error, user interface error, flow control error, calculation error, and testing error are types of errors.\nThe software is detected before it is deployed in production. The error occurs when the code is unable to be compiled. Software bugs are defects, which occur when the software or an application does not work as intended. A bug occurs when there is a coding error, which causes the program to malfunction.  Errors in code are caused by problems with the code, which means that the developer could have misunderstood the requirement or the requirement was not defined correctly, leading to a mistake. Software bugs are defects, which occur when the software or an application does not work as intended. A bug occurs when there is a coding error, which causes the program to malfunction. Errors in code are caused by problems with the code, which means that the developer could have misunderstood the requirement or the requirement was not defined correctly, leading to a mistake. The bug is submitted by the testers. Errors are raised by test engineers and developers. The bug is submitted by the testers. Errors are raised by test engineers and developers. Logic bugs, resource bugs, and algorithmic bugs are types of bugs. Syntactic error, error handling error, error handling error, user interface error, flow control error, calculation error, and testing error are types of errors. Logic bugs, resource bugs, and algorithmic bugs are types of bugs. Syntactic error, error handling error, error handling error, user interface error, flow control error, calculation error, and testing error are types of errors. The software is detected before it is deployed in production. The error occurs when the code is unable to be compiled. The software is detected before it is deployed in production. The error occurs when the code is unable to be compiled.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "17. What is a Test Plan? What does it include?",
        "answer": "A test plan is basically a dynamic document monitored and controlled by the testing manager. The success of a testing project totally depends upon a well-written test plan document that describes software testing scope and activities. It basically serves as a blueprint that outlines the what, when, how, and more of the entire test process.   A test plan must include the following details: Test Strategy \nTest Objective \nTest Scope \nReason for Testing \nExit/Suspension Criteria \nResource Planning \nTest Deliverables. Test Strategy Test Objective Test Scope Reason for Testing Exit/Suspension Criteria Resource Planning Test Deliverables.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "18. What is a Test Report? What does it include?",
        "answer": "Test report is basically a document that includes a total summary of testing objectives, activities, and results. It is very much required to reflect testing results and gives an opportunity to estimate testing results quickly. It helps us to decide whether the product is ready for release or not. It also helps us determine the current status of the project and the quality of the product. A test report must include the following details: Test Objective \nProject Information \nDefect \nTest Summary Test Objective Project Information Defect Test Summary",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "19. What do you mean by Test Deliverables?",
        "answer": "Test deliverables, also known as test artifacts, are basically a list of all of the documents, tools, and other components that are given to the stakeholders of a software project during the SDLC. Test deliverables are maintained and developed in support of the test. At every phase of SDLC, there are different deliverables as given below:   Before Testing Phase Before Testing Phase Test plans document. \nTest cases documents \nTest Design specifications. Test plans document. Test cases documents Test Design specifications. During Testing Phase During Testing Phase Test Scripts \nSimulators. \nTest Data \nTest Traceability Matrix \nError logs and execution logs Test Scripts Simulators. Test Data Test Traceability Matrix Error logs and execution logs After testing Phase After testing Phase Test Results/reports \nDefect Report \nInstallation/ Test procedures guidelines \nRelease notes Test Results/reports Defect Report Installation/ Test procedures guidelines Release notes",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "20. What are different categories of debugging?",
        "answer": "Different categories of debugging include: Brute force debugging \nBacktracking \nCause elimination \nProgram slicing \nFault tree analysis Brute force debugging Backtracking Cause elimination Program slicing Fault tree analysis",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "21. Write some common mistakes that lead to major issues.",
        "answer": "Some common mistakes include: Poor Scheduling \nUnderestimating \nIgnoring small issues \nNot following the exact process \nImproper resource allocation Poor Scheduling Underestimating Ignoring small issues Not following the exact process Improper resource allocation",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "22. What is a user story?",
        "answer": "All software has a target user. A user story describes the user's motivations and what they are trying to accomplish by using the software. Finally, it shows how the user uses the application. It ignores the design and implementation details. A user story aims to focus on the value provided to the end-user instead of the exact inputs they might enter and the expected output. In a user story, the tester creates user personas with real names and characteristics and tries to simulate a real-life interaction with the software. A user story often helps fish out hidden problems that are often not revealed by more formal testing processes.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "23. List some of the popular software testing tools/frameworks, providing a brief description of each.",
        "answer": "Selenium: a web browser automation tool that automates the test suites you need to run on a web browser.\nProtractor: An end-to-end test framework for Angular and AngularJS applications. Protractor runs tests against your application running in a real browser, interacting with it as a user would.\nCypress: A modern front-end testing tool built for the modern web. Though it’s similar to Selenium and Protractor, it’s architecturally different from them.\nJasmine: This is an open-source JavaScript testing framework that allows you to write behaviour-driven tests.\nJUnit and NUnit: These are unit testing frameworks for Java and C# programming languages, respectively. Selenium: a web browser automation tool that automates the test suites you need to run on a web browser. Protractor: An end-to-end test framework for Angular and AngularJS applications. Protractor runs tests against your application running in a real browser, interacting with it as a user would. Cypress: A modern front-end testing tool built for the modern web. Though it’s similar to Selenium and Protractor, it’s architecturally different from them. Jasmine: This is an open-source JavaScript testing framework that allows you to write behaviour-driven tests. JUnit and NUnit: These are unit testing frameworks for Java and C# programming languages, respectively.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "24. What is A/B testing?",
        "answer": "A/B testing is the process of testing two or more different versions of your software with users to assess which performs better. It is a low-risk way of testing variations of a new or existing functionality. You can choose a part of your users to use feature A. The other group uses feature B. Then user feedback and response are evaluated using statistical testing to decide the final version of the feature.   Typically, A/B testing is used to test the user experience of different interfaces. This allows the team to quickly gather feedback and test their initial hypothesis.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "25. What is defects in software testing?",
        "answer": "The term defect refers to a system error that prevents the intended action from being accomplished. Testing is most important when it comes to finding defects. Testing needs to begin early in the development process since defects can be found throughout. As shown in the following figure, defects are divided into three main categories: Wrong: It implies incorrect implementation of requirements. There is a variance between the specifications and what was expected, resulting in this defect.\nMissing: This indicates that a specification has not been implemented, or a requirement of the customer has not been properly noted.\nExtra: In this case, the defect is caused by a requirement incorporated into the product that was not provided by the end-user. Wrong: It implies incorrect implementation of requirements. There is a variance between the specifications and what was expected, resulting in this defect. Wrong: Missing: This indicates that a specification has not been implemented, or a requirement of the customer has not been properly noted. Missing: Extra: In this case, the defect is caused by a requirement incorporated into the product that was not provided by the end-user. Extra:",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "26. What is spice in software testing?",
        "answer": "SPICE stands for Software Process Improvement and Capability Determination. In the field of software development processes, SPICE is a standard framework for assessing the efficiency and effectiveness of the development process. IEC (International Electrotechnical Commission) and ISO (International Organization for Standardization) jointly developed SPICE.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "27. What do you mean by latent defect and masked defect?",
        "answer": "Latent Defect: Latent defects are defects that exist but have not yet been invoked because the conditions required to invoke them have not been met. As a systematic flaw, it encompasses the entire production process of the software, including all pre-production testing and extended testing. When users perform a particular task in an unusual or rare situation or without the presence of usual scenarios, latent defects are revealed.\nMasked Defect: These are the defects that have not yet resulted in a failure since another defect hides that portion of the code from being executed. It can only be discovered when the defect hiding it is exposed by the user through a specific operation. There are defects that are hidden or marked by another defect and remain hidden until the other defect is detected. Latent Defect: Latent defects are defects that exist but have not yet been invoked because the conditions required to invoke them have not been met. As a systematic flaw, it encompasses the entire production process of the software, including all pre-production testing and extended testing. When users perform a particular task in an unusual or rare situation or without the presence of usual scenarios, latent defects are revealed. Latent Defect: Masked Defect: These are the defects that have not yet resulted in a failure since another defect hides that portion of the code from being executed. It can only be discovered when the defect hiding it is exposed by the user through a specific operation. There are defects that are hidden or marked by another defect and remain hidden until the other defect is detected. Masked Defect:",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "28. Can you explain sanity testing in software testing?",
        "answer": "The term 'sanity testing' refers to a subset of regression testing. The sanity testing ensures that the changes made to the code do not adversely affect the system's performance. After the software build is received, a sanity test is conducted to ensure that the changes made to the code are working correctly. As a checkpoint, this testing is used to determine whether the build can proceed with further testing. Sanity testing focuses on validating the functionality of the application rather than detailed testing. Features Features It focuses on a smaller section of the application and is a subset of regression testing.\nThe process is undocumented.\nSanity testing is often unscripted.\nIn this approach, limited functionalities are deeply tested.\nA tester is usually responsible for performing this task. It focuses on a smaller section of the application and is a subset of regression testing. The process is undocumented. Sanity testing is often unscripted. In this approach, limited functionalities are deeply tested. A tester is usually responsible for performing this task.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "29. What is the purpose of TestNG?",
        "answer": "The TestNG framework for Java is an open-source advanced test automation framework that is designed to benefit both testers and developers. The purpose of TestNG is to provide an easy-to-use, readable, structured, maintainable, and user-friendly environment for automated tests. NG stands for 'Next Generation' in TestNG. The high-end annotations, such as data providers, make cross-browser testing easier since you can test across multiple devices and browsers. Furthermore, the framework has an inbuilt mechanism for handling exceptions that prevent the program from terminating unexpectedly.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "30. Is it possible to skip a method or a code block in TestNG?",
        "answer": "Yes, you can skip a particular test method or code by setting the 'enabled' parameter to ‘false’ in test annotations. @Test(enabled = false).",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "31. What is the best way to set priority for test cases in TestNG?",
        "answer": "Prioritizing the order of your test methods can be accomplished by defining a priority order. Consequently, the test will execute in accordance with the priority set. Syntax: @Test(priority=2) @Test(priority=2) Example: The following code demonstrates how to set the priority of a test case in TestNG. package TestNG;\nimport org.testng.annotations.*;\npublic class SettingPriority {\n@Test(priority=0)\npublic void scalermethod1() {\n}\n@Test(priority=1)\npublic void scalermethod2() {\n}\n@Test(priority=2)\npublic void scalermethod3() {\n}\n} package TestNG;\nimport org.testng.annotations.*;\npublic class SettingPriority {\n@Test(priority=0)\npublic void scalermethod1() {\n}\n@Test(priority=1)\npublic void scalermethod2() {\n}\n@Test(priority=2)\npublic void scalermethod3() {\n}\n} Test Execution Sequence: ScalerMethod1\nScalerMethod2\nScalerMethod3 ScalerMethod1\nScalerMethod2\nScalerMethod3",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "32. What is Object Repository?",
        "answer": "Object Repository is a collection of web elements and their locators that belong to the Application Under Test (AUT). The QAs maintain all element locators in a separate file known as the property file (. properties) in Selenium. During execution, it serves as a means of identifying objects between the test script and the application.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "33. What are the valuable steps to resolve issues while testing?",
        "answer": "The following steps can assist in resolving issues during testing: Record: Keep track of any problems that arise and resolve them.\nReport: Inform higher-level managers of the issues.\nControl: Establish a process for managing issues. Record: Keep track of any problems that arise and resolve them. Report: Inform higher-level managers of the issues. Control: Establish a process for managing issues.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "34. What qualities a software tester should have?",
        "answer": "Any software tester's goal is to find out as many bugs and problems in the system so that the customers don't have to. Hence, a good software tester should have a keen eye for detail. They should know the ins and outs of the software they are testing and push every aspect of the software to its limits, to identify bugs that are hard to find with the software's regular use. Having the domain knowledge of the application is essential. If a tester doesn't understand the specific problems the software is trying to solve, they won't be able to test it thoroughly. A good tester should keep the end-user in mind when they are testing. Having empathy with the end-user helps the tester ensure that the software is accessible and usable. Simultaneously, the tester should possess basic programming skills to think from a developer's perspective, which allows them to notice common programming errors such as null-references, out-of-memory errors, etc. Communication, both written and verbal, is an essential skill for a tester. A tester will frequently have to interact with both the developers and the management. They should be able to explain the bugs and problems found during testing to the developers. For each bug found, a good tester should provide a detailed bug report consisting of all the information a developer would need to fix that problem. They should be able to make a good case to the management if they are uncomfortable releasing the software if it contains unresolved issues.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "1. Explain boundary value analysis in software testing.",
        "answer": "BVA (Boundary Value Analysis) is a black box software testing technique that uses boundary values to create test cases. Input values near the boundary have a higher probability of error, so BVA is used to test boundary values. BVA includes values at the boundaries in the test cases. If the input falls within the boundary range, then the test is positive; if it falls outside, then it is negative. There are several types of values, including maximum or minimum, inside or outside edge, and typical or error values.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "2. Explain the role of testing in software development?",
        "answer": "Software testing comes into play at different times in different software development methodologies. There are two main methodologies in software development, namely Waterfall and Agile. In a traditional waterfall software development model, requirements are gathered first. Then a specification document is created based on the document, which drives the design and development of the software. Finally, the testers conduct the testing at the end of the software development life cycle once the complete software system is built. Waterfall Software Development Model  Waterfall Software Development Model An agile software development model works in small iterations. You test the software in parallel as it is getting built. The developers build a small functionality according to the requirements. The testers test it and get customer feedback, which drives future development.  ",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "3. How much testing is sufficient? Or, is it possible to do exhaustive testing of the software?",
        "answer": "It is impossible to exhaustively test software or prove the absence of errors, no matter how specific your test strategy is. An extensive test that finds hundreds of errors doesn’t imply that it has discovered them all. There could be many more errors that the test might have missed. The absence of errors doesn’t mean there are no errors, and the software is perfect. It could easily mean ineffective or incomplete tests. To prove that a program works, you’d have to test all possible inputs and their combinations. Consider a simple program that takes a string as an input that is ten characters long. To test it with each possible input, you’d have to enter 2610 names, which is impossible. Since exhaustive testing is not practical, your best strategy as a tester is to pick the test cases that are most likely to find errors. Testing is sufficient when you have enough confidence to release the software and assume it will work as expected.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "4. Why developers shouldn’t test the software they wrote?",
        "answer": "Developers make poor testers. Here are some reasons why: They try to test the code to make sure that it works, rather than testing all the ways in which it doesn't work. \nSince they wrote it themselves, developers tend to be very optimistic about the software and don't have the correct attitude needed for testing: to break software. \nDevelopers skip the more sophisticated tests that an experienced tester would perform to break the software. They follow the happy path to execute the code from start to finish with proper inputs, often not enough to get the confidence to ship software in production. They try to test the code to make sure that it works, rather than testing all the ways in which it doesn't work. Since they wrote it themselves, developers tend to be very optimistic about the software and don't have the correct attitude needed for testing: to break software. Developers skip the more sophisticated tests that an experienced tester would perform to break the software. They follow the happy path to execute the code from start to finish with proper inputs, often not enough to get the confidence to ship software in production. However, it doesn't mean that developers shouldn't test the software before sending it to the tester. Developer testing helps find many bugs that are caused by programming errors. These are hard to find for a tester because they don't always have access to the source code.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "5. What is SDLC in software testing?",
        "answer": "In short, SDLC (Software Development Life Cycle) enables the development of high-quality, low-cost software with the shortest possible development time. A major objective of the SDLC is to produce high-quality software that meets and exceeds the expectations of customers. SDLC provides a detailed plan with a series of stages, or phases, that encompass their own processes and deliverables. By adhering to the SDLC, developers can enhance the speed of their projects and minimize risks and costs.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "6. What is the software testing life cycle?",
        "answer": "Similar to software development, testing has its life cycle. During the testing, a tester goes through the following activities.   Understand the requirements: Before testing software or a feature, the tester must first understand what it is supposed to do. If they don’t know how the software is supposed to work, they can’t test it effectively. \nTest Planning and Case Development: Once the tester has a clear understanding of the requirements, they can create a test plan. It includes the scope of testing, i.e., part of software under test and objectives for testing. Various activities are involved in planning the test, such as creating documentation, estimating the time and efforts involved, deciding the tools and platforms, and the individuals who will be conducting the tests.\nPrepare a test environment: The development happens in a development environment, i.e., on a developer’s computer that might not represent the actual environment that the software will run in production. A tester prepares an environment with the test data that mimics the end user’s environment. It assists with realistic testing of the software. \nGenerate the test data: Though it is impossible to do exhaustive testing of the software, the tester tries to use realistic test data to give them the confidence that the software will survive the real world if it passes the tests. \nTest Execution: Once the tester has a complete understanding of the software and has a test environment set up with the test data, they execute the test. Here, execution means that the tester runs the software or the feature under test and verifies the output with the expected outcome. \nTest Closure: At the end of the test execution, there can be two possible outcomes. First, the tester finds a bug in the part of the software under test. In this case, they create a test record/bug report. Second, the software works as expected. Both these events indicate the end of the test cycle. Understand the requirements: Before testing software or a feature, the tester must first understand what it is supposed to do. If they don’t know how the software is supposed to work, they can’t test it effectively. Understand the requirements: Test Planning and Case Development: Once the tester has a clear understanding of the requirements, they can create a test plan. It includes the scope of testing, i.e., part of software under test and objectives for testing. Various activities are involved in planning the test, such as creating documentation, estimating the time and efforts involved, deciding the tools and platforms, and the individuals who will be conducting the tests. Test Planning and Case Development: Prepare a test environment: The development happens in a development environment, i.e., on a developer’s computer that might not represent the actual environment that the software will run in production. A tester prepares an environment with the test data that mimics the end user’s environment. It assists with realistic testing of the software. Prepare a test environment: Generate the test data: Though it is impossible to do exhaustive testing of the software, the tester tries to use realistic test data to give them the confidence that the software will survive the real world if it passes the tests. Generate the test data: Test Execution: Once the tester has a complete understanding of the software and has a test environment set up with the test data, they execute the test. Here, execution means that the tester runs the software or the feature under test and verifies the output with the expected outcome. Test Execution: Test Closure: At the end of the test execution, there can be two possible outcomes. First, the tester finds a bug in the part of the software under test. In this case, they create a test record/bug report. Second, the software works as expected. Both these events indicate the end of the test cycle. Test Closure:",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "7. What is functional testing?",
        "answer": "Functional testing is a form of black-box testing. As the name suggests, it focuses on the software's functional requirements rather than its internal implementation. A functional requirement refers to required behavior in the system, in terms of its input and output. Functional testing Functional testing It validates the software against the functional requirements or the specification, ignoring the non-functional attributes such as performance, usability, and reliability. Functional testing aims to answer the following questions, in particular: Does the software fulfill its functional requirements?\nDoes it solve its intended users' problems? Does the software fulfill its functional requirements? Does it solve its intended users' problems?",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "8. What is non-functional testing?",
        "answer": "Non-functional testing tests the system's non-functional requirements, which refer to an attribute or quality of the system explicitly requested by the client. These include performance, security, scalability, and usability. Non-functional testing comes after functional testing. It tests the general characteristics unrelated to the functional requirements of the software. Non-functional testing ensures that the software is secure, scalable, high-performance, and won't crash under heavy load.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "9. What is a bug report?",
        "answer": "During testing, a tester records their observations, findings, and other information useful to the developers or the management. All this data belongs to a test record, also called a bug report. A detailed bug report is an important artifact produced during testing. It helps the team members with: Understand the problem,\nSteps to reproduce the problem,\nThe environment and the specific conditions under which it happens, and\nThe resolution if/when the developers fix the problem. Understand the problem, Steps to reproduce the problem, The environment and the specific conditions under which it happens, and The resolution if/when the developers fix the problem. Here are a few bits of information that a good bug report should contain. Image Source: Bugzilla Image Source: Bugzilla Field Description\nTitle A short headline that summarizes the problem. It shouldn’t be too long but just to give just the right information to the reader. It should be specific and accurate.\nDescription The description should answer all the questions that are not explained by the title. It contains a detailed summary of the bug, its severity, and impact, steps to reproduce, expected results vs. the actual output. \nVersion A lot of time can be wasted in trying to reproduce a bug in the wrong version of the product. Knowing the exact product version or the build number on which this bug was found is very useful to the developer in reproducing the bug. \nStatus At any point, a bug can be either ‘Active’, ‘Ready for Testing’, or ‘Closed’. A bug becomes active when it is found, is ready for testing once the developer fixes it. A tester can mark it closed if the developer fixed it, or active if not. \nSteps to Reproduce Though the steps to reproduce the problem can be provided in the description, sometimes having a distinct field force the tester to think about them. They include each step one must take to successfully reproduce the problem.\nAssigned To Name of the developer or the tester to whom this bug is assigned. \nResolution When a developer fixes the bug, they should include the cause for the bug and its resolution. It helps the team in the future when a similar bug resurfaces. Field Description\nTitle A short headline that summarizes the problem. It shouldn’t be too long but just to give just the right information to the reader. It should be specific and accurate.\nDescription The description should answer all the questions that are not explained by the title. It contains a detailed summary of the bug, its severity, and impact, steps to reproduce, expected results vs. the actual output. \nVersion A lot of time can be wasted in trying to reproduce a bug in the wrong version of the product. Knowing the exact product version or the build number on which this bug was found is very useful to the developer in reproducing the bug. \nStatus At any point, a bug can be either ‘Active’, ‘Ready for Testing’, or ‘Closed’. A bug becomes active when it is found, is ready for testing once the developer fixes it. A tester can mark it closed if the developer fixed it, or active if not. \nSteps to Reproduce Though the steps to reproduce the problem can be provided in the description, sometimes having a distinct field force the tester to think about them. They include each step one must take to successfully reproduce the problem.\nAssigned To Name of the developer or the tester to whom this bug is assigned. \nResolution When a developer fixes the bug, they should include the cause for the bug and its resolution. It helps the team in the future when a similar bug resurfaces. Field Description Field Description Field Description Title A short headline that summarizes the problem. It shouldn’t be too long but just to give just the right information to the reader. It should be specific and accurate.\nDescription The description should answer all the questions that are not explained by the title. It contains a detailed summary of the bug, its severity, and impact, steps to reproduce, expected results vs. the actual output. \nVersion A lot of time can be wasted in trying to reproduce a bug in the wrong version of the product. Knowing the exact product version or the build number on which this bug was found is very useful to the developer in reproducing the bug. \nStatus At any point, a bug can be either ‘Active’, ‘Ready for Testing’, or ‘Closed’. A bug becomes active when it is found, is ready for testing once the developer fixes it. A tester can mark it closed if the developer fixed it, or active if not. \nSteps to Reproduce Though the steps to reproduce the problem can be provided in the description, sometimes having a distinct field force the tester to think about them. They include each step one must take to successfully reproduce the problem.\nAssigned To Name of the developer or the tester to whom this bug is assigned. \nResolution When a developer fixes the bug, they should include the cause for the bug and its resolution. It helps the team in the future when a similar bug resurfaces. Title A short headline that summarizes the problem. It shouldn’t be too long but just to give just the right information to the reader. It should be specific and accurate. Title A short headline that summarizes the problem. It shouldn’t be too long but just to give just the right information to the reader. It should be specific and accurate. Description The description should answer all the questions that are not explained by the title. It contains a detailed summary of the bug, its severity, and impact, steps to reproduce, expected results vs. the actual output. Description The description should answer all the questions that are not explained by the title. It contains a detailed summary of the bug, its severity, and impact, steps to reproduce, expected results vs. the actual output. Version A lot of time can be wasted in trying to reproduce a bug in the wrong version of the product. Knowing the exact product version or the build number on which this bug was found is very useful to the developer in reproducing the bug. Version A lot of time can be wasted in trying to reproduce a bug in the wrong version of the product. Knowing the exact product version or the build number on which this bug was found is very useful to the developer in reproducing the bug. Status At any point, a bug can be either ‘Active’, ‘Ready for Testing’, or ‘Closed’. A bug becomes active when it is found, is ready for testing once the developer fixes it. A tester can mark it closed if the developer fixed it, or active if not. Status At any point, a bug can be either ‘Active’, ‘Ready for Testing’, or ‘Closed’. A bug becomes active when it is found, is ready for testing once the developer fixes it. A tester can mark it closed if the developer fixed it, or active if not. Steps to Reproduce Though the steps to reproduce the problem can be provided in the description, sometimes having a distinct field force the tester to think about them. They include each step one must take to successfully reproduce the problem. Steps to Reproduce Though the steps to reproduce the problem can be provided in the description, sometimes having a distinct field force the tester to think about them. They include each step one must take to successfully reproduce the problem. Assigned To Name of the developer or the tester to whom this bug is assigned. Assigned To Name of the developer or the tester to whom this bug is assigned. Resolution When a developer fixes the bug, they should include the cause for the bug and its resolution. It helps the team in the future when a similar bug resurfaces. Resolution When a developer fixes the bug, they should include the cause for the bug and its resolution. It helps the team in the future when a similar bug resurfaces. For example, here is a picture of a bug reported on Jira, a popular bug-tracking software.  ",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "10. What are some important testing metrics?",
        "answer": "Testing metrics provide a high-level overview to the management or the developers on how the project is going and the next action steps.   Here are some of the metrics derived from a record of the tests and failures: Total number of defects found, ordered by their severity\nTotal number of bugs fixed\nTotal number of problems caused by an error in the source code vs. configuration or external environmental factors\nBug find and fix rate over time\nBugs by produce/feature area\nThe average time is taken by a bug since it’s found and fixed. \nTotal time spent on new feature development vs. time spent on resolving bugs and failures\nNumber of outstanding bugs before a release\nBugs/failures reported by the customers vs. those found by the testers Total number of defects found, ordered by their severity Total number of bugs fixed Total number of problems caused by an error in the source code vs. configuration or external environmental factors Bug find and fix rate over time Bugs by produce/feature area The average time is taken by a bug since it’s found and fixed. Total time spent on new feature development vs. time spent on resolving bugs and failures Number of outstanding bugs before a release Bugs/failures reported by the customers vs. those found by the testers",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "11. What is Test-Driven-Development?",
        "answer": "Test-Driven-Development (TDD) is a popular software development technique, first introduced by Kent Beck in his book with the same name, published in 1999. In TDD, a developer working on a feature first writes a failing test, then writes just enough code to make that test pass. Once they have a passing test, they add another failing test and then write just enough code to pass the failing test. This cycle repeats until the developer has the fully working feature. If the code under the test has external dependencies such as database, files, or network, you can mock them to isolate the code.   Benefits of TDD: Benefits of TDD: Writing tests first forces you to think about the feature you are trying to build, helping you produce better code. \nAs you always have a working set of tests at hand, a failing test indicates that the problem is with the code you just added, reducing the time spent in debugging. \nWriting tests help the developer to clarify the requirements and specification. It’s challenging to write good tests for a poor set of requirements. \nIt’s tough to produce high-quality software unless you can test the software after each new change. You can never be sure that your new code didn’t break the working software. TDD gives you the confidence to add new code, as you already have a test in place. Writing tests first forces you to think about the feature you are trying to build, helping you produce better code. As you always have a working set of tests at hand, a failing test indicates that the problem is with the code you just added, reducing the time spent in debugging. Writing tests help the developer to clarify the requirements and specification. It’s challenging to write good tests for a poor set of requirements. It’s tough to produce high-quality software unless you can test the software after each new change. You can never be sure that your new code didn’t break the working software. TDD gives you the confidence to add new code, as you already have a test in place.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "12. What is Selenium? What are its benefits?",
        "answer": "Selenium is a web browser automation tool that automates the test suits you need to run on a web browser. Selenium Some of the benefits of Selenium include: It is open-source software, eliminating licensing costs. \nIt supports all the major languages, such as Java, C#, Python, Ruby, etc. \nIt supports all the major web browsers, e.g., Google Chrome, Firefox, Safari, etc. \nYou can integrate it with other testing frameworks and tools to build a comprehensive test suite for your software. It is open-source software, eliminating licensing costs. It supports all the major languages, such as Java, C#, Python, Ruby, etc. It supports all the major web browsers, e.g., Google Chrome, Firefox, Safari, etc. You can integrate it with other testing frameworks and tools to build a comprehensive test suite for your software.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "13. What are the various components of Selenium?",
        "answer": "Selenium consists of the following components: Selenium Remote Control (RC).\nSelenium Integrated Development Environment (IDE).\nSelenium WebDriver.\nSelenium Grid. Selenium Remote Control (RC). Selenium Integrated Development Environment (IDE). Selenium WebDriver. Selenium Grid.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "14. What is cross-browser testing?",
        "answer": "All web applications run in browsers such as Google Chrome, Mozilla Firefox, Internet Explorer, Safari, etc. Though they all work primarily the same in implementing the web standards, there are subtle differences in all of them. When building the software, it’s not always possible for the software developer to meticulously test the feature on multiple browsers, noticing the subtle inconsistencies.   In cross-browser testing, a software tester launches the web application in all the supported browsers and tries to test the same functionality on all of them. They note any unexpected behavior in a browser that doesn’t work as expected or looks different; note the behavior and the browser name and version in the test report. This helps the programmer to fix the behavior in all the browsers where it doesn't work as intended.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "15. What are the different HTTP status codes that a server can return?",
        "answer": "An HTTP status code is a three-digit number that indicates the status of an incoming HTTP request, that is, if the request has been completed or not.   A server can send the following five types of responses for an HTTP request. Information (100 - 199): These status codes provide a temporary response. The response consists of the status line and optional headers and terminates by an empty line. \nSuccess (200 - 299): Indicate that the incoming HTTP request was successfully received, understood, and accepted. \nRedirect (300 - 399): These status codes indicate further actions the client should take to satisfy the HTTP request. It can mean that the requested resource may have moved temporarily or permanently. It can also redirect the client to another URL. \nA client error (400 - 499): Indicate a problem with the client who initiated the HTTP request. \nServer error (500 - 599): The 5XX status code indicates a problem on the server while processing the request. Information (100 - 199): These status codes provide a temporary response. The response consists of the status line and optional headers and terminates by an empty line. Success (200 - 299): Indicate that the incoming HTTP request was successfully received, understood, and accepted. Redirect (300 - 399): These status codes indicate further actions the client should take to satisfy the HTTP request. It can mean that the requested resource may have moved temporarily or permanently. It can also redirect the client to another URL. A client error (400 - 499): Indicate a problem with the client who initiated the HTTP request. Server error (500 - 599): The 5XX status code indicates a problem on the server while processing the request.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "16. What is automated testing?",
        "answer": "As the name suggests, automated testing, which is also called test automation, is the programmatic execution of the tests. The tester uses an automation tool or software like Selenium to write code that performs the following tasks. Automatically run the software.\nFeed the input data to the system.\nExamine the output with the expected outcome. \nFail the test if the results don’t match. Otherwise, pass the test. Automatically run the software. Feed the input data to the system. Examine the output with the expected outcome. Fail the test if the results don’t match. Otherwise, pass the test. Once a test is automated, you can run it as often as you want, to check if any new code has broken it. It enables you to spend your time on other high-value tests, such as exploratory testing that help find bugs that an automated test would miss. Automated testing is beneficial for repetitive testing with inputs that don’t change frequently. Humans get tired and bored from conducting the same tests repeatedly and seeing the same results. It’s easy to make mistakes when you are testing a feature for the twentieth time. Software is much better at doing repetitive tasks without getting tired or making mistakes than a human operator would.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "17. What is the most effective way to map automation testing success?",
        "answer": "The success of Automation testing can be measured using the following criteria: Savings on labor & other costs.\nDefect Detection Ratio.\nAutomating the execution process and reducing the release time. Savings on labor & other costs. Defect Detection Ratio. Automating the execution process and reducing the release time.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "18. What are the different types of severity you can assign to a bug?",
        "answer": "Though it varies depending on the size and structure of the software development teams, typically, a bug can be assigned the following types of severities, going from low to high: Low Low User Interface bugs.\nAccessibility issues. User Interface bugs. Accessibility issues. Medium Medium Leaky abstractions.\nSoftware hangs.\nUsers unable to perform a specific action.\nBoundary conditions. Leaky abstractions. Software hangs. Users unable to perform a specific action. Boundary conditions. High High Crashing under high load.\nBusiness logic and/or calculation errors.\nAny user action that causes the software to crash.\nExposing sensitive user data.\nSecurity problems.\nLoss of data. Crashing under high load. Business logic and/or calculation errors. Any user action that causes the software to crash. Exposing sensitive user data. Security problems. Loss of data.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "19. Which test cases are written first: white boxes or black boxes?",
        "answer": "Test cases for the black box testing are usually written first, followed by test cases for the white box testing. An outline of the design or project plan and the requirements document is required to write black-box test cases. Documents such as these are readily available at the beginning of the project. The initial phase of a project isn't the right time to start white box testing because it requires more architecture clarification that isn't available yet. Therefore, white-box test cases are typically written after black-box test cases have been developed.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "20. What is alpha testing?",
        "answer": "Before you ship the software to the customers, the internal testing team performs alpha testing. Alpha testing is part of the user acceptance testing. Its goal is to identify bugs before the customers start using the software.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "21. What is beta testing?",
        "answer": "Once you ship the software to the customers after alpha testing, the software's actual users perform the beta testing in a real production environment. It is one of the final components of user acceptance testing. Beta testing is helpful to get feedback from real people using your software in real environments.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "22. What is meant by browser automation?",
        "answer": "It’s a process of automatically testing a web application’s functionality in a browser, where a program launches the browser, navigates to the application, and interacts with the user interface by clicking buttons or links, just like an average user would. The only difference is that the browser automation can test this very quickly and often, whereas the same test would take a human tester a long time. It’s part of automated testing. Some essential tools for browser testing include Selenium, protractor.js, and cypress.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "23. What do you mean by Test Matrix and Traceability Matrix?",
        "answer": "Test Matrix: It is referred to as a testing tool that is used to capture actual quality, effort, resources, plan, and time required to capture all the phases of software testing. It only covers the testing phase of the life cycle.  \n\nRequirement Traceability Matrix (RTM): It is referred to as a document, usually present in the form table, that is used to trace and demonstrate the relationship between the requirements and other artifacts of the project right from start to end. In simple words, it maps between test cases and customer requirements. Test Matrix:   Requirement Traceability Matrix (RTM):",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "24. What is the V model in software testing?",
        "answer": "V-models, also known as validation or verification models, are SDLC models where the process occurs sequentially in a V-shape. This method consists of associating a testing phase with each corresponding development stage. As each development activity is accompanied by a testing activity, the next test phase occurs only after the previous phase has been completed. Validation: It is defined as a process that involves dynamic testing of software products by executing the code. This process validates whether we are building the right software that meets that customer's requirement or not. It involves various activities like system testing, integration testing, user acceptance testing, and unit testing.\nVerification: The technique involves static analysis (review) without running the code. It is defined as a process that involves analyzing the documents. This process verifies whether the software conforms to specifications or not.  Its ultimate goal is to ensure the quality of software products, design, architecture, etc. Validation: It is defined as a process that involves dynamic testing of software products by executing the code. This process validates whether we are building the right software that meets that customer's requirement or not. It involves various activities like system testing, integration testing, user acceptance testing, and unit testing. Validation Verification: The technique involves static analysis (review) without running the code. It is defined as a process that involves analyzing the documents. This process verifies whether the software conforms to specifications or not.  Its ultimate goal is to ensure the quality of software products, design, architecture, etc. Verification",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "25. State difference between verification and validation in software testing.",
        "answer": "Validation: It is defined as a process that involves dynamic testing of software products by running it. This process validates whether we are building the right software that meets that customer requirement or not. It involves various activities like system testing, integration testing, user acceptance testing, and unit testing.\n\nVerification: It is defined as a process that involves analyzing the documents. This process verifies whether the software conforms to specifications or not.  Its ultimate goal is to ensure the quality of software products, design, architecture, etc. Validation:   Verification:   Verification Vs Validation: Verification Vs Validation: Verification  Validation \nIt checks whether the software meets the specification or not. It checks whether the specification captures the customer’s needs or not.  \nIt is a type of static testing.  It is a type of dynamic testing. \nThere is no requirement of executing the code. There is a requirement for executing the code.\nThis process is performed by the QA team to make sure that the software is built as per the specifications in the SRS document. This process is performed with the involvement of the testing team. \nReviews, walkthroughs, inspections, and desk-checking are some methods that can be used in verification.  Black box testing, white box testing, and non-functional testing are some methods that can be used during validation.\nIt identifies the bugs or errors early in the development process. It can identify the bugs or errors that the verification process cannot catch.\nIt is performed before the validation process. It is performed after the verification process. Verification  Validation \nIt checks whether the software meets the specification or not. It checks whether the specification captures the customer’s needs or not.  \nIt is a type of static testing.  It is a type of dynamic testing. \nThere is no requirement of executing the code. There is a requirement for executing the code.\nThis process is performed by the QA team to make sure that the software is built as per the specifications in the SRS document. This process is performed with the involvement of the testing team. \nReviews, walkthroughs, inspections, and desk-checking are some methods that can be used in verification.  Black box testing, white box testing, and non-functional testing are some methods that can be used during validation.\nIt identifies the bugs or errors early in the development process. It can identify the bugs or errors that the verification process cannot catch.\nIt is performed before the validation process. It is performed after the verification process. Verification  Validation Verification  Validation Verification Validation It checks whether the software meets the specification or not. It checks whether the specification captures the customer’s needs or not.  \nIt is a type of static testing.  It is a type of dynamic testing. \nThere is no requirement of executing the code. There is a requirement for executing the code.\nThis process is performed by the QA team to make sure that the software is built as per the specifications in the SRS document. This process is performed with the involvement of the testing team. \nReviews, walkthroughs, inspections, and desk-checking are some methods that can be used in verification.  Black box testing, white box testing, and non-functional testing are some methods that can be used during validation.\nIt identifies the bugs or errors early in the development process. It can identify the bugs or errors that the verification process cannot catch.\nIt is performed before the validation process. It is performed after the verification process. It checks whether the software meets the specification or not. It checks whether the specification captures the customer’s needs or not. It checks whether the software meets the specification or not. It checks whether the specification captures the customer’s needs or not. It is a type of static testing.  It is a type of dynamic testing. It is a type of static testing. It is a type of dynamic testing. There is no requirement of executing the code. There is a requirement for executing the code. There is no requirement of executing the code. There is a requirement for executing the code. This process is performed by the QA team to make sure that the software is built as per the specifications in the SRS document. This process is performed with the involvement of the testing team. This process is performed by the QA team to make sure that the software is built as per the specifications in the SRS document. This process is performed with the involvement of the testing team. Reviews, walkthroughs, inspections, and desk-checking are some methods that can be used in verification.  Black box testing, white box testing, and non-functional testing are some methods that can be used during validation. Reviews, walkthroughs, inspections, and desk-checking are some methods that can be used in verification. Black box testing, white box testing, and non-functional testing are some methods that can be used during validation. It identifies the bugs or errors early in the development process. It can identify the bugs or errors that the verification process cannot catch. It identifies the bugs or errors early in the development process. It can identify the bugs or errors that the verification process cannot catch. It is performed before the validation process. It is performed after the verification process. It is performed before the validation process. It is performed after the verification process.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "26. What is static software testing?",
        "answer": "Static testing is a technique in which you test the software without actually executing it. It involves doing code walkthroughs, code reviews, peer-reviews, or using sophisticated tools such as eslint, StyleCop to perform static analysis of the source code. Static testing is typically performed during software development.  ",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "27. What is dynamic software testing?",
        "answer": "In contrast to static testing, dynamic software testing tests the software when it’s executing. The tester runs the software in a test environment and goes through all the steps involved, entering the inputs and verifying the actual output with the expected result.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "28. What do you mean by confirmation testing in software testing?",
        "answer": "A confirmation test involves retesting a software product to see if the previously reported bugs have been fixed. A bug is usually reported by testers when a test fails. A new version of the software is released after the development team fixes the defect. Now that the new software build has been released, the testing team will retest it in order to ensure that the reported bug was actually fixed. It is also referred to as retesting.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "29. What is the defect life cycle?",
        "answer": "Defect life cycle, also known as a bug life cycle, is a life cycle of various stages through which a defect goes during its whole lifetime. This life cycle starts as soon as the defect is discovered or reported by the tester and ends when the tester ensures that the defect is resolved and it won't occur again. The defect life cycle includes the steps as shown below:  ",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "30. How can Selenium WebDriver be used to detect broken links?",
        "answer": "You might be asked this tricky question by the interviewer. As an example, he could give you a web page with 20 links, and you would have to determine which of those 20 links are working and which aren't or are broken. Considering that you must verify the functionality of each link, the workaround is to send HTTP requests to each link and analyze the response. When you navigate to a URL using the driver.get() method, you will receive a 200 - OK status response. It is evident that the link has been obtained and is working. In the case of any other status, the link is broken. Let’s now understand how to do that. As a first step, we must determine the different hyperlinks on the webpage using anchor tags. We can obtain hyperlinks for each tag using the attribute 'href' value and analyze the response received using the driver.get() method.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "31. When there is neither a frame ID nor a frame name, what technique should be considered in the script?",
        "answer": "When frame name and frame id are unavailable, we can use frame index instead. Suppose there are four frames on a page that don't have frame names or frame identifiers (frame ID), but we can still select them with the frame (zero-based) index attribute. For instance, the first frame would be indexed 0, the second frame would be at index 1, the third frame would be at index 2, and the fourth frame would be at index 3. driver.switchTo().frame(int arg0); driver.switchTo().frame(int arg0);",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "32. What is meant by the workbench concept?",
        "answer": "A workbench is a document that explains how an activity should be completed. Often, it is referred to as a step, phase, or task. Workbenches serve as platforms for building and monitoring testers' work structures. Using this method, it is possible to divide tasks into each phase and to reach the customer's expectations using the initial data. Every workbench has five tasks, which are as follows: Input.\nExecute.\nCheck.\nProduction output.\nRework. Input. Execute. Check. Production output. Rework.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "33. A defect that could have been removed during the initial stage is later removed. What effect does this have on the cost?",
        "answer": "If a defect is discovered during the project's initial phase, it is important that the defect is removed during that phase rather than afterwards. The cost of fixing a defect increases greatly if it is delayed until a later stage in the development cycle. Following is a diagram showing how the cost of a fixing defect increases throughout the phases. It is more cost-effective to eliminate defects during the design phase, but it becomes twenty times more expensive to do so during maintenance.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "34. What is defect cascading in Software testing?",
        "answer": "In software testing, defect cascading is the scenario in which one defect leads to the occurrence of several other defects in a program. If a defect goes unnoticed during testing or if it doesn't get reported, it has the potential to trigger other problems. The result is that multiple defects arise during the later stages of the production process.",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "1. Conclusion",
        "answer": "Software testing is an important activity that ensures quality, giving the confidence to release the software to customers. This article explained the testing process and its importance in software development. It also covers important concepts on manual testing and will guide you to master the field of manual testing. However, testing is only a single component of a good software development strategy. A development team should use high coding standards, best practices, and patterns to reduce the bug count. As a long-term strategy, the best way to improve the testing process is to test frequently, measure the results, gather feedback and use it to get better. Recommended Resources: Recommended Resources: QA Engineer\nSoftware Testing MCQ\nManual Testing\nAutomation Testing\nDatabase Testing\nMobile App Testing\nJmeter\nCucumber\nSmoke vs Sanity Testing\nDifference Between Alpha and Beta Testing\nTest Plan vs Test Strategy\nAgile Vs Waterfall\nAgile Vs Scrum\nAutomation Testing Tools\nPerformance Testing Tools\nAPI Testing Tools\nTesting Tools\nManual Testing Tools\nPrinciples of Software Testing QA Engineer QA Engineer Software Testing MCQ Software Testing MCQ Manual Testing Manual Testing Automation Testing Automation Testing Database Testing Database Testing Mobile App Testing Mobile App Testing Jmeter Jmeter Cucumber Cucumber Smoke vs Sanity Testing Smoke vs Sanity Testing Difference Between Alpha and Beta Testing Difference Between Alpha and Beta Testing Test Plan vs Test Strategy Test Plan vs Test Strategy Agile Vs Waterfall Agile Vs Waterfall Agile Vs Scrum Agile Vs Scrum Automation Testing Tools Automation Testing Tools Performance Testing Tools Performance Testing Tools API Testing Tools API Testing Tools Testing Tools Testing Tools Manual Testing Tools Manual Testing Tools Principles of Software Testing Principles of Software Testing References: References: Selenium: https://www.selenium.dev/documentation\nProtractor: https://www.protractortest.org/\nCypress: https://docs.cypress.io/\nJasmine: https://jasmine.github.io/ Selenium: https://www.selenium.dev/documentation https://www.selenium.dev/documentation Protractor: https://www.protractortest.org/ https://www.protractortest.org/ Cypress: https://docs.cypress.io/ https://docs.cypress.io/ Jasmine: https://jasmine.github.io/ https://jasmine.github.io/",
        "reference": "interviewbit.com",
        "role": "software-testing"
    },
    {
        "question": "1) What is the PDCA cycle and where testing fits in?",
        "answer": "There are four steps in a normal software development process. In short, these steps are referred to as PDCA.\n\n\nPDCA stands for Plan, Do, Check, Act.\nADVERTISEMENT\nPlan: It defines the goal and the plan for achieving that goal.\nDo/ Execute: It depends on the plan strategy decided during the planning stage. It is done according to this phase.\nCheck: This is the testing part of the software development phase. It is used to ensure that we are moving according to plan and getting the desired result.\nAct: This step is used to solve if there any issue has occurred during the check cycle. It takes appropriate action accordingly and revises the plan again.\nThe developers do the \"planning and building\" of the project while testers do the \"check\" part of the project.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "2) What is the difference between the white box, black box, and gray box testing?",
        "answer": "Black box Testing: The strategy of black box testing is based on requirements and specification. It requires no need of knowledge of internal path, structure or implementation of the software being tested.\nWhite box Testing: White box testing is based on internal paths, code structure, and implementation of the software being tested. It requires a full and detail programming skill.\nGray box Testing: This is another type of testing in which we look into the box which is being tested, It is done only to understand how it has been implemented. After that, we close the box and use the black box testing.\nFollowing are the differences among white box, black box, and gray box testing are:\nBlack box testing Gray box testing White box testing\nBlack box testing does not need the implementation knowledge of a program. Gray box testing knows the limited knowledge of an internal program. In white box testing, implementation details of a program are fully required.\nIt has a low granularity. It has a medium granularity.\nIt has a high granularity.\nIt is also known as opaque box testing, closed box testing, input-output testing, data-driven testing, behavioral testing and functional testing. It is also known as translucent testing.\nIt is also known as glass box testing, clear box testing.\nIt is a user acceptance testing, i.e., it is done by end users. It is also a user acceptance testing.\nTesters and programmers mainly do it.\nTest cases are made by the functional specifications as internal details are not known. Test cases are made by the internal details of a program.\nTest cases are made by the internal details of a program.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "3)What are the advantages of designing tests early in the life cycle?",
        "answer": "Designing tests early in the life cycle prevent defects from being in the main code.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "4) What are the types of defects?",
        "answer": "There are three types of defects: Wrong, missing, and extra.\nWrong: These defects are occurred due to requirements have been implemented incorrectly.\nMissing: It is used to specify the missing things, i.e., a specification was not implemented, or the requirement of the customer was not appropriately noted.\nExtra: This is an extra facility incorporated into the product that was not given by the end customer. It is always a variance from the specification but may be an attribute that was desired by the customer. However, it is considered as a defect because of the variance from the user requirements.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "5) What is exploratory testing?",
        "answer": "Simultaneous test design and execution against an application is called exploratory testing. In this testing, the tester uses his domain knowledge and testing experience to predict where and under what conditions the system might behave unexpectedly.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "6) When should exploratory testing be performed?",
        "answer": "Exploratory testing is performed as a final check before the software is released. It is a complementary activity to automated regression testing.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "7) What are the advantages of designing tests early in the life cycle?",
        "answer": "It helps you to prevent defects in the code.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "",
        "answer": "The risk-based testing is a testing strategy that is based on prioritizing tests by risks. It is based on a detailed risk analysis approach which categorizes the risks by their priority. Highest priority risks are resolved first.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "9) What is acceptance testing?",
        "answer": "Acceptance testing is done to enable a user/customer to determine whether to accept a software product. It also validates whether the software follows a set of agreed acceptance criteria. In this level, the system is tested for the user acceptability.\n\nTypes of acceptance testing are:\nUser acceptance testing: It is also known as end-user testing. This type of testing is performed after the product is tested by the testers. The user acceptance testing is testing performed concerning the user needs, requirements, and business processes to determine whether the system satisfies the acceptance criteria or not.\nOperational acceptance testing: An operational acceptance testing is performed before the product is released in the market. But, it is performed after the user acceptance testing.\nContract and regulation acceptance testing: In the case of contract acceptance testing, the system is tested against certain criteria and the criteria are made in a contract. In the case of regulation acceptance testing, the software application is checked whether it meets the government regulations or not.\nAlpha and beta testing: Alpha testing is performed in the development environment before it is released to the customer. Input is taken from the alpha testers, and then the developer fixes the bug to improve the quality of a product. Unlike alpha testing, beta testing is performed in the customer environment. Customer performs the testing and provides the feedback, which is then implemented to improve the quality of a product.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "10) What is accessibility testing?",
        "answer": "Accessibility testing is used to verify whether a software product is accessible to the people having disabilities (deaf, blind, mentally disabled etc.).",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "11) What is Adhoc testing?",
        "answer": "Ad-hoc testing is a testing phase where the tester tries to 'break' the system by randomly trying the system's functionality.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "12) What is Agile testing?",
        "answer": "Agile testing is a testing practice that uses agile methodologies i.e. follow test-first design paradigm.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "13) What is API (Application Programming Interface)?",
        "answer": "Application Programming Interface is a formalized set of software calls and routines that can be referenced by an application program to access supporting system or network services.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "14) What do you mean by automated testing?",
        "answer": "Testing by using software tools which execute test without manual intervention is known as automated testing. Automated testing can be used in GUI, performance, API, etc.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "15) What is Bottom-up testing?",
        "answer": "The Bottom-up testing is a testing approach which follows integration testing where the lowest level components are tested first, after that the higher level components are tested. The process is repeated until the testing of the top-level component.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "16) What is Baseline Testing?",
        "answer": "In Baseline testing, a set of tests is run to capture performance information. Baseline testing improves the performance and capabilities of the application by using the information collected and make the changes in the application. Baseline compares the present performance of the application with its previous performance.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "17) What is Benchmark Testing?",
        "answer": "Benchmarking testing is the process of comparing application performance with respect to the industry standard given by some other organization.\nIt is a standard testing which specifies where our application stands with respect to others.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "18) Which types are testing are important for web testing?",
        "answer": "There are two types of testing which are very important for web testing:\nPerformance testing: Performance testing is a testing technique in which quality attributes of a system are measured such as responsiveness, speed under different load conditions and scalability. The performance testing describes which attributes need to be improved before the product is released in the market.\nSecurity testing: Security testing is a testing technique which determines that the data and resources be saved from the intruders.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "19) What is the difference between web application and desktop application in the scenario of testing?",
        "answer": "The difference between a web application and desktop application is that a web application is open to the world with potentially many users accessing the application simultaneously at various times, so load testing and stress testing are important. Web applications are also prone to all forms of attacks, mostly DDOS, so security testing is also very important in the case of web applications.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "20) What is the difference between verification and validation?",
        "answer": "Difference between verification and validation:\nVerification Validation\nVerification is Static Testing. Validation is Dynamic Testing.\nVerification occurs before Validation. Validation occurs after Verification.\nVerification evaluates plans, document, requirements and specification. Validation evaluates products.\nIn verification, inputs are the checklist, issues list, walkthroughs, and inspection. Invalidation testing, the actual product is tested.\nVerification output is a set of document, plans, specification and requirement documents. Invalidation actual product is output.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "21) What is the difference between Retesting and Regression Testing?",
        "answer": "A list of differences between Retesting and Regression Testing:\nRegression Retesting\nRegression is a type of software testing that checks the code change does not affect the current features and functions of an application. Retesting is the process of testing that checks the test cases which were failed in the final execution.\nThe main purpose of regression testing is that the changes made to the code should not affect the existing functionalities. Retesting is applied on the defect fixes.\nDefect verification is not an element of Regression testing. Defect verification is an element of regression testing.\nAutomation can be performed for regression testing while manual testing could be expensive and time-consuming. Automation cannot be performed for Retesting.\nRegression testing is also known as generic testing. Retesting is also known as planned testing.\nRegression testing concern with executing test cases that was passed in earlier builds. Retesting concern with executing those test cases that are failed earlier. Regression testing can be performed in parallel with the retesting. Priority of retesting is higher than the regression testing.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "22) What is the difference between preventative and reactive approaches to testing?",
        "answer": "Preventative tests are designed earlier, and reactive tests are designed after the software has been produced.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "23) What is the purpose of exit criteria?",
        "answer": "The exit criteria are used to define the completion of the test level.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "24) Why is the decision table testing used?",
        "answer": "A decision table consists of inputs in a column with the outputs in the same column but below the inputs.\nThe decision table testing is used for testing systems for which the specification takes the form of rules or cause-effect combination. The reminders you get in the table explore combinations of inputs to define the output produced.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "25) What is alpha and beta testing?",
        "answer": "These are the key differences between alpha and beta testing:\nNo. Alpha Testing Beta Testing\n1) It is always done by developers at the software development site. It is always performed by customers at their site.\n2) It is also performed by Independent testing team It is not be performed by Independent testing team\n3) It is not open to the market and public. It is open to the market and public.\n4) It is always performed in a virtual environment. It is always performed in a real-time environment.\n5) It is used for software applications and projects. It is used for software products.\n6) It follows the category of both white box testing and Black Box Testing. It is only the kind of Black Box Testing.\n7) It is not known by any other name. It is also known as field testing.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "26) What is Random/Monkey Testing?",
        "answer": "Random testing is also known as monkey testing. In this testing, data is generated randomly often using a tool. The data is generated either using a tool or some automated mechanism.\nRandom testing has some limitations:\nMost of the random tests are redundant and unrealistic.\nIt needs more time to analyze results.\nIt is not possible to recreate the test if you do not record what data was used for testing.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "27) What is the negative and positive testing?",
        "answer": "Negative Testing: When you put an invalid input and receive errors is known as negative testing.\nPositive Testing: When you put in the valid input and expect some actions that are completed according to the specification is known as positive testing.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "28) What is the benefit of test independence?",
        "answer": "Test independence is very useful because it avoids author bias in defining effective tests.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "29) What is the boundary value analysis/testing?",
        "answer": "In boundary value analysis/testing, we only test the exact boundaries rather than hitting in the middle. For example: If there is a bank application where you can withdraw a maximum of 25000 and a minimum of 100. So in boundary value testing we only test above the max and below the max. This covers all scenarios.\nThe following figure shows the boundary value testing for the above-discussed bank application.TC1 and TC2 are sufficient to test all conditions for the bank. TC3 and TC4 are duplicate/redundant test cases which do not add any value to the testing. So by applying proper boundary value fundamentals, we can avoid duplicate test cases, which do not add value to the testing.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "30) How would you test the login feature of a web application?",
        "answer": "There are many ways to test the login feature of a web application:\nSign in with valid login, Close browser and reopen and see whether you are still logged in or not.\nSign in, then log out and then go back to the login page to see if you are truly logged out.\nLog in, then go back to the same page, do you see the login screen again?\nSession management is important. You must focus on how do we keep track of logged in users, is it via cookies or web sessions?\nSign in from one browser, open another browser to see if you need to sign in again?\nLog in, change the password, and then log out, then see if you can log in again with the old password.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "31) What are the types of performance testing?",
        "answer": "Performance testing: Performance testing is a testing technique which determines the performance of the system such as speed, scalability, and stability under various load conditions. The product undergoes the performance testing before it gets live in the market.\nTypes of software testing are:\n\n1. Load testing:\nLoad testing is a testing technique in which system is tested with an increasing load until it reaches the threshold value.\nNote: An increasing load means the increasing the number of users.\nThe main purpose of load testing is to check the response time of the system with an increasing amount of load.\nLoad testing is non-functional testing means that the only non-functional requirements are tested.\nLoad testing is performed to make sure that the system can withstand a heavy load\n2. Stress testing:\nStress testing is a testing technique to check the system when hardware resources are not enough such as CPU, memory, disk space, etc.\nIn case of stress testing, software is tested when the system is loaded with the number of processes and the hardware resources are less.\nThe main purpose of stress testing is to check the failure of the system and to determine how to recover from this failure is known as recoverability.\nStress testing is non-functional testing means that the only non-functional requirements are tested.\n3. Spike testing:\nSpike testing is a subset of load testing. This type of testing checks the instability of the application when the load is varied.\nThere are different cases to be considered during testing:\nThe first case is not to allow the number of users so that the system will not suffer heavy load.\nThe second case is to provide warnings to the extra joiners, and this would slow down the response time.\n4. Endurance testing:\nEndurance testing is a subset of load testing. This type of testing checks the behavior of the system.\nEndurance testing is non-functional testing means that the only non-functional requirements are tested.\nEndurance testing is also known as Soak testing.\nEndurance testing checks the issues such as memory leak. A memory leak occurs when the program does not release its allocated memory after its use. Sometimes the application does not release its memory even after its use and this unusable memory cause memory leak. This causes an issue when the application runs for a long duration.\nSome of the main issues that are viewed during this testing are:\nMemory leaks occurred due to an application.\nMemory leaks occurred due to a database connection.\nMemory leaks occurred due to a third party software.\n5. Volume testing:\nVolume testing is a testing technique in which the system is tested when the volume of data is increased.\nVolume testing is also known as flood testing.\nVolume testing is non-functional testing means that the only non-functional requirements are tested.\nFor example: If we want to apply the volume testing then we need to expand the database size, i.e., adding more data into the database table and then perform the test.\n6. Scalability testing\nScalability testing is a testing technique that ensures that the system works well in proportion to the growing demands of the end users.\nFollowing are the attributes checked during this testing:\nResponse time\nThroughput\nNumber of users required for performance test\nThreshold load\nCPU usage\nMemory usage\nNetwork usage",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "32) What is the difference between functional and non-functional testing?",
        "answer": "Basis of comparison Functional testing Non-functional testing\nDescription Functional testing is a testing technique which checks that function of the application works under the requirement specification. Non-functional testing checks all the non-functional aspects such as performance, usability, reliability, etc.\nExecution Functional testing is implemented before non-functional testing. Non-functional testing is performed after functional testing.\nFocus area It depends on the customer requirements. It depends on the customer expectations.\nRequirement Functional requirements can be easily defined. Non-functional requirements cannot be easily defined.\nManual testing Functional testing can be performed by manual testing. Non-functional testing cannot be performed by manual testing.\nTesting types Following are the types of functional testing:\nUnit testing\nAcceptance testing\nIntegration testing\nSystem testing\nFollowing are the types of non-functional testing:\nPerformance testing\nLoad testing\nStress testing\nVolume testing\nSecurity testing\nInstallation testing\nRecovery testing",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "33) What is the difference between static and dynamic testing?",
        "answer": "Static testing Dynamic testing\nStatic testing is a white box testing technique which is done at the initial stage of the software development lifecycle. Dynamic testing is a testing process which is done at the later stage of the software development lifecycle.\nStatic testing is performed before the code deployment. Dynamic testing is performed after the code deployment.\nIt is implemented at the verification stage. It is implemented at the validation stage.\nExecution of code is not done during this type of testing. Execution of code is necessary for the dynamic testing.\nIn the case of static testing, the checklist is made for the testing process. In the case of dynamic testing, test cases are executed.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "34) What is the difference between negative and positive testing?",
        "answer": "Positive testing Negative testing\nPositive testing means testing the application by providing valid data. Negative testing means testing the application by providing the invalid data.\nIn case of positive testing, tester always checks the application for a valid set of values. In the case of negative testing, tester always checks the application for the invalid set of values.\nPositive testing is done by considering the positive point of view for example: checking the first name field by providing the value such as \"Akshay\". Negative testing is done by considering the negative point of view for example: checking the first name field by providing the value such as \"Akshay123\".\nIt verifies the known set of test conditions. It verifies the unknown set of conditions.\nThe positive testing checks the behavior of the system by providing the valid set of data. The negative testing tests the behavior of the system by providing the invalid set of data.\nThe main purpose of the positive testing is to prove that the project works well according to the customer requirements. The main purpose of the negative testing is to break the project by providing the invalid set of data.\nThe positive testing tries to prove that the project meets all the customer requirements. The negative testing tries to prove that the project does not meet all the customer requirements.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "35) What are the different models available in SDLC?",
        "answer": "There are various models available in software testing, which are the following:\nWaterfall model\nSpiral Model\nPrototype model\nVerification and validation model\nHybrid model\nAgile model\nRational unified process model[RUP]\nRapid Application development [RAD]",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "36) List out the difference between smoke testing and sanity testing and dry run testing?",
        "answer": "Following are the differences between smoke, sanity, and dry run testing:\nSmoke testing Sanity testing Dry-run testing\nIt is shallow, wide and scripted testing. It is narrow and deep and unscripted testing A dry run testing is a process where the effects of a possible failure are internally mitigated.\nWhen the builds come, we will write the automation script and execute the scripts. So it will perform automatically. It will perform manually. For Example, An aerospace company may conduct a Dry run of a takeoff using a new aircraft and a runway before the first test flight.\nIt will take all the essential features and perform high-level testing. It will take some significant features and perform in-depth testing.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "37) How do we test a web application? What are the types of tests we perform on the web application?",
        "answer": "To test any web application such as Yahoo, Gmail, and so on, we will perform the following testing:\nFunctional testing\nIntegration testing\nSystem testing\nPerformance testing\nCompatibility testing ( test the application on the various operating systems, multiple browsers, and different version)\nUsability testing ( check whether it is user friendly)\nAd-hoc testing\nAccessibility testing\nSmoke testing\nRegression testing\nSecurity testing\nGlobalization testing ( only if it is developed in different languages)",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "38) Why do we need to perform compatibility testing?",
        "answer": "We might have developed the software in one platform, and the chances are there that users might use it in the different platforms. Hence, it could be possible that they may encounter some bugs and stop using the application, and the business might get affected. Therefore, we will perform one round of Compatibility testing.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "39) How many test cases we can write in a day?",
        "answer": "We can tell anywhere between 2-5 test cases.\nFirst test case → 1st day, 2nd day.\nSecond test case → 3rd day, 4th day.\nForth test case → 5th day.\n9-10 test cases → 19th day.\nPrimarily, we use to write 2-5 test cases, but in future stages we write around 6-7 because, at that time, we have the better product knowledge, we start re-using the test cases, and the experience on the product.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "40) How many test cases can we review per day?",
        "answer": "It would be around 7 test cases we write so that we can review 7*3=21 test cases. And we can say that 25-30 test case per day.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "41) How many test cases can we run in a day?",
        "answer": "We can run around 30-55 test cases per day.\nNote: For these types of questions (39-41), always remember the ratio: x test cases we can write, 3x test cases we can review, and 5x test cases we can execute per day.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "42) Does the customer get a 100% bug-free product?",
        "answer": "The testing team is not good\nDevelopers are super\nProduct is old\nAll of the above\nThe correct answer is testing team is not good because sometimes the fundamentals of software testing define that no product has zero bugs.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "43) How to track the bug manually and with the help of automation?",
        "answer": "We can track the bug manually as:\nIdentify the bug.\nMake sure that it is not duplicate (that is, check it in bug repository).\nPrepare a bug report.\nStore it in bug repository.\nSend it to the development team.\nManage the bug life cycle (i.e., keep modifying the status).\n\n\nTracking the bug with the help of automation i.e., bug tracking tool:\nWe have various bug tracking tools available in the market, such as:\nJira\nBugzilla\nMantis\nTelelogic\nRational Clear Quest\nBug_track\nQuality center ( it is a test management tool, a part of it is used to track the bugs)\nNote: Here, we have two categories of tools:\nA product based: In the product based companies, they will use only one bug tracking tool.\nService-based: In service-based companies, they have many projects of different customers, and every project will have different bug tracking tools.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "44) Why does an application have bugs?",
        "answer": "The software can have a bug for the following reasons:\nSoftware complexity\nProgramming errors\nIf no communications are happening between the customer and the company, i.e., an application should or should not perform according to the software's needs.\nModification in requirements\nTime pressure.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "45) When we perform testing?",
        "answer": "We will perform testing whenever we need to check all requirements are executed correctly or not, and to make sure that we are delivering the right quality product.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "46) When do we stop the testing?",
        "answer": "We can stop testing whenever we have the following:\nOnce the functionality of the application is stable.\nWhen the time is less, then we test the necessary features, and we stop it.\nThe client's budget.\nWhen the essential feature itself is not working correctly.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "47) For which and all types of testing do we write test cases?",
        "answer": "We can write test cases for the following types of testing:\n\nDifferent types of testing Test cases\nSmoke testing In this, we will write only standard features; thus, we can pull out some test cases that have all the necessary functions. Therefore, we do not have to write a test case for smoke testing.\nFunctional/unit testing Yes, we write the test case for unit testing.\nIntegration testing Yes, we write the test case for integration testing.\nSystem testing Yes, we write the test case for system testing.\nAcceptance testing Yes, but here the customer may write the test case.\nCompatibility testing In this, we don't have to write the test case because the same test cases as above are used for testing on different platforms.\nAdhoc testing We don't write the test case for the Adhoc testing because there are some random scenarios or the ideas, which we used at the time of Adhoc time. Though, if we identify the critical bug, then we convert that scenario into a test case.\nPerformance testing We might not write the test cases because we will perform this testing with the help of performance tools.\nUsability testing In this, we use the regular checklist; therefore, we don't write the test case because here we are only testing the look and feel of the application.\nAccessibility testing In accessibility testing, we also use the checklist.\nReliability testing Here, we don't write the manual test cases as we are using the automation tool to perform reliability testing.\nRegression testing Yes, we write the test cases for functional, integration, and system testing.\nRecovery testing Yes, we write the test cases for recovery testing, and also check how the product recovers from the crash.\nSecurity testing Yes, we write the test case for security testing.\nGlobalization testing:\nLocalization testing\nInternationalization testing Yes, we write the test case for L10N testing.\nYes, we write the test case for I18N testing.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "48) What is the difference between the traceability matrix and the test case review process?",
        "answer": "Traceability matrix Test case review\nIn this, we will make sure that each requirement has got at least one test case. In this, we will check whether all the scenarios are covered for the particular requirements.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "49) What is the difference between use case and test case?",
        "answer": "Following are the significant differences between the use case and the test case:\nTest case Use Case\nIt is a document describing the input, action, and expected response to control whether the application is working fine based on the customer requirements. It is a detailed description of Customer Requirements.\nIt is derived from test scenarios, Use cases, and the SRS. It is derived from BRS/SRS.\nWhile developing test cases, we can also identify loopholes in the specifications. A business analyst or QA Lead prepares it.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    },
    {
        "question": "50) How to test a pen?",
        "answer": "We can perform both manual and automation testing. First, we will see how we perform manual testing:\nDifferent types of testing Scenario\nSmoke testing Checks that basic functionality is written or not.\nFunctional/unit testing Check that the Refill, pen body, pen cap, and pen size as per the requirement.\nIntegration testing Combine pen and cap and integrate other different sizes and see whether they work fine.\nCompatibility testing Various surfaces, multiple environments, weather conditions, and keep it in oven and then write, keep it in the freezer and write, try and write on water.\nAdhoc testing Throw the pen down and start writing, keep it vertically up and write, write on the wall.\nPerformance testing Test the writing speed of the pen.\nUsability testing Check whether the pen is user friendly or not, whether we can write it for more extended periods smoothly.\nAccessibility testing Handicapped people use them.\nReliability testing Drop it down and write, and continuously write and see whether it leaks or not\nRecovery testing Throw it down and write.\nGlobalization testing\nLocalization testing Price should be standard, expiry date format.\nInternationalize testing Check whether the print on the pen is as per the country language.\nNow, we will see how we perform automation testing on a pen:\n\nFor this take a roller, now put some sheets of paper on the roller, then connects the pen to the motor and switch on the motor. The pen starts writing on the paper. Once the pen has stopped writing, now observe the number of lines that it has written on each page, length of each track, and multiplying all this, so we can get for how many kilometers the pen can write.",
        "reference": "javatpoint.com",
        "role": "software-testing"
    }
]