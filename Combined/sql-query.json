[
    {
        "question": "1. How do you retrieve specific columns from a table using SQL?",
        "answer": "To retrieve specific columns from a table, you can use the SELECT statement followed by the column names you want to fetch. \nFor example:\nSELECT column1, column2, column3 FROM table_name;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "2. Write a SQL Query to retrieve the product names and their corresponding categories for products with a price greater than $50.",
        "answer": "Given the “Products” table:\nProductID ProductName Category Price\n1 Laptop Electronics 800\n2 T-shirt Apparel 20\n3 Headphones Electronics 100\n4 Jeans Apparel 50\nSELECT ProductName, Category\nFROM Products\nWHERE Price > 50;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "3. Write a SQL Query to retrieve the count of orders placed on each date.",
        "answer": "Given the “Orders” table:\nOrderID CustomerID OrderDate\n1 101 12-05-2021\n2 102 16-07-2019\n3 103 30-11-2022\nSELECT OrderDate, COUNT(OrderID) AS OrderCount\nFROM Orders\nGROUP BY OrderDate;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "4. Write a SQL Query to calculate the average total order amount.",
        "answer": "Given the “Orders” table:\nOrderID CustomerID TotalAmount\n1 101 150\n2 102 200\n3 103 100\nSELECT AVG(TotalAmount) AS AvgTotalAmount\nFROM Orders;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "5. Write a SQL Query to retrieve the customer names (concatenated first name and last name) along with their corresponding city.",
        "answer": "Given the “Customers” table:\nOrderID CustomerID TotalAmount\n1 101 150\n2 102 200\n3 103 100\nSELECT CONCAT(FirstName, ' ', LastName) AS CustomerName, City\nFROM Customers;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "6. Explain the difference between INNER JOIN and LEFT JOIN in SQL.",
        "answer": "The differences between INNER JOIN and LEFT JOIN in SQL are explained below:\nINNER JOIN: An INNER JOIN returns only the matching rows from both tables being joined. It filters out the rows where no matching data is found in either table.\nLEFT JOIN: A LEFT JOIN returns all the rows from the left (or first) table and the matching rows from the right (or second) table. If there is no match in the right table, it returns NULL values for the columns from the right table.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "7. What is an Aggregate function in SQL? Provide examples of aggregate functions.",
        "answer": "An Aggregate function in SQL performs a calculation on a set of values and returns a single value as the result. Common aggregate functions include:\nCOUNT(): Returns the count of rows (number of rows) present in the result set.\nSUM(): Calculates the sum of a numeric column in a result set.\nAVG(): Calculates the average of a numeric column in a result set.\nMAX(): Returns the highest value (maximum) of a column present in the result set.\nMIN(): Returns the lowest value (minimum) of a column present in the result set\nCheck out the PostgreSQL Interview Questions and Answers to prepare for your next interview.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "8. Explain the difference between the HAVING clause and the WHERE clause in SQL.",
        "answer": "The WHERE clause is used to filter rows before they are grouped and aggregated, whereas the HAVING clause is used as a condition to filter the result of aggregate functions applied to grouped data. WHERE is applied before any grouping, whereas HAVING is applied after grouping.\nGet 100% Hike!\nMaster Most in Demand Skills Now!\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "9. How do you use the DISTINCT keyword in a SQL Query? Provide an example.",
        "answer": "The DISTINCT keyword is used to retrieve unique values from a column in a SQL Query. \nFor example:\nSELECT DISTINCT department FROM employees;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "10. Explain the purpose of the GROUP BY clause in SQL and when is used?",
        "answer": "The GROUP BY clause is used to group rows based on specified columns in a SQL query. It is often used with aggregate functions like SUM, COUNT, AVG, etc. to perform calculations on groups of data. The GROUP BY clause is used when you want to analyze data in subsets or groups rather than the entire dataset.\n\nIntermediate SQL Query Interview Questions and Answers",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "11. How can you update data in a table using SQL? Provide an example.",
        "answer": "To update data in a table using SQL, you use the UPDATE statement. \nFor example:\nUPDATE employees\nSET department = 'Sales'\nWHERE employee_id = 101;\nInterested in SQL? Check out this blog on How to Become an SQL Developer to get ahead in your career.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "12. What is the purpose of the BETWEEN operator in SQL? Give an example of how it is used.",
        "answer": "The BETWEEN operator in SQL is used to retrieve rows with values within a specified range.\nFor example:\nSELECT product_name, price\nFROM products\nWHERE price BETWEEN 1000 AND 2000;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "13. Explain the LIKE operator in SQL, and how is it different from the = operator?",
        "answer": "The LIKE operator is used in SQL to perform pattern matching on text fields. It allows the use of wildcards (% and _) to match specific patterns.\nFor example:\nSELECT product_name\nFROM products\nWHERE product_name LIKE 'Chair%';\nThe = operator, on the other hand, performs an exact match comparison between two values. It does not allow for pattern matching or the use of wildcards.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "14. What is a SQL Query?",
        "answer": "A SQL Query is a structured query language statement used to interact with relational databases. It allows users to retrieve, insert, update, and delete data in a database. SQL Queries are used to perform various operations on the data, such as filtering, sorting, grouping, and aggregating, to retrieve the desired information from the database.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "15. What is the purpose of the WHERE clause in SQL Queries?",
        "answer": "The WHERE clause in SQL is used to filter the rows returned by a query based on specified conditions. It allows you to retrieve only the rows that meet the specified criteria, making the query more selective and targeted.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "16. How do you sort the result of a SQL Query?",
        "answer": "To sort the result of a SQL query, you can use the ORDER BY clause, followed by the column(s) you want to sort on and the sorting order (ASC for ascending and DESC for descending). \nFor example:\nSELECT column1, column2 FROM table_name ORDER BY column1 ASC;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "17. What is a primary key in SQL, and why is it important?",
        "answer": "A primary key in SQL is used to identify a column uniquely and without NULL values in each row of a table. It ensures data integrity by enforcing entity uniqueness and acts as a reference point for establishing relationships between tables. Primary keys are crucial for data retrieval and indexing, enabling faster search operations and maintaining data consistency.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "18. How do you create a new table in SQL? Provide an example.",
        "answer": "To create a new table in SQL, you use the CREATE TABLE statement. \nFor example:\nCREATE TABLE employees (\n    employee_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50),\n    age INT,\n    department VARCHAR(100)\n);",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "19. What is a foreign key in SQL, and how does it establish a relationship between tables?",
        "answer": "A foreign key in SQL is used to refer to a column or a set of columns that are the primary key of another table. It establishes a relationship between two tables, known as the parent table (with the primary key) and the child table (with the foreign key). This relationship ensures data integrity by enforcing referential constraints and maintaining data consistency between related tables.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "20. What are SQL views, and what are their advantages?",
        "answer": "SQL views are virtual tables created by SQL Queries. They are not physically stored in the database but provide a way to simplify complex queries and present a customized subset of data to users. Advantages of SQL views include improved security by restricting access to underlying tables, simplified data retrieval, and reduced redundancy in queries.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "21. Explain the differences between the INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL JOIN in SQL.",
        "answer": "The differences between the INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL JOIN in SQL are described below:\nINNER JOIN: Returns only the rows where there is a match in both tables.\nLEFT JOIN: Returns all the records (rows) from the left table and the matching records (rows) from the right table. If there is no match in the right table, NULL values are returned.\nRIGHT JOIN: Returns all the rows from the right table and the matching rows from the left table. If there is no match in the left table, NULL values are returned.\nFULL JOIN: Returns all the rows when there is a match in either the left or right table. If there is no match in both tables, NULL values are returned for the non-matching side.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "22. What is a self-join in SQL? Provide an example of how it can be used.",
        "answer": "A self-join is a type of SQL join where a table is joined with itself. It is used when you need to combine rows from the same table based on a related column. One common scenario is when a table has a hierarchical relationship, such as an employee and manager relationship.\nFor Example:\nConsider an “Employees” table with columns: EmployeeID, FirstName, LastName, and ManagerID. We can use a self-join to retrieve the manager’s name for each employee.\nSELECT e.FirstName AS EmployeeName, m.FirstName AS ManagerName\nFROM Employees e\nJOIN Employees m ON e.ManagerID = m.EmployeeID;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "23. What are SQL transactions, and what are the properties (ACID) associated with them?",
        "answer": "SQL transactions are sequences of one or more SQL operations that are executed as a single unit of work. Transactions ensure data integrity and consistency in the database. The properties associated with transactions (often referred to as ACID properties) are as follows:\nAtomicity: Transactions indicate all operations or nothing. If a single unit of the transaction fails, the entire transaction is rolled back, and the database remains unchanged.\nConsistency: Transactions bring the database from one valid state to another. It ensures that the data satisfies all defined integrity constraints.\nIsolation: Transactions are executed in isolation from other transactions, so the intermediate states of a transaction are not visible to other transactions.\nDurability: Once a transaction is saved (committed), the changes are permanent and will survive even if there is a system failure.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "24. Explain the difference between UNION and UNION ALL in SQL.",
        "answer": "The difference between UNION and UNION ALL in SQL is defined further:\nUNION: Combines the result sets of two or more SELECT statements, removing duplicate rows from the final result set. It performs a distinct operation.\nUNION ALL: Also combines the result sets of two or more SELECT statements but includes all rows, even if there are duplicates. It does not remove duplicate rows from the final result set, resulting in faster performance compared to UNION.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "25. Explain the concept of a Primary Key in SQL and its importance.",
        "answer": "In SQL, a primary key in SQL is used to identify a column uniquely and without NULL values in each row of a table. It ensures that there are no duplicate or NULL values in the designated column(s), which helps maintain data integrity and ensures the uniqueness of each record in the table.\nThe importance of a Primary Key includes:\nUniqueness: It enforces the uniqueness of records, ensuring that no two rows in the table have the same primary key value.\nData Integrity: It helps maintain data integrity by preventing the insertion of duplicate or NULL values in the primary key column(s).\nIndexing: A primary key is automatically indexed, which improves the performance of search and retrieval operations on the table.\nRelationships: Primary keys are used to establish relationships between tables through foreign keys, creating the basis for referential integrity in the database.\nEfficient Updates: Updating or deleting records based on primary key values is more efficient than doing the same without a primary key.\nRemember, SQL interview questions often cover a wide range of topics, so it’s essential to have a good understanding of SQL fundamentals, data manipulation, and database concepts to succeed in SQL interviews.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "26. Explain the differences between a view and a table in SQL.",
        "answer": "The differences between a view and a table in SQL are described further:\nTable: A table is a fundamental database object that stores data in a structured format. It is a permanent, physical storage location for data. Data in a table is directly accessible, and you can perform various operations like inserting, updating, and deleting records.\nView: A view is a virtual table derived from one or more tables or views. It does not store any data itself but contains a query that defines how the data should be retrieved from the underlying tables. Views provide a way to simplify complex queries, restrict data access, and present a different perspective on the data without altering the original tables.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "27. Explain the concept of SQL Subqueries.",
        "answer": "SQL Subqueries (also known as Nested Queries) are queries within another query. These subqueries are deployed to retrieve data that will be used as a condition or criteria for the main query. Subqueries are enclosed within parentheses and can be used in SELECT, INSERT, UPDATE, or DELETE statements.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "28. Explain the difference between the CHAR and VARCHAR data types in SQL.",
        "answer": "The difference between the CHAR and VARCHAR data types in SQL is referred to as:\nCHAR: The CHAR data type is used to store fixed-length strings. When you define a CHAR column, you must specify the maximum number of characters it can hold. If the actual data is shorter than the defined length, it is padded with spaces to reach the specified length.\nVARCHAR: The VARCHAR data type is used to store variable-length strings. Unlike CHAR, VARCHAR columns only consume the necessary amount of storage based on the actual data length. It does not pad the data with spaces.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "29. Explain the concept of SQL Common Table Expressions (CTEs) and provide an example.",
        "answer": "Common Table Expressions (CTEs) are temporary result sets that can be used within a SELECT, INSERT, UPDATE, or DELETE statement. CTEs help simplify complex queries and make them more readable by breaking them down into smaller, manageable parts.\nFor Example:\nConsider the “Products” table. We want to retrieve the products with a price greater than the average price:\nWITH AveragePrice AS (\n  SELECT AVG(Price) AS AvgPrice\n  FROM Products\n)\nSELECT ProductName, Price\nFROM Products\nWHERE Price > (SELECT AvgPrice FROM AveragePrice);\nIn this example, the CTE named “AveragePrice” calculates the average price of products. The main query then selects the product names and prices from the “Products” table where the price is greater than the average price obtained from the CTE.\nGet 100% Hike!\nMaster Most in Demand Skills Now!\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "30. Explain the concept of SQL Self-Joins and provide an example.",
        "answer": "SQL Self-Joins are used to join a table with itself. It is useful when you want to combine rows from the same table based on related columns within the table.\nFor Example:\nConsider the “Employees” table with columns: EmployeeID, FirstName, LastName, and ManagerID. We can use a self-join to retrieve the employee names along with their manager names.\nSELECT e.FirstName AS EmployeeName, m.FirstName AS ManagerName\nFROM Employees e\nJOIN Employees m ON e.ManagerID = m.EmployeeID;\n\nAdvanced SQL Query Interview Questions for Experienced",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "31. Explain the concept of SQL Index Optimization and its significance in improving database performance.",
        "answer": "SQL Index Optimization involves analyzing the database and creating appropriate indexes on tables to improve the speed of data retrieval operations. It plays a crucial role in enhancing database performance and optimizing query execution.\nSignificance of SQL Index Optimization:\nFaster Data Retrieval: Indexes allow the database engine to quickly find and retrieve the required data, reducing the need for full table scans and improving query performance.\nEfficient Joins: Indexes optimize join operations, which are essential for complex queries that involve multiple tables.\nMinimized Disk I/O: Indexes reduce the number of disk I/O operations, which can significantly improve the overall performance of the database.\nQuery Performance Tuning: Properly designed indexes can make queries execute faster and help identify and fix performance bottlenecks.\nConsiderations: While indexes improve read performance, they may have a slight negative impact on write operations. Therefore, it’s essential to strike a balance between read and write operations and create indexes selectively on columns that are frequently used for filtering, sorting, or joining.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "32. Explain the difference between UNION and UNION ALL in SQL.",
        "answer": "The difference between UNION and UNION ALL in SQL is referred to below:\nUNION: The UNION operator combines the result sets of two or more SELECT queries and removes duplicate rows from the final result. If a row appears in more than one SELECT query, only one instance of that row will be included in the final result.\nUNION ALL: The UNION ALL operator also combines the result sets of two or more SELECT queries, but it includes all rows, including duplicate rows, in the final result. It does not remove duplicate rows from the result set.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "33. Explain the concept of SQL Subquery vs. JOIN and when to use each.",
        "answer": "SQL Subquery: A subquery is a query nested within another query. It is used to retrieve data that will be used as a condition or criteria for the main query. Subqueries are typically used when the result of one query depends on the result of another query and when you need to filter the data based on certain conditions before performing the main query.\nJOIN: A JOIN is used to combine rows from more than one table (two or more tables) based on a common column between them. It is used when you need to retrieve data from multiple tables and when the data in one table is related to the data in another table.\nChoosing between a subquery and a JOIN depends on the specific requirements of the query. Generally, if you need to filter data before joining, or if you need to retrieve data from multiple tables, a JOIN is more appropriate. On the other hand, if you need to filter data based on the result of another query, a subquery is the preferred choice.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "34. Explain the concept of SQL Common Table Expressions (CTEs) and provide an example.",
        "answer": "SQL Common Table Expressions (CTEs) are temporary result sets that are defined within a single SQL statement like SELECT, INSERT, UPDATE, and DELETE. CTEs are used to simplify complex queries by breaking them down into smaller, manageable parts. They improve the readability of queries and can be referenced multiple times within a single query.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "35. Explain the concept of SQL Window Functions.",
        "answer": "SQL Window Functions are used to perform calculations among a set of related rows to the current row, without changing the result set. They are used with the OVER() clause to define the window or group of rows to which the function applies.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "36. Explain the concept of SQL Triggers.",
        "answer": "SQL Triggers are special types of stored procedures that will automatically execute when a particular event occurs in the database. Triggers are used to enforce data integrity, implement business rules, or perform custom actions based on specific conditions.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "37. Explain the concept of SQL User-Defined Functions (UDFs) and provide an example.",
        "answer": "SQL User-Defined Functions (UDFs) are custom functions created by users to encapsulate business logic or frequently used calculations. UDFs can be called within SQL queries to perform specific tasks and return a result.\nFor Example:\nCreating an UDF to calculate the total price of a product based on its quantity and unit price:\nCREATE FUNCTION CalculateTotalPrice(@Quantity INT, @UnitPrice DECIMAL(10, 2))\nRETURNS DECIMAL(10, 2)\nAS\nBEGIN\n  DECLARE @TotalPrice DECIMAL(10, 2);\n  SET @TotalPrice = @Quantity * @UnitPrice;\n  RETURN @TotalPrice;\nEND;",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "38. Explain the difference between input parameters and output parameters in stored procedures.",
        "answer": "Input Parameters: Input parameters are used to pass values into the stored procedure when it is called. They allow the procedure to accept external data, such as search criteria or IDs, to perform specific operations.\nOutput Parameters: Output parameters allow the stored procedure to return values back to the caller. Unlike result sets, which return multiple rows, output parameters are used to send specific data values back to the calling program.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "39. Explain the concept of transaction management within stored procedures.",
        "answer": "Transaction management within stored procedures involves controlling the scope of a transaction and ensuring data consistency. Stored procedures can be executed within a transaction, and you can specify whether the transaction should be committed or rolled back based on specific conditions or outcomes within the procedure. This ensures that multiple related operations either succeed or fail together as a single unit of work.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "40. What is the purpose of the SQL EXECUTE AS clause in stored procedures?",
        "answer": "The EXECUTE AS clause in stored procedures specifies the security context under which the procedure will be executed. It allows you to control the permissions and privileges available for the procedure, reducing the risk of unauthorized access to sensitive data. The EXECUTE AS clause can be set to SELF (default), OWNER, CALLER, or a specific user or login.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "41. What are the advantages of using stored procedures?",
        "answer": "Advantages of using stored procedures include:\nCode Reusability: Stored procedures can be called from multiple applications, reducing code duplication.\nSecurity: Stored procedures allow controlling access to data by granting execution permissions, reducing the risk of SQL injection.\nPerformance: Stored procedures are precompiled, resulting in improved execution speed.\nSimplified Maintenance: Changes to the stored procedure are done in one place, simplifying maintenance.\nEncapsulation of Business Logic: Business logic can be encapsulated within stored procedures, making it easier to maintain and update.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "42. Explain the concept of SQL Subqueries vs. Common Table Expressions (CTEs) and when to use each.",
        "answer": "The basic concept of SQL Subqueries vs. Common Table Expressions (CTEs) are defined further:\nSQL Subqueries: Subqueries are queries that are nested inside another query and are usually enclosed within parentheses. They are executed first, and their result is then used in the main query. Subqueries are often used when the result of one query depends on the result of another query.\nCommon Table Expressions (CTEs): CTEs are temporary result sets that can be referenced within a SELECT, INSERT, UPDATE, or DELETE statement. They help simplify complex queries by breaking them down into smaller, more manageable parts. CTEs are useful when a query involves recursion or when parts of the query need to be referenced multiple times.\nChoosing between a subquery and a CTE depends on the specific requirements of the query. Generally, use a subquery when you need to use the result once and a CTE when you need to reference the result multiple times within the same query.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "43. What is an SQL index, and what is its purpose?",
        "answer": "An SQL index is a database object that enhances data retrieval speed by providing a quick lookup method for rows in a table. It is created on one or more columns of a table and works like an index in a book, allowing the database engine to locate data more efficiently. The primary purpose of an index is to optimize query performance by reducing the number of disk I/O operations required to fetch data.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "44. Explain the difference between a clustered index and a non-clustered index.",
        "answer": "The difference between a clustered index and a non-clustered index is described below:\nClustered Index: A clustered index establishes the physical order of the data in the table. Each table can have only one clustered index. When a clustered index is created, the table’s data rows are reorganized to match the index’s logical order. This means the data is physically stored in the same order as the index key. Clustered indexes are generally used on columns that are frequently used in range queries, such as dates.\nNon-clustered Index: A non-clustered index creates a separate structure from the table data. It contains a copy of the indexed columns along with pointers to the actual data rows. Each table can have multiple non-clustered indexes. Non-clustered indexes are useful for improving the performance of queries that involve JOINs or WHERE clauses.",
        "reference": "intellipaat.com",
        "role": "sql-query"
    },
    {
        "question": "1. What is Query in SQL?",
        "answer": "A query is a request for information or data from a database table or set of tables. For example, let us assume that we have a database that stores details about books written by various authors. Now, if we want to know how many books have been written by a particular author, then this question can be referred to as a query that we want to do to the database. query query Use cases of SQL: Use cases of SQL: SQL is an interactive question language. Users write SQL commands into interactive SQL software to extract information and display them on the screen, making it a useful and simple tool for ad hoc database queries.\nSQL is a database programming language. To access the information in a database, programmers incorporate SQL instructions into their utility packages. This method of database access is used by both user-written packages and database software packages\nSQL is a server/client language. SQL allows personal computer programs to interface with database servers that store shared data through a network. Many well-known enterprise-class apps use this client/server design.\nSQL is a distributed database language. SQL is used in distributed database control systems to help spread data across numerous linked computer structures. Every device's DBMS software program uses SQL to communicate with other systems, issuing requests for information access. Learn More SQL is an interactive question language. Users write SQL commands into interactive SQL software to extract information and display them on the screen, making it a useful and simple tool for ad hoc database queries. SQL is an interactive question language. SQL is a database programming language. To access the information in a database, programmers incorporate SQL instructions into their utility packages. This method of database access is used by both user-written packages and database software packages SQL is a database programming language. SQL is a server/client language. SQL allows personal computer programs to interface with database servers that store shared data through a network. Many well-known enterprise-class apps use this client/server design. SQL is a server/client language. SQL is a distributed database language. SQL is used in distributed database control systems to help spread data across numerous linked computer structures. Every device's DBMS software program uses SQL to communicate with other systems, issuing requests for information access. Learn More SQL is a distributed database language. Learn More Learn More",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "2. Let us consider the following schema:",
        "answer": "Table: Person Column Name Type\nid int\nemail varchar Column Name Type\nid int\nemail varchar Column Name Type Column Name Type Column Name Type id int\nemail varchar id int id int email varchar email varchar Here, id is the primary key column for this table. Email represents the email id of the person. For the sake of simplicity, we assume that the emails will not contain uppercase letters. Write an SQL query to report all the duplicate emails. You can return the result table in any order. Example: Input: Person table: id email\n1 a@gmail.com\n2 c@yahoo.com\n3 a@gmail.com id email\n1 a@gmail.com\n2 c@yahoo.com\n3 a@gmail.com id email id email id email 1 a@gmail.com\n2 c@yahoo.com\n3 a@gmail.com 1 a@gmail.com 1 a@gmail.com 2 c@yahoo.com 2 c@yahoo.com 3 a@gmail.com 3 a@gmail.com Output: Email\na@gmail.com Email\na@gmail.com Email Email Email a@gmail.com a@gmail.com a@gmail.com Explanation: a@gmail.com is repeated two times. Approach 1: Approach 1: Approach 1: We can first have all the distinct email ids and their respective counts in our result set. For this, we can use the GROUP BY operator to group the tuples by their email id. We will use the COUNT operator to have the total number of a particular email id in the given table. The query for obtaining this resultant set can be written as: select email, count(email) as email_count\nfrom Person\ngroup by email; select email, count(email) as email_count\nfrom Person\ngroup by email; select count as from group by Now, we query in the above resultant query set to find out all the tuples which have an email id count greater than 1. This can be achieved using the following query: select email from\n(\n  select email, count(email) as email_count\n  from Person\n group by email\n) \nwhere email_count > 1; select email from\n(\n  select email, count(email) as email_count\n  from Person\n group by email\n) \nwhere email_count > 1; select from select count as from group by where > 1 Approach 2: Approach 2: Approach 2: The HAVING clause, which is significantly simpler and more efficient, is a more popular technique to add a condition to a GROUP BY. So, we can first group the tuples by the email ids and then have a condition to check if their count is greater than 1, only then do we include it in our result set. So we may change the solution above to this one. select email\nfrom Person\ngroup by email\nhaving count(email) > 1; select email\nfrom Person\ngroup by email\nhaving count(email) > 1; select from group by having count > 1 Approach 3: Approach 3: Approach 3: We can use the concept of joins to solve this problem. We will self-join the Person table with the condition that their email ids should be the same and their ids should be different. Having done this, we just need to count the number of tuples in our resultant set with distinct email ids. For this, we use the DISTINCT operator. This can be achieved using the following query: SELECT DISTINCT p1.email\nFROM Person p1, Person p2\nWHERE p1.email = p2.email and p1.id != p2.id; SELECT DISTINCT p1.email\nFROM Person p1, Person p2\nWHERE p1.email = p2.email and p1.id != p2.id; SELECT DISTINCT FROM WHERE = and !=",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "3. Let us consider the following schema:",
        "answer": "Table: Activity Column Name Type\nplayerId int\ndeviceId int\neventDate date\ngamesplayed int Column Name Type\nplayerId int\ndeviceId int\neventDate date\ngamesplayed int Column Name Type Column Name Type Column Name Type playerId int\ndeviceId int\neventDate date\ngamesplayed int playerId int playerId int deviceId int deviceId int eventDate date eventDate date gamesplayed int gamesplayed int This table's primary key is (playerId, eventDate). The activities of numerous game participants are depicted in this table. Each row indicates a person that logged in and played a particular number of games (perhaps 0) before moving on to another device at a later date. Construct a SQL query to provide each player's first login date. You can return the result table in any order. Example 1: Input: Activity table: PlayerId deviceId eventDate gamesPlayed\n1 2 2021-08-09 9\n1 2 2021-04-07 3\n2 3 2021-06-25 1\n3 1 2021-03-02 1\n3 4 2021-07-03 3 PlayerId deviceId eventDate gamesPlayed\n1 2 2021-08-09 9\n1 2 2021-04-07 3\n2 3 2021-06-25 1\n3 1 2021-03-02 1\n3 4 2021-07-03 3 PlayerId deviceId eventDate gamesPlayed PlayerId deviceId eventDate gamesPlayed PlayerId deviceId eventDate gamesPlayed 1 2 2021-08-09 9\n1 2 2021-04-07 3\n2 3 2021-06-25 1\n3 1 2021-03-02 1\n3 4 2021-07-03 3 1 2 2021-08-09 9 1 2 2021-08-09 9 1 2 2021-04-07 3 1 2 2021-04-07 3 2 3 2021-06-25 1 2 3 2021-06-25 1 3 1 2021-03-02 1 3 1 2021-03-02 1 3 4 2021-07-03 3 3 4 2021-07-03 3 Output: playerId firstLogin\n1 2021-04-07\n2 2021-06-25\n3 2021-07-03 playerId firstLogin\n1 2021-04-07\n2 2021-06-25\n3 2021-07-03 playerId firstLogin playerId firstLogin playerId firstLogin 1 2021-04-07\n2 2021-06-25\n3 2021-07-03 1 2021-04-07 1 2021-04-07 2 2021-06-25 2 2021-06-25 3 2021-07-03 3 2021-07-03 Explanation: Explanation: The player with playerId 1 has two login event dates in the example above. However, because the first login event date is 2021-04-07, we display it. Similarly, the first login event date for the player with playerId 2 is 2021-06-25, and the first login event date for the player with playerId 3 is 2021-07-03. Approach 1: Approach 1: Approach 1: We can first group the tuples by their player_id. Now, we want the most initial date when the player logged in to the game. For this, we can use the MIN operator and find the initial date on which the player logged in. The query can be written as follows: select playerId, min(eventDate) as firstLogin from Activity group by playerId select playerId, min(eventDate) as firstLogin from Activity group by playerId select min as from group by Approach 2: Approach 2: Approach 2: We can partition the tuples by the player_id and order them by their event_id such that all the tuples having the same player_id are grouped together. We then number every tuple in each of the groups starting with the number 1. Now, we just have to display the event_date for the tuple having row number 1. For this, we use the ROW_NUMBER operator. The SQL query for it can be written as follows: SELECT playerId, eventDate AS firstLogin\nFROM\n(\n    SELECT playerId, eventDate, ROW_NUMBER() OVER (PARTITION BY playerId ORDER BY eventDate) AS seq\n    FROM Activity\n) AS t\nWHERE seq = 1 SELECT playerId, eventDate AS firstLogin\nFROM\n(\n    SELECT playerId, eventDate, ROW_NUMBER() OVER (PARTITION BY playerId ORDER BY eventDate) AS seq\n    FROM Activity\n) AS t\nWHERE seq = 1 SELECT AS FROM SELECT ROW_NUMBER OVER PARTITION BY ORDER BY AS FROM AS WHERE = 1 Approach 3: Approach 3: Approach 3: We follow a similar kind of approach as used in Approach 2. But instead of using the ROW_NUMBER operator, we can use the FIRST_VALUE operator to find the first event_date. The SQL query for it can be written as follows: select distinct(playerId),\nFIRST_VALUE(eventDate) OVER(PARTITION BY playerId ORDER BY eventDate) as firstLogin\nfrom Activity; select distinct(playerId),\nFIRST_VALUE(eventDate) OVER(PARTITION BY playerId ORDER BY eventDate) as firstLogin\nfrom Activity; select distinct FIRST_VALUE OVER PARTITION BY ORDER BY as from",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "4. Given the following schema:",
        "answer": "Table: Customers Column Name Type\nid int\nname varchar Column Name Type\nid int\nname varchar Column Name Type Column Name Type Column Name Type id int\nname varchar id int id int name varchar name varchar The primary key column for this table is id. Each row in the table represents a customer's ID and name. Table: Orders Column Name Type\nid int\ncustomerId int Column Name Type\nid int\ncustomerId int Column Name Type Column Name Type Column Name Type id int\ncustomerId int id int id int customerId int customerId int The primary key column for this table is id. customerId is a foreign key of the ID from the Customers table. The ID of an order and the ID of the customer who placed it are listed in each row of this table. Write an SQL query to report all customers who never order anything. You can return the result table in any order. Example: Input: Customers table: id name\n1 Ram\n2 Sachin\n3 Rajat\n4 Ankit id name\n1 Ram\n2 Sachin\n3 Rajat\n4 Ankit id name id name id name 1 Ram\n2 Sachin\n3 Rajat\n4 Ankit 1 Ram 1 Ram 2 Sachin 2 Sachin 3 Rajat 3 Rajat 4 Ankit 4 Ankit Orders table: id customeId\n1 2\n2 1 id customeId\n1 2\n2 1 id customeId id customeId id customeId 1 2\n2 1 1 2 1 2 2 1 2 1 Output Customers\nRajat\nAnkit Customers\nRajat\nAnkit Customers Customers Customers Rajat\nAnkit Rajat Rajat Ankit Ankit Explanation: Here, the customers Sachin and Ram have placed an order having order id 1 and 2 respectively. Thus, the customers Rajat and Ankit have never placed an order. So, we print their names in the result set. Explanation: Approach 1: Approach 1: Approach 1: In this approach, we first try to find the customers who have ordered at least once. After having found this, we find the customers whose customer Id is not present in the previously obtained result set. This gives us the customers who have not placed a single order yet. The SQL query for it can be written as follows select customers.name as 'Customers'\nfrom customers\nwhere customers.id not in\n(\n    select customerid from orders\n); select customers.name as 'Customers'\nfrom customers\nwhere customers.id not in\n(\n    select customerid from orders\n); select as 'Customers' from where not in select from Approach 2: Approach 2: Approach 2: In this approach, we use the concept of JOIN. We will LEFT JOIN the customer table with the order table based on the condition that id of the customer table must be equal to that of the customer id of the order table. Now, in our joined resultant table, we just need to find those customers whose order id is null. The SQL query for this can be written as follows: select c.name as 'Customers' from Customers c\nleft join Orders o ON (o.customerId = c.id)\nwhere o.id is null select c.name as 'Customers' from Customers c\nleft join Orders o ON (o.customerId = c.id)\nwhere o.id is null select as 'Customers' from left join ON = where is null Here, we first create aliases of the tables Customers and Orders with the name ‘c’ and ‘o’ respectively. Having done so, we join them with the condition that o.customerId = c.id. At last, we check for the customers whose o.id is null.",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "5. Given the following schema:",
        "answer": "Table: Cinema Column Name Type\nid int\nmovie varchar\ndescription varchar\nrating float Column Name Type\nid int\nmovie varchar\ndescription varchar\nrating float Column Name Type Column Name Type Column Name Type id int\nmovie varchar\ndescription varchar\nrating float id int id int movie varchar movie varchar description varchar description varchar rating float rating float The primary key for this table is id. Each row includes information about a movie's name, genre, and rating. rating is a float with two decimal digits in the range [0, 10]. Write an SQL query to report the movies with an odd-numbered ID and a description that is not \"boring\". Return the result table ordered by rating in descending order. Example: Input: Cinema table: id movie description rating\n1 War thriller 8.9\n2 Dhakkad action 2.1\n3 Gippi boring 1.2\n4 Dangal wrestling 8.6\n5 P.K. Sci-Fi 9.1 id movie description rating\n1 War thriller 8.9\n2 Dhakkad action 2.1\n3 Gippi boring 1.2\n4 Dangal wrestling 8.6\n5 P.K. Sci-Fi 9.1 id movie description rating id movie description rating id movie description rating 1 War thriller 8.9\n2 Dhakkad action 2.1\n3 Gippi boring 1.2\n4 Dangal wrestling 8.6\n5 P.K. Sci-Fi 9.1 1 War thriller 8.9 1 War thriller 8.9 2 Dhakkad action 2.1 2 Dhakkad action 2.1 3 Gippi boring 1.2 3 Gippi boring 1.2 4 Dangal wrestling 8.6 4 Dangal wrestling 8.6 5 P.K. Sci-Fi 9.1 5 P.K. Sci-Fi 9.1 Output id movie description rating\n5 P.K. Sci-Fi 9.1\n1 War thriller 8.9 id movie description rating\n5 P.K. Sci-Fi 9.1\n1 War thriller 8.9 id movie description rating id movie description rating id movie description rating 5 P.K. Sci-Fi 9.1\n1 War thriller 8.9 5 P.K. Sci-Fi 9.1 5 P.K. Sci-Fi 9.1 1 War thriller 8.9 1 War thriller 8.9 Explanation: Explanation: There are three odd-numbered ID movies: 1, 3, and 5. We don't include the movie with ID = 3 in the answer because it's boring. We put the movie with id 5 at the top since it has the highest rating of 9.1. This question has a bit of ambiguity on purpose. You should ask the interviewer whether we need to check for the description to exactly match “boring” or we need to check if the word “boring” is present in the description. We have provided solutions for both cases. Approach 1 (When the description should not be exactly “boring” but can include “boring” as a substring): Approach 1 (When the description should not be exactly “boring” but can include “boring” as a substring): Approach 1 (When the description should not be exactly “boring” but can include “boring” as a substring): In this approach, we use the MOD operator to check whether the id of a movie is odd or not. Now, for all the odd-numbered id movies, we check if its description is not boring. At last, we sort the resultant data according to the descending order of the movie rating. The SQL query for this can be written as follows: select *\nfrom cinema\nwhere mod(id, 2) = 1 and description != 'boring'\norder by rating DESC; select *\nfrom cinema\nwhere mod(id, 2) = 1 and description != 'boring'\norder by rating DESC; select * from where mod 2 = 1 and != 'boring' order by DESC Approach 2 (When the description should not even contain “boring” as a substring in our resultant answer): Approach 2 (When the description should not even contain “boring” as a substring in our resultant answer): Approach 2 (When the description should not even contain “boring” as a substring in our resultant answer): In this approach, we use the LIKE operator to match the description having “boring” as a substring. We then use the NOT operator to eliminate all those results. For the odd-numbered id, we check it similarly as done in the previous approach. Finally, we order the result set according to the descending order of the movie rating. The SQL query for it can be written as follows: SELECT *\nFROM Cinema\nWHERE id % 2 = 1 AND description NOT LIKE '%boring%'\nORDER BY rating DESC; SELECT *\nFROM Cinema\nWHERE id % 2 = 1 AND description NOT LIKE '%boring%'\nORDER BY rating DESC; SELECT * FROM WHERE % 2 = 1 AND NOT LIKE '%boring%' ORDER BY DESC",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "6. Consider the following schema:",
        "answer": "Table: Users Column Name Type\naccount_number int\nname varchar Column Name Type\naccount_number int\nname varchar Column Name Type Column Name Type Column Name Type account_number int\nname varchar account_number int account_number int name varchar name varchar The account is the primary key for this table. Each row of this table contains the account number of each user in the bank. There will be no two users having the same name in the table. Table: Transactions Column Name Type\ntrans_id int\naccount_number int\namount int\ntransacted_on date Column Name Type\ntrans_id int\naccount_number int\namount int\ntransacted_on date Column Name Type Column Name Type Column Name Type trans_id int\naccount_number int\namount int\ntransacted_on date trans_id int trans_id int account_number int account_number int amount int amount int transacted_on date transacted_on date trans_id is the primary key for this table. Each row of this table contains all changes made to all accounts. The amount is positive if the user received money and negative if they transferred money. All accounts start with a balance of 0. Construct a SQL query to display the names and balances of people who have a balance greater than $10,000. The balance of an account is equal to the sum of the amounts of all transactions involving that account. You can return the result table in any order. Example: Input: Users table: Account_number name\n12300001 Ram\n12300002 Tim\n12300003 Shyam Account_number name\n12300001 Ram\n12300002 Tim\n12300003 Shyam Account_number name Account_number name Account_number name 12300001 Ram\n12300002 Tim\n12300003 Shyam 12300001 Ram 12300001 Ram 12300002 Tim 12300002 Tim 12300003 Shyam 12300003 Shyam Transactions table: trans_id account_number amount transacted_on\n1 12300001 8000 2022-03-01\n2 12300001 8000 2022-03-01\n3 12300001 -3000 2022-03-02\n4 12300002 4000 2022-03-12\n5 12300003 7000 2022-02-07\n6 12300003 7000 2022-03-07\n7 12300003 -4000 2022-03-11 trans_id account_number amount transacted_on\n1 12300001 8000 2022-03-01\n2 12300001 8000 2022-03-01\n3 12300001 -3000 2022-03-02\n4 12300002 4000 2022-03-12\n5 12300003 7000 2022-02-07\n6 12300003 7000 2022-03-07\n7 12300003 -4000 2022-03-11 trans_id account_number amount transacted_on trans_id account_number amount transacted_on trans_id account_number amount transacted_on 1 12300001 8000 2022-03-01\n2 12300001 8000 2022-03-01\n3 12300001 -3000 2022-03-02\n4 12300002 4000 2022-03-12\n5 12300003 7000 2022-02-07\n6 12300003 7000 2022-03-07\n7 12300003 -4000 2022-03-11 1 12300001 8000 2022-03-01 1 12300001 8000 2022-03-01 2 12300001 8000 2022-03-01 2 12300001 8000 2022-03-01 3 12300001 -3000 2022-03-02 3 12300001 -3000 2022-03-02 4 12300002 4000 2022-03-12 4 12300002 4000 2022-03-12 5 12300003 7000 2022-02-07 5 12300003 7000 2022-02-07 6 12300003 7000 2022-03-07 6 12300003 7000 2022-03-07 7 12300003 -4000 2022-03-11 7 12300003 -4000 2022-03-11 Output: name balance\nRam 13000 name balance\nRam 13000 name balance name balance name balance Ram 13000 Ram 13000 Ram 13000 Explanation: Explanation: Ram's balance is (8000 + 8000 - 3000) = 11000.\nTim's balance is 4000.\nShyam's balance is (7000 + 7000 - 4000) = 10000.\nApproach 1: Ram's balance is (8000 + 8000 - 3000) = 11000. Tim's balance is 4000. Shyam's balance is (7000 + 7000 - 4000) = 10000. Approach 1: Approach 1: In this approach, we first create aliases of the given two tables' users and transactions. We can natural join the two tables and then group them by their account number. Next, we use the SUM operator to find the balance of each of the accounts after all the transactions have been processed. The SQL query for this can be written as follows: SELECT u.name, SUM(t.amount) AS balance\nFROM Users natural join Transactions t \nGROUP BY t.account_number\nHAVING balance> 10000; SELECT u.name, SUM(t.amount) AS balance\nFROM Users natural join Transactions t \nGROUP BY t.account_number\nHAVING balance> 10000; SELECT SUM AS FROM natural join GROUP BY HAVING > 10000",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "7. Given the following schema:",
        "answer": "Table: Employee Column Name Type\nid int\nname varcahar\ndepartment varchar\nmanagerId int Column Name Type\nid int\nname varcahar\ndepartment varchar\nmanagerId int Column Name Type Column Name Type Column Name Type id int\nname varcahar\ndepartment varchar\nmanagerId int id int id int name varcahar name varcahar department varchar department varchar managerId int managerId int All employees, including their managers, are present at the Employee table. There is an Id for each employee, as well as a column for the manager's Id. Write a SQL query that detects managers with at least 5 direct reports from the Employee table. Example: Input: Id Name Department ManagerId\n201 Ram A null\n202 Naresh A 201\n203 Krishna A 201\n204 Vaibhav A 201\n205 Jainender A 201\n206 Sid B 201 Id Name Department ManagerId\n201 Ram A null\n202 Naresh A 201\n203 Krishna A 201\n204 Vaibhav A 201\n205 Jainender A 201\n206 Sid B 201 Id Name Department ManagerId Id Name Department ManagerId Id Name Department ManagerId 201 Ram A null\n202 Naresh A 201\n203 Krishna A 201\n204 Vaibhav A 201\n205 Jainender A 201\n206 Sid B 201 201 Ram A null 201 Ram A null 202 Naresh A 201 202 Naresh A 201 203 Krishna A 201 203 Krishna A 201 204 Vaibhav A 201 204 Vaibhav A 201 205 Jainender A 201 205 Jainender A 201 206 Sid B 201 206 Sid B 201 Output: Name\nRam Name\nRam Name Name Name Ram Ram Ram Approach: Approach: Approach: In this problem, we first find all the manager ids who have more than 5 employees under them. Next, we find all the employees having the manager id present in the previously obtained manager id set. The SQL query for this can be written as follows: SELECT Name\nFROM Employee\nWHERE id IN\n  (SELECT ManagerId\n    FROM Employee\n    GROUP BY ManagerId\n    HAVING COUNT(DISTINCT Id) >= 5); SELECT Name\nFROM Employee\nWHERE id IN\n  (SELECT ManagerId\n    FROM Employee\n    GROUP BY ManagerId\n    HAVING COUNT(DISTINCT Id) >= 5); SELECT FROM WHERE IN SELECT FROM GROUP BY HAVING COUNT DISTINCT >= 5",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "8. Consider the following table schema:",
        "answer": "Construct an SQL query to retrieve duplicate records from the Employee table. Table: Employee Column Name Type\nid int\nfname varchar\nlname varchar\ndepartment varchar\nprojectId varchar\naddress varchar\ndateofbirth varchar\ngender varchar Column Name Type\nid int\nfname varchar\nlname varchar\ndepartment varchar\nprojectId varchar\naddress varchar\ndateofbirth varchar\ngender varchar Column Name Type Column Name Type Column Name Type id int\nfname varchar\nlname varchar\ndepartment varchar\nprojectId varchar\naddress varchar\ndateofbirth varchar\ngender varchar id int id int fname varchar fname varchar lname varchar lname varchar department varchar department varchar projectId varchar projectId varchar address varchar address varchar dateofbirth varchar dateofbirth varchar gender varchar gender varchar Table: Salary Column Name Type\nid int\nposition varchar\ndateofJoining varchar\nsalary varchar Column Name Type\nid int\nposition varchar\ndateofJoining varchar\nsalary varchar Column Name Type Column Name Type Column Name Type id int\nposition varchar\ndateofJoining varchar\nsalary varchar id int id int position varchar position varchar dateofJoining varchar dateofJoining varchar salary varchar salary varchar Now answer the following questions: 1. Construct an SQL query that retrieves the fname in upper case from the Employee table and uses the ALIAS name as the EmployeeName in the result. 1. Construct an SQL query that retrieves the fname in upper case from the Employee table and uses the ALIAS name as the EmployeeName in the result. SELECT UPPER(fname) AS EmployeeName FROM Employee; SELECT UPPER(fname) AS EmployeeName FROM Employee; SELECT UPPER AS FROM 2. Construct an SQL query to find out how many people work in the \"HR\" department 2. Construct an SQL query to find out how many people work in the \"HR\" department SELECT COUNT(*) FROM Employee WHERE department = 'HR'; SELECT COUNT(*) FROM Employee WHERE department = 'HR'; SELECT COUNT * FROM WHERE = 'HR' 3. Construct an SQL query to retrieve the first four characters of the ‘lname’ column from the Employee table. 3. Construct an SQL query to retrieve the first four characters of the ‘lname’ column from the Employee table. SELECT SUBSTRING(lname, 1, 4) FROM Employee; SELECT SUBSTRING(lname, 1, 4) FROM Employee; SELECT SUBSTRING 1 4 FROM 4. Construct a new table with data and structure that are copied from the existing table ‘Employee’ by writing a query. The name of the new table should be ‘SampleTable’. 4. Construct a new table with data and structure that are copied from the existing table ‘Employee’ by writing a query. The name of the new table should be ‘SampleTable’. SELECT * INTO SampleTable FROM Employee WHERE 1 = 0 SELECT * INTO SampleTable FROM Employee WHERE 1 = 0 SELECT * INTO FROM WHERE 1 = 0 5. Construct an SQL query to find the names of employees whose first names start with \"S\". 5. Construct an SQL query to find the names of employees whose first names start with \"S\". SELECT * FROM Employee WHERE fname LIKE 'S%'; SELECT * FROM Employee WHERE fname LIKE 'S%'; SELECT * FROM WHERE LIKE 'S%' 6. Construct an SQL query to count the number of employees grouped by gender whose dateOfBirth is between 01/03/1975 and 31/12/1976. 6. Construct an SQL query to count the number of employees grouped by gender whose dateOfBirth is between 01/03/1975 and 31/12/1976. SELECT COUNT(*), gender FROM Employee WHERE dateOfBirth BETWEEN '01/03/1975 ' AND '31/12/1976' GROUP BY gender; SELECT COUNT(*), gender FROM Employee WHERE dateOfBirth BETWEEN '01/03/1975 ' AND '31/12/1976' GROUP BY gender; SELECT COUNT * FROM WHERE BETWEEN '01/03/1975 ' AND '31/12/1976' GROUP BY 7. Construct an SQL query to retrieve all employees who are also managers. 7. Construct an SQL query to retrieve all employees who are also managers. SELECT emp.fname, emp.lname, sal.position \nFROM Employee emp INNER JOIN Salary sal ON\nemp.id = sal.id AND sal.position IN ('Manager'); SELECT emp.fname, emp.lname, sal.position \nFROM Employee emp INNER JOIN Salary sal ON\nemp.id = sal.id AND sal.position IN ('Manager'); SELECT FROM INNER JOIN ON = AND IN 'Manager' 8. Construct an SQL query to retrieve the employee count broken down by department and ordered by department count in ascending manner. 8. Construct an SQL query to retrieve the employee count broken down by department and ordered by department count in ascending manner. SELECT department, COUNT(id) AS DepartmentCount \nFROM Employee GROUP BY department \nORDER BY DepartmentCount ASC; SELECT department, COUNT(id) AS DepartmentCount \nFROM Employee GROUP BY department \nORDER BY DepartmentCount ASC; SELECT COUNT AS FROM GROUP BY ORDER BY ASC 9. Construct an SQL query to retrieve duplicate records from the Employee table. 9. Construct an SQL query to retrieve duplicate records from the Employee table. SELECT id, fname, department, COUNT(*) as Count\nFROM Employee GROUP BY id, fname, department \nHAVING COUNT(*) > 1; SELECT id, fname, department, COUNT(*) as Count\nFROM Employee GROUP BY id, fname, department \nHAVING COUNT(*) > 1; SELECT COUNT * as FROM GROUP BY HAVING COUNT * > 1",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "1. Consider the following Schema:",
        "answer": "Table: Tree Column Name Type\nid int\nparent_id int Column Name Type\nid int\nparent_id int Column Name Type Column Name Type Column Name Type id int\nparent_id int id int id int parent_id int parent_id int Here, id is the primary key column for this table. id represents the unique identity of a tree node and parent_id represents the unique identity of the parent of the current tree node.  The id of a node and the id of its parent node in a tree are both listed in each row of this table. There is always a valid tree in the given structure. Every node in the given tree can be categorized into one of the following types: 1. \"Leaf\": When the tree node is a leaf node, we label it as “Leaf” 2. \"Root\": When the tree node is a root node, we label it as “Root” 3. \"Inner\": When the tree node is an inner node, we label it as “Inner” Write a SQL query to find and return the type of each of the nodes in the given tree. You can return the result in any order. Example:   Input: Tree Table  id parent_id\n1 null\n2 1\n3 1\n4 3\n5 2 id parent_id\n1 null\n2 1\n3 1\n4 3\n5 2 id parent_id id parent_id id parent_id 1 null\n2 1\n3 1\n4 3\n5 2 1 null 1 null 2 1 2 1 3 1 3 1 4 3 4 3 5 2 5 2 Output: id type\n1 Root\n2 Inner\n3 Inner\n4 Leaf\n5 Leaf id type\n1 Root\n2 Inner\n3 Inner\n4 Leaf\n5 Leaf id type id type id type 1 Root\n2 Inner\n3 Inner\n4 Leaf\n5 Leaf 1 Root 1 Root 2 Inner 2 Inner 3 Inner 3 Inner 4 Leaf 4 Leaf 5 Leaf 5 Leaf Explanation: Explanation: Because node 1’s parent node is null, and it has child nodes 2 and 3, Node 1 is the root node.\nBecause node 2  and node 3 have parent node 1 and child nodes 5 and 4 respectively, Node 2  and node 3 are inner nodes.\nBecause nodes 4 and 5 have parent nodes but no child nodes, nodes  4, and 5 are leaf nodes. Because node 1’s parent node is null, and it has child nodes 2 and 3, Node 1 is the root node. Because node 2  and node 3 have parent node 1 and child nodes 5 and 4 respectively, Node 2  and node 3 are inner nodes. Because nodes 4 and 5 have parent nodes but no child nodes, nodes  4, and 5 are leaf nodes. Approach 1: Approach 1: In this approach, we subdivide our problem of categorizing the type of each of the nodes in the tree. We first find all the root nodes and add them to our resultant set with the type “root”. Then, we find all the leaf nodes and add them to our resultant set with the type “leaf”. Similarly, we find all the inner nodes and add them to our resultant set with the type “inner”. Now let us look at the query for finding each of the node types. For root nodes: For root nodes: For root nodes: SELECT\n    id, 'Root' AS Type\nFROM\n    tree\nWHERE\n    parent_id IS NULL SELECT\n    id, 'Root' AS Type\nFROM\n    tree\nWHERE\n    parent_id IS NULL SELECT 'Root' AS FROM WHERE IS NULL Here, we check if the parent_id of the node is null, then we assign the type of node as ‘Root’ and include it in our result set. For leaf nodes: For leaf nodes: For leaf nodes: SELECT\n    id, 'Leaf' AS Type\nFROM\n    tree\nWHERE\n    id NOT IN (SELECT DISTINCT\n            parent_id\n        FROM\n            tree\n        WHERE\n            parent_id IS NOT NULL)\n        AND parent_id IS NOT NULL SELECT\n    id, 'Leaf' AS Type\nFROM\n    tree\nWHERE\n    id NOT IN (SELECT DISTINCT\n            parent_id\n        FROM\n            tree\n        WHERE\n            parent_id IS NOT NULL)\n        AND parent_id IS NOT NULL SELECT 'Leaf' AS FROM WHERE NOT IN SELECT DISTINCT FROM WHERE IS NOT NULL AND IS NOT NULL Here, we first find all the nodes that have a child node. Next, we check if the current node is present in the set of root nodes. If present, it cannot be a leaf node and we eliminate it from our answer set. We also check that the parent_id of the current node is not null. If both the conditions satisfy then we include it in our answer set. For inner nodes: For inner nodes: For inner nodes: SELECT\n    id, 'Inner' AS Type\nFROM\n    tree\nWHERE\n    id IN (SELECT DISTINCT\n            parent_id\n        FROM\n            tree\n        WHERE\n            parent_id IS NOT NULL)\n        AND parent_id IS NOT NULL SELECT\n    id, 'Inner' AS Type\nFROM\n    tree\nWHERE\n    id IN (SELECT DISTINCT\n            parent_id\n        FROM\n            tree\n        WHERE\n            parent_id IS NOT NULL)\n        AND parent_id IS NOT NULL SELECT 'Inner' AS FROM WHERE IN SELECT DISTINCT FROM WHERE IS NOT NULL AND IS NOT NULL Here, we first find all the nodes that have a child node. Next, we check if the current node is present in the set of root nodes. If not present, it cannot be an inner node and we eliminate it from our answer set. We also check that the parent_id of the current node is not null. If both the conditions satisfy then we include it in our answer set. At last, we combine all three resultant sets using the UNION operator. So, the final SQL query is as follows: SELECT\n    id, 'Root' AS Type\nFROM\n    tree\nWHERE\n    parent_id IS NULL\n\nUNION\n\nSELECT\n    id, 'Leaf' AS Type\nFROM\n    tree\nWHERE\n    id NOT IN (SELECT DISTINCT\n            parent_id\n        FROM\n            tree\n        WHERE\n            parent_id IS NOT NULL)\n        AND parent_id IS NOT NULL\n\nUNION\n\nSELECT\n    id, 'Inner' AS Type\nFROM\n    tree\nWHERE\n    id IN (SELECT DISTINCT\n            parent_id\n        FROM\n            tree\n        WHERE\n            parent_id IS NOT NULL)\n        AND parent_id IS NOT NULL\nORDER BY id; SELECT\n    id, 'Root' AS Type\nFROM\n    tree\nWHERE\n    parent_id IS NULL\n\nUNION\n\nSELECT\n    id, 'Leaf' AS Type\nFROM\n    tree\nWHERE\n    id NOT IN (SELECT DISTINCT\n            parent_id\n        FROM\n            tree\n        WHERE\n            parent_id IS NOT NULL)\n        AND parent_id IS NOT NULL\n\nUNION\n\nSELECT\n    id, 'Inner' AS Type\nFROM\n    tree\nWHERE\n    id IN (SELECT DISTINCT\n            parent_id\n        FROM\n            tree\n        WHERE\n            parent_id IS NOT NULL)\n        AND parent_id IS NOT NULL\nORDER BY id; SELECT 'Root' AS FROM WHERE IS NULL UNION SELECT 'Leaf' AS FROM WHERE NOT IN SELECT DISTINCT FROM WHERE IS NOT NULL AND IS NOT NULL UNION SELECT 'Inner' AS FROM WHERE IN SELECT DISTINCT FROM WHERE IS NOT NULL AND IS NOT NULL ORDER BY Approach 2: Approach 2: In this approach, we use the control statement CASE. This simplifies our query a lot from the previous approach. We first check if a node falls into the category of “Root”. If the node does not satisfy the conditions of a root node, it implies that the node will either be a “Leaf” node or an “Inner” node. Next, we check if the node falls into the category of “Inner” node. If it is not an “Inner” node, there is only one option left, which is the “Leaf” node. The SQL query for this approach can be written as follows: SELECT\n    id AS `Id`,\n    CASE\n        WHEN tree.id = (SELECT aliastree.id FROM tree aliastree WHERE aliastree.parent_id IS NULL)\n          THEN 'Root'\n        WHEN tree.id IN (SELECT aliastree.parent_id FROM tree aliastree)\n          THEN 'Inner'\n        ELSE 'Leaf'\n    END AS Type\nFROM\n    tree\nORDER BY `Id`; SELECT\n    id AS `Id`,\n    CASE\n        WHEN tree.id = (SELECT aliastree.id FROM tree aliastree WHERE aliastree.parent_id IS NULL)\n          THEN 'Root'\n        WHEN tree.id IN (SELECT aliastree.parent_id FROM tree aliastree)\n          THEN 'Inner'\n        ELSE 'Leaf'\n    END AS Type\nFROM\n    tree\nORDER BY `Id`; SELECT AS CASE WHEN = SELECT FROM WHERE IS NULL THEN 'Root' WHEN IN SELECT FROM THEN 'Inner' ELSE 'Leaf' END AS FROM ORDER BY Approach 3: Approach 3: In this approach, we follow a similar logic as discussed in the previous approach. However, we will use the IF operator instead of the CASE operator. The SQL query for this approach can be written as follows: SELECT\n    aliastree.id,\n    IF(ISNULL(aliastree.parent_id),\n        'Root',\n        IF(aliastree.id IN (SELECT parent_id FROM tree), 'Inner','Leaf')) Type\nFROM\n    tree aliastree\nORDER BY aliastree.id SELECT\n    aliastree.id,\n    IF(ISNULL(aliastree.parent_id),\n        'Root',\n        IF(aliastree.id IN (SELECT parent_id FROM tree), 'Inner','Leaf')) Type\nFROM\n    tree aliastree\nORDER BY aliastree.id SELECT 'Root' IN SELECT FROM 'Inner' 'Leaf' FROM ORDER BY",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "2. Consider the following schema:",
        "answer": "Table: Seat Column Name type\nid int\nstudent varchar Column Name type\nid int\nstudent varchar Column Name type Column Name type Column Name type id int\nstudent varchar id int id int student varchar student varchar The table contains a list of students. Every tuple in the table consists of a seat id along with the name of the student. You can assume that the given table is sorted according to the seat id and that the seat ids are in continuous increments. Now, the class teacher wants to swap the seat id for alternate students in order to give them a last-minute surprise before the examination. You need to write a query that swaps alternate students' seat id and returns the result. If the number of students is odd, you can leave the seat id for the last student as it is. Example: id student\n1 Ram\n2 Shyam\n3 Vaibhav\n4 Govind\n5 Krishna id student\n1 Ram\n2 Shyam\n3 Vaibhav\n4 Govind\n5 Krishna id student id student id student 1 Ram\n2 Shyam\n3 Vaibhav\n4 Govind\n5 Krishna 1 Ram 1 Ram 2 Shyam 2 Shyam 3 Vaibhav 3 Vaibhav 4 Govind 4 Govind 5 Krishna 5 Krishna For the same input, the output is: id student\n1 Shyam\n2 Ram\n3 Govind\n4 Vaibhav\n5 Krishna id student\n1 Shyam\n2 Ram\n3 Govind\n4 Vaibhav\n5 Krishna id student id student id student 1 Shyam\n2 Ram\n3 Govind\n4 Vaibhav\n5 Krishna 1 Shyam 1 Shyam 2 Ram 2 Ram 3 Govind 3 Govind 4 Vaibhav 4 Vaibhav 5 Krishna 5 Krishna Approach 1: Approach 1: Approach 1: In this approach, first we count the total number of students. Having done so, we consider the case when the seat id is odd but is not equal to the total number of students. In this case, we simply increment the seat id by 1. Next, we consider the case when the seat id is odd but is equal to the total number of students. In this case, the seat id remains the same. At last, we consider the case when the seat id is even. In this case, we decrement the seat id by 1. The SQL query for this approach can be written as follows: SELECT \n CASE WHEN MOD(id, 2) != 0 AND counts != id THEN id + 1 -- for odd ids\n   WHEN MOD(id, 2) != 0 AND counts = id THEN id -- special case for last seat\n   ELSE id - 1 -- For even ids\n   END as id,\n student\nFROM \nseat, (SELECT COUNT(*) as counts \n    FROM seat) AS seat_count\nORDER by id; SELECT \n CASE WHEN MOD(id, 2) != 0 AND counts != id THEN id + 1 -- for odd ids\n   WHEN MOD(id, 2) != 0 AND counts = id THEN id -- special case for last seat\n   ELSE id - 1 -- For even ids\n   END as id,\n student\nFROM \nseat, (SELECT COUNT(*) as counts \n    FROM seat) AS seat_count\nORDER by id; SELECT CASE WHEN MOD 2 != 0 AND != THEN + 1 -- for odd ids WHEN MOD 2 != 0 AND = THEN -- special case for last seat ELSE - 1 -- For even ids END as FROM SELECT COUNT * as FROM AS ORDER by Approach 2: Approach 2: Approach 2: In this approach, we use the ROW_NUMBER operator. We increment the id for the odd-numbered ids by 1 and decrement the even-numbered ids by 1. We then sort the tuples, according to the id values. Next, we assign the row number as the id for the sorted tuples. The SQL query for this approach can  be written as follows: select row_number() \n   over (order by \n      (if(id%2=1,id+1,id-1))\n   ) as id, student\nfrom seat; select row_number() \n   over (order by \n      (if(id%2=1,id+1,id-1))\n   ) as id, student\nfrom seat; select row_number over order by % 2 = 1 + 1 -1 as from",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "3. Given the following schema:",
        "answer": "Table: Employee Column Name type\nid int\nname varchar\nsalary int\ndepartmentId int Column Name type\nid int\nname varchar\nsalary int\ndepartmentId int Column Name type Column Name type Column Name type id int\nname varchar\nsalary int\ndepartmentId int id int id int name varchar name varchar salary int salary int departmentId int departmentId int id is the primary key column for this table. departmentId is a foreign key of the ID from the Department table. Each row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department. Table: Department Column Name type\nid int\nname varchar Column Name type\nid int\nname varchar Column Name type Column Name type Column Name type id int\nname varchar id int id int name varchar name varchar id is the primary key column for this table. Each row of this table indicates the ID of a department and its name. The executives of an organization are interested in seeing who earns the most money in each department. A high earner in a department is someone who earns one of the department's top three unique salaries. Construct a SQL query to identify the high-earning employees in each department. You can return the result table in any order. Example: Input:  Employee table: id name salary departmentId\n1 Ram 85000 1\n2 Divya 80000 2\n3 Tim 60000 2\n4 Kim 90000 1\n5 Priya 69000 1\n6 Saket 85000 1\n7 Will 70000 1 id name salary departmentId\n1 Ram 85000 1\n2 Divya 80000 2\n3 Tim 60000 2\n4 Kim 90000 1\n5 Priya 69000 1\n6 Saket 85000 1\n7 Will 70000 1 id name salary departmentId id name salary departmentId id name salary departmentId 1 Ram 85000 1\n2 Divya 80000 2\n3 Tim 60000 2\n4 Kim 90000 1\n5 Priya 69000 1\n6 Saket 85000 1\n7 Will 70000 1 1 Ram 85000 1 1 Ram 85000 1 2 Divya 80000 2 2 Divya 80000 2 3 Tim 60000 2 3 Tim 60000 2 4 Kim 90000 1 4 Kim 90000 1 5 Priya 69000 1 5 Priya 69000 1 6 Saket 85000 1 6 Saket 85000 1 7 Will 70000 1 7 Will 70000 1 Department table: id name\n1 Marketing\n2 HR id name\n1 Marketing\n2 HR id name id name id name 1 Marketing\n2 HR 1 Marketing 1 Marketing 2 HR 2 HR Output: Department Employee Salary\nMarketing Kim 90000\nMarketing Ram 85000\nMarketing Saket 85000\nMarketing Will 70000\nHR Divya 80000\nHR Tim 60000 Department Employee Salary\nMarketing Kim 90000\nMarketing Ram 85000\nMarketing Saket 85000\nMarketing Will 70000\nHR Divya 80000\nHR Tim 60000 Department Employee Salary Department Employee Salary Department Employee Salary Marketing Kim 90000\nMarketing Ram 85000\nMarketing Saket 85000\nMarketing Will 70000\nHR Divya 80000\nHR Tim 60000 Marketing Kim 90000 Marketing Kim 90000 Marketing Ram 85000 Marketing Ram 85000 Marketing Saket 85000 Marketing Saket 85000 Marketing Will 70000 Marketing Will 70000 HR Divya 80000 HR Divya 80000 HR Tim 60000 HR Tim 60000 Explanation: Explanation: Kim has the greatest unique income in the Marketing department - Ram and Saket have the second-highest unique salary.\nWill has the third-highest unique compensation. Kim has the greatest unique income in the Marketing department - Ram and Saket have the second-highest unique salary. Will has the third-highest unique compensation. In the HR department: Divya has the greatest unique income.\nTim earns the second-highest salary.\nBecause there are only two employees, there is no third-highest compensation. Divya has the greatest unique income. Tim earns the second-highest salary. Because there are only two employees, there is no third-highest compensation. Approach 1: Approach 1: In this approach, let us first assume that all the employees are from the same department. So let us first figure out how we can find the top 3 high-earner employees. This can be done by the following SQL query: select emp1.Name as 'Employee', emp1.Salary\nfrom Employee emp1\nwhere 3 >\n(\n    select count(distinct emp2.Salary)\n    from Employee emp2\n    where emp2.Salary > emp1.Salary\n); select emp1.Name as 'Employee', emp1.Salary\nfrom Employee emp1\nwhere 3 >\n(\n    select count(distinct emp2.Salary)\n    from Employee emp2\n    where emp2.Salary > emp1.Salary\n); select as 'Employee' from where 3 > select count distinct from where > Here, we have created two aliases for the Employee table. For every tuple of the emp1 alias, we compare it with all the distinct salaries to find out how many salaries are less than it. If the number is less than 3, it falls into our answer set. Next, we need to join the Employee table with the Department table in order to obtain the high-earner employees department-wise. For this, we run the following SQL command: SELECT\n    d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary\nFROM\n    Employee e1\n        JOIN\n    Department d ON e1.DepartmentId = d.Id\nWHERE\n    3 > (SELECT\n            COUNT(DISTINCT e2.Salary)\n        FROM\n            Employee e2\n        WHERE\n            e2.Salary > e1.Salary\n                AND e1.DepartmentId = e2.DepartmentId\n        ); SELECT\n    d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary\nFROM\n    Employee e1\n        JOIN\n    Department d ON e1.DepartmentId = d.Id\nWHERE\n    3 > (SELECT\n            COUNT(DISTINCT e2.Salary)\n        FROM\n            Employee e2\n        WHERE\n            e2.Salary > e1.Salary\n                AND e1.DepartmentId = e2.DepartmentId\n        ); SELECT AS 'Department' AS 'Employee' FROM JOIN ON = WHERE 3 > SELECT COUNT DISTINCT FROM WHERE > AND = Here, we join the Employee table and the Department table based on the department ids in both tables. Also, while finding out the high-earner employees for a specific department, we compare the department ids of the employees as well to ensure that they belong to the same department. Approach 2: Approach 2: In this approach, we use the concept of the DENSE_RANK function in SQL. We use the DENSE_RANK function and not the RANK function since we do not want the ranking number to be skipped. The SQL query using this approach can be written as follows: SELECT Final.Department, Final.Employee, Final.Salary FROM\n    (SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\n            DENSE_RANK() OVER (PARTITION BY D.name ORDER BY E.salary DESC) Rank\n    FROM Employee E, Department D\n    WHERE E.departmentId = D.id) Final\nWHERE Final.Rank < 4; SELECT Final.Department, Final.Employee, Final.Salary FROM\n    (SELECT D.name AS Department, E.name AS Employee, E.salary AS Salary,\n            DENSE_RANK() OVER (PARTITION BY D.name ORDER BY E.salary DESC) Rank\n    FROM Employee E, Department D\n    WHERE E.departmentId = D.id) Final\nWHERE Final.Rank < 4; SELECT FROM SELECT AS AS AS DENSE_RANK OVER PARTITION BY ORDER BY DESC FROM WHERE = Final WHERE < 4 Here, we first run a subquery where we partition the tuples by their department and rank them according to the decreasing order of the salaries of the employees. Next, we select those tuples from this set, whose rank is less than 4.",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "4. Given the following schema:",
        "answer": "Table: Stadium Column Name type\nid int\ndate_visited date\ncount_people int Column Name type\nid int\ndate_visited date\ncount_people int Column Name type\nid int\ndate_visited date\ncount_people int Column Name type Column Name type id int id int date_visited date date_visited date count_people int count_people int date_visited is the primary key for this table. The visit date, the stadium visit ID, and the total number of visitors are listed in each row of this table. No two rows will share the same visit date, and the dates get older as the id gets bigger. Construct a SQL query to display records that have three or more rows of consecutive ids and a total number of people higher than or equal to 100. Return the result table in ascending order by visit date. Example: Input:  Stadium table: id date_visited count_people\n1 2022-03-01 6\n2 2022-03-02 102\n3 2022-03-03 135\n4 2022-03-04 90\n5 2022-03-05 123\n6 2022-03-06 115\n7 2022-03-07 101\n8 2022-03-09 235 id date_visited count_people\n1 2022-03-01 6\n2 2022-03-02 102\n3 2022-03-03 135\n4 2022-03-04 90\n5 2022-03-05 123\n6 2022-03-06 115\n7 2022-03-07 101\n8 2022-03-09 235 id date_visited count_people\n1 2022-03-01 6\n2 2022-03-02 102\n3 2022-03-03 135\n4 2022-03-04 90\n5 2022-03-05 123\n6 2022-03-06 115\n7 2022-03-07 101\n8 2022-03-09 235 id date_visited count_people id date_visited count_people 1 2022-03-01 6 1 2022-03-01 6 2 2022-03-02 102 2 2022-03-02 102 3 2022-03-03 135 3 2022-03-03 135 4 2022-03-04 90 4 2022-03-04 90 5 2022-03-05 123 5 2022-03-05 123 6 2022-03-06 115 6 2022-03-06 115 7 2022-03-07 101 7 2022-03-07 101 8 2022-03-09 235 8 2022-03-09 235 Output: id date_visited count_people\n5 2022-03-05 123\n6 2022-03-06 115\n7 2022-03-07 101\n8 2022-03-09 235 id date_visited count_people\n5 2022-03-05 123\n6 2022-03-06 115\n7 2022-03-07 101\n8 2022-03-09 235 id date_visited count_people\n5 2022-03-05 123\n6 2022-03-06 115\n7 2022-03-07 101\n8 2022-03-09 235 id date_visited count_people id date_visited count_people 5 2022-03-05 123 5 2022-03-05 123 6 2022-03-06 115 6 2022-03-06 115 7 2022-03-07 101 7 2022-03-07 101 8 2022-03-09 235 8 2022-03-09 235 Explanation: Explanation: The four rows with ids 5, 6, 7, and 8 have consecutive ids and each of them has >= 100 people attended. Note that row 8 was included even though the date_visited was not the next day after row 7. The rows with ids 2 and 3 are not included because we need at least three consecutive ids. Approach 1: Approach 1: Approach 1: In this approach, we first create three aliases of the given table and cross-join all of them. We filter the tuples such that the number of people in each of the alias’ should be greater than or equal to 100. The query for this would be select distinct t1.*\nfrom stadium t1, stadium t2, stadium t3\nwhere t1.count_people >= 100 and t2.count_people >= 100 and t3.count_people >= 100; select distinct t1.*\nfrom stadium t1, stadium t2, stadium t3\nwhere t1.count_people >= 100 and t2.count_people >= 100 and t3.count_people >= 100; select distinct * from where >= 100 and >= 100 and >= 100 Now, we have to check for the condition of consecutive 3 tuples. For this, we compare the ids of the three aliases to check if they form a possible triplet with consecutive ids. We do this by the following query: select t1.*\nfrom stadium t1, stadium t2, stadium t3\nwhere t1.count_people >= 100 and t2.count_people >= 100 and t3.count_people >= 100\nand\n(\n    (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1) \n    or\n    (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1)\n    or\n    (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2)\n); select t1.*\nfrom stadium t1, stadium t2, stadium t3\nwhere t1.count_people >= 100 and t2.count_people >= 100 and t3.count_people >= 100\nand\n(\n    (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1) \n    or\n    (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1)\n    or\n    (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2)\n); select * from where >= 100 and >= 100 and >= 100 and - = 1 and - = 2 and - = 1 or - = 1 and - = 2 and - = 1 or - = 1 and - = 1 and - = 2 The above query may contain duplicate triplets. So we remove them by using the DISTINCT operator. The final query becomes as follows: select distinct t1.*\nfrom stadium t1, stadium t2, stadium t3\nwhere t1.count_people >= 100 and t2.count_people >= 100 and t3.count_people >= 100\nand\n(\n    (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1) \n    or\n    (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1)\n    or\n    (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2)\n)\norder by t1.id; select distinct t1.*\nfrom stadium t1, stadium t2, stadium t3\nwhere t1.count_people >= 100 and t2.count_people >= 100 and t3.count_people >= 100\nand\n(\n    (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1) \n    or\n    (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1)\n    or\n    (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2)\n)\norder by t1.id; select distinct * from where >= 100 and >= 100 and >= 100 and - = 1 and - = 2 and - = 1 or - = 1 and - = 2 and - = 1 or - = 1 and - = 1 and - = 2 order by Approach 2: Approach 2: Approach 2: In this approach, we first filter out all the tuples where the number of people is greater than or equal to 100. Next, for every tuple, we check, if there exist 2 other tuples with ids such that the three ids when grouped together form a consecutive triplet. The SQL query for this approach can be written as follows: with cte as\n(select * from stadium\nwhere count_people >= 100)\n\nselect cte.id, cte.date_visited, cte.count_people\nfrom cte\nwhere\n((cte.id + 1) in (select id from cte)\nand\n(cte.id + 2) in (select id from cte))\n\nor\n((cte.id - 1) in (select id from cte)\nand\n(cte.id - 2) in (select id from cte))\n\nor\n((cte.id + 1) in (select id from cte)\nand\n(cte.id - 1) in (select id from cte)) with cte as\n(select * from stadium\nwhere count_people >= 100)\n\nselect cte.id, cte.date_visited, cte.count_people\nfrom cte\nwhere\n((cte.id + 1) in (select id from cte)\nand\n(cte.id + 2) in (select id from cte))\n\nor\n((cte.id - 1) in (select id from cte)\nand\n(cte.id - 2) in (select id from cte))\n\nor\n((cte.id + 1) in (select id from cte)\nand\n(cte.id - 1) in (select id from cte)) with as select * from where >= 100 select from where + 1 in select from and + 2 in select from or - 1 in select from and - 2 in select from or + 1 in select from and - 1 in select from",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "5. Given the following schema:",
        "answer": "Table: Employee Column Name Type\nid int\ncompany varchar\nsalary int Column Name Type\nid int\ncompany varchar\nsalary int Column Name Type Column Name Type Column Name Type id int\ncompany varchar\nsalary int id int id int company varchar company varchar salary int salary int Here, id is the id of the employee. company is the name of the company he/she is working in. salary is the salary of the employee Construct a SQL query to determine each company's median salary. If you can solve it without utilising any built-in SQL functions, you'll get bonus points. Example: Input: Id Company Salary\n1 Amazon 1100\n2 Amazon 312\n3 Amazon 150\n4 Amazon 1300\n5 Amazon 414\n6 Amazon 700\n7 Microsoft 110\n8 Microsoft 105\n9 Microsoft 470\n10 Microsoft 1500\n11 Microsoft 1100\n12 Microsoft 290\n13 Google 2000\n14 Google 2200\n15 Google 2200\n16 Google 2400\n17 Google 1000 Id Company Salary\n1 Amazon 1100\n2 Amazon 312\n3 Amazon 150\n4 Amazon 1300\n5 Amazon 414\n6 Amazon 700\n7 Microsoft 110\n8 Microsoft 105\n9 Microsoft 470\n10 Microsoft 1500\n11 Microsoft 1100\n12 Microsoft 290\n13 Google 2000\n14 Google 2200\n15 Google 2200\n16 Google 2400\n17 Google 1000 Id Company Salary Id Company Salary Id Company Salary 1 Amazon 1100\n2 Amazon 312\n3 Amazon 150\n4 Amazon 1300\n5 Amazon 414\n6 Amazon 700\n7 Microsoft 110\n8 Microsoft 105\n9 Microsoft 470\n10 Microsoft 1500\n11 Microsoft 1100\n12 Microsoft 290\n13 Google 2000\n14 Google 2200\n15 Google 2200\n16 Google 2400\n17 Google 1000 1 Amazon 1100 1 Amazon 1100 2 Amazon 312 2 Amazon 312 3 Amazon 150 3 Amazon 150 4 Amazon 1300 4 Amazon 1300 5 Amazon 414 5 Amazon 414 6 Amazon 700 6 Amazon 700 7 Microsoft 110 7 Microsoft 110 8 Microsoft 105 8 Microsoft 105 9 Microsoft 470 9 Microsoft 470 10 Microsoft 1500 10 Microsoft 1500 11 Microsoft 1100 11 Microsoft 1100 12 Microsoft 290 12 Microsoft 290 13 Google 2000 13 Google 2000 14 Google 2200 14 Google 2200 15 Google 2200 15 Google 2200 16 Google 2400 16 Google 2400 17 Google 1000 17 Google 1000 Output: Id Company Salary\n5 Amazon 414\n6 Amazon 700\n12 Microsoft 290\n9 Microsoft 470\n14 Google 2200 Id Company Salary\n5 Amazon 414\n6 Amazon 700\n12 Microsoft 290\n9 Microsoft 470\n14 Google 2200 Id Company Salary Id Company Salary Id Company Salary 5 Amazon 414\n6 Amazon 700\n12 Microsoft 290\n9 Microsoft 470\n14 Google 2200 5 Amazon 414 5 Amazon 414 6 Amazon 700 6 Amazon 700 12 Microsoft 290 12 Microsoft 290 9 Microsoft 470 9 Microsoft 470 14 Google 2200 14 Google 2200 Approach 1: Approach 1: Approach 1: In this approach, we have a subquery where we partition the tuples according to the company name and rank the tuples in the increasing order of salary and id. We also find the count of the total number of tuples in each company and then divide it by 2 in order to find the median tuple. After we have this result, we run an outer query to fetch the median salary and the employee id for each of the companies. The SQL query for this can be written as follows: select table.id, table.company, table.salary\nfrom (select id, company, salary, \n      dense_rank() over (partition by company order by salary, id) as Ranking, \n      count(1) over (partition by company) / 2.0 as EmployeeCount\nfrom Employee ) table\nwhere Ranking between EmployeeCount and EmployeeCount + 1; select table.id, table.company, table.salary\nfrom (select id, company, salary, \n      dense_rank() over (partition by company order by salary, id) as Ranking, \n      count(1) over (partition by company) / 2.0 as EmployeeCount\nfrom Employee ) table\nwhere Ranking between EmployeeCount and EmployeeCount + 1; select from select dense_rank over partition by order by as count 1 over partition by / 2.0 as from table where between and + 1 Additional Resources SQL Programming\nSQL Cheat Sheet\nSQL Commands\n10 Best SQL Books\nSQL MCQ With Answers\nSQL Server Interview Questions and Answers\nDBMS Interview Questions and Answers\nSQL Joins Interview Questions and Answers SQL Programming SQL Programming SQL Cheat Sheet SQL Cheat Sheet SQL Commands SQL Commands 10 Best SQL Books 10 Best SQL Books SQL MCQ With Answers SQL MCQ With Answers SQL Server Interview Questions and Answers SQL Server Interview Questions and Answers DBMS Interview Questions and Answers DBMS Interview Questions and Answers SQL Joins Interview Questions and Answers SQL Joins Interview Questions and Answers",
        "reference": "interviewbit.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax to Create a Table in SQL:\nCREATE TABLE table_name  \n(  \ncolumn_Name1 data type (size of the column),    \ncolumn_Name2 data type (size of the column),    \ncolumn_Name3 data type (size of the column),    \n...    \ncolumn_NameN data type (size of the column)  \n);    \nWe can create a table using Create Table keyword. This keyword creates only one table at a time.\nExamples:\nExample 1:\nThe following example creates the Student table:\nADVERTISEMENT\nCREATE TABLE Student  \n(  \nStudent_ID int,  \nStu_Name varchar (25),    \nStu_Subject_ID varchar (10),    \nStu_Marks int,  \nStu_Age int  \n);    \nExample 2:\nThe following example creates the Subject table:\nCREATE TABLE Subject  \n(  \nSubject_ID varchar (10),    \nSubject_Name varchar (30),    \n);",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax to insert data into a table:\nINSERT INTO Table_Name VALUES (value_1, value_2, value_3, ...., value_N);    \nWe can easily insert the record using the INSERT statement in SQL.\nExamples:\nExample 1:\nThe following queries insert the data of students into Student table:\nINSERT INTO Student VALUES (101, Akhil, BCA101, 85, 20);    \nINSERT INTO Student VALUES (102, Balram, BCA104, 78, 19);  \nINSERT INTO Student VALUES (103, Bheem, BCA102, 80, 22);  \nINSERT INTO Student VALUES (104, Chetan, BCA103, 95, 20);  \nINSERT INTO Student VALUES (105, Diksha, BCA104, 99, 20);  \nINSERT INTO Student VALUES (106, Raman, BCA105, 88, 19);   \nINSERT INTO Student VALUES (107, Sheetal, BCA103, 98, 22);   \nExample 2:\nThe following query inserts Subject_ID and Subject_Name into the Subject table:\nINSERT INTO Subject VALUES (BCA101, C);  \nINSERT INTO Subject VALUES (BCA102, C++);   \nINSERT INTO Subject VALUES (BCA103, Principle of Management);  \nINSERT INTO Subject VALUES (BCA104, Core Java);  \nINSERT INTO Subject VALUES (BCA105, Math);  \nINSERT INTO Subject VALUES (BCA106, Android);",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax to access specific records from the table:\nSELECT * FROM Table_Name WHERE condition;  \n\nExamples:\nExample 1:\nThe following query shows all the rows of those Students whose age is 20:\nSELECT * FROM Student WHERE Stu_Age = 20;  \nThe WHERE clause in this query shows only those rows which satisfy the specified condition.\nOutput:\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n101 Akhil BCA101 85 20\n104 Chetan BCA103 95 20\n105 Diksha BCA104 99 20\nExample 2: The following query shows the Subject_Name of those subjects whose Subject_ID is BCA103 and BCA106:\nSELECT * FROM Student WHERE Subject_ID = 'BCA103' and Subject_ID = 'BCA106' ;  \n\nThe WHERE clause in this query shows only those rows which satisfy the specified condition.\nOutput:\nSubject_ID Subject_Name\nBCA103 Principle of Management\nBCA106 Android",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 4: Write a query in SQL to find the minimum and maximum number from the integer column:",
        "answer": "Sol:\nSyntax to find the maximum and minimum number from the column:\nSELECT MAX(Column_Name), MIN(Column_Name) FROM Table_Name;  \nWe can easily find the maximum and minimum values of any integer column using the MAX and MIN aggregate functions.\nExample:\nThe following query shows the maximum and minimum marks of the Stu_Marks column from the Student table:\nSELECT MAX(Stu_Marks), MIN(Stu_Marks) FROM Student;",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 5: Write a query to access the first record from the SQL table?",
        "answer": "Sol:\nSyntax to find the first record from the table:\nSELECT * FROM Table_Name WHERE Rownum = 1;  \nWe can easily find the first row of any table by assigning 1 to the Rownum keyword in the WHERE clause of the SELECT statement.\nExample:\nThe following query shows the first row of the student table in the output:\nSELECT * FROM Student WHERE Rownum = 1;  \nOutput:\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n101 Akhil BCA101 85 20",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 6: Write a query to access the last record from the table?",
        "answer": "Sol:\nSyntax to find the first record from the table:\nSELECT * FROM Table_Name WHERE Rowid = SELECT MAX(Rowid) from Table_Name;  \nWe can easily find the last row of any table by using the above syntax.\nExample:\nThe following query shows the last row of the student table in the output:\nSELECT * FROM Student WHERE Rowid = SELECT MAX(Rowid) from Student;  \nOutput:\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n107 Sheetal BCA103 98 22",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 7: Write a query to access the first Nth rows from the table?",
        "answer": "Sol:\nSyntax to find the first Nth records from the table:\nSELECT * FROM Table_Name WHERE Rownum < = N ;  \nWe can easily retrieve the first five rows of any table by using the Rownum keyword. We have to use the 'Less than equals to' comparison operator for this operation.\nHere, N defines the number of rows to be shown in the output.\nExample:\nThe following query shows the first five rows of the student table in the output:\nSELECT * FROM Student WHERE Rownum < = 5;  \nOutput:\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n101 Akhil BCA101 85 20\n102 Balram BCA104 78 19\n103 Bheem BCA102 80 22\n104 Chetan BCA103 95 20\n105 Diksha BCA104 99 20",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 8: Write a query to access the last Nth rows from the SQL table?",
        "answer": "Sol:\nSyntax to find the last Nth records from the table:\nSELECT * FROM (SELECT * FROM Table_Name order by Rowid DESC) WHERE Rownum < = N ;  \nWe can easily retrieve the first five rows of any table by using the Rownum keyword.\nExample:\nThe following query shows the last four rows of the Subject table:\nSELECT * FROM (SELECT * FROM Subject order by Rowid DESC) WHERE Rownum < = 4 ;  \nOutput:\nSubject_ID Subject_Name\nBCA103 Principle of Management\nBCA104 Core Java\nBCA105 Math\nBCA106 Android",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 9: Write a query in SQL to retrieve only even rows from the table?",
        "answer": "Sol:\nSyntax to find the Even rows from the table:\nSELECT * FROM Table_Name WHERE MOD (Rowid,2) = 0 ;  \nWe can easily retrieve the even rows from the table by using the MOD function in the WHERE clause of the SELECT statement.\nExample:\nThe following query shows even rows of student table in the result:\nSELECT * FROM Student WHERE MOD (Rowid,2) = 0 ;  \nOutput:\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n102 Balram BCA104 78 19\n104 Chetan BCA103 95 20\n106 Raman BCA105 88 19",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 10: Write a query in SQL to retrieve only an odd number of rows from the table?",
        "answer": "Sol:\nSyntax to find the Odd number of rows from the table:\nSELECT * FROM Table_Name WHERE MOD (Rowid,2) = 1 ;  \nWe can easily retrieve the odd rows from the table by using the MOD function in the WHERE clause of the SELECT statement.\nExample:\nThe following query shows odd rows of Student table in the result:\nSELECT * FROM Student WHERE MOD (Rowid,2) = 1 ;  \nOutput:\n\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n101 Akhil BCA101 85 20\n103 Bheem BCA102 80 22\n105 Diksha BCA104 99 20\n107 Sheetal BCA103 98 22",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax:\nCREATE TABLE New_Table_Name SELECT * FROM Existing_Table_Name;  \nExample: The following query creates Student_Marks table from the existing Student table:\nCREATE TABLE Student_Marks SELECT * FROM Student;",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax:\nSELECT TOP 1 Column_Name  \nFROM (  \nSELECT DISTINCT TOP N Column_Name  \nFROM Table_Name  \nORDER BY Column_Name DESC  \n)  \nORDER BY Column_Name ASC;  \nExample:\nThe following query shows the 3rd highest marks from the Student table:\nSELECT TOP 1 Stu_Marks  \nFROM (  \nSELECT DISTINCT TOP N Stu_Marks  \nFROM Student  \nORDER BY Stu_Marks DESC  \n)  \nORDER BY Stu_Marks ASC;",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 13: Write a query in SQL to find the second-highest value of an integer column from the table?",
        "answer": "Sol:\nSyntax to find the second highest value of the integer column:\nSelect MAX(Column_Name) from Table_Name   \nwhere Column_Name NOT IN (Select MAX(Column_Name) from Table_Name);  \nExample:\nThe following query shows the second-highest marks from the student table:\nSelect MAX(Stu_Marks) from Student   \nwhere Stu_Marks NOT IN (Select MAX(Stu_Marks) from Student);",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSELECT GETDATE();",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax:\nSELECT (Column_Name) FROM (SELECT DISTINCT Column_Name from Table_Name ORDER BY Column_Name DESC) WHERE ROWNUM<=3;  \nExample:\nThe following query shows the record of the three highest marks from the student table:\nSELECT (Stu_Marks) FROM (SELECT DISTINCT Stu_Marks from Student ORDER BY Stu_Marks DESC) WHERE ROWNUM<=3;  \nOutput:\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n105 Diksha BCA104 99 20\n107 Sheetal BCA103 98 22\n104 Chetan BCA103 95 20",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nFor this operation, you have to use the WHERE clause in the SELECT statement.\nSELECT Stu_Name, Stu_Marks FROM Student WHERE Stu_Age = 20;  \nOutput:\nStu_Name Stu_Marks\nAkhil 85\nChetan 95\nDiksha 99",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nFor this operation, you need to use the MAX function with the GROUP BY statement.\nSelect Student_ID, Stu_Subject_ID, MAX(Stu_Marks) from Student group by Stu_Subject_ID;  \nOutput:\nStudent_ID Stu_Subject_ID MAX(Stu_Marks)\n101 BCA101 85\n105 BCA104 99\n103 BCA102 80\n107 BCA103 98\n106 BCA105 88",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 18: Write a query to show all the record of those students whose Marks is greater than 82 and age is 22",
        "answer": "Sol:\nHere, you have to use the AND operator between the two conditions in the WHERE clause. The AND operator returns those records which match the specified conditions.\nSELECT * FROM Student WHERE Stu_Marks > 82 and Stu_Age = 22;  \nOutput:\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n107 Sheetal BCA103 98 22",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nHere, you have to use the LIKE operator, which matches the given pattern in the table.\nSELECT * FROM Student WHERE Stu_Name LIKE '%m';  \nOutput:\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n102 Balram BCA104 78 19\n103 Bheem BCA102 80 22",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol: The following query uses the GROUP BY statement with the COUNT function, which returns the number of students in each subject.\nSELECT Stu_Subject_ID COUNT(Stu_Subject_ID) as 'Number of Students' FROM Student GROUP BY Stu_Subject_ID ;  \nOutput:\nStu_Subject_ID Number of Students\nBCA101 1\nBCA104 2\nBCA102 1\nBCA103 2\nBCA105 1",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nThe following query uses the UPPER function with that column name whose values are to be shown in upper case:\nSELECT UPPER(Stu_Name) from Student;",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 22: Write an SQL query to show the unique values of Stu_Age from the student table:",
        "answer": "Sol:\nThe following query uses the SQL DISTINCT function with the Stu_Age column:\nSELECT DISTINCT(Stu_Age) from Student;",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax:\nSELECT SUBSTRING(Column_Name, 1, N) from Table_Name;  \nThis syntax uses the SUBSTRING function, which shows the specific characters of the string.\nExample:\nThe following query shows the first two characters of Stu_Name from the Student table:\nSELECT SUBSTRING(Stu_Name, 1, 2) from Student;",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nHere, we have to use the ORDER BY clause, which shows the student details in the descending order of Stu_Name:\nSELECT * FROM Student ORDER BY Stu_Name DESC;  \nOutput:\nStudent_ID Stu_Name Stu_Subject_ID Stu_Marks Stu_Age\n107 Sheetal BCA103 98 22\n106 Raman BCA105 88 19\n105 Diksha BCA104 99 20\n104 Chetan BCA103 95 20\n103 Bheem BCA102 80 22\n102 Balram BCA104 78 19\n101 Akhil BCA101 85 20",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax:\nSELECT * FROM Table_Name1 MINUS SELECT * FROM Table_Name2;  \nThis syntax uses the SQL MINUS operator, which shows the values of Table1 that does not exist in Table2.\nExample: Let's take another table, Student2, consisting of 3 columns Bus_ID, Stu_Name, and Stu_Address.\nBus_ID Stu_Name Stu_Subject_ID\n1 Ramesh BCA101\n6 Chetan BCA103\n5 Akhil BCA101\n4 Bhanu BCA103\n3 Balram BCA104\n2 Ram BCA105\nThe following query shows only those rows of Stu_Name and Stu_Subject_ID of student table which does not exist in Student2 table:\nOutput:\nSELECT Stu_Name, Stu_Subject_ID from Student \nMINUS \nSELECT Stu_Name, Stu_Subject_ID from Student2;   \nOutput:\nStu_Name Stu_Subject_ID\nBheem BCA102\nDiksha BCA104\nRaman BCA105\nSheetal BCA103",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax:\nSELECT DISTINCT Column_Name FROM Table_Name a WHERE 3 <= (SELECT COUNT(DISTINCT Column_Name) FROM Table_Name b WHERE a. Column_Name <= b.Column_Name ) ORDER BY a. Column_Name DESC;  \nExample:\nThe following query shows the three minimum marks from the student table:\nSELECT DISTINCT Stu_Marks FROM Student a WHERE 3 <= (SELECT COUNT(DISTINCT Stu_Marks) FROM Student b WHERE a. Stu_Marks <= b.Stu_Marks ) ORDER BY a.Stu_Marks DESC;",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nSyntax:\nSELECT AVG (Column_Name) FROM Table_Name;  \nExample:\nThe following query finds the average of marks of Student table:\nSELECT AVG (Stu_Marks ) FROM Student;",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 28: Write a query to create a View in Structured Query Language,",
        "answer": "Sol:\nSyntax:\nCREATE VIEW View_Name AS SELECT Column_Name1, Column_Name2, ..... FROM Table_Name WHERE Condition;  \nFor Creating a View in SQL, we have to use the Create View statement with the SELECT statement.    \nExample:\nThe following query creates the View of those students whose Marks is greater than 85 from the Student table:\nCREATE VIEW Student_Age AS SELECT Stu_Name, Stu_Age FROM Student WHERE Stu_Marks < 85;  \nYou can see the view table by using the following query:\nSELECT * FROM Student_Age;  \nOutput:\nStu_Name Stu_Age\nChetan 20\nDiksha 20\nSheetal 22",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "Query 29: Write a Query to add another column in the existing table:",
        "answer": "Sol:\nSyntax:\nALTER TABLE Table_Name ADD Column_Name Datatype ( Length_of_Column) ;  \nIf you want to add another column or field to the existing table, you must use the ALTER statement in SQL.\nExample:\nThe following query adds the Stu_Address column to the existing Student table:\nALTER TABLE Student ADD Stu_Addressvarchar (25) ;",
        "reference": "javatpoint.com",
        "role": "sql-query"
    },
    {
        "question": "",
        "answer": "Sol:\nThe following query converts the floating-point value into the integer type.\nSELECT CONVERT (int, 3025.58);",
        "reference": "javatpoint.com",
        "role": "sql-query"
    }
]