[
    {
        "question": "1. What is Database Testing?",
        "answer": "Database testing is the process of examining the data stored in a database as well as assessing the functionality and components that control the database entities, such as tables, stored procedures, views, triggers, and functions. \nDatabase testing is a crucial quality assurance process that verifies the accuracy, integrity, and performance of a database system. It involves validating data retrieval, modification, and storage operations. For example, in a relational database, foreign key implementation ensures referential integrity by linking tables through a shared key, preventing inconsistent or orphaned data entries.\nData Validity Testing: This type of testing requires familiarity with SQL queries to retrieve and validate data from the database.\nData Integrity Testing: Testers evaluate data against imposed limitations and database integrity requirements to ensure data integrity.\nDatabase Performance Testing: Testers assess the performance of triggers, indices, and processes to determine their efficiency. The system should be able to handle database transactions effectively. A solid understanding of database structures is necessary for this type of testing.\nValidation of Logic: This involves verifying the logic associated with triggers, functions, and procedures present in the database.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "2.What do you understand about data-driven testing?",
        "answer": "Data-driven testing is a software testing methodology where test scenarios are executed using various external data sets. It aims to validate application functionality across multiple data inputs, enhancing test coverage and efficiency. For instance, in a database system, foreign key implementation ensures data integrity by linking a column in one table with the primary key of another table, preventing inconsistent or invalid data entries.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "3. Mention some DML commands.",
        "answer": "Data Manipulation Language (DML) commands are used to insert, update, delete, and select data from a database. The most common DML commands are as follows:\nSELECT: Retrieves data from a database.\nSyntax: SELECT column1, column2 FROM table_name WHERE condition;\nExample: SELECT student_name, score FROM exam_results WHERE score > 90;\nINSERT: Adds new records to a table.\nSyntax: INSERT INTO table_name (column1, column2) VALUES (value1, value2);\nExample: INSERT INTO employees (emp_id, emp_name) VALUES (101, ‘John Smith’);\nUPDATE: Modifies existing records.\nSyntax: UPDATE table_name SET column1 = value1 WHERE condition;\nExample: UPDATE products SET price = 25 WHERE product_id = 123;\nDELETE: Removes records from a table.\nSyntax: DELETE FROM table_name WHERE condition;\nExample: DELETE FROM customers WHERE customer_id = 456;",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "4. What is SQL?",
        "answer": "Structured query language (SQL) is a standardized domain-specific language used for managing relational databases. Its primary purpose is to retrieve, manipulate, and manage data stored in relational database management systems (RDBMS). It was introduced in 1974 by IBM’s Donald D. Chamberlin and Raymond F. Boyce. SQL is now maintained by the American National Standards Institute (ANSI) and the International Organization for Standardization (ISO).",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "5. Name some types of database testing techniques.",
        "answer": "Here are the major types of database testing techniques:\nStructural Testing: This type of testing verifies the structure of the database, such as the tables, columns, and relationships.\nFunctional Testing: Functional testing verifies the functionality of the database, such as the ability to insert, update, delete, and query data.\nNon-Functional Testing: It verifies the non-functional aspects of the database, such as performance, scalability, and security.\nSecurity Testing: This type of testing verifies the security of the database against unauthorized access, modification, or destruction of data.\nRecovery Testing: This type of testing technique verifies the ability of the database to recover from failures, such as hardware failures or software errors.\nGet 100% Hike!\nMaster Most in Demand Skills Now!\nBy providing your contact details, you agree to our Terms of Use & Privacy Policy",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "6. What are white box testing and black box testing?",
        "answer": "White box testing is a method where internal code structures, logic, and algorithms are analyzed to identify errors. An example is reviewing the source code of a software application to find bugs. Black box testing evaluates the functionality of the software without inspecting its internal code; for instance, testing a website’s user interface by interacting with it without knowledge of the underlying code.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "7. Explain the relationship between data validation and database testing.",
        "answer": "Database testing and data validation are interrelated processes in software quality assurance. Database testing involves verifying the accuracy and reliability of data stored in a database, ensuring it conforms to defined rules and structures; for example, checking that a customer’s birthdate is within a valid range.\nData validation, on the other hand, focuses on input data before it enters the database, ensuring it meets predefined criteria; for instance, validating that an email address provided during registration follows the correct format. Both processes collectively ensure data integrity and consistency in software applications.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "8. Name some common types of database testing techniques.",
        "answer": "Common types of database testing techniques include data validity testing, data integrity testing, database performance testing, database security testing, database recovery testing, database migration testing, database scalability testing, database usability testing, stored procedure testing, and database integration testing.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "9. Discuss the role of data masking in database testing and data security.",
        "answer": "Data masking plays a pivotal role in both database testing and data security. It involves the encryption of sensitive data within databases, thereby ensuring confidentiality during testing processes. This practice makes sure that real data remains confidential, minimizing security risks. Also, data masking aids in compliance with data protection regulations and provides overall data security measures, assuring data integrity and trustworthiness in database environments.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "10. Explain the concept of database migration testing.",
        "answer": "migration testing involves validating the successful migration of data from one database system to another, ensuring data integrity and compatibility. It ensures that the data remains intact, accurately transferred, and usable in the target database.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "11. Discuss the role of database triggers in maintaining data consistency and how they can be tested.",
        "answer": "Database triggers play a crucial role in maintaining data consistency by automating actions when specific events occur, ensuring data integrity, and enforcing business rules. To test them, one can employ unit testing frameworks to verify trigger functionality, assessing responses to various input scenarios. Triggers can be tested using unit testing, integration testing, and system testing. For instance, consider a trigger that updates inventory levels when a sale is recorded in an e-commerce system, guaranteeing real-time accuracy in stock information.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "12. Explain the concept of database partitioning and its relevance in testing.",
        "answer": "Database partitioning is a technique that divides a database into smaller, more manageable pieces. This can be done for a variety of reasons, such as performance, scalability, or security.\nIn testing, database partitioning can be used for the following:\nImprove Performance: By dividing the database into smaller pieces, queries can be executed more quickly. This is because the database server does not have to scan the entire database for each query.\nImprove Scalability: By dividing the database into smaller modules, it can be scaled out to more servers. This can help handle increased traffic or workload.\nImprove Security: By dividing the database into smaller pieces, it can be easier to control access to sensitive data.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "13 Describe the concept of database normalization and its importance in testing.",
        "answer": "Database normalization is the process of organizing data in a database to reduce redundancy and improve data integrity. It is a fundamental concept in database design and is important for both performance and testing.\nThere are three main levels of database normalization:\nFirst Normal Form (1NF): Thisis the most basic level of normalization and requires that each table in the database have a primary key. The primary key is a unique identifier for each row in the table.\nSecond Normal Form (2NF): 2NF requires that each non-primary key column in a table be dependent on the primary key. This means that each column in the table must contain data that is unique to the row.\nThird Normal Form (3NF):This level of normalization requires that each non-primary key column in a table be independent of all other non-primary key columns. This means that each column in the table must contain data that is unique to the row and is not dependent on any other column in the table.\nBoyce-Codd Normal Form (BCNF)is a database normalization concept that ensures the elimination of partial dependencies in relational databases. It enforces stricter criteria for table design, preventing data redundancy and anomalies. BCNF is vital for maintaining data integrity and efficient query performance in relational database systems.\n\nIntermediate Database Testing Interview Questions\nHere are some of the frequently asked database interview questions for testing",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "14. How do you test database triggers and procedures?",
        "answer": "To assess database procedures and triggers, it is crucial to have knowledge of input and output parameters. The ‘EXEC’ statement facilitates the execution of procedures, allowing examination of table behaviors. Follow these steps:\nOpen the database project in the Solution Explorer\nAccess the database schema via the ‘View’ menu\nNavigate to the project folder from the schema view\nRight-click on the object requiring testing and select ‘Create Unit Tests’\nCreate a new language test project\nChoose either a) Insert the unit test or b) Create a new test and click ‘OK’\nConfigure the project using the Project Configuration dialog box\nConfirm the configuration and click ‘OK’ to proceed.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "15. What are Acid Properties?",
        "answer": "ACID stands for Atomicity, Consistency, Isolation, and Durability.\nAtomicity ensures that a transaction is treated as a single, indivisible unit of work. Either all the operations within the transaction are completed successfully, or none of them are.\nConsistency ensures that the database remains in a consistent state before and after a transaction is executed.\nIsolation ensures that concurrent transactions do not interfere with each other.\nDurability ensures that the results of a transaction are not lost even if there is a system failure.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "16. How is database testing different from front-end testing ?",
        "answer": "Here are the differences between database testing and front-end testing:\nParameters Database Testing Front-End Testing\nFocus Evaluates the database and data-related processes like data retrieval, storage, and manipulation Concentrates on the user interface, assessing the visual and interactive aspects of the application\nPurpose Ensures data accuracy, integrity, and consistency within the database Verifies user experience, usability, and functionality from a user’s perspective\nTesting Tools Utilizes database-specific tools like SQL queries, data comparison tools, and ETL testing tools Employs automation frameworks like Selenium, Cypress, or manual testing for UI interactions\nScope Involves testing data validation, data migration, and database performance Encompasses UI functionality, layout, navigation, responsiveness, and browser compatibility\nDependencies Dependent on the state of the database and the data being processed Independent of the database; primarily relies on the application’s graphical user interface\nExample Scenario Verifying that data is correctly inserted into the database after a user submits a form Ensuring that buttons, links, and forms on a website work as expected, and that the interface is visually appealing.\nHave a look at our interview questions for job preparation on Top ETL Testing Interview Questions!",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "17. Mention some database testing tools.",
        "answer": "Below are the major database testing tools:\nDBUnit is a Java-based tool that helps with setting up test data and verifying database results. It can be used with a variety of databases, including MySQL, Oracle, and Microsoft SQL Server.\nApache JMeter is an open-source tool that can be used for load testing, performance testing, and functional testing of databases. It can be used to simulate a large number of users accessing the database simultaneously.\nSQL Power Architect is a commercial tool that provides a graphical user interface for creating and managing test cases for databases. It also includes a number of features for automating the testing process.\nToad for Oracle is a commercial tool that provides a comprehensive set of features for testing Oracle databases. It includes features for creating and managing test cases, executing test cases, and analyzing test results.\nTestComplete is a commercial tool that can be used for testing a variety of software applications, including databases. It includes features for creating and managing test cases, executing test cases, and analyzing test results.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "18. Why are SQL constraints used in a database?",
        "answer": "SQL constraints are essential in databases to maintain data integrity and enforce data quality standards. They ensure that data entered into tables sticks to predefined rules, preventing erroneous or inconsistent information. For instance, a ‘UNIQUE’ constraint ensures that a column contains only unique values, preventing duplicate entries and maintaining the accuracy of the database. This enhances data reliability and overall database performance.\nThere are many different types of SQL constraints, including:\nNOT NULL constraints: These constraints ensure that a column cannot contain a NULL value.\nUNIQUE constraints: These constraints ensure that each row in a table has a unique value in a particular column.\nCHECK constraints: These constraints allow you to specify a condition that the data in a column must meet.\nFOREIGN KEY constraints: These constraints ensure that the value in a column refers to a valid value in another table.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "19. What are CRUD operations?",
        "answer": "CRUD stands for Create, Read, Update, and Delete. These are the four basic operations that are performed on data in a database.\nCreate is the operation of adding new data to the database.\nRead is the operation of retrieving data from the database.\nUpdate is the operation of modifying existing data in the database.\nDelete is the operation of removing data from the database.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "20. What are joins, and what are the different types of joins?",
        "answer": "Joins in database management are operations that combine data from multiple tables based on specified conditions. Different types of joins include:\nINNER JOIN: Retrieves matching records from both tables.\nSyntax: SELECT * FROM tableone INNER JOIN tabletwoON column = tabletwo.column;\nExample: SELECT orders.order_id, customers.customer_name FROM orders INNER JOIN customers ON orders.customer_id = customers.customer_id;\nLEFT JOIN (or LEFT OUTER JOIN): Retrieves allrecords from the left table and matching records from the right table.\nSyntax: SELECT * FROM tableone LEFT JOIN tabletwoON column = tabletwo.column;\nExample: SELECT employees.employee_id, departments.department_name FROM employees LEFT JOIN departments ON employees.department_id = departments.department_id;\nRIGHT JOIN (or RIGHT OUTER JOIN): Retrieves all records from the right table and matching records from the left table.\nSyntax: SELECT * FROM tableone RIGHT JOIN tabletwoON column = tabletwo.column;\nExample: SELECT products.product_name, orders.order_date FROM products RIGHT JOIN orders ON products.product_id = orders.product_id;\nFULL JOIN (or FULL OUTER JOIN): Retrievesall records when there is a match in either the left or right table.\nSyntax: SELECT * FROM tableone FULL JOIN tabletwoON column = tabletwo.column;\nExample: SELECT customers.customer_name, orders.order_id FROM customers FULL JOIN orders ON customers.customer_id = orders.customer_id;\nSELF JOIN: Joins a table to itself;typically used to retrieve hierarchical data.\nSyntax: SELECT * FROM tableone t1, tableone t2 WHERE t1.column = t2.column;\nExample: SELECT e1.employee_name, e2.manager_name FROM employees e1, employees e2 WHERE e1.manager_id = e2.employee_id;",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "● 21. How can data anomalies such as duplicates, null values, or outliers be identified in database testing?",
        "answer": "Data anomalies such as duplicates, null values, or outliers can be identified in database testing using a variety of methods, including:\nData Profiling:Data profiling is the process of collecting and analyzing data to understand its characteristics. This can be done using a variety of tools, such as database discovery tools, data quality tools, and data mining tools. Data profiling can be used to identify data anomalies by looking for data that is out of range, inconsistent, or missing.\nData Analysis: Data analysis involves examining, purifying, modifying, and shaping data to uncover valuable insights, inform conclusions, and aid in decision-making.Data analysis can be used to identify data anomalies by looking for data that does not fit the expected patterns.\nData Visualization:Data visualization is the process of transforming data into a visual format that can be easily understood. Data visualization can be used to identify data anomalies by looking for data that stands out from the rest.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "22. What is meant by database schema validation, and how is it performed?",
        "answer": "Database schema validation is the process of checking whether a database schema conforms to a set of rules. This can be done manually or automatically. Schema validation can be performed on a regular basis to help ensure the integrity of the database.\nHere are some of the benefits of performing database schema validation:\nData Integrity: Schema validation can help ensure that the data in your database is accurate and consistent.\nPerformance: Schema validation can help improve the performance of your database by preventing errors that can slow down queries.\nSecurity: Schema validation can help improve the security of your database by preventing unauthorized users from accessing or modifying data.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "23. How can performance bottlenecks in database queries be identified and optimized?",
        "answer": "Performance bottlenecks in database queries can be identified and optimized by using a variety of tools and techniques. Some of the most common methods include:\nQuery Profiling: This involves running a query and collecting statistics about its performance, such as the amount of time it takes to execute, the number of rows it returns, and the amount of memory it uses. This information can be used to identify the areas where the query performs poorly and to make changes to improve its performance.\nIndexing: This involves creating indexes on tables to improve the performance of queries that access specific columns or ranges of data. Indexes can help speed up queries by reducing the amount of data that needs to be scanned.\nRewriting Queries: This involves changing the structure of a query to improve its performance. For example, a query that joins two tables can often be rewritten to use a single table, which can improve performance.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "24. What do you mean by data redundancy?",
        "answer": "Data redundancy refers to the storage of the same data in multiple places within a database or data storage system. This can occur accidentally but is also done deliberately for backup and recovery purposes.\nAccidental data redundancy can happen when data is entered into multiple systems or databases without being properly synchronized. This can lead to inconsistencies and errors in the data, as well as making it difficult to keep track of changes.\nDeliberate data redundancy is often used as a way to improve performance and availability. For example, a database may store a copy of its data on a backup server in case the primary server fails. This way, users can still access the data even if the primary server is unavailable.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "25. Explain the importance of database migration testing.",
        "answer": "Data Integrity: Database migration testing ensures that data is accurately and completely transferred without loss or corruption during the migration process. It validates the integrity of migrated data to maintain data consistency and reliability.\nCompatibility: It verifies that the migrated data is compatible with the target database system, including the database schema, data types, constraints, and indexes. This helps avoid any compatibility issues that may arise during the migration.\nFunctionality: Database migration testing ensures that the functionality of the application or system relying on the migrated database remains intact. It verifies that all queries, stored procedures, triggers, and other database-related functionality work as expected in the new environment.\nPerformance: It assesses the performance of the migrated database by executing queries, transactions, and other operations to ensure that the performance is on par with or better than the original database.\n\nAdvanced Database Testing Interview Questions for Experienced\nHere are some frequently asked advanced database testing interview questions and answers:",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "26. What is the QTP testing process, and how do you use SQL queries in QTP?",
        "answer": "QTP (QuickTest Professional) serves as a commercial automation testing tool employed to conduct functional testing on software applications. The QTP testing process typically encompasses these stages:\nRequirement Collection: Initially, the software application’s requirements are gathered.\nTest Case Formulation: After acquiring the requirements, test cases are crafted to validate the application’s functionality.\nScript Creation: The test cases are then developed within QTP, utilizing VBScript or Java.\nData Arrangement: The necessary data for executing the test cases is prepared.\nTest Execution: Subsequently, the test cases are executed against the application.\nReporting: Finally, the outcomes of the test execution are documented and reported.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "27. Can Selenium be used for database testing?",
        "answer": "Selenium can be used for database testing, but it is not a dedicated database testing tool. It can be used to automate queries and verify the results, but it cannot perform more complex database testing tasks such as data validation and security testing.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "28. How is a shared lock different from an exclusive lock?",
        "answer": "A shared lock allows multiple transactions to read a resource simultaneously, while an exclusive lock prevents other transactions from accessing the resource until the lock is released.\nFeature Shared Lock Exclusive Lock\nPermissions Allows multiple transactions to be read Prevents other transactions from accessing\nUse cases Reading data Writing data\nBlocking behavior Blocks only when an exclusive lock is requested. Blocks all other transactions",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "29. What is sStructural database testing?",
        "answer": "Structural database testing is a category of database testing focused on validating the database’s internal structure, including elements like tables, columns, and relationships. This method is considered a white-box testing approach, necessitating a deep understanding of the database schema.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "30. How is stored procedure testing done?",
        "answer": "Stored procedure testing is the process of testing the functionality, performance, and security of stored procedures. It is done by executing the stored procedures with different input data and verifying the results. Stored procedure testing can be done manually or using automated tools.\nThe following are the steps involved in stored procedure testing:\nIdentify the stored procedures that need to be tested\nDevelop test cases for each stored procedure\nExecute the stored procedures with different input data\nVerify the results of the stored procedures\nFix any defects that are found.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "31. What are the different types of database errors?",
        "answer": "Database errors fall into four primary categories: user errors, statement errors, process errors, and media errors.\nUser errors result from user actionslike inputting incorrect data or accidental table deletion.\nStatement errors arise from SQL statement issues, such as syntax or logic errors.\nProcess errors occur due to database process problems, like deadlocks or transaction failures.\nMedia errors stem from physical damage to the database media, such as disk corruption or file loss.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "32. . What does denormalization refer to in the context of a database?",
        "answer": "Denormalization is a strategy in database design where redundant data is intentionally stored within the database to enhance query performance. This approach diverges from the conventional practice of centralizing data in a single normalized table by distributing it across multiple locations.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "33. . How many types of locks are there in a database system?",
        "answer": "There are three main types of locks in a database system: shared locks, exclusive locks, and update locks.\nShared locks allow multiple transactions to read the same data but prevent any transactions from writing to it. This is the most common type of lock.\nExclusive locks prevent any other transactions from accessing the data, whether they want to read or write it. This is used when a transaction needs to update the data.\nUpdate locks are a type of exclusive lock that allows other transactions to read the data but not write to it. This is used when a transaction needs to update the data, but other transactions still need to be able to read it.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "34.. What are the various types of relationships depicted in an ER diagram?",
        "answer": "There are three main types of relationships depicted in an ER diagram:\nOne-to-one:A one-to-one relationship between two entities means that each entity in the first entity can be related to at most one entity in the second entity, and vice versa. For example, a person can have at most one passport, and a passport can be issued to at most one person.\nOne-to-many:A one-to-many relationship between two entities means that each entity in the first entity can be related to zero or more entities in the second entity, but each entity in the second entity can be related to only one entity in the first entity. For example, a customer can place zero or more orders, but each order can be placed by only one customer.\nMany-to-many:A many-to-many relationship between two entities means that each entity in the first entity can be related to zero or more entities in the second entity, and vice versa. For example, a product can be sold in zero or more stores, and each store can sell zero or more products.",
        "reference": "intellipaat.com",
        "role": "database-testing"
    },
    {
        "question": "1. What is Database Testing?",
        "answer": "Database testing is a procedure of validating data stored in a database and its related functionality and objects controlling database entities like tables, stored procedures, views, triggers and functions. This testing is widely used in applications that use databases. With modern technologies and advancements in software development, databases are widely used to store data which is why checking the correctness and quality of data matters. It is divided into 4 categories such as: Data Validity Testing: In this testing, testers need to know SQL queries to retrieve data from the database and validate it.\nData Integrity Testing: Here, the testers need to validate data against various constraints and referential integrity in the database.\nDatabase Performance Testing: Here, the testers need to validate the performance of various triggers, indices, procedures to see how effectively the operations occur. The system also needs to execute database transactions efficiently. Good knowledge of database structures needs to be there while doing this.\nTesting triggers, functions and procedures present in the database to validate the logic associated with them. Data Validity Testing: In this testing, testers need to know SQL queries to retrieve data from the database and validate it. Data Validity Testing: Data Integrity Testing: Here, the testers need to validate data against various constraints and referential integrity in the database. Data Integrity Testing: Database Performance Testing: Here, the testers need to validate the performance of various triggers, indices, procedures to see how effectively the operations occur. The system also needs to execute database transactions efficiently. Good knowledge of database structures needs to be there while doing this. Database Performance Testing: Testing triggers, functions and procedures present in the database to validate the logic associated with them. Testing triggers, functions and procedures",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "2. What do you understand by data-driven testing?",
        "answer": "Data-driven testing is an automation testing framework that involves testing data stored in a spreadsheet or a table and using that stored data as input values to the test scripts. This is done to avoid writing individual test cases of the same functionalities with different inputs. The inputs to the test scripts can be stored in XML, CSV, XLS and other data formats.   There are 4 main types of data-driven testing based on the source of test data inputs: Key-driven: Here, dynamic data is provided as inputs to the test cases by employing a keyboard to retest the application and validate the business logic.\nFlat files: Application retesting is done by taking input data stored in flat files like .doc or .txt.\nFront-end object: The test scripts use data from front-end objects like list, table, menu, data window etc.\nSpreadsheet/Excel: Here, the test data is taken from data stored in excel sheets or spreadsheets. Key-driven: Here, dynamic data is provided as inputs to the test cases by employing a keyboard to retest the application and validate the business logic. Key-driven: Flat files: Application retesting is done by taking input data stored in flat files like .doc or .txt. Flat files: Front-end object: The test scripts use data from front-end objects like list, table, menu, data window etc. Front-end object: Spreadsheet/Excel: Here, the test data is taken from data stored in excel sheets or spreadsheets. Spreadsheet/Excel:",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "3. What do you understand about Trigger Testing?",
        "answer": "Trigger testing involves testing the database triggers that answers the following questions: Are the coding conventions followed while defining and coding the triggers?\nAre the triggers executing the DML transactions successfully by satisfying all conditions?\nAre the triggers updating the data correctly post the execution of queries?\nIs the application functionality working fine post the data updation, insertion or deletion? Are the coding conventions followed while defining and coding the triggers? Are the triggers executing the DML transactions successfully by satisfying all conditions? Are the triggers updating the data correctly post the execution of queries? Is the application functionality working fine post the data updation, insertion or deletion?",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "4. What is Database Stress Testing?",
        "answer": "Database Stress Testing is one of the methods used for gauging the database performance by subjecting it to the heavy load that would potentially cause the system to fail at some point. This is used for identifying the breakdown points of the database application. Before performing this testing, proper planning needs to be done for avoiding the wastage of resources. This testing is also known as fatigue testing. It uses tools like LoadRunner and JMeter for accomplishing this. JMeter",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "5. What do you understand by database transactions?",
        "answer": "A database transaction is defined as a task sequence that is to be performed on the database to achieve the required results logically. The task can include creating, deleting, updating the records in the database tables. The tasks upon successful completion affect the records in the database. A transaction provides 4 controls as listed below: COMMIT: This is used for saving all changes done utilizing the transaction. We generally use this post INSERT, UPDATE, DELETE statements.\nROLLBACK: This is used for rolling back the transaction to the previous state before it was operated. We generally use this post INSERT, UPDATE, DELETE statements.\nSAVEPOINT: This is used for setting the point where the transaction is supposed to roll back.\nSET TRANSACTION: This is used for setting the name of the transaction. COMMIT: This is used for saving all changes done utilizing the transaction. We generally use this post INSERT, UPDATE, DELETE statements. COMMIT: ROLLBACK: This is used for rolling back the transaction to the previous state before it was operated. We generally use this post INSERT, UPDATE, DELETE statements. ROLLBACK: SAVEPOINT: This is used for setting the point where the transaction is supposed to roll back. SAVEPOINT: SET TRANSACTION: This is used for setting the name of the transaction. SET TRANSACTION:",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "6. What do you understand by Keys and indexes Testing?",
        "answer": "The keys and indexes testing in a database is a form of database testing which answers the below questions: Have the required primary keys and foreign keys constraints been created on the targetted tables?\nAre the foreign key references valid?\nIs the data type of the primary key of one table and the corresponding foreign key in the other table the same?\nAre the naming conventions being followed for all indexes and keys?\nAre the lengths and sizes of the required indexes and fields expected?\nAre the indexes clustered or non-clustered working as expected and is according to the business requirements? Have the required primary keys and foreign keys constraints been created on the targetted tables? Are the foreign key references valid? Is the data type of the primary key of one table and the corresponding foreign key in the other table the same? Are the naming conventions being followed for all indexes and keys? Are the lengths and sizes of the required indexes and fields expected? Are the indexes clustered or non-clustered working as expected and is according to the business requirements?",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "7. What do you understand by Non-functional testing in terms of database testing?",
        "answer": "Non-functional testing in terms of testing databases involves various testing methods like stress testing, load testing, usability testing, security testing, etc that tests and validate the non-functional business requirements. It helps in the quantification of risks with regards to the database system in terms of how the system performs under heavy load. It addresses the following questions which help to mitigate the risks if detected earlier: Does the system break?\nDoes the system slow down?\nAre there any risks to the system as the load or stress on the system increases?\nIs the system scalable and usable whenever new business requirements come in? Does the system break? Does the system slow down? Are there any risks to the system as the load or stress on the system increases? Is the system scalable and usable whenever new business requirements come in? Non-functional testing also helps in identifying what are the minimum system requirements to run effectively without any limitations on hardware or software.  ",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "8. What would be the SQL statements used for managing and manipulating the test tables?",
        "answer": "We can use the statements like INSERT, UPDATE, SELECT, DELETE for manipulating the table content. Statements like ALTER TABLE, DELETE TABLE, CREATE TABLE are used for creating and managing the tables.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "9. What do you understand by validation of ACID properties in database testing?",
        "answer": "ACID stands for Atomicity, Consistency, Isolation and Durability. Everything refers to a property of database transactions. Atomicity – This refers to that the transactions are atomic which means that the result of the transaction can either be a success or a failure and nothing in between.\nConsistency – This property implies that the state of the database has to remain valid after the completion of the transactions.\nIsolation – This implies that the presence of multiple transactions does not hinder each other as well as the state of the database.\nDurability – This states that post-commit of a transaction, the data should not be lost even if there is a power failure. Atomicity – This refers to that the transactions are atomic which means that the result of the transaction can either be a success or a failure and nothing in between. Atomicity Consistency – This property implies that the state of the database has to remain valid after the completion of the transactions. Consistency Isolation – This implies that the presence of multiple transactions does not hinder each other as well as the state of the database. Isolation Durability – This states that post-commit of a transaction, the data should not be lost even if there is a power failure. Durability  ",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "10. What do you understand by retesting and how is it different from data-driven testing?",
        "answer": "Retesting refers to the method of executing the same test script using different input data every time. It helps in finding faults in the system when subjected to different inputs. The faults can be fixed and once again the system can be subjected to testing using the same scripts with the same or different inputs to check if it works fine. Retesting is different from data-driven testing. This is because retesting is mostly a manual process that involves using a whole new data input set. Data-driven testing is an automated testing framework that has the test data and the scripts take the data and run it automatically.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "11. Explain with an example how you can test the database manually?",
        "answer": "Database testing can be done manually as well. This requires human effort in observing the behaviour of the application when subjected to different manual test cases drafted by the testers. This can also involve observation of the behaviour in front-end applications when the backend database has changed. We can also manually check whether the record has been created, updated or deleted in the database tables post the execution of the queries. Consider an example of a database system that keeps track of student details. The operations run on the Student tables database can be validated manually by looking at the state of the records post query execution or can be validated in how the front end interface looks like.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "12. How do you validate whether the database table has been updated after you enter data from the front-end application?",
        "answer": "This depends on the front-end application’s interface which is being used. We can test by using the following ways: Check for the updated data in the front-end application’s view. The view should be updated with the new value post successful insertion. This kind of testing constitutes black box testing.\nIf there is no view available, then we can go to the database system, run the select query and check for the data manually.\nWe can also use the WinRunner or QTP for checking the database update. Check for the updated data in the front-end application’s view. The view should be updated with the new value post successful insertion. This kind of testing constitutes black box testing. If there is no view available, then we can go to the database system, run the select query and check for the data manually. We can also use the WinRunner or QTP for checking the database update.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "13. How is stored procedure testing done?",
        "answer": "Stored Procedures are similar to user-defined functions that are invoked using Cal Procedure or Execute Procedure statements. The output of these procedures is generally in the form of result sets. The stored procedures are stored in RDBMS and are readily available for the applications. These can be tested using the following techniques: White box testing: Here, the stubs are used for invoking stored procedures and the results of those are validated against our expected results.\nBlack box testing: We perform operations on the front-end view of our application in a way that the stored procedures are invoked and we validate the result by observing the changes in the view. White box testing: Here, the stubs are used for invoking stored procedures and the results of those are validated against our expected results. Black box testing: We perform operations on the front-end view of our application in a way that the stored procedures are invoked and we validate the result by observing the changes in the view.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "14. How will you know if a trigger is fired or not at the time of database testing?",
        "answer": "To know if a trigger is fired, we will have to enable the audit logs of the table. You can refer to the steps to access logs here. here",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "15. What are the different SQL statements that can be used for database testing?",
        "answer": "Following are the SQL statements categories that can be used in database testing: DDL – Data Definition Language:\nCREATE: Used for creating databases and their objects like tables, views etc.\nALTER: Used for altering the properties of database objects.\nDROP: Used for dropping the database and objects of the database.\nTRUNCATE: Used for removing all records from a table without touching its structure.\nRENAME: Used for renaming the database objects.\nDML – Data Manipulation Language:\nSELECT: Used for selecting specific records or data from the database objects.\nINSERT: Used for inserting new data or records into the database tables.\nUPDATE: Used for updating existing records.\nDELETE: Used for deleting existing records.\nDQL – Data Query Language:\nSELECT queries come under data query language to query the data based on any given conditions.\nDCL – Data Control Language:\nUsed for creating roles, granting permissions and controlling accesses to the database and the objects of the database. The commands that fall under DCL are:\nGRANT: Used for providing the user access permissions.\nDENY: Used for denying the user permissions.\nREVOKE: Used for removing the user access.\nTCL – Transaction Control Language:\nCOMMIT: Used for writing and storing changes to the database.\nROLLBACK: Used for restoring the changes to the database to the last commit. DDL – Data Definition Language:\nCREATE: Used for creating databases and their objects like tables, views etc.\nALTER: Used for altering the properties of database objects.\nDROP: Used for dropping the database and objects of the database.\nTRUNCATE: Used for removing all records from a table without touching its structure.\nRENAME: Used for renaming the database objects. DDL – Data Definition Language: CREATE: Used for creating databases and their objects like tables, views etc.\nALTER: Used for altering the properties of database objects.\nDROP: Used for dropping the database and objects of the database.\nTRUNCATE: Used for removing all records from a table without touching its structure.\nRENAME: Used for renaming the database objects. CREATE: Used for creating databases and their objects like tables, views etc. ALTER: Used for altering the properties of database objects. DROP: Used for dropping the database and objects of the database. TRUNCATE: Used for removing all records from a table without touching its structure. RENAME: Used for renaming the database objects. DML – Data Manipulation Language:\nSELECT: Used for selecting specific records or data from the database objects.\nINSERT: Used for inserting new data or records into the database tables.\nUPDATE: Used for updating existing records.\nDELETE: Used for deleting existing records. DML – Data Manipulation Language: SELECT: Used for selecting specific records or data from the database objects.\nINSERT: Used for inserting new data or records into the database tables.\nUPDATE: Used for updating existing records.\nDELETE: Used for deleting existing records. SELECT: Used for selecting specific records or data from the database objects. INSERT: Used for inserting new data or records into the database tables. UPDATE: Used for updating existing records. DELETE: Used for deleting existing records. DQL – Data Query Language:\nSELECT queries come under data query language to query the data based on any given conditions. DQL – Data Query Language: SELECT queries come under data query language to query the data based on any given conditions. SELECT queries come under data query language to query the data based on any given conditions. DCL – Data Control Language:\nUsed for creating roles, granting permissions and controlling accesses to the database and the objects of the database. The commands that fall under DCL are:\nGRANT: Used for providing the user access permissions.\nDENY: Used for denying the user permissions.\nREVOKE: Used for removing the user access. DCL – Data Control Language: Used for creating roles, granting permissions and controlling accesses to the database and the objects of the database. The commands that fall under DCL are:\nGRANT: Used for providing the user access permissions.\nDENY: Used for denying the user permissions.\nREVOKE: Used for removing the user access. Used for creating roles, granting permissions and controlling accesses to the database and the objects of the database. The commands that fall under DCL are:\nGRANT: Used for providing the user access permissions.\nDENY: Used for denying the user permissions.\nREVOKE: Used for removing the user access. GRANT: Used for providing the user access permissions.\nDENY: Used for denying the user permissions.\nREVOKE: Used for removing the user access. GRANT: Used for providing the user access permissions. DENY: Used for denying the user permissions. REVOKE: Used for removing the user access. TCL – Transaction Control Language:\nCOMMIT: Used for writing and storing changes to the database.\nROLLBACK: Used for restoring the changes to the database to the last commit. TCL – Transaction Control Language: COMMIT: Used for writing and storing changes to the database.\nROLLBACK: Used for restoring the changes to the database to the last commit. COMMIT: Used for writing and storing changes to the database. ROLLBACK: Used for restoring the changes to the database to the last commit.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "1. Why do you think database testing is important in the field of software testing?",
        "answer": "Database testing ensures that the data in the database that is received from various sources are correct and as per the business requirements or not. It helps to analyse the risks associated with incorrect data, protect from data losses due to incorrect transactions and also properly check for unauthorized access to the data. In most of the applications, the User Interface is given the most importance while testing to validate the correctness of the data. But in cases where there is a lack of UI or view, it is very much essential to test the quality of the information in the database. Consider the example of a banking application where lots of users use it to perform transactions. While testing the database, it is very much important to note the following points: Does the application store the relevant transaction information and display the data correctly to the correct user?\nEnsure that information is not lost during the transaction process.\nEnsure that the system doesn’t store partially performed transactions or aborted transactions that are not saved.\nEnsure that only authorized users have access to the relevant information. Does the application store the relevant transaction information and display the data correctly to the correct user? Ensure that information is not lost during the transaction process. Ensure that the system doesn’t store partially performed transactions or aborted transactions that are not saved. Ensure that only authorized users have access to the relevant information. To perform these validations, it is very much needed to possess the art of data testing or database testing.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "2. Write the step-by-step process to test the database?",
        "answer": "The process to perform database testing is very similar to the steps that we follow for testing any other applications. Following are the steps that are followed: Prepare the test environment and test scripts\nRun the script\nCheck for the test results\nValidate the results against the expected results.\nReport the validation findings to the developers and the stakeholders. Prepare the test environment and test scripts Run the script Check for the test results Validate the results against the expected results. Report the validation findings to the developers and the stakeholders.  ",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "3. What is structural database testing?",
        "answer": "This testing involves testing database structures that depend on schema, tables, triggers, functions, procedures and also the servers used for databases. Following are the types of structural testing: Schema Testing: Here, the exact schema name should map between both front-end and backend. The schema validation is very important because in some cases, the schema of the tables would be different from the actual business requirement and the front-end applications. This also involves verifying unmapped tables or views or columns.\nTables Testing: This testing involves testing table names and testing columns. The names mapped to frontend and backend should be the same and the datatype and sizes of the columns should be as per the requirements specified by the business. It also involves testing constraints applied to the tables and columns. Furthermore, testing of indexes based on the property of clustered or non-clustered and their functionality should also be tested accordingly.\nProcedure and Function Testing: Here, the testers have to test the procedures and functions available in the database and validate for the list of points below:\nDid the team follow the business requirements correctly?\nIs the code following good practices and proper naming conventions?\nAre the parameters for input and output of these as per the expected requirements?\nAre the exceptions handled?\nAre the procedures and functions inserting data to required tables properly?\nAre the procedures and functions updating/modifying data in the required tables properly?\nTrigger testing: The testing rules are similar to the procedure or functional testing. In addition to those rules, we have to check if the triggers are getting triggered/executed at required instants.\nDatabase Server Testing: Test whether the database configurations, RAM, capacity of processors, storage capacity etc based on the business requirements. Schema Testing: Here, the exact schema name should map between both front-end and backend. The schema validation is very important because in some cases, the schema of the tables would be different from the actual business requirement and the front-end applications. This also involves verifying unmapped tables or views or columns. Schema Testing: Tables Testing: This testing involves testing table names and testing columns. The names mapped to frontend and backend should be the same and the datatype and sizes of the columns should be as per the requirements specified by the business. It also involves testing constraints applied to the tables and columns. Furthermore, testing of indexes based on the property of clustered or non-clustered and their functionality should also be tested accordingly. Tables Testing: Procedure and Function Testing: Here, the testers have to test the procedures and functions available in the database and validate for the list of points below:\nDid the team follow the business requirements correctly?\nIs the code following good practices and proper naming conventions?\nAre the parameters for input and output of these as per the expected requirements?\nAre the exceptions handled?\nAre the procedures and functions inserting data to required tables properly?\nAre the procedures and functions updating/modifying data in the required tables properly? Procedure and Function Testing: Did the team follow the business requirements correctly?\nIs the code following good practices and proper naming conventions?\nAre the parameters for input and output of these as per the expected requirements?\nAre the exceptions handled?\nAre the procedures and functions inserting data to required tables properly?\nAre the procedures and functions updating/modifying data in the required tables properly? Did the team follow the business requirements correctly? Is the code following good practices and proper naming conventions? Are the parameters for input and output of these as per the expected requirements? Are the exceptions handled? Are the procedures and functions inserting data to required tables properly? Are the procedures and functions updating/modifying data in the required tables properly? Trigger testing: The testing rules are similar to the procedure or functional testing. In addition to those rules, we have to check if the triggers are getting triggered/executed at required instants. Trigger testing: Database Server Testing: Test whether the database configurations, RAM, capacity of processors, storage capacity etc based on the business requirements. Database Server Testing:",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "4. How do you test the database triggers and procedures?",
        "answer": "For testing the database triggers and procedures, it is required to know the input parameters to these functionalities and know what would be the expected output for these. The EXEC statement can be used for determining the behaviour of the tables when the procedures or triggers are run. You can also achieve this by creating SQL unit tests for checking the database objects modified due to the execution of the triggers or procedures. The SQL unit tests follow the 3 rules as shown below:   The test case should check whether the objects exist in the database or not. It should check or validate what the normal outputs would be for success scenarios. It should also check for the behaviour of the system under the influence of negative test cases.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "5. What are the possible test scenarios that need to be tested when a database gets migrated from one SQL server to another?",
        "answer": "Firstly, when migration happens, we need to be aware of all the changes and enhancements are done in the new SQL server. Based on this information, design your test case suite by considering the following points: What is the data type used?\nWhat is the length of the fields used in the server?\nAre the database objects created as expected in the new SQL server?\nPerform stress testing on the new SQL server to identify any risks associated with the migrated environment. What is the data type used? What is the length of the fields used in the server? Are the database objects created as expected in the new SQL server? Perform stress testing on the new SQL server to identify any risks associated with the migrated environment.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "6. Why are SQL constraints used in a database?",
        "answer": "SQL Constraints are used for setting the rules for the records in the database table. If any constraints are not satisfied, then the action can be aborted. The constraints are defined when we create the database objects. It can also be altered by using the ALTER commands. SQL has 6 major constraints, they are: NOT NULL: This constraint is used for specifying that a column cannot have NULL values.\nUNIQUE: This constraint specifies that each column has a unique value, meaning the values are not repeated.\nPRIMARY KEY: This constraint also combines NOT NULL and UNIQUE constraints and indicates that one or more combinations having this key is used for uniquely identifying a record in the database table.\nFOREIGN KEY: It is used for ensuring the referential integrity of that record in the database table. It matches the value of a column in one table with the value defined as the primary key in the other table.\nCHECK: It is used for ensuring whether the column values fulfil given specified conditions.\nDEFAULT: This constraint is used for adding default values to the column whenever needed. If the user specifies any value in the DEFAULT constraint, then at the time of record creation, if we do not specify values to that column, the default value will be saved in the table. NOT NULL: This constraint is used for specifying that a column cannot have NULL values. NOT NULL: UNIQUE: This constraint specifies that each column has a unique value, meaning the values are not repeated. UNIQUE: PRIMARY KEY: This constraint also combines NOT NULL and UNIQUE constraints and indicates that one or more combinations having this key is used for uniquely identifying a record in the database table. PRIMARY KEY: FOREIGN KEY: It is used for ensuring the referential integrity of that record in the database table. It matches the value of a column in one table with the value defined as the primary key in the other table. FOREIGN KEY CHECK: It is used for ensuring whether the column values fulfil given specified conditions. CHECK: DEFAULT: This constraint is used for adding default values to the column whenever needed. If the user specifies any value in the DEFAULT constraint, then at the time of record creation, if we do not specify values to that column, the default value will be saved in the table. DEFAULT:  ",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "7. How will you perform data load testing?",
        "answer": "Data load testing requires the testers to know about source databases and the destination databases and their objects like tables, columns, design, constraints etc. While performing tests, we need to validate the compatibility of the source and destination databases using the DTS package in SQL Enterprise Manager. We can follow the below steps for the same: Open the DTS package and run it.\nCompare the column data of the source and destination tables.\nCheck for the number of rows in source and destination tables.\nPost updating data in source tables, check if the same changes are reflected in the destination database.\nCheck about the data quality whether the destination data received any junk characters and NULL values.\nCheck for the maximum processable volume on the servers and evaluate the response times and speed of data load from the source to destination. Open the DTS package and run it. Compare the column data of the source and destination tables. Check for the number of rows in source and destination tables. Post updating data in source tables, check if the same changes are reflected in the destination database. Check about the data quality whether the destination data received any junk characters and NULL values. Check for the maximum processable volume on the servers and evaluate the response times and speed of data load from the source to destination.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "8. How can you test Transactions in SQL Databases?",
        "answer": "Transactions require the ACID properties to be satisfied. To achieve that, we use the below statements: BEGIN TRANSACTION TRANSACTION#\nEND TRANSACTION TRANSACTION#\n\nROLLBACK TRANSACTION# BEGIN TRANSACTION TRANSACTION#\nEND TRANSACTION TRANSACTION#\n\nROLLBACK TRANSACTION# BEGIN END ROLLBACK The Rollback command ensures that the database changes are rolled back to the previous stable commit and ensures consistency. Once the transactions are executed, we can make use of SELECT queries to run on the tables where the transaction took place and validate the data.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "9. How can you validate the ACID properties? Explain with an example.",
        "answer": "Consider a simple SQL code below: CREATE TABLE ACID_DEMO (X INTEGER, Y INTEGER, CHECK (X + Y = 50)); CREATE TABLE ACID_DEMO (X INTEGER, Y INTEGER, CHECK (X + Y = 50)); CREATE TABLE INTEGER INTEGER CHECK + = 50 We will test for the ACID properties for two columns X and Y. There is also a constraint added on the table that the sum of values in columns X and Y should always be 50. Atomicity: Here, we test that the transactions done on the table is either successful or failed. No records should be updated if the transactions fail.\nConsistency: Here, we test that the values in columns X and Y are updated correctly by following the constraint that the sum of these two values is always 50. The insertion or updation should not be allowed if the sum is not equal to 50.\nIsolation: Here, in the presence of multiple transactions, we need to test they are happening in isolation.\nDurability: Here, the test cases should consider that if a transaction has been committed, it should remain even after the incidents of power losses, crashes and errors. If we are using sharded or distributed database applications, rigorous testing needs to be done to ensure the data is not lost. Atomicity: Here, we test that the transactions done on the table is either successful or failed. No records should be updated if the transactions fail. Atomicity: Consistency: Here, we test that the values in columns X and Y are updated correctly by following the constraint that the sum of these two values is always 50. The insertion or updation should not be allowed if the sum is not equal to 50. Consistency: Isolation: Here, in the presence of multiple transactions, we need to test they are happening in isolation. Isolation: Durability: Here, the test cases should consider that if a transaction has been committed, it should remain even after the incidents of power losses, crashes and errors. If we are using sharded or distributed database applications, rigorous testing needs to be done to ensure the data is not lost. Durability:",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "10. How can you test the data integrity in database testing?",
        "answer": "Whenever there are different modules in the application that are using the same data and also perform different operations on them, it is very much necessary to have the latest data to be shown everywhere. The most recent value of the data should be used by the systems. This is called Data Integrity. Following image shows 5 characteristics of data following data integrity:   We can apply the following test cases for testing out the integrity of the data: Are all the triggers working fine to update the records in the reference tables?\nAre there any invalid data in the columns of each database?\nInsert wrong data into the tables and see how the insertion behaves.\nWhat would happen if you try to insert the child record before inserting the parent record in the main table?\nIs there any failure if you are trying to delete records referenced by another table?\nAre the replicated servers in sync? The data should not be out of sync in two or more replicated servers as it would defy the intent of replication. Are all the triggers working fine to update the records in the reference tables? Are there any invalid data in the columns of each database? Insert wrong data into the tables and see how the insertion behaves. What would happen if you try to insert the child record before inserting the parent record in the main table? Is there any failure if you are trying to delete records referenced by another table? Are the replicated servers in sync? The data should not be out of sync in two or more replicated servers as it would defy the intent of replication.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "11. What are the most commonly occurring issues that are faced during database testing and how can they be solved?",
        "answer": "Significant overhead can be involved to determine the state of transactions.\nSolution: Plan the process that is efficient in both time and cost. A fine balance needs to be present while managing the quality of the database testing and the application project duration.\nPost the clean up of old test data, testers need to come up with a design of new data.\nSolution: Plan a methodology and design test cases that can easily take up different data sets without much effort.\nTo validate the SQL queries, there is a need for an SQL generator that can help to validate the data and can easily help in handling different test cases. This maintenance, if not done correctly, can result in messy and unmanageable scenarios.\nSolution: Overall process of testing should be well planned and the queries should be well maintained in a way that continuous updates are supported. Significant overhead can be involved to determine the state of transactions.\nSolution: Plan the process that is efficient in both time and cost. A fine balance needs to be present while managing the quality of the database testing and the application project duration. Solution: Plan the process that is efficient in both time and cost. A fine balance needs to be present while managing the quality of the database testing and the application project duration. Solution: Plan the process that is efficient in both time and cost. A fine balance needs to be present while managing the quality of the database testing and the application project duration. Solution: Solution: Post the clean up of old test data, testers need to come up with a design of new data.\nSolution: Plan a methodology and design test cases that can easily take up different data sets without much effort. Solution: Plan a methodology and design test cases that can easily take up different data sets without much effort. Solution: Plan a methodology and design test cases that can easily take up different data sets without much effort. Solution: Solution: To validate the SQL queries, there is a need for an SQL generator that can help to validate the data and can easily help in handling different test cases. This maintenance, if not done correctly, can result in messy and unmanageable scenarios.\nSolution: Overall process of testing should be well planned and the queries should be well maintained in a way that continuous updates are supported. Solution: Overall process of testing should be well planned and the queries should be well maintained in a way that continuous updates are supported. Solution: Overall process of testing should be well planned and the queries should be well maintained in a way that continuous updates are supported. Solution: Solution:",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "12. What are the best practices that need to be followed while performing database testing?",
        "answer": "Following are some good practices that need to be followed while performing database testing: Validate every single piece of data that includes metadata and functional data based on the requirement specifications.\nTest data should be verified and created after consultation with the development team and only then the validation needs to be done.\nOutput data needs to be validated by using both automated and manual processes.\nPerform boundary value analysis, graphing techniques, equivalence partitioning techniques to get the required test data inputs.\nThe referential integrity of the data in the tables also needs to be carefully evaluated.\nThe selection of default values in the table needs to be validated too to check for consistency of data.\nCheck if appropriate logging events have been tracked and added to the database.\nAre the jobs scheduled to run are executed on time?\nEnsure that timely backup of the test database is taken to ensure test cases do not fail.\nEnsure that the test server is periodically refreshed with close to real-time data so that testing can be as accurate as possible. Validate every single piece of data that includes metadata and functional data based on the requirement specifications. Test data should be verified and created after consultation with the development team and only then the validation needs to be done. Output data needs to be validated by using both automated and manual processes. Perform boundary value analysis, graphing techniques, equivalence partitioning techniques to get the required test data inputs. The referential integrity of the data in the tables also needs to be carefully evaluated. The selection of default values in the table needs to be validated too to check for consistency of data. Check if appropriate logging events have been tracked and added to the database. Are the jobs scheduled to run are executed on time? Ensure that timely backup of the test database is taken to ensure test cases do not fail. Ensure that the test server is periodically refreshed with close to real-time data so that testing can be as accurate as possible.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "13. How can you validate the tables and columns in the database?",
        "answer": "We can test the tables and columns in the databases by applying the following test cases: Are the database fields mapped correctly and is compatible with the required mappings in the front-end or backend requirements?\nAre the fields following proper naming conventions and have lengths and sizes as per the requirements?\nCheck if there are any unused or unmapped tables and columns.\nCheck if the table design and the referential integrities and constraints on the columns are applied effectively and are scalable to different requirements. Are the database fields mapped correctly and is compatible with the required mappings in the front-end or backend requirements? Are the fields following proper naming conventions and have lengths and sizes as per the requirements? Check if there are any unused or unmapped tables and columns. Check if the table design and the referential integrities and constraints on the columns are applied effectively and are scalable to different requirements.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "14. How do you check for an error in a stored procedure consisting of 1000s of lines of code?",
        "answer": "We can test using the following methods: At compilation time, check if there are any compile-time errors.\nAdd proper comments and loggers that would give you hints about the stages completed and help you narrow down the region of error. At compilation time, check if there are any compile-time errors. Add proper comments and loggers that would give you hints about the stages completed and help you narrow down the region of error.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "15. Is it possible to have multiple primary keys in a table?",
        "answer": "No. A table can allow one composite primary key that consists of two or more columns. But it does not allow for multiple primary keys.",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "16. How will you fetch the values from TableA that are not present in TableB without using the NOT keyword?",
        "answer": "TableA\n20\n21\n25\n45 TableA\n20\n21\n25\n45 TableA TableA TableA 20\n21\n25\n45 20 20 21 21 25 25 45 45 TableB\n20\n45 TableB\n20\n45 TableB TableB TableB 20\n45 20 20 45 45 The result should have 21 and 25. We can do it easily by using the SELECT and EXCEPT keywords as shown below: SELECT * FROM TableA EXCEPT SELECT * FROM TableB; SELECT * FROM TableA EXCEPT SELECT * FROM TableB; SELECT * FROM EXCEPT SELECT * FROM",
        "reference": "interviewbit.com",
        "role": "database-testing"
    },
    {
        "question": "17. What are the differences between GUI Testing and Database Testing?",
        "answer": "GUI Testing Database Testing\nUser Interface Testing is also known as Front-end Testing. Backend Testing or also known as data testing.\nTests all testable items that are visible to the user in the application such as forms, buttons, menus etc. Tests all testable items that are not visible to the users but are essential for the proper functioning of the system.\nTester need not know SQL. Tester needs to know the database technologies like SQL to run the queries and validate the data.\nMajorly deals with the look and feel of the software application. Mostly deals with the data integrity, validation of schema of the structures where the data resides, validating data duplication, referential integrity and everything that deals with data.\nSome of the tools that we use for GUI testing are: Katalon Studio, RAPISE by Inflectra, TestComplete, Abbot Java GUI Test Framework, AutoIt UI testing Some of the tools are Database Rider, Db stress, DbUnit, DB Test Driven etc GUI Testing Database Testing\nUser Interface Testing is also known as Front-end Testing. Backend Testing or also known as data testing.\nTests all testable items that are visible to the user in the application such as forms, buttons, menus etc. Tests all testable items that are not visible to the users but are essential for the proper functioning of the system.\nTester need not know SQL. Tester needs to know the database technologies like SQL to run the queries and validate the data.\nMajorly deals with the look and feel of the software application. Mostly deals with the data integrity, validation of schema of the structures where the data resides, validating data duplication, referential integrity and everything that deals with data.\nSome of the tools that we use for GUI testing are: Katalon Studio, RAPISE by Inflectra, TestComplete, Abbot Java GUI Test Framework, AutoIt UI testing Some of the tools are Database Rider, Db stress, DbUnit, DB Test Driven etc GUI Testing Database Testing GUI Testing Database Testing GUI Testing Database Testing User Interface Testing is also known as Front-end Testing. Backend Testing or also known as data testing.\nTests all testable items that are visible to the user in the application such as forms, buttons, menus etc. Tests all testable items that are not visible to the users but are essential for the proper functioning of the system.\nTester need not know SQL. Tester needs to know the database technologies like SQL to run the queries and validate the data.\nMajorly deals with the look and feel of the software application. Mostly deals with the data integrity, validation of schema of the structures where the data resides, validating data duplication, referential integrity and everything that deals with data.\nSome of the tools that we use for GUI testing are: Katalon Studio, RAPISE by Inflectra, TestComplete, Abbot Java GUI Test Framework, AutoIt UI testing Some of the tools are Database Rider, Db stress, DbUnit, DB Test Driven etc User Interface Testing is also known as Front-end Testing. Backend Testing or also known as data testing. User Interface Testing is also known as Front-end Testing. Backend Testing or also known as data testing. Tests all testable items that are visible to the user in the application such as forms, buttons, menus etc. Tests all testable items that are not visible to the users but are essential for the proper functioning of the system. Tests all testable items that are visible to the user in the application such as forms, buttons, menus etc. Tests all testable items that are not visible to the users but are essential for the proper functioning of the system. Tester need not know SQL. Tester needs to know the database technologies like SQL to run the queries and validate the data. Tester need not know SQL. Tester needs to know the database technologies like SQL to run the queries and validate the data. Majorly deals with the look and feel of the software application. Mostly deals with the data integrity, validation of schema of the structures where the data resides, validating data duplication, referential integrity and everything that deals with data. Majorly deals with the look and feel of the software application. Mostly deals with the data integrity, validation of schema of the structures where the data resides, validating data duplication, referential integrity and everything that deals with data. Some of the tools that we use for GUI testing are: Katalon Studio, RAPISE by Inflectra, TestComplete, Abbot Java GUI Test Framework, AutoIt UI testing Some of the tools are Database Rider, Db stress, DbUnit, DB Test Driven etc Some of the tools that we use for GUI testing are: Katalon Studio, RAPISE by Inflectra, TestComplete, Abbot Java GUI Test Framework, AutoIt UI testing Some of the tools are Database Rider, Db stress, DbUnit, DB Test Driven etc Conclusion The need for correct data has grown exponentially in the software development field. It is very crucial to use the right data, perform the right set of operations on it and show the results to the right set of people. Due to this, database testing helps to validate the correctness, integrity and truthfulness of the data. In this article, we have seen the most commonly asked questions in database testing that deals with RDBMS database systems to both freshers and experienced people. Useful Resources: Useful Resources: DBMS Interview\nSQL Interview\nMYSQL Interview\nSelenium Tester Interview Questions\nAutomation Testing\nManual Testing Interview\nDatabase Testing\nDBMS Tutorial\nTechnical Interview Questions DBMS Interview DBMS Interview SQL Interview SQL Interview MYSQL Interview MYSQL Interview Selenium Tester Interview Questions Selenium Tester Interview Questions Automation Testing Automation Testing Manual Testing Interview Manual Testing Interview Database Testing Database Testing DBMS Tutorial DBMS Tutorial Technical Interview Questions Technical Interview Questions",
        "reference": "interviewbit.com",
        "role": "database-testing"
    }
]